// ============================================================================
// Body
// ======================================================================================

Body <- _* bodyI:body {
    return bodyI, nil
} / EOC {
    return nil, &fileerr.Error{
        Message: "missing body",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Annotation: "expected a body",
        }),
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "start a scope", Example: "`{ ... }`"},
            {Suggestion: "write bracketed text", Example: "`[ woof woof ]`"},
        },
    }
} / _* startI:POS [^\r\n;[{}]* endI:POS &[[{] bodyI:body {
    return bodyI, newUnexpectedTokensErr(c, *startI.(*ast.Position), *endI.(*ast.Position), "unexpected tokens")
} / _* startI:POS UNEXPECTED endI:EOC {
    return nil, newUnexpectedTokensErr(c, *startI.(*ast.Position), *endI.(*ast.Position), "expected a body")
}

OptionalBody <- _* bodyI:body {
    return bodyI, nil
} / EOC {
    return nil, nil
} / _* startI:POS [^\r\n;[{}]+ endI:POS &[[{] bodyI:body {
    return bodyI, newUnexpectedTokensErr(c, *startI.(*ast.Position), *endI.(*ast.Position), "unexpected tokens")
} / _* startI:POS UNEXPECTED endI:EOC {
    return nil, newUnexpectedTokensErr(c, *startI.(*ast.Position), *endI.(*ast.Position), "expected a body, or nothing")
}

body <- Scope / BracketText

// ============================================================================
// Scope
// ======================================================================================

GlobalScope <- scopeStart itmsI:globalScopeItem* rBraceI:scopeEnd {
    return &ast.Scope{
        LBrace: pos(c),
        Items:  sliceOf[ast.ScopeItem](itemsI),
        RBrace: rBraceI.(*ast.Position),
    }, nil
}

globalScopeItem <- WS* itmI:(LoneBrace / Import / State / Component / GlobalCode) {
    return itmI, nil
}

Scope <- scopeStart itemsI:ScopeItem* rBraceI:scopeEnd {
    return &ast.Scope{
        LBrace: pos(c),
        Items:  sliceOf[ast.ScopeItem](itemsI),
        RBrace: rBraceI.(*ast.Position),
    }, nil
}

ScopeItem <- WS* !'}' itmI:(ValidScopeItem / BadItem) {
    return itmI, nil
}

ValidScopeItem <- WS* itmI:validScopeItem {
    return itmI, nil
}
validScopeItem <- And /                                         // attribute.peg
                  DevComment /                                // body.peg
                  Code / Return / Continue / Break /            // code.peg
                  ComponentCall / Block /                       // component.peg
                  If / Switch / For /                           // control_structures.peg
                  HTMLComment / And / RawElement / Doctype /    // element.peg, excl. Element, which is last
                  ArrowBlock /                                  // text.peg
                  Element                                       // needs to come last

// ============================================================================
// Lone Brace
// ======================================================================================

LoneBrace <- R_BRACE {
    return &ast.BadItem{
        Line:     "}",
        Position: pos(c),
    }, &fileerr.Error{
        Message: "lone brace",
        ErrorAnnotation: anno(c, annotation{
            ContextStartDelta: -2,
            Start:      pos(c),
            Annotation: "does not belong to a scope",
        }),
    }
}

// ============================================================================
// BadItem
// ======================================================================================

BadItem <- reservedBadItem / lineI:(!(_* [\r\n;{}]) [^\r\n;{}])+ bodyI:OptionalBody {
    line := concat(lineI)

    firstWordLen := strings.IndexByte(line, ' ')
    if firstWordLen <= 0 {
        firstWordLen = len([]rune(line))
    }

    return &ast.BadItem{
        Line:     line,
        Body:     optCast[ast.Body](bodyI),
        Position: pos(c),
    }, &fileerr.Error{
        Message: "unrecognized directive or invalid element name",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Len:        firstWordLen,
            Annotation: "expected a valid directive or an element name",
        }),
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "if this is supposed to be an element name, make sure it conforms to the HTML spec"},
            {Suggestion: "if this is Go code and you didn't misspell, it needs the `-` code prefix"},
            {
                Suggestion: "use a valid directive",
                ShouldBe: "a block (`block`), code (`-`), a conditional (`if`, `else if`, `else`, `switch`),\n" +
                    "a loop (`for`), & attributes (`&`), a component call (`+`), an arrow block (`>`)",
            },
        },
    }
} / LoneBody

LoneBody <- _* &[[{] bodyI:Body {
    return &ast.BadItem{
        Body:     optCast[ast.Body](bodyI),
        Position: pos(c),
    }, &fileerr.Error{
        Message: "lone body",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Annotation: "this body is not attached to a directive or element",
        }),
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "if this belongs to a directive, make sure it starts on the same line"},
            {Suggestion: "if this is Go code and you didn't misspell, it needs the `-` code prefix"},
            {
                Suggestion: "place a directive requiring a body in front",
                ShouldBe: "a block (`block`), a conditional (`if`, `else if`, `else`),\n" +
                    "a loop (`for`), a component call (`+`)",
            },
        },
    }
}

reservedBadItem <- RESERVED endI:POS _* UNEXPECTED? EOC {
    return &ast.BadItem{
        Line:     string(c.globalStore["lines"].([]string)[pos(c).Line-1]),
        Body:     optCast[ast.Body](bodyI),
        Position: pos(c),
    }, &fileerr.Error{
        Message: "potential use of reserved word",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            End:        *endI.(*ast.Position),
            EndOffset:  -1,
            Annotation: "cannot use reserved word",
        }),
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "if this is supposed to be an element, uppercase the first letter"},
            {Suggestion: "if this is Go code, you are seeing this error because you have a syntax error"},
        },
    }
}

// ============================================================================
// Comment
// ======================================================================================

DevComment <- "//" !'-' textI:(!EOL .) EOL {
    return &ast.DevComment{
        Comment:  concat(textI),
        Position: pos(c),
    }, nil
}
