// ============================================================================
// Body
// ======================================================================================

Body <- _* bodyI:body {
    return bodyI, nil
} / EOC {
    return nil, &fileerr.Error{
        Message: "missing body",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Annotation: "expected a body",
        }),
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "start a scope", Example: "`{ ... }`"},
            {Suggestion: "write bracketed text", Example: "`[ woof woof ]`"},
        },
    }
} / _* startI:POS [^\r\n;[{}]* endI:POS &[[{] bodyI:body {
    return bodyI, newUnexpectedTokensErr(c, startI.(file.Position), endI.(file.Position), "unexpected tokens")
} / _* startI:POS UNEXPECTED endI:EOC {
    return nil, newUnexpectedTokensErr(c, startI.(file.Position), endI.(file.Position), "expected a body")
}

OptionalBody <- _* body / EOC {
    return nil, nil
} / _* startI:POS [^\r\n;[{}]+ endI:POS &[[{] bodyI:body {
    return bodyI, newUnexpectedTokensErr(c, startI.(file.Position), endI.(file.Position), "unexpected tokens")
} / _* startI:POS UNEXPECTED endI:EOC {
    return nil, newUnexpectedTokensErr(c, startI.(file.Position), endI.(file.Position), "expected a body, or nothing")
}

body <- Scope / BracketText

// ============================================================================
// Scope
// ======================================================================================

GlobalScope <- itmsI:globalScopeItem* {
    return file.Scope{Items: sliceOf[file.ScopeItem](itmsI)}, nil
}

globalScopeItem <- WS* itmI:(LoneBrace / Import / State / Component / GlobalCode) {
    return itmI, nil
}

Scope <- scopeStart itemsI:scopeItem* rBraceI:scopeEnd {
    return file.Scope{
        LBrace: pos(c),
        Items:  sliceOf[file.ScopeItem](itemsI),
        RBrace: rBraceI.(file.Position),
    }, nil
}

scopeItem <- WS* !'}' itmI:(
    And /                                         // attribute.peg
    CorgiComment /                                // body.peg
    Code / Return / Continue / Break /            // code.peg
    ComponentCall / Block /                       // component.peg
    If / Switch / For /                           // control_structures.peg
    HTMLComment / And / RawElement / Doctype /    // element.peg, excl. Element, which is last
    ArrowBlock /                                  // text.peg

    Element /  // needs to come last
    BadItem
) {
    return itmI, nil
}

// ============================================================================
// Lone Brace
// ======================================================================================

LoneBrace <- R_BRACE {
    return file.BadItem{
        Line:     "}",
        Position: pos(c),
    }, &fileerr.Error{
        Message: "lone brace",
        ErrorAnnotation: anno(c, annotation{
            ContextStartDelta: -2,
            Start:      pos(c),
            Annotation: "does not belong to a scope",
        }),
    }
}

// ============================================================================
// BadItem
// ======================================================================================

BadItem <- reservedBadItem / lineI:(!(_* [\r\n;{}]) [^\r\n;{}])+ bodyI:OptionalBody {
    line := concat(lineI)

    firstWordLen := strings.IndexByte(line, ' ')
    if firstWordLen <= 0 {
        firstWordLen = len([]rune(line))
    }

    return file.BadItem{
        Line:     line,
        Body:     optCast[file.Scope](bodyI),
        Position: pos(c),
    }, &fileerr.Error{
        Message: "unrecognized directive or invalid element name",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Len:        firstWordLen,
            Annotation: "expected a valid corgi directive or an element name",
        }),
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "if this is supposed to be an element name, make sure it conforms to the HTML spec"},
            {Suggestion: "if this is Go code and you didn't misspell, it needs the `-` code prefix"},
            {
                Suggestion: "use a valid corgi directive",
                ShouldBe: "a block (`block`), code (`-`), a conditional (`if`, `else if`, `else`, `switch`),\n" +
                    "a loop (`for`), & attributes (`&`), a component call (`+`), an arrow block (`>`)",
            },
        },
    }
} / _* &[[{] bodyI:Body {
    return file.BadItem{
        Body:     optCast[file.Scope](bodyI),
        Position: pos(c),
    }, &fileerr.Error{
        Message: "lone body",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Annotation: "this body is not attached to a directive or element",
        }),
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "if this belongs to a directive, make sure it starts on the same line"},
            {Suggestion: "if this is Go code and you didn't misspell, it needs the `-` code prefix"},
            {
                Suggestion: "place a corgi directive requiring a body in front",
                ShouldBe: "a block (`block`), a conditional (`if`, `else if`, `else`),\n" +
                    "a loop (`for`), a component call (`+`)",
            },
        },
    }
}

reservedBadItem <- RESERVED reservedEndI:POS _* UNEXPECTED? endI:POS bodyI:OptionalBody {
    return file.BadItem{
        Line:     string(c.globalStore["lines"].([]string)[pos(c).Line-1]),
        Body:     optCast[file.Scope](bodyI),
        Position: pos(c),
    }, &fileerr.Error{
        Message: "potential use of reserved word",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            End:        reservedEndI.(file.Position),
            EndOffset:  -1,
            Annotation: "cannot use reserved word",
        }),
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "if this is supposed to be an element, you need to use a different name"},
            {Suggestion: "if this is Go code, you are seeing this error because you have a syntax error"},
        },
    }
}

// ============================================================================
// Comment
// ======================================================================================

CorgiComment <- "//" !'-' textI:(!EOL .) EOL {
    return file.CorgiComment{
        Comment:  concat(textI),
        Position: pos(c),
    }, nil
}
