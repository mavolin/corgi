// Code generated by pigeon; DO NOT EDIT.

package internal

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"

	"github.com/mavolin/corgi/corgierr"
	"github.com/mavolin/corgi/file"
	"github.com/mavolin/corgi/internal/stack"
)

// todo: rm these as soon as pigeon#115 is fixed
const lbrace = "{"
const rbrace = "}"

type ErrList = errList
type ParserError = parserError

var g = &grammar{
	rules: []*rule{
		{
			name: "File",
			pos:  position{line: 12, col: 1, offset: 189},
			expr: &actionExpr{
				pos: position{line: 13, col: 5, offset: 201},
				run: (*parser).callonFile1,
				expr: &seqExpr{
					pos: position{line: 13, col: 5, offset: 201},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 13, col: 5, offset: 201},
							name: "init",
						},
						&zeroOrOneExpr{
							pos: position{line: 14, col: 5, offset: 210},
							expr: &ruleRefExpr{
								pos:  position{line: 14, col: 5, offset: 210},
								name: "NEW_LNS",
							},
						},
						&labeledExpr{
							pos:   position{line: 15, col: 5, offset: 223},
							label: "extendComments",
							expr: &zeroOrOneExpr{
								pos: position{line: 15, col: 20, offset: 238},
								expr: &ruleRefExpr{
									pos:  position{line: 15, col: 20, offset: 238},
									name: "CorgiComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 15, col: 35, offset: 253},
							expr: &ruleRefExpr{
								pos:  position{line: 15, col: 35, offset: 253},
								name: "NEW_LNS",
							},
						},
						&labeledExpr{
							pos:   position{line: 16, col: 5, offset: 266},
							label: "extendI",
							expr: &zeroOrOneExpr{
								pos: position{line: 16, col: 13, offset: 274},
								expr: &ruleRefExpr{
									pos:  position{line: 16, col: 13, offset: 274},
									name: "Extend",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 16, col: 21, offset: 282},
							expr: &ruleRefExpr{
								pos:  position{line: 16, col: 21, offset: 282},
								name: "NEW_LNS",
							},
						},
						&labeledExpr{
							pos:   position{line: 17, col: 5, offset: 295},
							label: "importsAndCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 17, col: 25, offset: 315},
								expr: &ruleRefExpr{
									pos:  position{line: 17, col: 25, offset: 315},
									name: "importsAndComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 17, col: 45, offset: 335},
							expr: &ruleRefExpr{
								pos:  position{line: 17, col: 45, offset: 335},
								name: "NEW_LNS",
							},
						},
						&labeledExpr{
							pos:   position{line: 18, col: 5, offset: 348},
							label: "usesAndCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 18, col: 22, offset: 365},
								expr: &ruleRefExpr{
									pos:  position{line: 18, col: 22, offset: 365},
									name: "usesAndComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 18, col: 39, offset: 382},
							expr: &ruleRefExpr{
								pos:  position{line: 18, col: 39, offset: 382},
								name: "NEW_LNS",
							},
						},
						&labeledExpr{
							pos:   position{line: 19, col: 5, offset: 395},
							label: "globalCodeAndFuncI",
							expr: &zeroOrOneExpr{
								pos: position{line: 19, col: 24, offset: 414},
								expr: &ruleRefExpr{
									pos:  position{line: 19, col: 24, offset: 414},
									name: "globalCodeAndFunc",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 19, col: 43, offset: 433},
							expr: &ruleRefExpr{
								pos:  position{line: 19, col: 43, offset: 433},
								name: "NEW_LNS",
							},
						},
						&labeledExpr{
							pos:   position{line: 20, col: 5, offset: 446},
							label: "doctypeCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 20, col: 22, offset: 463},
								expr: &ruleRefExpr{
									pos:  position{line: 20, col: 22, offset: 463},
									name: "CorgiComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 20, col: 37, offset: 478},
							expr: &ruleRefExpr{
								pos:  position{line: 20, col: 37, offset: 478},
								name: "NEW_LNS",
							},
						},
						&labeledExpr{
							pos:   position{line: 21, col: 5, offset: 491},
							label: "doctypeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 21, col: 14, offset: 500},
								expr: &ruleRefExpr{
									pos:  position{line: 21, col: 14, offset: 500},
									name: "Doctype",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 21, col: 23, offset: 509},
							expr: &ruleRefExpr{
								pos:  position{line: 21, col: 23, offset: 509},
								name: "NEW_LNS",
							},
						},
						&labeledExpr{
							pos:   position{line: 22, col: 5, offset: 522},
							label: "scopeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 22, col: 12, offset: 529},
								expr: &ruleRefExpr{
									pos:  position{line: 22, col: 12, offset: 529},
									name: "Scope",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 22, col: 19, offset: 536},
							expr: &ruleRefExpr{
								pos:  position{line: 22, col: 19, offset: 536},
								name: "NEW_LNS",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 23, col: 5, offset: 549},
							name: "EOF",
						},
					},
				},
			},
		},
		{
			name: "importsAndComments",
			pos:  position{line: 68, col: 1, offset: 1902},
			expr: &actionExpr{
				pos: position{line: 68, col: 23, offset: 1924},
				run: (*parser).callonimportsAndComments1,
				expr: &labeledExpr{
					pos:   position{line: 68, col: 23, offset: 1924},
					label: "valsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 68, col: 29, offset: 1930},
						expr: &seqExpr{
							pos: position{line: 68, col: 30, offset: 1931},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 68, col: 30, offset: 1931},
									expr: &ruleRefExpr{
										pos:  position{line: 68, col: 30, offset: 1931},
										name: "CorgiComments",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 68, col: 45, offset: 1946},
									expr: &ruleRefExpr{
										pos:  position{line: 68, col: 45, offset: 1946},
										name: "NEW_LNS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 68, col: 54, offset: 1955},
									name: "Imports",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "usesAndComments",
			pos:  position{line: 82, col: 1, offset: 2315},
			expr: &actionExpr{
				pos: position{line: 82, col: 20, offset: 2334},
				run: (*parser).callonusesAndComments1,
				expr: &labeledExpr{
					pos:   position{line: 82, col: 20, offset: 2334},
					label: "valsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 82, col: 26, offset: 2340},
						expr: &seqExpr{
							pos: position{line: 82, col: 27, offset: 2341},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 82, col: 27, offset: 2341},
									expr: &ruleRefExpr{
										pos:  position{line: 82, col: 27, offset: 2341},
										name: "CorgiComments",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 82, col: 42, offset: 2356},
									expr: &ruleRefExpr{
										pos:  position{line: 82, col: 42, offset: 2356},
										name: "NEW_LNS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 82, col: 51, offset: 2365},
									name: "Uses",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "codesAndComments",
			pos:  position{line: 96, col: 1, offset: 2704},
			expr: &actionExpr{
				pos: position{line: 96, col: 21, offset: 2724},
				run: (*parser).calloncodesAndComments1,
				expr: &labeledExpr{
					pos:   position{line: 96, col: 21, offset: 2724},
					label: "valsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 96, col: 27, offset: 2730},
						expr: &seqExpr{
							pos: position{line: 96, col: 28, offset: 2731},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 96, col: 28, offset: 2731},
									expr: &ruleRefExpr{
										pos:  position{line: 96, col: 28, offset: 2731},
										name: "CorgiComments",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 96, col: 43, offset: 2746},
									expr: &ruleRefExpr{
										pos:  position{line: 96, col: 43, offset: 2746},
										name: "NEW_LNS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 96, col: 52, offset: 2755},
									name: "Codes",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "globalCodeAndFunc",
			pos:  position{line: 110, col: 1, offset: 3101},
			expr: &actionExpr{
				pos: position{line: 110, col: 22, offset: 3122},
				run: (*parser).callonglobalCodeAndFunc1,
				expr: &seqExpr{
					pos: position{line: 110, col: 22, offset: 3122},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 110, col: 22, offset: 3122},
							label: "codesAndCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 110, col: 40, offset: 3140},
								expr: &ruleRefExpr{
									pos:  position{line: 110, col: 40, offset: 3140},
									name: "codesAndComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 110, col: 58, offset: 3158},
							expr: &ruleRefExpr{
								pos:  position{line: 110, col: 58, offset: 3158},
								name: "NEW_LNS",
							},
						},
						&labeledExpr{
							pos:   position{line: 110, col: 67, offset: 3167},
							label: "commentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 110, col: 77, offset: 3177},
								expr: &ruleRefExpr{
									pos:  position{line: 110, col: 77, offset: 3177},
									name: "CorgiComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 110, col: 92, offset: 3192},
							expr: &ruleRefExpr{
								pos:  position{line: 110, col: 92, offset: 3192},
								name: "NEW_LNS",
							},
						},
						&labeledExpr{
							pos:   position{line: 110, col: 101, offset: 3201},
							label: "funcI",
							expr: &ruleRefExpr{
								pos:  position{line: 110, col: 107, offset: 3207},
								name: "Func",
							},
						},
					},
				},
			},
		},
		{
			name: "init",
			pos:  position{line: 128, col: 1, offset: 3661},
			expr: &stateCodeExpr{
				pos: position{line: 128, col: 9, offset: 3669},
				run: (*parser).calloninit1,
			},
		},
		{
			name: "Scope",
			pos:  position{line: 148, col: 1, offset: 4585},
			expr: &actionExpr{
				pos: position{line: 148, col: 10, offset: 4594},
				run: (*parser).callonScope1,
				expr: &labeledExpr{
					pos:   position{line: 148, col: 10, offset: 4594},
					label: "itemsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 148, col: 17, offset: 4601},
						expr: &seqExpr{
							pos: position{line: 148, col: 18, offset: 4602},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 148, col: 18, offset: 4602},
									expr: &ruleRefExpr{
										pos:  position{line: 148, col: 18, offset: 4602},
										name: "NEW_LNS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 148, col: 27, offset: 4611},
									name: "INDENTATION",
								},
								&ruleRefExpr{
									pos:  position{line: 148, col: 39, offset: 4623},
									name: "scopeItem",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "scopeItem",
			pos:  position{line: 162, col: 1, offset: 4929},
			expr: &choiceExpr{
				pos: position{line: 163, col: 5, offset: 4948},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 163, col: 5, offset: 4948},
						name: "Block",
					},
					&ruleRefExpr{
						pos:  position{line: 163, col: 13, offset: 4956},
						name: "Prepend",
					},
					&ruleRefExpr{
						pos:  position{line: 163, col: 23, offset: 4966},
						name: "Append",
					},
					&ruleRefExpr{
						pos:  position{line: 164, col: 5, offset: 4995},
						name: "Code",
					},
					&ruleRefExpr{
						pos:  position{line: 165, col: 5, offset: 5041},
						name: "If",
					},
					&ruleRefExpr{
						pos:  position{line: 165, col: 10, offset: 5046},
						name: "IfBlock",
					},
					&ruleRefExpr{
						pos:  position{line: 165, col: 20, offset: 5056},
						name: "Switch",
					},
					&ruleRefExpr{
						pos:  position{line: 165, col: 29, offset: 5065},
						name: "For",
					},
					&ruleRefExpr{
						pos:  position{line: 166, col: 5, offset: 5101},
						name: "CorgiComment",
					},
					&ruleRefExpr{
						pos:  position{line: 167, col: 5, offset: 5148},
						name: "HTMLComment",
					},
					&ruleRefExpr{
						pos:  position{line: 167, col: 19, offset: 5162},
						name: "And",
					},
					&ruleRefExpr{
						pos:  position{line: 168, col: 5, offset: 5227},
						name: "Filter",
					},
					&ruleRefExpr{
						pos:  position{line: 169, col: 5, offset: 5275},
						name: "Include",
					},
					&ruleRefExpr{
						pos:  position{line: 170, col: 5, offset: 5324},
						name: "Mixin",
					},
					&ruleRefExpr{
						pos:  position{line: 170, col: 13, offset: 5332},
						name: "Return",
					},
					&ruleRefExpr{
						pos:  position{line: 170, col: 22, offset: 5341},
						name: "MixinCall",
					},
					&ruleRefExpr{
						pos:  position{line: 171, col: 5, offset: 5373},
						name: "ArrowBlock",
					},
					&ruleRefExpr{
						pos:  position{line: 173, col: 5, offset: 5420},
						name: "scopeDoctype",
					},
					&ruleRefExpr{
						pos:  position{line: 174, col: 5, offset: 5439},
						name: "DivShorthand",
					},
					&ruleRefExpr{
						pos:  position{line: 174, col: 20, offset: 5454},
						name: "Element",
					},
					&ruleRefExpr{
						pos:  position{line: 175, col: 5, offset: 5494},
						name: "BadItem",
					},
				},
			},
		},
		{
			name: "scopeDoctype",
			pos:  position{line: 178, col: 1, offset: 5505},
			expr: &actionExpr{
				pos: position{line: 178, col: 17, offset: 5521},
				run: (*parser).callonscopeDoctype1,
				expr: &labeledExpr{
					pos:   position{line: 178, col: 17, offset: 5521},
					label: "doctypeI",
					expr: &ruleRefExpr{
						pos:  position{line: 178, col: 26, offset: 5530},
						name: "Doctype",
					},
				},
			},
		},
		{
			name: "Body",
			pos:  position{line: 200, col: 1, offset: 6349},
			expr: &actionExpr{
				pos: position{line: 200, col: 9, offset: 6357},
				run: (*parser).callonBody1,
				expr: &seqExpr{
					pos: position{line: 200, col: 9, offset: 6357},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 200, col: 9, offset: 6357},
							name: "INDENT",
						},
						&labeledExpr{
							pos:   position{line: 200, col: 16, offset: 6364},
							label: "scopeI",
							expr: &ruleRefExpr{
								pos:  position{line: 200, col: 23, offset: 6371},
								name: "Scope",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 200, col: 29, offset: 6377},
							name: "DEDENT",
						},
					},
				},
			},
		},
		{
			name: "Beaitb",
			pos:  position{line: 204, col: 1, offset: 6412},
			expr: &choiceExpr{
				pos: position{line: 204, col: 11, offset: 6422},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 204, col: 11, offset: 6422},
						run: (*parser).callonBeaitb2,
						expr: &labeledExpr{
							pos:   position{line: 204, col: 11, offset: 6422},
							label: "scopeItemI",
							expr: &choiceExpr{
								pos: position{line: 204, col: 23, offset: 6434},
								alternatives: []interface{}{
									&ruleRefExpr{
										pos:  position{line: 204, col: 23, offset: 6434},
										name: "BlockExpansion",
									},
									&ruleRefExpr{
										pos:  position{line: 204, col: 40, offset: 6451},
										name: "InlineText",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 206, col: 5, offset: 6529},
						run: (*parser).callonBeaitb7,
						expr: &seqExpr{
							pos: position{line: 206, col: 5, offset: 6529},
							exprs: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 206, col: 5, offset: 6529},
									name: "EOL",
								},
								&labeledExpr{
									pos:   position{line: 206, col: 9, offset: 6533},
									label: "bodyI",
									expr: &ruleRefExpr{
										pos:  position{line: 206, col: 15, offset: 6539},
										name: "Body",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 208, col: 5, offset: 6572},
						run: (*parser).callonBeaitb12,
						expr: &ruleRefExpr{
							pos:  position{line: 208, col: 5, offset: 6572},
							name: "EOL",
						},
					},
					&actionExpr{
						pos: position{line: 210, col: 5, offset: 6614},
						run: (*parser).callonBeaitb14,
						expr: &seqExpr{
							pos: position{line: 210, col: 5, offset: 6614},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 210, col: 5, offset: 6614},
									label: "lineI",
									expr: &oneOrMoreExpr{
										pos: position{line: 210, col: 11, offset: 6620},
										expr: &ruleRefExpr{
											pos:  position{line: 210, col: 11, offset: 6620},
											name: "NOT_EOL",
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 210, col: 20, offset: 6629},
									name: "EOL",
								},
								&labeledExpr{
									pos:   position{line: 210, col: 24, offset: 6633},
									label: "bodyI",
									expr: &zeroOrOneExpr{
										pos: position{line: 210, col: 30, offset: 6639},
										expr: &ruleRefExpr{
											pos:  position{line: 210, col: 30, offset: 6639},
											name: "Body",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Beait",
			pos:  position{line: 225, col: 1, offset: 7084},
			expr: &choiceExpr{
				pos: position{line: 225, col: 10, offset: 7093},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 225, col: 10, offset: 7093},
						run: (*parser).callonBeait2,
						expr: &labeledExpr{
							pos:   position{line: 225, col: 10, offset: 7093},
							label: "scopeItemI",
							expr: &choiceExpr{
								pos: position{line: 225, col: 22, offset: 7105},
								alternatives: []interface{}{
									&ruleRefExpr{
										pos:  position{line: 225, col: 22, offset: 7105},
										name: "BlockExpansion",
									},
									&ruleRefExpr{
										pos:  position{line: 225, col: 39, offset: 7122},
										name: "InlineText",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 227, col: 5, offset: 7196},
						run: (*parser).callonBeait7,
						expr: &ruleRefExpr{
							pos:  position{line: 227, col: 5, offset: 7196},
							name: "EOL",
						},
					},
					&actionExpr{
						pos: position{line: 229, col: 5, offset: 7238},
						run: (*parser).callonBeait9,
						expr: &seqExpr{
							pos: position{line: 229, col: 5, offset: 7238},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 229, col: 5, offset: 7238},
									label: "lineI",
									expr: &oneOrMoreExpr{
										pos: position{line: 229, col: 11, offset: 7244},
										expr: &ruleRefExpr{
											pos:  position{line: 229, col: 11, offset: 7244},
											name: "NOT_EOL",
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 229, col: 20, offset: 7253},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BadItem",
			pos:  position{line: 242, col: 1, offset: 7640},
			expr: &actionExpr{
				pos: position{line: 242, col: 12, offset: 7651},
				run: (*parser).callonBadItem1,
				expr: &seqExpr{
					pos: position{line: 242, col: 12, offset: 7651},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 242, col: 12, offset: 7651},
							label: "lineI",
							expr: &oneOrMoreExpr{
								pos: position{line: 242, col: 18, offset: 7657},
								expr: &ruleRefExpr{
									pos:  position{line: 242, col: 18, offset: 7657},
									name: "NOT_EOL",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 242, col: 27, offset: 7666},
							name: "EOL",
						},
						&labeledExpr{
							pos:   position{line: 242, col: 31, offset: 7670},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 242, col: 37, offset: 7676},
								expr: &ruleRefExpr{
									pos:  position{line: 242, col: 37, offset: 7676},
									name: "Body",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Block",
			pos:  position{line: 278, col: 1, offset: 9118},
			expr: &actionExpr{
				pos: position{line: 278, col: 10, offset: 9127},
				run: (*parser).callonBlock1,
				expr: &seqExpr{
					pos: position{line: 278, col: 10, offset: 9127},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 278, col: 10, offset: 9127},
							label: "blockI",
							expr: &ruleRefExpr{
								pos:  position{line: 278, col: 17, offset: 9134},
								name: "blockDirective",
							},
						},
						&labeledExpr{
							pos:   position{line: 278, col: 32, offset: 9149},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 278, col: 38, offset: 9155},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineBlock",
			pos:  position{line: 283, col: 1, offset: 9257},
			expr: &actionExpr{
				pos: position{line: 283, col: 16, offset: 9272},
				run: (*parser).callonInlineBlock1,
				expr: &seqExpr{
					pos: position{line: 283, col: 16, offset: 9272},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 283, col: 16, offset: 9272},
							label: "blockI",
							expr: &ruleRefExpr{
								pos:  position{line: 283, col: 23, offset: 9279},
								name: "blockDirective",
							},
						},
						&labeledExpr{
							pos:   position{line: 283, col: 38, offset: 9294},
							label: "scopeI",
							expr: &ruleRefExpr{
								pos:  position{line: 283, col: 45, offset: 9301},
								name: "Beait",
							},
						},
					},
				},
			},
		},
		{
			name: "Prepend",
			pos:  position{line: 288, col: 1, offset: 9416},
			expr: &actionExpr{
				pos: position{line: 288, col: 12, offset: 9427},
				run: (*parser).callonPrepend1,
				expr: &seqExpr{
					pos: position{line: 288, col: 12, offset: 9427},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 288, col: 12, offset: 9427},
							label: "blockI",
							expr: &ruleRefExpr{
								pos:  position{line: 288, col: 19, offset: 9434},
								name: "prependDirective",
							},
						},
						&labeledExpr{
							pos:   position{line: 288, col: 36, offset: 9451},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 288, col: 42, offset: 9457},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "Append",
			pos:  position{line: 293, col: 1, offset: 9559},
			expr: &actionExpr{
				pos: position{line: 293, col: 11, offset: 9569},
				run: (*parser).callonAppend1,
				expr: &seqExpr{
					pos: position{line: 293, col: 11, offset: 9569},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 293, col: 11, offset: 9569},
							label: "blockI",
							expr: &ruleRefExpr{
								pos:  position{line: 293, col: 18, offset: 9576},
								name: "appendDirective",
							},
						},
						&labeledExpr{
							pos:   position{line: 293, col: 34, offset: 9592},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 293, col: 40, offset: 9598},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "blockDirective",
			pos:  position{line: 299, col: 1, offset: 9701},
			expr: &actionExpr{
				pos: position{line: 299, col: 19, offset: 9719},
				run: (*parser).callonblockDirective1,
				expr: &seqExpr{
					pos: position{line: 299, col: 19, offset: 9719},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 299, col: 19, offset: 9719},
							val:        "block",
							ignoreCase: false,
							want:       "\"block\"",
						},
						&labeledExpr{
							pos:   position{line: 299, col: 27, offset: 9727},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 299, col: 33, offset: 9733},
								name: "blockName",
							},
						},
					},
				},
			},
		},
		{
			name: "prependDirective",
			pos:  position{line: 307, col: 1, offset: 9893},
			expr: &actionExpr{
				pos: position{line: 307, col: 21, offset: 9913},
				run: (*parser).callonprependDirective1,
				expr: &seqExpr{
					pos: position{line: 307, col: 21, offset: 9913},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 307, col: 21, offset: 9913},
							val:        "prepend",
							ignoreCase: false,
							want:       "\"prepend\"",
						},
						&labeledExpr{
							pos:   position{line: 307, col: 31, offset: 9923},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 307, col: 37, offset: 9929},
								name: "blockName",
							},
						},
					},
				},
			},
		},
		{
			name: "appendDirective",
			pos:  position{line: 315, col: 1, offset: 10091},
			expr: &actionExpr{
				pos: position{line: 315, col: 20, offset: 10110},
				run: (*parser).callonappendDirective1,
				expr: &seqExpr{
					pos: position{line: 315, col: 20, offset: 10110},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 315, col: 20, offset: 10110},
							val:        "append",
							ignoreCase: false,
							want:       "\"append\"",
						},
						&labeledExpr{
							pos:   position{line: 315, col: 29, offset: 10119},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 315, col: 35, offset: 10125},
								name: "blockName",
							},
						},
					},
				},
			},
		},
		{
			name: "blockName",
			pos:  position{line: 324, col: 1, offset: 10287},
			expr: &choiceExpr{
				pos: position{line: 324, col: 14, offset: 10300},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 324, col: 14, offset: 10300},
						run: (*parser).callonblockName2,
						expr: &seqExpr{
							pos: position{line: 324, col: 14, offset: 10300},
							exprs: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 324, col: 14, offset: 10300},
									expr: &litMatcher{
										pos:        position{line: 324, col: 14, offset: 10300},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 324, col: 19, offset: 10305},
									label: "identI",
									expr: &ruleRefExpr{
										pos:  position{line: 324, col: 26, offset: 10312},
										name: "MustIdent",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 326, col: 5, offset: 10351},
						run: (*parser).callonblockName8,
						expr: &andExpr{
							pos: position{line: 326, col: 5, offset: 10351},
							expr: &ruleRefExpr{
								pos:  position{line: 326, col: 6, offset: 10352},
								name: "EOL",
							},
						},
					},
				},
			},
		},
		{
			name: "BlockExpansion",
			pos:  position{line: 341, col: 1, offset: 10798},
			expr: &actionExpr{
				pos: position{line: 341, col: 19, offset: 10816},
				run: (*parser).callonBlockExpansion1,
				expr: &seqExpr{
					pos: position{line: 341, col: 19, offset: 10816},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 341, col: 19, offset: 10816},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&labeledExpr{
							pos:   position{line: 341, col: 23, offset: 10820},
							label: "sI",
							expr: &ruleRefExpr{
								pos:  position{line: 341, col: 26, offset: 10823},
								name: "blockExpansionItem",
							},
						},
					},
				},
			},
		},
		{
			name: "blockExpansionItem",
			pos:  position{line: 348, col: 1, offset: 10951},
			expr: &choiceExpr{
				pos: position{line: 348, col: 23, offset: 10973},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 348, col: 23, offset: 10973},
						name: "InlineArrowBlock",
					},
					&ruleRefExpr{
						pos:  position{line: 348, col: 42, offset: 10992},
						name: "spacedBlockExpansionItem",
					},
					&ruleRefExpr{
						pos:  position{line: 348, col: 69, offset: 11019},
						name: "badBlockExpansion",
					},
				},
			},
		},
		{
			name: "spacedBlockExpansionItem",
			pos:  position{line: 350, col: 1, offset: 11038},
			expr: &choiceExpr{
				pos: position{line: 350, col: 29, offset: 11066},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 350, col: 29, offset: 11066},
						run: (*parser).callonspacedBlockExpansionItem2,
						expr: &seqExpr{
							pos: position{line: 350, col: 29, offset: 11066},
							exprs: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 350, col: 29, offset: 11066},
									expr: &litMatcher{
										pos:        position{line: 350, col: 29, offset: 11066},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 350, col: 34, offset: 11071},
									label: "sI",
									expr: &ruleRefExpr{
										pos:  position{line: 350, col: 37, offset: 11074},
										name: "_spacedBlockExpansionItem",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 352, col: 5, offset: 11125},
						run: (*parser).callonspacedBlockExpansionItem8,
						expr: &seqExpr{
							pos: position{line: 352, col: 5, offset: 11125},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 352, col: 5, offset: 11125},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 352, col: 10, offset: 11130},
										name: "POS",
									},
								},
								&labeledExpr{
									pos:   position{line: 352, col: 14, offset: 11134},
									label: "sI",
									expr: &ruleRefExpr{
										pos:  position{line: 352, col: 17, offset: 11137},
										name: "_spacedBlockExpansionItem",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "_spacedBlockExpansionItem",
			pos:  position{line: 380, col: 1, offset: 11864},
			expr: &choiceExpr{
				pos: position{line: 380, col: 30, offset: 11893},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 380, col: 30, offset: 11893},
						name: "InlineBlock",
					},
					&ruleRefExpr{
						pos:  position{line: 380, col: 44, offset: 11907},
						name: "InlineElement",
					},
					&ruleRefExpr{
						pos:  position{line: 380, col: 60, offset: 11923},
						name: "InlineDivShorthand",
					},
					&ruleRefExpr{
						pos:  position{line: 380, col: 81, offset: 11944},
						name: "InlineMixinCall",
					},
					&ruleRefExpr{
						pos:  position{line: 380, col: 99, offset: 11962},
						name: "InlineAnd",
					},
				},
			},
		},
		{
			name: "badBlockExpansion",
			pos:  position{line: 382, col: 1, offset: 11973},
			expr: &actionExpr{
				pos: position{line: 382, col: 22, offset: 11994},
				run: (*parser).callonbadBlockExpansion1,
				expr: &seqExpr{
					pos: position{line: 382, col: 22, offset: 11994},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 382, col: 22, offset: 11994},
							label: "lineI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 382, col: 28, offset: 12000},
								expr: &ruleRefExpr{
									pos:  position{line: 382, col: 28, offset: 12000},
									name: "NOT_EOL",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 382, col: 37, offset: 12009},
							name: "EOL",
						},
					},
				},
			},
		},
		{
			name: "Codes",
			pos:  position{line: 412, col: 1, offset: 12892},
			expr: &actionExpr{
				pos: position{line: 412, col: 10, offset: 12901},
				run: (*parser).callonCodes1,
				expr: &labeledExpr{
					pos:   position{line: 412, col: 10, offset: 12901},
					label: "codesI",
					expr: &oneOrMoreExpr{
						pos: position{line: 412, col: 17, offset: 12908},
						expr: &seqExpr{
							pos: position{line: 412, col: 18, offset: 12909},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 412, col: 18, offset: 12909},
									expr: &ruleRefExpr{
										pos:  position{line: 412, col: 18, offset: 12909},
										name: "NEW_LNS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 412, col: 27, offset: 12918},
									name: "Code",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Code",
			pos:  position{line: 416, col: 1, offset: 12989},
			expr: &choiceExpr{
				pos: position{line: 416, col: 9, offset: 12997},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 416, col: 9, offset: 12997},
						run: (*parser).callonCode2,
						expr: &seqExpr{
							pos: position{line: 416, col: 9, offset: 12997},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 416, col: 9, offset: 12997},
									val:        "- ",
									ignoreCase: false,
									want:       "\"- \"",
								},
								&labeledExpr{
									pos:   position{line: 416, col: 14, offset: 13002},
									label: "firstLineI",
									expr: &ruleRefExpr{
										pos:  position{line: 416, col: 25, offset: 13013},
										name: "codeSpec",
									},
								},
								&labeledExpr{
									pos:   position{line: 416, col: 34, offset: 13022},
									label: "additionalLinesI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 416, col: 51, offset: 13039},
										expr: &seqExpr{
											pos: position{line: 416, col: 52, offset: 13040},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 416, col: 52, offset: 13040},
													expr: &ruleRefExpr{
														pos:  position{line: 416, col: 52, offset: 13040},
														name: "NEW_LNS",
													},
												},
												&ruleRefExpr{
													pos:  position{line: 416, col: 61, offset: 13049},
													name: "INDENTATION2",
												},
												&ruleRefExpr{
													pos:  position{line: 416, col: 74, offset: 13062},
													name: "codeSpec",
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 429, col: 5, offset: 13426},
						run: (*parser).callonCode14,
						expr: &seqExpr{
							pos: position{line: 429, col: 5, offset: 13426},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 429, col: 5, offset: 13426},
									val:        "-",
									ignoreCase: false,
									want:       "\"-\"",
								},
								&labeledExpr{
									pos:   position{line: 429, col: 9, offset: 13430},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 429, col: 14, offset: 13435},
										name: "POS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 429, col: 18, offset: 13439},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "codeSpec",
			pos:  position{line: 442, col: 1, offset: 13820},
			expr: &actionExpr{
				pos: position{line: 442, col: 13, offset: 13832},
				run: (*parser).calloncodeSpec1,
				expr: &seqExpr{
					pos: position{line: 442, col: 13, offset: 13832},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 442, col: 13, offset: 13832},
							label: "code",
							expr: &oneOrMoreExpr{
								pos: position{line: 442, col: 18, offset: 13837},
								expr: &ruleRefExpr{
									pos:  position{line: 442, col: 18, offset: 13837},
									name: "NOT_EOL",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 442, col: 27, offset: 13846},
							name: "EOL",
						},
					},
				},
			},
		},
		{
			name: "condition",
			pos:  position{line: 446, col: 1, offset: 13923},
			expr: &choiceExpr{
				pos: position{line: 446, col: 14, offset: 13936},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 446, col: 14, offset: 13936},
						run: (*parser).calloncondition2,
						expr: &seqExpr{
							pos: position{line: 446, col: 14, offset: 13936},
							exprs: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 446, col: 14, offset: 13936},
									expr: &litMatcher{
										pos:        position{line: 446, col: 14, offset: 13936},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 446, col: 19, offset: 13941},
									label: "condI",
									expr: &ruleRefExpr{
										pos:  position{line: 446, col: 25, offset: 13947},
										name: "IfExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 448, col: 5, offset: 13988},
						run: (*parser).calloncondition8,
						expr: &seqExpr{
							pos: position{line: 448, col: 5, offset: 13988},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 448, col: 5, offset: 13988},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 448, col: 10, offset: 13993},
										name: "POS",
									},
								},
								&andExpr{
									pos: position{line: 448, col: 14, offset: 13997},
									expr: &ruleRefExpr{
										pos:  position{line: 448, col: 15, offset: 13998},
										name: "EOL",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 457, col: 5, offset: 14280},
						run: (*parser).calloncondition14,
						expr: &labeledExpr{
							pos:   position{line: 457, col: 5, offset: 14280},
							label: "posI",
							expr: &ruleRefExpr{
								pos:  position{line: 457, col: 10, offset: 14285},
								name: "POS",
							},
						},
					},
				},
			},
		},
		{
			name: "then",
			pos:  position{line: 467, col: 1, offset: 14538},
			expr: &choiceExpr{
				pos: position{line: 467, col: 9, offset: 14546},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 467, col: 9, offset: 14546},
						run: (*parser).callonthen2,
						expr: &seqExpr{
							pos: position{line: 467, col: 9, offset: 14546},
							exprs: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 467, col: 9, offset: 14546},
									name: "EOL",
								},
								&labeledExpr{
									pos:   position{line: 467, col: 13, offset: 14550},
									label: "scopeI",
									expr: &ruleRefExpr{
										pos:  position{line: 467, col: 20, offset: 14557},
										name: "Body",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 469, col: 5, offset: 14591},
						run: (*parser).callonthen7,
						expr: &labeledExpr{
							pos:   position{line: 469, col: 5, offset: 14591},
							label: "beI",
							expr: &ruleRefExpr{
								pos:  position{line: 469, col: 9, offset: 14595},
								name: "BlockExpansion",
							},
						},
					},
					&actionExpr{
						pos: position{line: 471, col: 5, offset: 14670},
						run: (*parser).callonthen10,
						expr: &ruleRefExpr{
							pos:  position{line: 471, col: 5, offset: 14670},
							name: "EOL",
						},
					},
					&seqExpr{
						pos: position{line: 479, col: 5, offset: 14922},
						exprs: []interface{}{
							&seqExpr{
								pos: position{line: 480, col: 5, offset: 14928},
								exprs: []interface{}{
									&actionExpr{
										pos: position{line: 480, col: 6, offset: 14929},
										run: (*parser).callonthen14,
										expr: &oneOrMoreExpr{
											pos: position{line: 480, col: 6, offset: 14929},
											expr: &charClassMatcher{
												pos:        position{line: 480, col: 6, offset: 14929},
												val:        "[^:\\r\\n]",
												chars:      []rune{':', '\r', '\n'},
												ignoreCase: false,
												inverted:   true,
											},
										},
									},
									&andCodeExpr{
										pos: position{line: 480, col: 40, offset: 14963},
										run: (*parser).callonthen17,
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 489, col: 3, offset: 15238},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "If",
			pos:  position{line: 498, col: 1, offset: 15439},
			expr: &actionExpr{
				pos: position{line: 498, col: 7, offset: 15445},
				run: (*parser).callonIf1,
				expr: &seqExpr{
					pos: position{line: 498, col: 7, offset: 15445},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 498, col: 7, offset: 15445},
							val:        "if",
							ignoreCase: false,
							want:       "\"if\"",
						},
						&notExpr{
							pos: position{line: 498, col: 12, offset: 15450},
							expr: &litMatcher{
								pos:        position{line: 498, col: 13, offset: 15451},
								val:        " block",
								ignoreCase: false,
								want:       "\" block\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 498, col: 22, offset: 15460},
							label: "condI",
							expr: &ruleRefExpr{
								pos:  position{line: 498, col: 28, offset: 15466},
								name: "condition",
							},
						},
						&labeledExpr{
							pos:   position{line: 498, col: 38, offset: 15476},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 498, col: 44, offset: 15482},
								name: "then",
							},
						},
						&labeledExpr{
							pos:   position{line: 498, col: 49, offset: 15487},
							label: "elseIfsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 498, col: 58, offset: 15496},
								expr: &ruleRefExpr{
									pos:  position{line: 498, col: 58, offset: 15496},
									name: "ElseIf",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 498, col: 66, offset: 15504},
							label: "elseI",
							expr: &zeroOrOneExpr{
								pos: position{line: 498, col: 72, offset: 15510},
								expr: &ruleRefExpr{
									pos:  position{line: 498, col: 72, offset: 15510},
									name: "Else",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ElseIf",
			pos:  position{line: 508, col: 1, offset: 15750},
			expr: &actionExpr{
				pos: position{line: 508, col: 11, offset: 15760},
				run: (*parser).callonElseIf1,
				expr: &seqExpr{
					pos: position{line: 508, col: 11, offset: 15760},
					exprs: []interface{}{
						&zeroOrOneExpr{
							pos: position{line: 508, col: 11, offset: 15760},
							expr: &ruleRefExpr{
								pos:  position{line: 508, col: 11, offset: 15760},
								name: "NEW_LNS",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 508, col: 20, offset: 15769},
							name: "INDENTATION",
						},
						&labeledExpr{
							pos:   position{line: 508, col: 32, offset: 15781},
							label: "posI",
							expr: &ruleRefExpr{
								pos:  position{line: 508, col: 37, offset: 15786},
								name: "POS",
							},
						},
						&litMatcher{
							pos:        position{line: 508, col: 41, offset: 15790},
							val:        "else if",
							ignoreCase: false,
							want:       "\"else if\"",
						},
						&labeledExpr{
							pos:   position{line: 508, col: 51, offset: 15800},
							label: "condI",
							expr: &ruleRefExpr{
								pos:  position{line: 508, col: 57, offset: 15806},
								name: "condition",
							},
						},
						&labeledExpr{
							pos:   position{line: 508, col: 67, offset: 15816},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 508, col: 73, offset: 15822},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "Else",
			pos:  position{line: 516, col: 1, offset: 15985},
			expr: &actionExpr{
				pos: position{line: 516, col: 9, offset: 15993},
				run: (*parser).callonElse1,
				expr: &seqExpr{
					pos: position{line: 516, col: 9, offset: 15993},
					exprs: []interface{}{
						&zeroOrOneExpr{
							pos: position{line: 516, col: 9, offset: 15993},
							expr: &ruleRefExpr{
								pos:  position{line: 516, col: 9, offset: 15993},
								name: "NEW_LNS",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 516, col: 18, offset: 16002},
							name: "INDENTATION",
						},
						&litMatcher{
							pos:        position{line: 516, col: 30, offset: 16014},
							val:        "else",
							ignoreCase: false,
							want:       "\"else\"",
						},
						&labeledExpr{
							pos:   position{line: 516, col: 37, offset: 16021},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 516, col: 43, offset: 16027},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "IfBlock",
			pos:  position{line: 527, col: 1, offset: 16149},
			expr: &actionExpr{
				pos: position{line: 527, col: 12, offset: 16160},
				run: (*parser).callonIfBlock1,
				expr: &seqExpr{
					pos: position{line: 527, col: 12, offset: 16160},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 527, col: 12, offset: 16160},
							val:        "if block",
							ignoreCase: false,
							want:       "\"if block\"",
						},
						&labeledExpr{
							pos:   position{line: 527, col: 23, offset: 16171},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 527, col: 29, offset: 16177},
								name: "blockName",
							},
						},
						&labeledExpr{
							pos:   position{line: 527, col: 39, offset: 16187},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 527, col: 45, offset: 16193},
								name: "then",
							},
						},
						&labeledExpr{
							pos:   position{line: 527, col: 50, offset: 16198},
							label: "elseIfsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 527, col: 59, offset: 16207},
								expr: &ruleRefExpr{
									pos:  position{line: 527, col: 59, offset: 16207},
									name: "ElseIfBlock",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 527, col: 72, offset: 16220},
							label: "elseI",
							expr: &zeroOrOneExpr{
								pos: position{line: 527, col: 78, offset: 16226},
								expr: &ruleRefExpr{
									pos:  position{line: 527, col: 78, offset: 16226},
									name: "Else",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ElseIfBlock",
			pos:  position{line: 537, col: 1, offset: 16466},
			expr: &actionExpr{
				pos: position{line: 537, col: 16, offset: 16481},
				run: (*parser).callonElseIfBlock1,
				expr: &seqExpr{
					pos: position{line: 537, col: 16, offset: 16481},
					exprs: []interface{}{
						&zeroOrOneExpr{
							pos: position{line: 537, col: 16, offset: 16481},
							expr: &ruleRefExpr{
								pos:  position{line: 537, col: 16, offset: 16481},
								name: "NEW_LNS",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 537, col: 25, offset: 16490},
							name: "INDENTATION",
						},
						&labeledExpr{
							pos:   position{line: 537, col: 37, offset: 16502},
							label: "posI",
							expr: &ruleRefExpr{
								pos:  position{line: 537, col: 42, offset: 16507},
								name: "POS",
							},
						},
						&litMatcher{
							pos:        position{line: 537, col: 46, offset: 16511},
							val:        "else if block",
							ignoreCase: false,
							want:       "\"else if block\"",
						},
						&labeledExpr{
							pos:   position{line: 537, col: 62, offset: 16527},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 537, col: 68, offset: 16533},
								name: "blockName",
							},
						},
						&labeledExpr{
							pos:   position{line: 537, col: 78, offset: 16543},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 537, col: 84, offset: 16549},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "ElseBlock",
			pos:  position{line: 545, col: 1, offset: 16707},
			expr: &actionExpr{
				pos: position{line: 545, col: 14, offset: 16720},
				run: (*parser).callonElseBlock1,
				expr: &seqExpr{
					pos: position{line: 545, col: 14, offset: 16720},
					exprs: []interface{}{
						&zeroOrOneExpr{
							pos: position{line: 545, col: 14, offset: 16720},
							expr: &ruleRefExpr{
								pos:  position{line: 545, col: 14, offset: 16720},
								name: "NEW_LNS",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 545, col: 23, offset: 16729},
							name: "INDENTATION",
						},
						&litMatcher{
							pos:        position{line: 545, col: 35, offset: 16741},
							val:        "else",
							ignoreCase: false,
							want:       "\"else\"",
						},
						&labeledExpr{
							pos:   position{line: 545, col: 42, offset: 16748},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 545, col: 48, offset: 16754},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "Switch",
			pos:  position{line: 556, col: 1, offset: 17038},
			expr: &actionExpr{
				pos: position{line: 556, col: 11, offset: 17048},
				run: (*parser).callonSwitch1,
				expr: &seqExpr{
					pos: position{line: 556, col: 11, offset: 17048},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 556, col: 11, offset: 17048},
							val:        "switch",
							ignoreCase: false,
							want:       "\"switch\"",
						},
						&labeledExpr{
							pos:   position{line: 556, col: 20, offset: 17057},
							label: "comparatorI",
							expr: &ruleRefExpr{
								pos:  position{line: 556, col: 32, offset: 17069},
								name: "switchComparator",
							},
						},
						&labeledExpr{
							pos:   position{line: 556, col: 49, offset: 17086},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 556, col: 55, offset: 17092},
								name: "switchBody",
							},
						},
					},
				},
			},
		},
		{
			name: "switchComparator",
			pos:  position{line: 581, col: 1, offset: 17709},
			expr: &choiceExpr{
				pos: position{line: 581, col: 21, offset: 17729},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 581, col: 21, offset: 17729},
						run: (*parser).callonswitchComparator2,
						expr: &ruleRefExpr{
							pos:  position{line: 581, col: 21, offset: 17729},
							name: "EOL",
						},
					},
					&actionExpr{
						pos: position{line: 583, col: 5, offset: 17779},
						run: (*parser).callonswitchComparator4,
						expr: &seqExpr{
							pos: position{line: 583, col: 5, offset: 17779},
							exprs: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 583, col: 5, offset: 17779},
									expr: &litMatcher{
										pos:        position{line: 583, col: 5, offset: 17779},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 583, col: 10, offset: 17784},
									label: "compI",
									expr: &ruleRefExpr{
										pos:  position{line: 583, col: 16, offset: 17790},
										name: "IfExpression",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 583, col: 29, offset: 17803},
									name: "EOL",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 586, col: 5, offset: 17871},
						run: (*parser).callonswitchComparator11,
						expr: &seqExpr{
							pos: position{line: 586, col: 5, offset: 17871},
							exprs: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 586, col: 5, offset: 17871},
									expr: &litMatcher{
										pos:        position{line: 586, col: 5, offset: 17871},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 586, col: 10, offset: 17876},
									label: "compI",
									expr: &ruleRefExpr{
										pos:  position{line: 586, col: 16, offset: 17882},
										name: "IfExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 586, col: 29, offset: 17895},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 586, col: 39, offset: 17905},
										name: "POS",
									},
								},
								&oneOrMoreExpr{
									pos: position{line: 586, col: 43, offset: 17909},
									expr: &ruleRefExpr{
										pos:  position{line: 586, col: 43, offset: 17909},
										name: "NOT_EOL",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 586, col: 52, offset: 17918},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "switchBody",
			pos:  position{line: 597, col: 1, offset: 18232},
			expr: &actionExpr{
				pos: position{line: 597, col: 15, offset: 18246},
				run: (*parser).callonswitchBody1,
				expr: &seqExpr{
					pos: position{line: 597, col: 15, offset: 18246},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 597, col: 15, offset: 18246},
							name: "INDENT",
						},
						&labeledExpr{
							pos:   position{line: 597, col: 22, offset: 18253},
							label: "itms",
							expr: &zeroOrMoreExpr{
								pos: position{line: 597, col: 27, offset: 18258},
								expr: &seqExpr{
									pos: position{line: 597, col: 28, offset: 18259},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 597, col: 28, offset: 18259},
											expr: &ruleRefExpr{
												pos:  position{line: 597, col: 28, offset: 18259},
												name: "NEW_LNS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 597, col: 37, offset: 18268},
											name: "INDENTATION",
										},
										&ruleRefExpr{
											pos:  position{line: 597, col: 49, offset: 18280},
											name: "switchBodyItem",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 597, col: 66, offset: 18297},
							name: "DEDENT",
						},
					},
				},
			},
		},
		{
			name: "switchBodyItem",
			pos:  position{line: 635, col: 1, offset: 19545},
			expr: &choiceExpr{
				pos: position{line: 635, col: 19, offset: 19563},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 635, col: 19, offset: 19563},
						run: (*parser).callonswitchBodyItem2,
						expr: &labeledExpr{
							pos:   position{line: 635, col: 19, offset: 19563},
							label: "caseI",
							expr: &choiceExpr{
								pos: position{line: 635, col: 26, offset: 19570},
								alternatives: []interface{}{
									&ruleRefExpr{
										pos:  position{line: 635, col: 26, offset: 19570},
										name: "Case",
									},
									&ruleRefExpr{
										pos:  position{line: 635, col: 33, offset: 19577},
										name: "Default",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 637, col: 5, offset: 19627},
						run: (*parser).callonswitchBodyItem7,
						expr: &labeledExpr{
							pos:   position{line: 637, col: 5, offset: 19627},
							label: "caseI",
							expr: &ruleRefExpr{
								pos:  position{line: 637, col: 11, offset: 19633},
								name: "BadCase",
							},
						},
					},
				},
			},
		},
		{
			name: "Case",
			pos:  position{line: 641, col: 1, offset: 19682},
			expr: &actionExpr{
				pos: position{line: 641, col: 9, offset: 19690},
				run: (*parser).callonCase1,
				expr: &seqExpr{
					pos: position{line: 641, col: 9, offset: 19690},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 641, col: 9, offset: 19690},
							val:        "case",
							ignoreCase: false,
							want:       "\"case\"",
						},
						&labeledExpr{
							pos:   position{line: 641, col: 16, offset: 19697},
							label: "condI",
							expr: &ruleRefExpr{
								pos:  position{line: 641, col: 22, offset: 19703},
								name: "condition",
							},
						},
						&labeledExpr{
							pos:   position{line: 641, col: 32, offset: 19713},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 641, col: 38, offset: 19719},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "Default",
			pos:  position{line: 649, col: 1, offset: 19876},
			expr: &actionExpr{
				pos: position{line: 649, col: 12, offset: 19887},
				run: (*parser).callonDefault1,
				expr: &seqExpr{
					pos: position{line: 649, col: 12, offset: 19887},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 649, col: 12, offset: 19887},
							val:        "default",
							ignoreCase: false,
							want:       "\"default\"",
						},
						&labeledExpr{
							pos:   position{line: 649, col: 22, offset: 19897},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 649, col: 28, offset: 19903},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "BadCase",
			pos:  position{line: 656, col: 1, offset: 20006},
			expr: &actionExpr{
				pos: position{line: 656, col: 12, offset: 20017},
				run: (*parser).callonBadCase1,
				expr: &seqExpr{
					pos: position{line: 656, col: 12, offset: 20017},
					exprs: []interface{}{
						&oneOrMoreExpr{
							pos: position{line: 656, col: 12, offset: 20017},
							expr: &ruleRefExpr{
								pos:  position{line: 656, col: 12, offset: 20017},
								name: "NOT_EOL",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 656, col: 21, offset: 20026},
							name: "EOL",
						},
						&labeledExpr{
							pos:   position{line: 656, col: 25, offset: 20030},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 656, col: 31, offset: 20036},
								expr: &ruleRefExpr{
									pos:  position{line: 656, col: 31, offset: 20036},
									name: "Body",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "For",
			pos:  position{line: 679, col: 1, offset: 20723},
			expr: &actionExpr{
				pos: position{line: 679, col: 8, offset: 20730},
				run: (*parser).callonFor1,
				expr: &seqExpr{
					pos: position{line: 679, col: 8, offset: 20730},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 679, col: 8, offset: 20730},
							val:        "for",
							ignoreCase: false,
							want:       "\"for\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 679, col: 14, offset: 20736},
							expr: &litMatcher{
								pos:        position{line: 679, col: 14, offset: 20736},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 679, col: 19, offset: 20741},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 679, col: 25, offset: 20747},
								name: "ForExpression",
							},
						},
						&labeledExpr{
							pos:   position{line: 679, col: 39, offset: 20761},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 679, col: 45, offset: 20767},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "Ident",
			pos:  position{line: 691, col: 1, offset: 21095},
			expr: &choiceExpr{
				pos: position{line: 691, col: 10, offset: 21104},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 691, col: 10, offset: 21104},
						run: (*parser).callonIdent2,
						expr: &labeledExpr{
							pos:   position{line: 691, col: 10, offset: 21104},
							label: "identI",
							expr: &ruleRefExpr{
								pos:  position{line: 691, col: 17, offset: 21111},
								name: "goIdentifier",
							},
						},
					},
					&actionExpr{
						pos: position{line: 693, col: 5, offset: 21198},
						run: (*parser).callonIdent5,
						expr: &seqExpr{
							pos: position{line: 693, col: 5, offset: 21198},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 693, col: 5, offset: 21198},
									label: "identI",
									expr: &seqExpr{
										pos: position{line: 693, col: 13, offset: 21206},
										exprs: []interface{}{
											&zeroOrOneExpr{
												pos: position{line: 693, col: 13, offset: 21206},
												expr: &litMatcher{
													pos:        position{line: 693, col: 13, offset: 21206},
													val:        "$",
													ignoreCase: false,
													want:       "\"$\"",
												},
											},
											&oneOrMoreExpr{
												pos: position{line: 693, col: 18, offset: 21211},
												expr: &choiceExpr{
													pos: position{line: 693, col: 19, offset: 21212},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 693, col: 19, offset: 21212},
															exprs: []interface{}{
																&charClassMatcher{
																	pos:        position{line: 693, col: 19, offset: 21212},
																	val:        "[\\p{Nd}]",
																	classes:    []*unicode.RangeTable{rangeTable("Nd")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 693, col: 28, offset: 21221},
																	val:        "[_-\\pL]",
																	chars:      []rune{'_', '-'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&charClassMatcher{
															pos:        position{line: 693, col: 38, offset: 21231},
															val:        "[_-\\pL]",
															chars:      []rune{'_', '-'},
															classes:    []*unicode.RangeTable{rangeTable("L")},
															ignoreCase: false,
															inverted:   false,
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 693, col: 49, offset: 21242},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 693, col: 57, offset: 21250},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "MustIdent",
			pos:  position{line: 705, col: 1, offset: 21646},
			expr: &choiceExpr{
				pos: position{line: 705, col: 14, offset: 21659},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 705, col: 14, offset: 21659},
						run: (*parser).callonMustIdent2,
						expr: &labeledExpr{
							pos:   position{line: 705, col: 14, offset: 21659},
							label: "identI",
							expr: &ruleRefExpr{
								pos:  position{line: 705, col: 21, offset: 21666},
								name: "Ident",
							},
						},
					},
					&actionExpr{
						pos: position{line: 707, col: 5, offset: 21701},
						run: (*parser).callonMustIdent5,
						expr: &seqExpr{
							pos: position{line: 707, col: 5, offset: 21701},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 707, col: 5, offset: 21701},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 707, col: 10, offset: 21706},
										name: "POS",
									},
								},
								&andExpr{
									pos: position{line: 707, col: 14, offset: 21710},
									expr: &choiceExpr{
										pos: position{line: 707, col: 16, offset: 21712},
										alternatives: []interface{}{
											&ruleRefExpr{
												pos:  position{line: 707, col: 16, offset: 21712},
												name: "EOL",
											},
											&litMatcher{
												pos:        position{line: 707, col: 22, offset: 21718},
												val:        ":",
												ignoreCase: false,
												want:       "\":\"",
											},
											&litMatcher{
												pos:        position{line: 707, col: 28, offset: 21724},
												val:        "!",
												ignoreCase: false,
												want:       "\"!\"",
											},
											&litMatcher{
												pos:        position{line: 707, col: 34, offset: 21730},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
											&litMatcher{
												pos:        position{line: 707, col: 40, offset: 21736},
												val:        "(",
												ignoreCase: false,
												want:       "\"(\"",
											},
											&litMatcher{
												pos:        position{line: 707, col: 46, offset: 21742},
												val:        ")",
												ignoreCase: false,
												want:       "\")\"",
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 718, col: 5, offset: 22050},
						run: (*parser).callonMustIdent17,
						expr: &seqExpr{
							pos: position{line: 718, col: 5, offset: 22050},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 718, col: 5, offset: 22050},
									label: "identI",
									expr: &oneOrMoreExpr{
										pos: position{line: 718, col: 12, offset: 22057},
										expr: &charClassMatcher{
											pos:        position{line: 718, col: 12, offset: 22057},
											val:        "[^ \\t\\r\\n:!=()]",
											chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 718, col: 29, offset: 22074},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 718, col: 37, offset: 22082},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "MustIdentIfText",
			pos:  position{line: 733, col: 1, offset: 22501},
			expr: &choiceExpr{
				pos: position{line: 733, col: 20, offset: 22520},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 733, col: 20, offset: 22520},
						run: (*parser).callonMustIdentIfText2,
						expr: &labeledExpr{
							pos:   position{line: 733, col: 20, offset: 22520},
							label: "identI",
							expr: &ruleRefExpr{
								pos:  position{line: 733, col: 27, offset: 22527},
								name: "Ident",
							},
						},
					},
					&actionExpr{
						pos: position{line: 735, col: 5, offset: 22562},
						run: (*parser).callonMustIdentIfText5,
						expr: &seqExpr{
							pos: position{line: 735, col: 5, offset: 22562},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 735, col: 5, offset: 22562},
									label: "identI",
									expr: &oneOrMoreExpr{
										pos: position{line: 735, col: 12, offset: 22569},
										expr: &charClassMatcher{
											pos:        position{line: 735, col: 12, offset: 22569},
											val:        "[^ \\t\\r\\n:!=()]",
											chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 735, col: 29, offset: 22586},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 735, col: 37, offset: 22594},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "String",
			pos:  position{line: 754, col: 1, offset: 23194},
			expr: &choiceExpr{
				pos: position{line: 754, col: 11, offset: 23204},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 754, col: 11, offset: 23204},
						name: "rawString",
					},
					&ruleRefExpr{
						pos:  position{line: 754, col: 23, offset: 23216},
						name: "interpretedString",
					},
					&ruleRefExpr{
						pos:  position{line: 754, col: 43, offset: 23236},
						name: "singleQuoteString",
					},
				},
			},
		},
		{
			name: "rawString",
			pos:  position{line: 760, col: 1, offset: 23278},
			expr: &choiceExpr{
				pos: position{line: 760, col: 14, offset: 23291},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 760, col: 14, offset: 23291},
						run: (*parser).callonrawString2,
						expr: &seqExpr{
							pos: position{line: 760, col: 14, offset: 23291},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 760, col: 14, offset: 23291},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
								&labeledExpr{
									pos:   position{line: 760, col: 18, offset: 23295},
									label: "strI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 760, col: 23, offset: 23300},
										expr: &ruleRefExpr{
											pos:  position{line: 760, col: 23, offset: 23300},
											name: "goRawStringUnicodeChar",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 760, col: 47, offset: 23324},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 762, col: 5, offset: 23416},
						run: (*parser).callonrawString9,
						expr: &seqExpr{
							pos: position{line: 762, col: 5, offset: 23416},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 762, col: 5, offset: 23416},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
								&labeledExpr{
									pos:   position{line: 762, col: 9, offset: 23420},
									label: "strI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 762, col: 14, offset: 23425},
										expr: &ruleRefExpr{
											pos:  position{line: 762, col: 14, offset: 23425},
											name: "goRawStringUnicodeChar",
										},
									},
								},
								&andExpr{
									pos: position{line: 762, col: 38, offset: 23449},
									expr: &ruleRefExpr{
										pos:  position{line: 762, col: 39, offset: 23450},
										name: "EOL",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "interpretedString",
			pos:  position{line: 781, col: 1, offset: 23832},
			expr: &choiceExpr{
				pos: position{line: 781, col: 22, offset: 23853},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 781, col: 22, offset: 23853},
						run: (*parser).calloninterpretedString2,
						expr: &seqExpr{
							pos: position{line: 781, col: 22, offset: 23853},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 781, col: 22, offset: 23853},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
								&labeledExpr{
									pos:   position{line: 781, col: 26, offset: 23857},
									label: "strI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 781, col: 31, offset: 23862},
										expr: &choiceExpr{
											pos: position{line: 781, col: 32, offset: 23863},
											alternatives: []interface{}{
												&ruleRefExpr{
													pos:  position{line: 781, col: 32, offset: 23863},
													name: "goByteValue",
												},
												&ruleRefExpr{
													pos:  position{line: 781, col: 46, offset: 23877},
													name: "goInterpretedStringUnicodeValue",
												},
												&ruleRefExpr{
													pos:  position{line: 781, col: 80, offset: 23911},
													name: "goRecoverInterpretedStringEscape",
												},
											},
										},
									},
								},
								&litMatcher{
									pos:        position{line: 781, col: 115, offset: 23946},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 783, col: 5, offset: 24038},
						run: (*parser).calloninterpretedString12,
						expr: &seqExpr{
							pos: position{line: 783, col: 5, offset: 24038},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 783, col: 5, offset: 24038},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
								&labeledExpr{
									pos:   position{line: 783, col: 9, offset: 24042},
									label: "strI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 783, col: 14, offset: 24047},
										expr: &choiceExpr{
											pos: position{line: 783, col: 15, offset: 24048},
											alternatives: []interface{}{
												&ruleRefExpr{
													pos:  position{line: 783, col: 15, offset: 24048},
													name: "goByteValue",
												},
												&ruleRefExpr{
													pos:  position{line: 783, col: 29, offset: 24062},
													name: "goInterpretedStringUnicodeValue",
												},
												&ruleRefExpr{
													pos:  position{line: 783, col: 63, offset: 24096},
													name: "goRecoverInterpretedStringEscape",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 783, col: 98, offset: 24131},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 783, col: 106, offset: 24139},
										name: "POS",
									},
								},
								&andExpr{
									pos: position{line: 783, col: 110, offset: 24143},
									expr: &ruleRefExpr{
										pos:  position{line: 783, col: 111, offset: 24144},
										name: "EOL",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleQuoteString",
			pos:  position{line: 802, col: 1, offset: 24528},
			expr: &actionExpr{
				pos: position{line: 802, col: 22, offset: 24549},
				run: (*parser).callonsingleQuoteString1,
				expr: &seqExpr{
					pos: position{line: 802, col: 22, offset: 24549},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 802, col: 22, offset: 24549},
							val:        "'",
							ignoreCase: false,
							want:       "\"'\"",
						},
						&labeledExpr{
							pos:   position{line: 802, col: 27, offset: 24554},
							label: "strI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 802, col: 32, offset: 24559},
								expr: &charClassMatcher{
									pos:        position{line: 802, col: 32, offset: 24559},
									val:        "[^'\\r\\n]",
									chars:      []rune{'\'', '\r', '\n'},
									ignoreCase: false,
									inverted:   true,
								},
							},
						},
						&litMatcher{
							pos:        position{line: 802, col: 42, offset: 24569},
							val:        "'",
							ignoreCase: false,
							want:       "\"'\"",
						},
						&labeledExpr{
							pos:   position{line: 802, col: 47, offset: 24574},
							label: "endPosI",
							expr: &ruleRefExpr{
								pos:  position{line: 802, col: 55, offset: 24582},
								name: "POS",
							},
						},
					},
				},
			},
		},
		{
			name: "CorgiComments",
			pos:  position{line: 835, col: 1, offset: 25665},
			expr: &actionExpr{
				pos: position{line: 835, col: 18, offset: 25682},
				run: (*parser).callonCorgiComments1,
				expr: &labeledExpr{
					pos:   position{line: 835, col: 18, offset: 25682},
					label: "commentsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 835, col: 28, offset: 25692},
						expr: &seqExpr{
							pos: position{line: 835, col: 29, offset: 25693},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 835, col: 29, offset: 25693},
									expr: &ruleRefExpr{
										pos:  position{line: 835, col: 29, offset: 25693},
										name: "NEW_LNS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 835, col: 38, offset: 25702},
									name: "CorgiComment",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "CorgiComment",
			pos:  position{line: 839, col: 1, offset: 25793},
			expr: &actionExpr{
				pos: position{line: 839, col: 17, offset: 25809},
				run: (*parser).callonCorgiComment1,
				expr: &seqExpr{
					pos: position{line: 839, col: 17, offset: 25809},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 839, col: 17, offset: 25809},
							val:        "//",
							ignoreCase: false,
							want:       "\"//\"",
						},
						&notExpr{
							pos: position{line: 839, col: 22, offset: 25814},
							expr: &litMatcher{
								pos:        position{line: 839, col: 23, offset: 25815},
								val:        "-",
								ignoreCase: false,
								want:       "\"-\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 839, col: 27, offset: 25819},
							label: "linesI",
							expr: &ruleRefExpr{
								pos:  position{line: 839, col: 34, offset: 25826},
								name: "corgiCommentLines",
							},
						},
					},
				},
			},
		},
		{
			name: "corgiCommentLines",
			pos:  position{line: 846, col: 1, offset: 25965},
			expr: &choiceExpr{
				pos: position{line: 846, col: 22, offset: 25986},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 846, col: 22, offset: 25986},
						run: (*parser).calloncorgiCommentLines2,
						expr: &seqExpr{
							pos: position{line: 846, col: 22, offset: 25986},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 846, col: 22, offset: 25986},
									expr: &ruleRefExpr{
										pos:  position{line: 846, col: 22, offset: 25986},
										name: "_",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 846, col: 25, offset: 25989},
									name: "EOL",
								},
								&labeledExpr{
									pos:   position{line: 846, col: 29, offset: 25993},
									label: "linesI",
									expr: &ruleRefExpr{
										pos:  position{line: 846, col: 36, offset: 26000},
										name: "corgiCommentBlock",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 848, col: 5, offset: 26047},
						run: (*parser).calloncorgiCommentLines9,
						expr: &labeledExpr{
							pos:   position{line: 848, col: 5, offset: 26047},
							label: "lineI",
							expr: &ruleRefExpr{
								pos:  position{line: 848, col: 11, offset: 26053},
								name: "corgiCommentLine",
							},
						},
					},
				},
			},
		},
		{
			name: "corgiCommentBlock",
			pos:  position{line: 852, col: 1, offset: 26146},
			expr: &actionExpr{
				pos: position{line: 852, col: 22, offset: 26167},
				run: (*parser).calloncorgiCommentBlock1,
				expr: &seqExpr{
					pos: position{line: 852, col: 22, offset: 26167},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 852, col: 22, offset: 26167},
							name: "INDENT",
						},
						&labeledExpr{
							pos:   position{line: 852, col: 29, offset: 26174},
							label: "linesI",
							expr: &oneOrMoreExpr{
								pos: position{line: 852, col: 36, offset: 26181},
								expr: &seqExpr{
									pos: position{line: 852, col: 37, offset: 26182},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 852, col: 37, offset: 26182},
											expr: &ruleRefExpr{
												pos:  position{line: 852, col: 37, offset: 26182},
												name: "NEW_LNS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 852, col: 46, offset: 26191},
											name: "INDENTATION_IGNORE_ADDITIONAL",
										},
										&ruleRefExpr{
											pos:  position{line: 852, col: 76, offset: 26221},
											name: "corgiCommentLine",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 852, col: 95, offset: 26240},
							name: "DEDENT",
						},
					},
				},
			},
		},
		{
			name: "corgiCommentLine",
			pos:  position{line: 856, col: 1, offset: 26324},
			expr: &actionExpr{
				pos: position{line: 856, col: 21, offset: 26344},
				run: (*parser).calloncorgiCommentLine1,
				expr: &seqExpr{
					pos: position{line: 856, col: 21, offset: 26344},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 856, col: 21, offset: 26344},
							label: "commentI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 856, col: 30, offset: 26353},
								expr: &ruleRefExpr{
									pos:  position{line: 856, col: 30, offset: 26353},
									name: "NOT_EOL",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 856, col: 39, offset: 26362},
							name: "EOL",
						},
					},
				},
			},
		},
		{
			name: "Doctype",
			pos:  position{line: 864, col: 1, offset: 26636},
			expr: &choiceExpr{
				pos: position{line: 864, col: 12, offset: 26647},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 864, col: 12, offset: 26647},
						run: (*parser).callonDoctype2,
						expr: &seqExpr{
							pos: position{line: 864, col: 12, offset: 26647},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 864, col: 12, offset: 26647},
									val:        "doctype",
									ignoreCase: false,
									want:       "\"doctype\"",
								},
								&ruleRefExpr{
									pos:  position{line: 864, col: 22, offset: 26657},
									name: "behindDoctype",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 866, col: 5, offset: 26724},
						run: (*parser).callonDoctype6,
						expr: &seqExpr{
							pos: position{line: 866, col: 5, offset: 26724},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 866, col: 5, offset: 26724},
									val:        "!doctype",
									ignoreCase: false,
									want:       "\"!doctype\"",
								},
								&ruleRefExpr{
									pos:  position{line: 866, col: 16, offset: 26735},
									name: "behindDoctype",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "behindDoctype",
			pos:  position{line: 877, col: 1, offset: 27053},
			expr: &choiceExpr{
				pos: position{line: 877, col: 18, offset: 27070},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 877, col: 18, offset: 27070},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 877, col: 18, offset: 27070},
								val:        " html",
								ignoreCase: false,
								want:       "\" html\"",
							},
							&ruleRefExpr{
								pos:  position{line: 877, col: 26, offset: 27078},
								name: "EOL",
							},
						},
					},
					&actionExpr{
						pos: position{line: 878, col: 5, offset: 27088},
						run: (*parser).callonbehindDoctype5,
						expr: &seqExpr{
							pos: position{line: 878, col: 5, offset: 27088},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 878, col: 5, offset: 27088},
									val:        " ",
									ignoreCase: false,
									want:       "\" \"",
								},
								&labeledExpr{
									pos:   position{line: 878, col: 9, offset: 27092},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 878, col: 19, offset: 27102},
										name: "POS",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 878, col: 23, offset: 27106},
									expr: &ruleRefExpr{
										pos:  position{line: 878, col: 23, offset: 27106},
										name: "NOT_EOL",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 878, col: 32, offset: 27115},
									name: "EOL",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 888, col: 9, offset: 27487},
						run: (*parser).callonbehindDoctype13,
						expr: &seqExpr{
							pos: position{line: 888, col: 9, offset: 27487},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 888, col: 9, offset: 27487},
									expr: &litMatcher{
										pos:        position{line: 888, col: 9, offset: 27487},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 888, col: 14, offset: 27492},
									expr: &ruleRefExpr{
										pos:  position{line: 888, col: 14, offset: 27492},
										name: "NOT_EOL",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 888, col: 23, offset: 27501},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "HTMLComment",
			pos:  position{line: 905, col: 1, offset: 28026},
			expr: &actionExpr{
				pos: position{line: 905, col: 16, offset: 28041},
				run: (*parser).callonHTMLComment1,
				expr: &seqExpr{
					pos: position{line: 905, col: 16, offset: 28041},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 905, col: 16, offset: 28041},
							val:        "//-",
							ignoreCase: false,
							want:       "\"//-\"",
						},
						&labeledExpr{
							pos:   position{line: 905, col: 22, offset: 28047},
							label: "linesI",
							expr: &choiceExpr{
								pos: position{line: 906, col: 5, offset: 28060},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 906, col: 5, offset: 28060},
										run: (*parser).callonHTMLComment6,
										expr: &seqExpr{
											pos: position{line: 906, col: 5, offset: 28060},
											exprs: []interface{}{
												&ruleRefExpr{
													pos:  position{line: 906, col: 5, offset: 28060},
													name: "EOL",
												},
												&labeledExpr{
													pos:   position{line: 906, col: 9, offset: 28064},
													label: "linesI",
													expr: &ruleRefExpr{
														pos:  position{line: 906, col: 16, offset: 28071},
														name: "htmlCommentBlock",
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 908, col: 9, offset: 28125},
										run: (*parser).callonHTMLComment11,
										expr: &labeledExpr{
											pos:   position{line: 908, col: 9, offset: 28125},
											label: "lineI",
											expr: &ruleRefExpr{
												pos:  position{line: 908, col: 15, offset: 28131},
												name: "htmlCommentLine",
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "htmlCommentBlock",
			pos:  position{line: 918, col: 1, offset: 28349},
			expr: &actionExpr{
				pos: position{line: 918, col: 21, offset: 28369},
				run: (*parser).callonhtmlCommentBlock1,
				expr: &seqExpr{
					pos: position{line: 918, col: 21, offset: 28369},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 918, col: 21, offset: 28369},
							name: "INDENT",
						},
						&labeledExpr{
							pos:   position{line: 918, col: 28, offset: 28376},
							label: "linesI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 918, col: 35, offset: 28383},
								expr: &seqExpr{
									pos: position{line: 918, col: 36, offset: 28384},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 918, col: 36, offset: 28384},
											expr: &ruleRefExpr{
												pos:  position{line: 918, col: 36, offset: 28384},
												name: "NEW_LNS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 918, col: 45, offset: 28393},
											name: "INDENTATION_IGNORE_ADDITIONAL",
										},
										&ruleRefExpr{
											pos:  position{line: 918, col: 75, offset: 28423},
											name: "htmlCommentLine",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 918, col: 93, offset: 28441},
							name: "DEDENT",
						},
					},
				},
			},
		},
		{
			name: "htmlCommentLine",
			pos:  position{line: 922, col: 1, offset: 28524},
			expr: &actionExpr{
				pos: position{line: 922, col: 20, offset: 28543},
				run: (*parser).callonhtmlCommentLine1,
				expr: &seqExpr{
					pos: position{line: 922, col: 20, offset: 28543},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 922, col: 20, offset: 28543},
							label: "commentI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 922, col: 29, offset: 28552},
								expr: &ruleRefExpr{
									pos:  position{line: 922, col: 29, offset: 28552},
									name: "NOT_EOL",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 922, col: 38, offset: 28561},
							name: "EOL",
						},
					},
				},
			},
		},
		{
			name: "Element",
			pos:  position{line: 930, col: 1, offset: 28834},
			expr: &actionExpr{
				pos: position{line: 930, col: 12, offset: 28845},
				run: (*parser).callonElement1,
				expr: &seqExpr{
					pos: position{line: 930, col: 12, offset: 28845},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 930, col: 12, offset: 28845},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 930, col: 18, offset: 28851},
								name: "htmlTagName",
							},
						},
						&labeledExpr{
							pos:   position{line: 930, col: 30, offset: 28863},
							label: "attrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 930, col: 37, offset: 28870},
								expr: &ruleRefExpr{
									pos:  position{line: 930, col: 37, offset: 28870},
									name: "AttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 930, col: 58, offset: 28891},
							label: "voidI",
							expr: &zeroOrOneExpr{
								pos: position{line: 930, col: 64, offset: 28897},
								expr: &litMatcher{
									pos:        position{line: 930, col: 64, offset: 28897},
									val:        "/",
									ignoreCase: false,
									want:       "\"/\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 930, col: 69, offset: 28902},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 930, col: 75, offset: 28908},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineElement",
			pos:  position{line: 940, col: 1, offset: 29139},
			expr: &actionExpr{
				pos: position{line: 940, col: 18, offset: 29156},
				run: (*parser).callonInlineElement1,
				expr: &seqExpr{
					pos: position{line: 940, col: 18, offset: 29156},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 940, col: 18, offset: 29156},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 940, col: 24, offset: 29162},
								name: "htmlTagName",
							},
						},
						&labeledExpr{
							pos:   position{line: 940, col: 36, offset: 29174},
							label: "attrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 940, col: 43, offset: 29181},
								expr: &ruleRefExpr{
									pos:  position{line: 940, col: 43, offset: 29181},
									name: "SingleLineAttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 940, col: 74, offset: 29212},
							label: "voidI",
							expr: &zeroOrOneExpr{
								pos: position{line: 940, col: 80, offset: 29218},
								expr: &litMatcher{
									pos:        position{line: 940, col: 80, offset: 29218},
									val:        "/",
									ignoreCase: false,
									want:       "\"/\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 940, col: 85, offset: 29223},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 940, col: 91, offset: 29229},
								name: "Beait",
							},
						},
					},
				},
			},
		},
		{
			name: "DivShorthand",
			pos:  position{line: 954, col: 1, offset: 29646},
			expr: &actionExpr{
				pos: position{line: 954, col: 17, offset: 29662},
				run: (*parser).callonDivShorthand1,
				expr: &seqExpr{
					pos: position{line: 954, col: 17, offset: 29662},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 954, col: 17, offset: 29662},
							label: "firstAttrI",
							expr: &choiceExpr{
								pos: position{line: 954, col: 29, offset: 29674},
								alternatives: []interface{}{
									&ruleRefExpr{
										pos:  position{line: 954, col: 29, offset: 29674},
										name: "ClassShorthand",
									},
									&ruleRefExpr{
										pos:  position{line: 954, col: 46, offset: 29691},
										name: "IDShorthand",
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 954, col: 59, offset: 29704},
							label: "moreAttrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 954, col: 70, offset: 29715},
								expr: &ruleRefExpr{
									pos:  position{line: 954, col: 70, offset: 29715},
									name: "AttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 954, col: 91, offset: 29736},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 954, col: 97, offset: 29742},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineDivShorthand",
			pos:  position{line: 962, col: 1, offset: 30003},
			expr: &actionExpr{
				pos: position{line: 962, col: 23, offset: 30025},
				run: (*parser).callonInlineDivShorthand1,
				expr: &seqExpr{
					pos: position{line: 962, col: 23, offset: 30025},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 962, col: 23, offset: 30025},
							label: "firstAttrI",
							expr: &choiceExpr{
								pos: position{line: 962, col: 35, offset: 30037},
								alternatives: []interface{}{
									&ruleRefExpr{
										pos:  position{line: 962, col: 35, offset: 30037},
										name: "ClassShorthand",
									},
									&ruleRefExpr{
										pos:  position{line: 962, col: 52, offset: 30054},
										name: "IDShorthand",
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 962, col: 65, offset: 30067},
							label: "moreAttrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 962, col: 76, offset: 30078},
								expr: &ruleRefExpr{
									pos:  position{line: 962, col: 76, offset: 30078},
									name: "SingleLineAttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 962, col: 107, offset: 30109},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 962, col: 113, offset: 30115},
								name: "Beait",
							},
						},
					},
				},
			},
		},
		{
			name: "And",
			pos:  position{line: 974, col: 1, offset: 30553},
			expr: &choiceExpr{
				pos: position{line: 974, col: 8, offset: 30560},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 974, col: 8, offset: 30560},
						run: (*parser).callonAnd2,
						expr: &seqExpr{
							pos: position{line: 974, col: 8, offset: 30560},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 974, col: 8, offset: 30560},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 974, col: 12, offset: 30564},
									label: "collsI",
									expr: &oneOrMoreExpr{
										pos: position{line: 974, col: 19, offset: 30571},
										expr: &ruleRefExpr{
											pos:  position{line: 974, col: 19, offset: 30571},
											name: "AttributeCollection",
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 974, col: 40, offset: 30592},
									name: "EOL",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 979, col: 5, offset: 30726},
						run: (*parser).callonAnd9,
						expr: &seqExpr{
							pos: position{line: 979, col: 5, offset: 30726},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 979, col: 5, offset: 30726},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 979, col: 9, offset: 30730},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 979, col: 14, offset: 30735},
										name: "POS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 979, col: 18, offset: 30739},
									name: "EOL",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 994, col: 5, offset: 31326},
						run: (*parser).callonAnd15,
						expr: &seqExpr{
							pos: position{line: 994, col: 5, offset: 31326},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 994, col: 5, offset: 31326},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 994, col: 9, offset: 31330},
									label: "collsI",
									expr: &oneOrMoreExpr{
										pos: position{line: 994, col: 16, offset: 31337},
										expr: &ruleRefExpr{
											pos:  position{line: 994, col: 16, offset: 31337},
											name: "AttributeCollection",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 994, col: 37, offset: 31358},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 994, col: 42, offset: 31363},
										name: "POS",
									},
								},
								&oneOrMoreExpr{
									pos: position{line: 994, col: 46, offset: 31367},
									expr: &ruleRefExpr{
										pos:  position{line: 994, col: 46, offset: 31367},
										name: "NOT_EOL",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 994, col: 55, offset: 31376},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineAnd",
			pos:  position{line: 1016, col: 1, offset: 32237},
			expr: &choiceExpr{
				pos: position{line: 1016, col: 14, offset: 32250},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1016, col: 14, offset: 32250},
						run: (*parser).callonInlineAnd2,
						expr: &seqExpr{
							pos: position{line: 1016, col: 14, offset: 32250},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1016, col: 14, offset: 32250},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 1016, col: 18, offset: 32254},
									label: "collsI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1016, col: 25, offset: 32261},
										expr: &ruleRefExpr{
											pos:  position{line: 1016, col: 25, offset: 32261},
											name: "SingleLineAttributeCollection",
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 1016, col: 56, offset: 32292},
									name: "EOL",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1021, col: 5, offset: 32426},
						run: (*parser).callonInlineAnd9,
						expr: &seqExpr{
							pos: position{line: 1021, col: 5, offset: 32426},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1021, col: 5, offset: 32426},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 1021, col: 9, offset: 32430},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 1021, col: 14, offset: 32435},
										name: "POS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 1021, col: 18, offset: 32439},
									name: "EOL",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1036, col: 5, offset: 33026},
						run: (*parser).callonInlineAnd15,
						expr: &seqExpr{
							pos: position{line: 1036, col: 5, offset: 33026},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1036, col: 5, offset: 33026},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 1036, col: 9, offset: 33030},
									label: "collsI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1036, col: 16, offset: 33037},
										expr: &ruleRefExpr{
											pos:  position{line: 1036, col: 16, offset: 33037},
											name: "SingleLineAttributeCollection",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1036, col: 47, offset: 33068},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 1036, col: 52, offset: 33073},
										name: "POS",
									},
								},
								&oneOrMoreExpr{
									pos: position{line: 1036, col: 56, offset: 33077},
									expr: &ruleRefExpr{
										pos:  position{line: 1036, col: 56, offset: 33077},
										name: "NOT_EOL",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 1036, col: 65, offset: 33086},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeCollection",
			pos:  position{line: 1062, col: 1, offset: 34141},
			expr: &choiceExpr{
				pos: position{line: 1062, col: 34, offset: 34174},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1062, col: 34, offset: 34174},
						name: "IDShorthand",
					},
					&ruleRefExpr{
						pos:  position{line: 1062, col: 48, offset: 34188},
						name: "ClassShorthand",
					},
					&ruleRefExpr{
						pos:  position{line: 1062, col: 65, offset: 34205},
						name: "AttributeList",
					},
				},
			},
		},
		{
			name: "SingleLineAttributeCollection",
			pos:  position{line: 1063, col: 1, offset: 34219},
			expr: &choiceExpr{
				pos: position{line: 1063, col: 34, offset: 34252},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1063, col: 34, offset: 34252},
						name: "IDShorthand",
					},
					&ruleRefExpr{
						pos:  position{line: 1063, col: 48, offset: 34266},
						name: "ClassShorthand",
					},
					&ruleRefExpr{
						pos:  position{line: 1063, col: 65, offset: 34283},
						name: "SingleLineAttributeList",
					},
				},
			},
		},
		{
			name: "IDShorthand",
			pos:  position{line: 1068, col: 1, offset: 34327},
			expr: &choiceExpr{
				pos: position{line: 1068, col: 16, offset: 34342},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1068, col: 16, offset: 34342},
						run: (*parser).callonIDShorthand2,
						expr: &seqExpr{
							pos: position{line: 1068, col: 16, offset: 34342},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1068, col: 16, offset: 34342},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1068, col: 20, offset: 34346},
									label: "idI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1068, col: 24, offset: 34350},
										expr: &charClassMatcher{
											pos:        position{line: 1068, col: 24, offset: 34350},
											val:        "[^ \\t\\r\\n.()]",
											chars:      []rune{' ', '\t', '\r', '\n', '.', '(', ')'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1073, col: 5, offset: 34462},
						run: (*parser).callonIDShorthand8,
						expr: &seqExpr{
							pos: position{line: 1073, col: 5, offset: 34462},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1073, col: 5, offset: 34462},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1073, col: 9, offset: 34466},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 1073, col: 14, offset: 34471},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ClassShorthand",
			pos:  position{line: 1087, col: 1, offset: 34765},
			expr: &choiceExpr{
				pos: position{line: 1087, col: 19, offset: 34783},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1087, col: 19, offset: 34783},
						run: (*parser).callonClassShorthand2,
						expr: &seqExpr{
							pos: position{line: 1087, col: 19, offset: 34783},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1087, col: 19, offset: 34783},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&labeledExpr{
									pos:   position{line: 1087, col: 23, offset: 34787},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1087, col: 29, offset: 34793},
										expr: &charClassMatcher{
											pos:        position{line: 1087, col: 29, offset: 34793},
											val:        "[^ \\t\\r\\n.()]",
											chars:      []rune{' ', '\t', '\r', '\n', '.', '(', ')'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1092, col: 5, offset: 34912},
						run: (*parser).callonClassShorthand8,
						expr: &seqExpr{
							pos: position{line: 1092, col: 5, offset: 34912},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1092, col: 5, offset: 34912},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&labeledExpr{
									pos:   position{line: 1092, col: 9, offset: 34916},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 1092, col: 14, offset: 34921},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeList",
			pos:  position{line: 1106, col: 1, offset: 35235},
			expr: &choiceExpr{
				pos: position{line: 1106, col: 18, offset: 35252},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1106, col: 18, offset: 35252},
						run: (*parser).callonAttributeList2,
						expr: &seqExpr{
							pos: position{line: 1106, col: 18, offset: 35252},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1106, col: 18, offset: 35252},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1106, col: 22, offset: 35256},
									expr: &ruleRefExpr{
										pos:  position{line: 1106, col: 22, offset: 35256},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1106, col: 26, offset: 35260},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1106, col: 38, offset: 35272},
										expr: &ruleRefExpr{
											pos:  position{line: 1106, col: 38, offset: 35272},
											name: "attributes",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1106, col: 50, offset: 35284},
									expr: &litMatcher{
										pos:        position{line: 1106, col: 50, offset: 35284},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1106, col: 55, offset: 35289},
									expr: &seqExpr{
										pos: position{line: 1106, col: 56, offset: 35290},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1106, col: 56, offset: 35290},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1106, col: 60, offset: 35294},
												expr: &ruleRefExpr{
													pos:  position{line: 1106, col: 60, offset: 35294},
													name: "WS",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1106, col: 66, offset: 35300},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1106, col: 77, offset: 35311},
										name: "R_PAREN",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1112, col: 5, offset: 35506},
						run: (*parser).callonAttributeList19,
						expr: &seqExpr{
							pos: position{line: 1112, col: 5, offset: 35506},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1112, col: 5, offset: 35506},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1112, col: 9, offset: 35510},
									expr: &ruleRefExpr{
										pos:  position{line: 1112, col: 9, offset: 35510},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1112, col: 13, offset: 35514},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1112, col: 25, offset: 35526},
										expr: &ruleRefExpr{
											pos:  position{line: 1112, col: 25, offset: 35526},
											name: "attributes",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1112, col: 37, offset: 35538},
									expr: &seqExpr{
										pos: position{line: 1112, col: 38, offset: 35539},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 1112, col: 38, offset: 35539},
												expr: &litMatcher{
													pos:        position{line: 1112, col: 38, offset: 35539},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 1112, col: 43, offset: 35544},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1112, col: 49, offset: 35550},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 1112, col: 54, offset: 35555},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "attributes",
			pos:  position{line: 1131, col: 1, offset: 36103},
			expr: &actionExpr{
				pos: position{line: 1131, col: 15, offset: 36117},
				run: (*parser).callonattributes1,
				expr: &seqExpr{
					pos: position{line: 1131, col: 15, offset: 36117},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1131, col: 15, offset: 36117},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 1131, col: 22, offset: 36124},
								name: "Attribute",
							},
						},
						&labeledExpr{
							pos:   position{line: 1131, col: 32, offset: 36134},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1131, col: 38, offset: 36140},
								expr: &seqExpr{
									pos: position{line: 1131, col: 39, offset: 36141},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 1131, col: 39, offset: 36141},
											expr: &litMatcher{
												pos:        position{line: 1131, col: 39, offset: 36141},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 1131, col: 44, offset: 36146},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 1131, col: 48, offset: 36150},
											expr: &ruleRefExpr{
												pos:  position{line: 1131, col: 48, offset: 36150},
												name: "WS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1131, col: 52, offset: 36154},
											name: "Attribute",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineAttributeList",
			pos:  position{line: 1142, col: 1, offset: 36424},
			expr: &choiceExpr{
				pos: position{line: 1142, col: 28, offset: 36451},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1142, col: 28, offset: 36451},
						run: (*parser).callonSingleLineAttributeList2,
						expr: &seqExpr{
							pos: position{line: 1142, col: 28, offset: 36451},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1142, col: 28, offset: 36451},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1142, col: 32, offset: 36455},
									expr: &litMatcher{
										pos:        position{line: 1142, col: 32, offset: 36455},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1142, col: 37, offset: 36460},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1142, col: 49, offset: 36472},
										expr: &ruleRefExpr{
											pos:  position{line: 1142, col: 49, offset: 36472},
											name: "singleLineAttributes",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1142, col: 71, offset: 36494},
									expr: &litMatcher{
										pos:        position{line: 1142, col: 71, offset: 36494},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1142, col: 76, offset: 36499},
									expr: &seqExpr{
										pos: position{line: 1142, col: 77, offset: 36500},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1142, col: 77, offset: 36500},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1142, col: 81, offset: 36504},
												expr: &litMatcher{
													pos:        position{line: 1142, col: 81, offset: 36504},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1142, col: 88, offset: 36511},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1142, col: 99, offset: 36522},
										name: "R_PAREN",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1148, col: 5, offset: 36717},
						run: (*parser).callonSingleLineAttributeList19,
						expr: &seqExpr{
							pos: position{line: 1148, col: 5, offset: 36717},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1148, col: 5, offset: 36717},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1148, col: 9, offset: 36721},
									expr: &litMatcher{
										pos:        position{line: 1148, col: 9, offset: 36721},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1148, col: 14, offset: 36726},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1148, col: 26, offset: 36738},
										expr: &ruleRefExpr{
											pos:  position{line: 1148, col: 26, offset: 36738},
											name: "singleLineAttributes",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1148, col: 48, offset: 36760},
									expr: &seqExpr{
										pos: position{line: 1148, col: 49, offset: 36761},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 1148, col: 49, offset: 36761},
												expr: &litMatcher{
													pos:        position{line: 1148, col: 49, offset: 36761},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 1148, col: 54, offset: 36766},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1148, col: 60, offset: 36772},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 1148, col: 65, offset: 36777},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineAttributes",
			pos:  position{line: 1167, col: 1, offset: 37325},
			expr: &actionExpr{
				pos: position{line: 1167, col: 25, offset: 37349},
				run: (*parser).callonsingleLineAttributes1,
				expr: &seqExpr{
					pos: position{line: 1167, col: 25, offset: 37349},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1167, col: 25, offset: 37349},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 1167, col: 32, offset: 37356},
								name: "Attribute",
							},
						},
						&labeledExpr{
							pos:   position{line: 1167, col: 42, offset: 37366},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1167, col: 48, offset: 37372},
								expr: &seqExpr{
									pos: position{line: 1167, col: 49, offset: 37373},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 1167, col: 49, offset: 37373},
											expr: &litMatcher{
												pos:        position{line: 1167, col: 49, offset: 37373},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 1167, col: 54, offset: 37378},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 1167, col: 58, offset: 37382},
											expr: &litMatcher{
												pos:        position{line: 1167, col: 58, offset: 37382},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1167, col: 63, offset: 37387},
											name: "SingleLineAttribute",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Attribute",
			pos:  position{line: 1182, col: 1, offset: 37851},
			expr: &choiceExpr{
				pos: position{line: 1182, col: 24, offset: 37874},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1182, col: 24, offset: 37874},
						name: "MixinCallAttribute",
					},
					&ruleRefExpr{
						pos:  position{line: 1182, col: 45, offset: 37895},
						name: "AndPlaceholder",
					},
					&ruleRefExpr{
						pos:  position{line: 1182, col: 62, offset: 37912},
						name: "SimpleAttribute",
					},
				},
			},
		},
		{
			name: "SingleLineAttribute",
			pos:  position{line: 1183, col: 1, offset: 37928},
			expr: &choiceExpr{
				pos: position{line: 1183, col: 24, offset: 37951},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1183, col: 24, offset: 37951},
						name: "SingleLineMixinCallAttribute",
					},
					&ruleRefExpr{
						pos:  position{line: 1183, col: 55, offset: 37982},
						name: "AndPlaceholder",
					},
					&ruleRefExpr{
						pos:  position{line: 1183, col: 72, offset: 37999},
						name: "SingleLineSimpleAttribute",
					},
				},
			},
		},
		{
			name: "attributeName",
			pos:  position{line: 1185, col: 1, offset: 38026},
			expr: &oneOrMoreExpr{
				pos: position{line: 1185, col: 18, offset: 38043},
				expr: &seqExpr{
					pos: position{line: 1185, col: 19, offset: 38044},
					exprs: []interface{}{
						&notExpr{
							pos: position{line: 1185, col: 19, offset: 38044},
							expr: &charClassMatcher{
								pos:        position{line: 1185, col: 20, offset: 38045},
								val:        "[()]",
								chars:      []rune{'(', ')'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1185, col: 25, offset: 38050},
							name: "htmlAttributeNameChar",
						},
					},
				},
			},
		},
		{
			name: "SimpleAttribute",
			pos:  position{line: 1190, col: 1, offset: 38099},
			expr: &choiceExpr{
				pos: position{line: 1190, col: 30, offset: 38128},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1190, col: 30, offset: 38128},
						name: "simpleValueAttribute",
					},
					&ruleRefExpr{
						pos:  position{line: 1190, col: 53, offset: 38151},
						name: "simpleBooleanAttribute",
					},
				},
			},
		},
		{
			name: "SingleLineSimpleAttribute",
			pos:  position{line: 1191, col: 1, offset: 38174},
			expr: &choiceExpr{
				pos: position{line: 1191, col: 30, offset: 38203},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1191, col: 30, offset: 38203},
						name: "singleLineSimpleValueAttribute",
					},
					&ruleRefExpr{
						pos:  position{line: 1191, col: 63, offset: 38236},
						name: "simpleBooleanAttribute",
					},
				},
			},
		},
		{
			name: "simpleValueAttribute",
			pos:  position{line: 1193, col: 1, offset: 38260},
			expr: &choiceExpr{
				pos: position{line: 1193, col: 25, offset: 38284},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1193, col: 25, offset: 38284},
						run: (*parser).callonsimpleValueAttribute2,
						expr: &seqExpr{
							pos: position{line: 1193, col: 25, offset: 38284},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1193, col: 25, offset: 38284},
									label: "nameI",
									expr: &ruleRefExpr{
										pos:  position{line: 1193, col: 31, offset: 38290},
										name: "attributeName",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1193, col: 45, offset: 38304},
									expr: &litMatcher{
										pos:        position{line: 1193, col: 45, offset: 38304},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1193, col: 50, offset: 38309},
									label: "assignPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1193, col: 61, offset: 38320},
										name: "POS",
									},
								},
								&litMatcher{
									pos:        position{line: 1193, col: 65, offset: 38324},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1193, col: 69, offset: 38328},
									expr: &ruleRefExpr{
										pos:  position{line: 1193, col: 69, offset: 38328},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1193, col: 73, offset: 38332},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 1193, col: 78, offset: 38337},
										name: "POS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1193, col: 82, offset: 38341},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1193, col: 88, offset: 38347},
										name: "Expression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1200, col: 5, offset: 38564},
						run: (*parser).callonsimpleValueAttribute17,
						expr: &seqExpr{
							pos: position{line: 1200, col: 5, offset: 38564},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1200, col: 5, offset: 38564},
									label: "nameI",
									expr: &ruleRefExpr{
										pos:  position{line: 1200, col: 11, offset: 38570},
										name: "attributeName",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1200, col: 25, offset: 38584},
									expr: &litMatcher{
										pos:        position{line: 1200, col: 25, offset: 38584},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1200, col: 30, offset: 38589},
									label: "assignPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1200, col: 41, offset: 38600},
										name: "POS",
									},
								},
								&litMatcher{
									pos:        position{line: 1200, col: 45, offset: 38604},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&labeledExpr{
									pos:   position{line: 1200, col: 49, offset: 38608},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 1200, col: 54, offset: 38613},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineSimpleValueAttribute",
			pos:  position{line: 1214, col: 1, offset: 39005},
			expr: &choiceExpr{
				pos: position{line: 1214, col: 35, offset: 39039},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1214, col: 35, offset: 39039},
						run: (*parser).callonsingleLineSimpleValueAttribute2,
						expr: &seqExpr{
							pos: position{line: 1214, col: 35, offset: 39039},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1214, col: 35, offset: 39039},
									label: "nameI",
									expr: &ruleRefExpr{
										pos:  position{line: 1214, col: 41, offset: 39045},
										name: "attributeName",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1214, col: 55, offset: 39059},
									expr: &litMatcher{
										pos:        position{line: 1214, col: 55, offset: 39059},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1214, col: 60, offset: 39064},
									label: "assignPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1214, col: 71, offset: 39075},
										name: "POS",
									},
								},
								&litMatcher{
									pos:        position{line: 1214, col: 75, offset: 39079},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1214, col: 79, offset: 39083},
									expr: &litMatcher{
										pos:        position{line: 1214, col: 79, offset: 39083},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1214, col: 84, offset: 39088},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1214, col: 90, offset: 39094},
										name: "Expression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1221, col: 5, offset: 39315},
						run: (*parser).callonsingleLineSimpleValueAttribute15,
						expr: &seqExpr{
							pos: position{line: 1221, col: 5, offset: 39315},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1221, col: 5, offset: 39315},
									label: "nameI",
									expr: &ruleRefExpr{
										pos:  position{line: 1221, col: 11, offset: 39321},
										name: "attributeName",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1221, col: 25, offset: 39335},
									expr: &litMatcher{
										pos:        position{line: 1221, col: 25, offset: 39335},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1221, col: 30, offset: 39340},
									label: "assignPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1221, col: 41, offset: 39351},
										name: "POS",
									},
								},
								&litMatcher{
									pos:        position{line: 1221, col: 45, offset: 39355},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&labeledExpr{
									pos:   position{line: 1221, col: 49, offset: 39359},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 1221, col: 54, offset: 39364},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "simpleBooleanAttribute",
			pos:  position{line: 1235, col: 1, offset: 39772},
			expr: &actionExpr{
				pos: position{line: 1235, col: 27, offset: 39798},
				run: (*parser).callonsimpleBooleanAttribute1,
				expr: &seqExpr{
					pos: position{line: 1235, col: 27, offset: 39798},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1235, col: 27, offset: 39798},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 1235, col: 33, offset: 39804},
								name: "attributeName",
							},
						},
						&notExpr{
							pos: position{line: 1235, col: 47, offset: 39818},
							expr: &seqExpr{
								pos: position{line: 1235, col: 49, offset: 39820},
								exprs: []interface{}{
									&zeroOrMoreExpr{
										pos: position{line: 1235, col: 49, offset: 39820},
										expr: &litMatcher{
											pos:        position{line: 1235, col: 49, offset: 39820},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&charClassMatcher{
										pos:        position{line: 1235, col: 54, offset: 39825},
										val:        "[!=]",
										chars:      []rune{'!', '='},
										ignoreCase: false,
										inverted:   false,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "AndPlaceholder",
			pos:  position{line: 1246, col: 1, offset: 39960},
			expr: &actionExpr{
				pos: position{line: 1246, col: 19, offset: 39978},
				run: (*parser).callonAndPlaceholder1,
				expr: &seqExpr{
					pos: position{line: 1246, col: 19, offset: 39978},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 1246, col: 19, offset: 39978},
							val:        "&&",
							ignoreCase: false,
							want:       "\"&&\"",
						},
						&andExpr{
							pos: position{line: 1246, col: 24, offset: 39983},
							expr: &choiceExpr{
								pos: position{line: 1246, col: 26, offset: 39985},
								alternatives: []interface{}{
									&ruleRefExpr{
										pos:  position{line: 1246, col: 26, offset: 39985},
										name: "WS",
									},
									&litMatcher{
										pos:        position{line: 1246, col: 31, offset: 39990},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&litMatcher{
										pos:        position{line: 1246, col: 37, offset: 39996},
										val:        ")",
										ignoreCase: false,
										want:       "\")\"",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "MixinCallAttribute",
			pos:  position{line: 1254, col: 1, offset: 40089},
			expr: &actionExpr{
				pos: position{line: 1254, col: 23, offset: 40111},
				run: (*parser).callonMixinCallAttribute1,
				expr: &seqExpr{
					pos: position{line: 1254, col: 23, offset: 40111},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1254, col: 23, offset: 40111},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 1254, col: 29, offset: 40117},
								name: "attributeName",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1254, col: 43, offset: 40131},
							expr: &litMatcher{
								pos:        position{line: 1254, col: 43, offset: 40131},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1254, col: 48, offset: 40136},
							label: "assignPosI",
							expr: &ruleRefExpr{
								pos:  position{line: 1254, col: 59, offset: 40147},
								name: "POS",
							},
						},
						&litMatcher{
							pos:        position{line: 1254, col: 63, offset: 40151},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1254, col: 67, offset: 40155},
							expr: &ruleRefExpr{
								pos:  position{line: 1254, col: 67, offset: 40155},
								name: "WS",
							},
						},
						&labeledExpr{
							pos:   position{line: 1254, col: 71, offset: 40159},
							label: "callI",
							expr: &ruleRefExpr{
								pos:  position{line: 1254, col: 77, offset: 40165},
								name: "mixinCallAttributeCall",
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineMixinCallAttribute",
			pos:  position{line: 1264, col: 1, offset: 40447},
			expr: &actionExpr{
				pos: position{line: 1264, col: 33, offset: 40479},
				run: (*parser).callonSingleLineMixinCallAttribute1,
				expr: &seqExpr{
					pos: position{line: 1264, col: 33, offset: 40479},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1264, col: 33, offset: 40479},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 1264, col: 39, offset: 40485},
								name: "attributeName",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1264, col: 53, offset: 40499},
							expr: &litMatcher{
								pos:        position{line: 1264, col: 53, offset: 40499},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1264, col: 58, offset: 40504},
							label: "assignPosI",
							expr: &ruleRefExpr{
								pos:  position{line: 1264, col: 69, offset: 40515},
								name: "POS",
							},
						},
						&litMatcher{
							pos:        position{line: 1264, col: 73, offset: 40519},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1264, col: 77, offset: 40523},
							expr: &litMatcher{
								pos:        position{line: 1264, col: 77, offset: 40523},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1264, col: 82, offset: 40528},
							label: "callI",
							expr: &ruleRefExpr{
								pos:  position{line: 1264, col: 88, offset: 40534},
								name: "singleLineMixinCallAttributeCall",
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallAttributeCall",
			pos:  position{line: 1275, col: 1, offset: 40827},
			expr: &actionExpr{
				pos: position{line: 1275, col: 27, offset: 40853},
				run: (*parser).callonmixinCallAttributeCall1,
				expr: &seqExpr{
					pos: position{line: 1275, col: 27, offset: 40853},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 1275, col: 27, offset: 40853},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 1275, col: 31, offset: 40857},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1275, col: 42, offset: 40868},
								expr: &seqExpr{
									pos: position{line: 1275, col: 43, offset: 40869},
									exprs: []interface{}{
										&ruleRefExpr{
											pos:  position{line: 1275, col: 43, offset: 40869},
											name: "Ident",
										},
										&litMatcher{
											pos:        position{line: 1275, col: 49, offset: 40875},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1275, col: 55, offset: 40881},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 1275, col: 61, offset: 40887},
								name: "MustIdent",
							},
						},
						&labeledExpr{
							pos:   position{line: 1275, col: 71, offset: 40897},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1275, col: 77, offset: 40903},
								expr: &ruleRefExpr{
									pos:  position{line: 1275, col: 77, offset: 40903},
									name: "mixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1275, col: 91, offset: 40917},
							label: "valueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1275, col: 98, offset: 40924},
								expr: &ruleRefExpr{
									pos:  position{line: 1275, col: 98, offset: 40924},
									name: "mixinCallAttributeValue",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinCallAttributeCall",
			pos:  position{line: 1295, col: 1, offset: 41491},
			expr: &actionExpr{
				pos: position{line: 1295, col: 37, offset: 41527},
				run: (*parser).callonsingleLineMixinCallAttributeCall1,
				expr: &seqExpr{
					pos: position{line: 1295, col: 37, offset: 41527},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 1295, col: 37, offset: 41527},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 1295, col: 41, offset: 41531},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1295, col: 52, offset: 41542},
								expr: &seqExpr{
									pos: position{line: 1295, col: 53, offset: 41543},
									exprs: []interface{}{
										&ruleRefExpr{
											pos:  position{line: 1295, col: 53, offset: 41543},
											name: "Ident",
										},
										&litMatcher{
											pos:        position{line: 1295, col: 59, offset: 41549},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1295, col: 65, offset: 41555},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 1295, col: 71, offset: 41561},
								name: "MustIdent",
							},
						},
						&labeledExpr{
							pos:   position{line: 1295, col: 81, offset: 41571},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1295, col: 87, offset: 41577},
								expr: &ruleRefExpr{
									pos:  position{line: 1295, col: 87, offset: 41577},
									name: "singleLineMixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1295, col: 111, offset: 41601},
							label: "valueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1295, col: 118, offset: 41608},
								expr: &ruleRefExpr{
									pos:  position{line: 1295, col: 118, offset: 41608},
									name: "mixinCallAttributeValue",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallAttributeValue",
			pos:  position{line: 1316, col: 1, offset: 42176},
			expr: &choiceExpr{
				pos: position{line: 1316, col: 28, offset: 42203},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1316, col: 28, offset: 42203},
						name: "textInterpolationValue",
					},
					&ruleRefExpr{
						pos:  position{line: 1316, col: 53, offset: 42228},
						name: "expressionInterpolationValue",
					},
				},
			},
		},
		{
			name: "unexpectedTokens",
			pos:  position{line: 1318, col: 1, offset: 42258},
			expr: &actionExpr{
				pos: position{line: 1318, col: 21, offset: 42278},
				run: (*parser).callonunexpectedTokens1,
				expr: &oneOrMoreExpr{
					pos: position{line: 1318, col: 21, offset: 42278},
					expr: &ruleRefExpr{
						pos:  position{line: 1318, col: 21, offset: 42278},
						name: "NOT_EOL",
					},
				},
			},
		},
		{
			name: "Expression",
			pos:  position{line: 1329, col: 1, offset: 42513},
			expr: &choiceExpr{
				pos: position{line: 1329, col: 15, offset: 42527},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1329, col: 15, offset: 42527},
						run: (*parser).callonExpression2,
						expr: &labeledExpr{
							pos:   position{line: 1329, col: 15, offset: 42527},
							label: "cExprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1329, col: 22, offset: 42534},
								name: "ChainExpression",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1331, col: 5, offset: 42655},
						name: "GoExpression",
					},
				},
			},
		},
		{
			name: "SingleLineExpression",
			pos:  position{line: 1333, col: 1, offset: 42669},
			expr: &choiceExpr{
				pos: position{line: 1333, col: 25, offset: 42693},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1333, col: 25, offset: 42693},
						run: (*parser).callonSingleLineExpression2,
						expr: &labeledExpr{
							pos:   position{line: 1333, col: 25, offset: 42693},
							label: "cExprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1333, col: 32, offset: 42700},
								name: "SingleLineChainExpression",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1335, col: 5, offset: 42831},
						name: "SingleLineGoExpression",
					},
				},
			},
		},
		{
			name: "expressionTerminator",
			pos:  position{line: 1337, col: 1, offset: 42855},
			expr: &choiceExpr{
				pos: position{line: 1337, col: 25, offset: 42879},
				alternatives: []interface{}{
					&charClassMatcher{
						pos:        position{line: 1337, col: 25, offset: 42879},
						val:        "[)}\\]]",
						chars:      []rune{')', '}', ']'},
						ignoreCase: false,
						inverted:   false,
					},
					&litMatcher{
						pos:        position{line: 1337, col: 34, offset: 42888},
						val:        ",",
						ignoreCase: false,
						want:       "\",\"",
					},
					&seqExpr{
						pos: position{line: 1337, col: 40, offset: 42894},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 1337, col: 40, offset: 42894},
								val:        ":",
								ignoreCase: false,
								want:       "\":\"",
							},
							&notExpr{
								pos: position{line: 1337, col: 44, offset: 42898},
								expr: &litMatcher{
									pos:        position{line: 1337, col: 45, offset: 42899},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "GoExpression",
			pos:  position{line: 1345, col: 1, offset: 43239},
			expr: &actionExpr{
				pos: position{line: 1345, col: 17, offset: 43255},
				run: (*parser).callonGoExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1345, col: 17, offset: 43255},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1345, col: 24, offset: 43262},
						expr: &choiceExpr{
							pos: position{line: 1346, col: 6, offset: 43269},
							alternatives: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 1346, col: 6, offset: 43269},
									name: "goParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 1346, col: 20, offset: 43283},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1346, col: 39, offset: 43302},
									name: "TernaryExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1346, col: 59, offset: 43322},
									name: "goRuneExpr",
								},
								&actionExpr{
									pos: position{line: 1347, col: 6, offset: 43340},
									run: (*parser).callonGoExpression9,
									expr: &seqExpr{
										pos: position{line: 1347, col: 6, offset: 43340},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 1347, col: 6, offset: 43340},
												label: "posI",
												expr: &ruleRefExpr{
													pos:  position{line: 1347, col: 11, offset: 43345},
													name: "POS",
												},
											},
											&notExpr{
												pos: position{line: 1347, col: 15, offset: 43349},
												expr: &ruleRefExpr{
													pos:  position{line: 1347, col: 16, offset: 43350},
													name: "expressionTerminator",
												},
											},
											&ruleRefExpr{
												pos:  position{line: 1347, col: 37, offset: 43371},
												name: "NOT_EOL",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1347, col: 45, offset: 43379},
												expr: &seqExpr{
													pos: position{line: 1347, col: 46, offset: 43380},
													exprs: []interface{}{
														&notExpr{
															pos: position{line: 1347, col: 46, offset: 43380},
															expr: &ruleRefExpr{
																pos:  position{line: 1347, col: 47, offset: 43381},
																name: "expressionTerminator",
															},
														},
														&notExpr{
															pos: position{line: 1347, col: 68, offset: 43402},
															expr: &ruleRefExpr{
																pos:  position{line: 1347, col: 69, offset: 43403},
																name: "EOL",
															},
														},
														&charClassMatcher{
															pos:        position{line: 1347, col: 73, offset: 43407},
															val:        "[^'\"`?([{]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goParenExpr",
			pos:  position{line: 1354, col: 1, offset: 43572},
			expr: &choiceExpr{
				pos: position{line: 1354, col: 16, offset: 43587},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1354, col: 16, offset: 43587},
						run: (*parser).callongoParenExpr2,
						expr: &labeledExpr{
							pos:   position{line: 1354, col: 16, offset: 43587},
							label: "exprI",
							expr: &choiceExpr{
								pos: position{line: 1354, col: 23, offset: 43594},
								alternatives: []interface{}{
									&seqExpr{
										pos: position{line: 1354, col: 23, offset: 43594},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1354, col: 23, offset: 43594},
												val:        "(",
												ignoreCase: false,
												want:       "\"(\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1354, col: 27, offset: 43598},
												expr: &ruleRefExpr{
													pos:  position{line: 1354, col: 27, offset: 43598},
													name: "goSubExpression",
												},
											},
											&ruleRefExpr{
												pos:  position{line: 1354, col: 44, offset: 43615},
												name: "POS",
											},
											&litMatcher{
												pos:        position{line: 1354, col: 48, offset: 43619},
												val:        ")",
												ignoreCase: false,
												want:       "\")\"",
											},
										},
									},
									&seqExpr{
										pos: position{line: 1354, col: 54, offset: 43625},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1354, col: 54, offset: 43625},
												val:        "[",
												ignoreCase: false,
												want:       "\"[\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1354, col: 58, offset: 43629},
												expr: &ruleRefExpr{
													pos:  position{line: 1354, col: 58, offset: 43629},
													name: "goSubExpression",
												},
											},
											&ruleRefExpr{
												pos:  position{line: 1354, col: 75, offset: 43646},
												name: "POS",
											},
											&litMatcher{
												pos:        position{line: 1354, col: 79, offset: 43650},
												val:        "]",
												ignoreCase: false,
												want:       "\"]\"",
											},
										},
									},
									&seqExpr{
										pos: position{line: 1354, col: 85, offset: 43656},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1354, col: 85, offset: 43656},
												val:        "{",
												ignoreCase: false,
												want:       "\"{\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1354, col: 89, offset: 43660},
												expr: &ruleRefExpr{
													pos:  position{line: 1354, col: 89, offset: 43660},
													name: "goSubExpression",
												},
											},
											&ruleRefExpr{
												pos:  position{line: 1354, col: 106, offset: 43677},
												name: "POS",
											},
											&litMatcher{
												pos:        position{line: 1354, col: 110, offset: 43681},
												val:        "}",
												ignoreCase: false,
												want:       "\"}\"",
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1377, col: 5, offset: 44364},
						run: (*parser).callongoParenExpr23,
						expr: &seqExpr{
							pos: position{line: 1377, col: 5, offset: 44364},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1377, col: 5, offset: 44364},
									label: "parenI",
									expr: &charClassMatcher{
										pos:        position{line: 1377, col: 12, offset: 44371},
										val:        "[([{]",
										chars:      []rune{'(', '[', '{'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&labeledExpr{
									pos:   position{line: 1377, col: 18, offset: 44377},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1377, col: 28, offset: 44387},
										name: "POS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1377, col: 32, offset: 44391},
									label: "exprI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1377, col: 38, offset: 44397},
										expr: &ruleRefExpr{
											pos:  position{line: 1377, col: 38, offset: 44397},
											name: "goSubExpression",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goRuneExpr",
			pos:  position{line: 1409, col: 1, offset: 45329},
			expr: &actionExpr{
				pos: position{line: 1409, col: 15, offset: 45343},
				run: (*parser).callongoRuneExpr1,
				expr: &seqExpr{
					pos: position{line: 1409, col: 15, offset: 45343},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1409, col: 15, offset: 45343},
							label: "posI",
							expr: &ruleRefExpr{
								pos:  position{line: 1409, col: 20, offset: 45348},
								name: "POS",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1409, col: 24, offset: 45352},
							name: "goRuneLit",
						},
					},
				},
			},
		},
		{
			name: "goSubExpression",
			pos:  position{line: 1413, col: 1, offset: 45461},
			expr: &actionExpr{
				pos: position{line: 1413, col: 20, offset: 45480},
				run: (*parser).callongoSubExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1413, col: 20, offset: 45480},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1413, col: 27, offset: 45487},
						expr: &choiceExpr{
							pos: position{line: 1414, col: 5, offset: 45493},
							alternatives: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 1414, col: 5, offset: 45493},
									name: "goParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 1414, col: 19, offset: 45507},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1414, col: 38, offset: 45526},
									name: "TernaryExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1414, col: 58, offset: 45546},
									name: "goRuneExpr",
								},
								&actionExpr{
									pos: position{line: 1415, col: 5, offset: 45563},
									run: (*parser).callongoSubExpression9,
									expr: &seqExpr{
										pos: position{line: 1415, col: 5, offset: 45563},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 1415, col: 5, offset: 45563},
												label: "posI",
												expr: &ruleRefExpr{
													pos:  position{line: 1415, col: 10, offset: 45568},
													name: "POS",
												},
											},
											&charClassMatcher{
												pos:        position{line: 1415, col: 14, offset: 45572},
												val:        "[^)}\\]]",
												chars:      []rune{')', '}', ']'},
												ignoreCase: false,
												inverted:   true,
											},
											&zeroOrMoreExpr{
												pos: position{line: 1415, col: 22, offset: 45580},
												expr: &charClassMatcher{
													pos:        position{line: 1415, col: 22, offset: 45580},
													val:        "[^'\"`?([{}\\])]",
													chars:      []rune{'\'', '"', '`', '?', '(', '[', '{', '}', ']', ')'},
													ignoreCase: false,
													inverted:   true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "multiLineGoExpression",
			pos:  position{line: 1422, col: 1, offset: 45748},
			expr: &actionExpr{
				pos: position{line: 1422, col: 26, offset: 45773},
				run: (*parser).callonmultiLineGoExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1422, col: 26, offset: 45773},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1422, col: 33, offset: 45780},
						expr: &choiceExpr{
							pos: position{line: 1423, col: 5, offset: 45786},
							alternatives: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 1423, col: 5, offset: 45786},
									name: "goParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 1423, col: 19, offset: 45800},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1423, col: 38, offset: 45819},
									name: "TernaryExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1423, col: 58, offset: 45839},
									name: "goRuneExpr",
								},
								&actionExpr{
									pos: position{line: 1424, col: 5, offset: 45856},
									run: (*parser).callonmultiLineGoExpression9,
									expr: &seqExpr{
										pos: position{line: 1424, col: 5, offset: 45856},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 1424, col: 5, offset: 45856},
												label: "posI",
												expr: &ruleRefExpr{
													pos:  position{line: 1424, col: 10, offset: 45861},
													name: "POS",
												},
											},
											&notExpr{
												pos: position{line: 1424, col: 14, offset: 45865},
												expr: &ruleRefExpr{
													pos:  position{line: 1424, col: 15, offset: 45866},
													name: "expressionTerminator",
												},
											},
											&anyMatcher{
												line: 1424, col: 36, offset: 45887,
											},
											&zeroOrMoreExpr{
												pos: position{line: 1424, col: 38, offset: 45889},
												expr: &seqExpr{
													pos: position{line: 1424, col: 39, offset: 45890},
													exprs: []interface{}{
														&notExpr{
															pos: position{line: 1424, col: 39, offset: 45890},
															expr: &ruleRefExpr{
																pos:  position{line: 1424, col: 40, offset: 45891},
																name: "expressionTerminator",
															},
														},
														&charClassMatcher{
															pos:        position{line: 1424, col: 61, offset: 45912},
															val:        "[^'\"`?([{]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineGoExpression",
			pos:  position{line: 1431, col: 1, offset: 46077},
			expr: &actionExpr{
				pos: position{line: 1431, col: 27, offset: 46103},
				run: (*parser).callonSingleLineGoExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1431, col: 27, offset: 46103},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1431, col: 34, offset: 46110},
						expr: &choiceExpr{
							pos: position{line: 1432, col: 5, offset: 46116},
							alternatives: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 1432, col: 5, offset: 46116},
									name: "singleLineGoParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 1432, col: 29, offset: 46140},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1432, col: 48, offset: 46159},
									name: "SingleLineTernaryExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1432, col: 78, offset: 46189},
									name: "goRuneExpr",
								},
								&actionExpr{
									pos: position{line: 1433, col: 5, offset: 46206},
									run: (*parser).callonSingleLineGoExpression9,
									expr: &seqExpr{
										pos: position{line: 1433, col: 5, offset: 46206},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 1433, col: 5, offset: 46206},
												label: "posI",
												expr: &ruleRefExpr{
													pos:  position{line: 1433, col: 10, offset: 46211},
													name: "POS",
												},
											},
											&notExpr{
												pos: position{line: 1433, col: 14, offset: 46215},
												expr: &ruleRefExpr{
													pos:  position{line: 1433, col: 15, offset: 46216},
													name: "expressionTerminator",
												},
											},
											&ruleRefExpr{
												pos:  position{line: 1433, col: 36, offset: 46237},
												name: "NOT_EOL",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1433, col: 44, offset: 46245},
												expr: &seqExpr{
													pos: position{line: 1433, col: 45, offset: 46246},
													exprs: []interface{}{
														&notExpr{
															pos: position{line: 1433, col: 45, offset: 46246},
															expr: &ruleRefExpr{
																pos:  position{line: 1433, col: 46, offset: 46247},
																name: "expressionTerminator",
															},
														},
														&notExpr{
															pos: position{line: 1433, col: 67, offset: 46268},
															expr: &ruleRefExpr{
																pos:  position{line: 1433, col: 68, offset: 46269},
																name: "EOL",
															},
														},
														&charClassMatcher{
															pos:        position{line: 1433, col: 72, offset: 46273},
															val:        "[^'\"`?([{]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineGoParenExpr",
			pos:  position{line: 1440, col: 1, offset: 46438},
			expr: &choiceExpr{
				pos: position{line: 1440, col: 26, offset: 46463},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1440, col: 26, offset: 46463},
						run: (*parser).callonsingleLineGoParenExpr2,
						expr: &labeledExpr{
							pos:   position{line: 1440, col: 26, offset: 46463},
							label: "exprI",
							expr: &choiceExpr{
								pos: position{line: 1440, col: 33, offset: 46470},
								alternatives: []interface{}{
									&seqExpr{
										pos: position{line: 1440, col: 33, offset: 46470},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1440, col: 33, offset: 46470},
												val:        "(",
												ignoreCase: false,
												want:       "\"(\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1440, col: 37, offset: 46474},
												expr: &ruleRefExpr{
													pos:  position{line: 1440, col: 37, offset: 46474},
													name: "singleLineGoSubExpression",
												},
											},
											&ruleRefExpr{
												pos:  position{line: 1440, col: 64, offset: 46501},
												name: "POS",
											},
											&litMatcher{
												pos:        position{line: 1440, col: 68, offset: 46505},
												val:        ")",
												ignoreCase: false,
												want:       "\")\"",
											},
										},
									},
									&seqExpr{
										pos: position{line: 1440, col: 74, offset: 46511},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1440, col: 74, offset: 46511},
												val:        "[",
												ignoreCase: false,
												want:       "\"[\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1440, col: 78, offset: 46515},
												expr: &ruleRefExpr{
													pos:  position{line: 1440, col: 78, offset: 46515},
													name: "singleLineGoSubExpression",
												},
											},
											&ruleRefExpr{
												pos:  position{line: 1440, col: 105, offset: 46542},
												name: "POS",
											},
											&litMatcher{
												pos:        position{line: 1440, col: 109, offset: 46546},
												val:        "]",
												ignoreCase: false,
												want:       "\"]\"",
											},
										},
									},
									&seqExpr{
										pos: position{line: 1440, col: 115, offset: 46552},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1440, col: 115, offset: 46552},
												val:        "{",
												ignoreCase: false,
												want:       "\"{\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1440, col: 119, offset: 46556},
												expr: &ruleRefExpr{
													pos:  position{line: 1440, col: 119, offset: 46556},
													name: "singleLineGoSubExpression",
												},
											},
											&ruleRefExpr{
												pos:  position{line: 1440, col: 146, offset: 46583},
												name: "POS",
											},
											&litMatcher{
												pos:        position{line: 1440, col: 150, offset: 46587},
												val:        "}",
												ignoreCase: false,
												want:       "\"}\"",
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1463, col: 5, offset: 47236},
						run: (*parser).callonsingleLineGoParenExpr23,
						expr: &seqExpr{
							pos: position{line: 1463, col: 5, offset: 47236},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1463, col: 5, offset: 47236},
									label: "parenI",
									expr: &charClassMatcher{
										pos:        position{line: 1463, col: 12, offset: 47243},
										val:        "[([{]",
										chars:      []rune{'(', '[', '{'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&labeledExpr{
									pos:   position{line: 1463, col: 18, offset: 47249},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1463, col: 28, offset: 47259},
										name: "POS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1463, col: 32, offset: 47263},
									label: "exprI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1463, col: 38, offset: 47269},
										expr: &ruleRefExpr{
											pos:  position{line: 1463, col: 38, offset: 47269},
											name: "singleLineGoSubExpression",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineGoSubExpression",
			pos:  position{line: 1494, col: 1, offset: 48165},
			expr: &actionExpr{
				pos: position{line: 1494, col: 30, offset: 48194},
				run: (*parser).callonsingleLineGoSubExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1494, col: 30, offset: 48194},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1494, col: 37, offset: 48201},
						expr: &choiceExpr{
							pos: position{line: 1495, col: 5, offset: 48207},
							alternatives: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 1495, col: 5, offset: 48207},
									name: "singleLineGoParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 1495, col: 29, offset: 48231},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1495, col: 48, offset: 48250},
									name: "SingleLineTernaryExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1495, col: 78, offset: 48280},
									name: "goRuneExpr",
								},
								&actionExpr{
									pos: position{line: 1496, col: 5, offset: 48297},
									run: (*parser).callonsingleLineGoSubExpression9,
									expr: &seqExpr{
										pos: position{line: 1496, col: 5, offset: 48297},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 1496, col: 5, offset: 48297},
												label: "posI",
												expr: &ruleRefExpr{
													pos:  position{line: 1496, col: 10, offset: 48302},
													name: "POS",
												},
											},
											&notExpr{
												pos: position{line: 1496, col: 14, offset: 48306},
												expr: &ruleRefExpr{
													pos:  position{line: 1496, col: 15, offset: 48307},
													name: "EOL",
												},
											},
											&charClassMatcher{
												pos:        position{line: 1496, col: 19, offset: 48311},
												val:        "[^)}\\]]",
												chars:      []rune{')', '}', ']'},
												ignoreCase: false,
												inverted:   true,
											},
											&zeroOrMoreExpr{
												pos: position{line: 1496, col: 27, offset: 48319},
												expr: &seqExpr{
													pos: position{line: 1496, col: 28, offset: 48320},
													exprs: []interface{}{
														&notExpr{
															pos: position{line: 1496, col: 28, offset: 48320},
															expr: &ruleRefExpr{
																pos:  position{line: 1496, col: 29, offset: 48321},
																name: "EOL",
															},
														},
														&charClassMatcher{
															pos:        position{line: 1496, col: 33, offset: 48325},
															val:        "[^'\"`?([{}\\])]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{', '}', ']', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "IfExpressionTerminator",
			pos:  position{line: 1507, col: 1, offset: 48682},
			expr: &choiceExpr{
				pos: position{line: 1507, col: 27, offset: 48708},
				alternatives: []interface{}{
					&charClassMatcher{
						pos:        position{line: 1507, col: 27, offset: 48708},
						val:        "[)}\\]]",
						chars:      []rune{')', '}', ']'},
						ignoreCase: false,
						inverted:   false,
					},
					&seqExpr{
						pos: position{line: 1507, col: 36, offset: 48717},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 1507, col: 36, offset: 48717},
								val:        ":",
								ignoreCase: false,
								want:       "\":\"",
							},
							&notExpr{
								pos: position{line: 1507, col: 40, offset: 48721},
								expr: &litMatcher{
									pos:        position{line: 1507, col: 41, offset: 48722},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "IfExpression",
			pos:  position{line: 1509, col: 1, offset: 48727},
			expr: &choiceExpr{
				pos: position{line: 1509, col: 17, offset: 48743},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1509, col: 17, offset: 48743},
						run: (*parser).callonIfExpression2,
						expr: &labeledExpr{
							pos:   position{line: 1509, col: 17, offset: 48743},
							label: "cExprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1509, col: 24, offset: 48750},
								name: "ChainExpression",
							},
						},
					},
					&actionExpr{
						pos: position{line: 1526, col: 5, offset: 49355},
						run: (*parser).callonIfExpression5,
						expr: &labeledExpr{
							pos:   position{line: 1526, col: 5, offset: 49355},
							label: "exprsI",
							expr: &oneOrMoreExpr{
								pos: position{line: 1526, col: 12, offset: 49362},
								expr: &choiceExpr{
									pos: position{line: 1527, col: 5, offset: 49368},
									alternatives: []interface{}{
										&ruleRefExpr{
											pos:  position{line: 1527, col: 5, offset: 49368},
											name: "goParenExpr",
										},
										&ruleRefExpr{
											pos:  position{line: 1527, col: 19, offset: 49382},
											name: "StringExpression",
										},
										&ruleRefExpr{
											pos:  position{line: 1527, col: 38, offset: 49401},
											name: "TernaryExpression",
										},
										&ruleRefExpr{
											pos:  position{line: 1527, col: 58, offset: 49421},
											name: "goRuneExpr",
										},
										&actionExpr{
											pos: position{line: 1528, col: 5, offset: 49438},
											run: (*parser).callonIfExpression13,
											expr: &seqExpr{
												pos: position{line: 1528, col: 5, offset: 49438},
												exprs: []interface{}{
													&labeledExpr{
														pos:   position{line: 1528, col: 5, offset: 49438},
														label: "posI",
														expr: &ruleRefExpr{
															pos:  position{line: 1528, col: 10, offset: 49443},
															name: "POS",
														},
													},
													&notExpr{
														pos: position{line: 1528, col: 14, offset: 49447},
														expr: &ruleRefExpr{
															pos:  position{line: 1528, col: 15, offset: 49448},
															name: "IfExpressionTerminator",
														},
													},
													&ruleRefExpr{
														pos:  position{line: 1528, col: 38, offset: 49471},
														name: "NOT_EOL",
													},
													&zeroOrMoreExpr{
														pos: position{line: 1528, col: 46, offset: 49479},
														expr: &seqExpr{
															pos: position{line: 1528, col: 47, offset: 49480},
															exprs: []interface{}{
																&notExpr{
																	pos: position{line: 1528, col: 47, offset: 49480},
																	expr: &ruleRefExpr{
																		pos:  position{line: 1528, col: 48, offset: 49481},
																		name: "IfExpressionTerminator",
																	},
																},
																&notExpr{
																	pos: position{line: 1528, col: 71, offset: 49504},
																	expr: &ruleRefExpr{
																		pos:  position{line: 1528, col: 72, offset: 49505},
																		name: "EOL",
																	},
																},
																&charClassMatcher{
																	pos:        position{line: 1528, col: 76, offset: 49509},
																	val:        "[^'\"`?([{]",
																	chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ForExpression",
			pos:  position{line: 1539, col: 1, offset: 49863},
			expr: &choiceExpr{
				pos: position{line: 1539, col: 18, offset: 49880},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1539, col: 18, offset: 49880},
						run: (*parser).callonForExpression2,
						expr: &labeledExpr{
							pos:   position{line: 1539, col: 18, offset: 49880},
							label: "rExprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1539, col: 25, offset: 49887},
								name: "RangeExpression",
							},
						},
					},
					&actionExpr{
						pos: position{line: 1541, col: 5, offset: 50009},
						run: (*parser).callonForExpression5,
						expr: &labeledExpr{
							pos:   position{line: 1541, col: 5, offset: 50009},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1541, col: 11, offset: 50015},
								name: "IfExpression",
							},
						},
					},
					&actionExpr{
						pos: position{line: 1543, col: 5, offset: 50079},
						run: (*parser).callonForExpression8,
						expr: &andExpr{
							pos: position{line: 1543, col: 5, offset: 50079},
							expr: &choiceExpr{
								pos: position{line: 1543, col: 7, offset: 50081},
								alternatives: []interface{}{
									&anyMatcher{
										line: 1543, col: 7, offset: 50081,
									},
									&notExpr{
										pos: position{line: 1543, col: 11, offset: 50085},
										expr: &anyMatcher{
											line: 1543, col: 12, offset: 50086,
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "RangeExpression",
			pos:  position{line: 1547, col: 1, offset: 50134},
			expr: &actionExpr{
				pos: position{line: 1547, col: 20, offset: 50153},
				run: (*parser).callonRangeExpression1,
				expr: &seqExpr{
					pos: position{line: 1547, col: 20, offset: 50153},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1547, col: 20, offset: 50153},
							label: "varsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1547, col: 26, offset: 50159},
								expr: &ruleRefExpr{
									pos:  position{line: 1547, col: 26, offset: 50159},
									name: "rangeExpressionVars",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1547, col: 47, offset: 50180},
							label: "orderedI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1547, col: 56, offset: 50189},
								expr: &seqExpr{
									pos: position{line: 1547, col: 57, offset: 50190},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 1547, col: 57, offset: 50190},
											val:        "ordered",
											ignoreCase: false,
											want:       "\"ordered\"",
										},
										&oneOrMoreExpr{
											pos: position{line: 1547, col: 67, offset: 50200},
											expr: &litMatcher{
												pos:        position{line: 1547, col: 67, offset: 50200},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1547, col: 74, offset: 50207},
							val:        "range",
							ignoreCase: false,
							want:       "\"range\"",
						},
						&oneOrMoreExpr{
							pos: position{line: 1547, col: 82, offset: 50215},
							expr: &litMatcher{
								pos:        position{line: 1547, col: 82, offset: 50215},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1547, col: 87, offset: 50220},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1547, col: 93, offset: 50226},
								name: "SingleLineExpression",
							},
						},
					},
				},
			},
		},
		{
			name: "rangeExpressionVars",
			pos:  position{line: 1564, col: 1, offset: 50613},
			expr: &actionExpr{
				pos: position{line: 1564, col: 24, offset: 50636},
				run: (*parser).callonrangeExpressionVars1,
				expr: &seqExpr{
					pos: position{line: 1564, col: 24, offset: 50636},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1564, col: 24, offset: 50636},
							label: "var1I",
							expr: &ruleRefExpr{
								pos:  position{line: 1564, col: 30, offset: 50642},
								name: "GoIdent",
							},
						},
						&labeledExpr{
							pos:   position{line: 1564, col: 38, offset: 50650},
							label: "var2I",
							expr: &zeroOrOneExpr{
								pos: position{line: 1564, col: 44, offset: 50656},
								expr: &seqExpr{
									pos: position{line: 1564, col: 45, offset: 50657},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 1564, col: 45, offset: 50657},
											expr: &litMatcher{
												pos:        position{line: 1564, col: 45, offset: 50657},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 1564, col: 50, offset: 50662},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 1564, col: 54, offset: 50666},
											expr: &litMatcher{
												pos:        position{line: 1564, col: 54, offset: 50666},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1564, col: 59, offset: 50671},
											name: "GoIdent",
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1564, col: 69, offset: 50681},
							expr: &litMatcher{
								pos:        position{line: 1564, col: 69, offset: 50681},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1564, col: 74, offset: 50686},
							label: "eqPosI",
							expr: &ruleRefExpr{
								pos:  position{line: 1564, col: 81, offset: 50693},
								name: "POS",
							},
						},
						&labeledExpr{
							pos:   position{line: 1564, col: 85, offset: 50697},
							label: "declaresI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1564, col: 95, offset: 50707},
								expr: &litMatcher{
									pos:        position{line: 1564, col: 95, offset: 50707},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1564, col: 100, offset: 50712},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1564, col: 104, offset: 50716},
							expr: &litMatcher{
								pos:        position{line: 1564, col: 104, offset: 50716},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
					},
				},
			},
		},
		{
			name: "StringExpression",
			pos:  position{line: 1585, col: 1, offset: 51245},
			expr: &choiceExpr{
				pos: position{line: 1585, col: 21, offset: 51265},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1585, col: 21, offset: 51265},
						name: "InterpretedStringExpression",
					},
					&ruleRefExpr{
						pos:  position{line: 1585, col: 51, offset: 51295},
						name: "RawStringExpression",
					},
				},
			},
		},
		{
			name: "InterpretedStringExpression",
			pos:  position{line: 1587, col: 1, offset: 51316},
			expr: &choiceExpr{
				pos: position{line: 1587, col: 32, offset: 51347},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1587, col: 32, offset: 51347},
						run: (*parser).callonInterpretedStringExpression2,
						expr: &seqExpr{
							pos: position{line: 1587, col: 32, offset: 51347},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1587, col: 32, offset: 51347},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
								&labeledExpr{
									pos:   position{line: 1587, col: 36, offset: 51351},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1587, col: 46, offset: 51361},
										expr: &ruleRefExpr{
											pos:  position{line: 1587, col: 46, offset: 51361},
											name: "InterpretedStringExpressionItem",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1587, col: 79, offset: 51394},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1593, col: 5, offset: 51563},
						run: (*parser).callonInterpretedStringExpression9,
						expr: &seqExpr{
							pos: position{line: 1593, col: 5, offset: 51563},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1593, col: 5, offset: 51563},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
								&labeledExpr{
									pos:   position{line: 1593, col: 9, offset: 51567},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1593, col: 19, offset: 51577},
										name: "POS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1593, col: 23, offset: 51581},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1593, col: 33, offset: 51591},
										expr: &ruleRefExpr{
											pos:  position{line: 1593, col: 33, offset: 51591},
											name: "InterpretedStringExpressionItem",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "RawStringExpression",
			pos:  position{line: 1613, col: 1, offset: 52241},
			expr: &choiceExpr{
				pos: position{line: 1613, col: 24, offset: 52264},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1613, col: 24, offset: 52264},
						run: (*parser).callonRawStringExpression2,
						expr: &seqExpr{
							pos: position{line: 1613, col: 24, offset: 52264},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1613, col: 24, offset: 52264},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
								&labeledExpr{
									pos:   position{line: 1613, col: 28, offset: 52268},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1613, col: 38, offset: 52278},
										expr: &ruleRefExpr{
											pos:  position{line: 1613, col: 38, offset: 52278},
											name: "RawStringExpressionItem",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1613, col: 63, offset: 52303},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1619, col: 5, offset: 52472},
						run: (*parser).callonRawStringExpression9,
						expr: &seqExpr{
							pos: position{line: 1619, col: 5, offset: 52472},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1619, col: 5, offset: 52472},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
								&labeledExpr{
									pos:   position{line: 1619, col: 9, offset: 52476},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1619, col: 19, offset: 52486},
										name: "POS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1619, col: 23, offset: 52490},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1619, col: 33, offset: 52500},
										expr: &ruleRefExpr{
											pos:  position{line: 1619, col: 33, offset: 52500},
											name: "RawStringExpressionItem",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InterpretedStringExpressionItem",
			pos:  position{line: 1640, col: 1, offset: 53142},
			expr: &choiceExpr{
				pos: position{line: 1640, col: 36, offset: 53177},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1640, col: 36, offset: 53177},
						name: "InterpretedStringExpressionText",
					},
					&ruleRefExpr{
						pos:  position{line: 1640, col: 70, offset: 53211},
						name: "StringExpressionInterpolation",
					},
				},
			},
		},
		{
			name: "RawStringExpressionItem",
			pos:  position{line: 1641, col: 1, offset: 53241},
			expr: &choiceExpr{
				pos: position{line: 1641, col: 36, offset: 53276},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1641, col: 36, offset: 53276},
						name: "RawStringExpressionText",
					},
					&ruleRefExpr{
						pos:  position{line: 1641, col: 62, offset: 53302},
						name: "StringExpressionInterpolation",
					},
				},
			},
		},
		{
			name: "InterpretedStringExpressionText",
			pos:  position{line: 1643, col: 1, offset: 53333},
			expr: &actionExpr{
				pos: position{line: 1643, col: 36, offset: 53368},
				run: (*parser).callonInterpretedStringExpressionText1,
				expr: &oneOrMoreExpr{
					pos: position{line: 1643, col: 36, offset: 53368},
					expr: &choiceExpr{
						pos: position{line: 1643, col: 37, offset: 53369},
						alternatives: []interface{}{
							&litMatcher{
								pos:        position{line: 1643, col: 37, offset: 53369},
								val:        "##",
								ignoreCase: false,
								want:       "\"##\"",
							},
							&seqExpr{
								pos: position{line: 1643, col: 44, offset: 53376},
								exprs: []interface{}{
									&notExpr{
										pos: position{line: 1643, col: 44, offset: 53376},
										expr: &litMatcher{
											pos:        position{line: 1643, col: 45, offset: 53377},
											val:        "#",
											ignoreCase: false,
											want:       "\"#\"",
										},
									},
									&ruleRefExpr{
										pos:  position{line: 1643, col: 49, offset: 53381},
										name: "goInterpretedStringUnicodeValue",
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 1643, col: 83, offset: 53415},
								name: "goByteValue",
							},
							&ruleRefExpr{
								pos:  position{line: 1643, col: 97, offset: 53429},
								name: "goRecoverInterpretedStringEscape",
							},
						},
					},
				},
			},
		},
		{
			name: "RawStringExpressionText",
			pos:  position{line: 1649, col: 1, offset: 53573},
			expr: &actionExpr{
				pos: position{line: 1649, col: 28, offset: 53600},
				run: (*parser).callonRawStringExpressionText1,
				expr: &oneOrMoreExpr{
					pos: position{line: 1649, col: 28, offset: 53600},
					expr: &choiceExpr{
						pos: position{line: 1649, col: 29, offset: 53601},
						alternatives: []interface{}{
							&litMatcher{
								pos:        position{line: 1649, col: 29, offset: 53601},
								val:        "##",
								ignoreCase: false,
								want:       "\"##\"",
							},
							&seqExpr{
								pos: position{line: 1649, col: 36, offset: 53608},
								exprs: []interface{}{
									&notExpr{
										pos: position{line: 1649, col: 36, offset: 53608},
										expr: &litMatcher{
											pos:        position{line: 1649, col: 37, offset: 53609},
											val:        "#",
											ignoreCase: false,
											want:       "\"#\"",
										},
									},
									&ruleRefExpr{
										pos:  position{line: 1649, col: 41, offset: 53613},
										name: "goRawStringUnicodeChar",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "StringExpressionInterpolation",
			pos:  position{line: 1656, col: 1, offset: 53748},
			expr: &choiceExpr{
				pos: position{line: 1656, col: 34, offset: 53781},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1656, col: 34, offset: 53781},
						run: (*parser).callonStringExpressionInterpolation2,
						expr: &seqExpr{
							pos: position{line: 1656, col: 34, offset: 53781},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1656, col: 34, offset: 53781},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1656, col: 38, offset: 53785},
									label: "fmtDirectiveI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1656, col: 52, offset: 53799},
										expr: &ruleRefExpr{
											pos:  position{line: 1656, col: 52, offset: 53799},
											name: "fmtDirective",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1656, col: 66, offset: 53813},
									label: "lBracePosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1656, col: 77, offset: 53824},
										name: "L_BRACE",
									},
								},
								&labeledExpr{
									pos:   position{line: 1656, col: 85, offset: 53832},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1656, col: 91, offset: 53838},
										name: "SingleLineExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1656, col: 112, offset: 53859},
									label: "rBracePosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1656, col: 123, offset: 53870},
										name: "R_BRACE",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1664, col: 5, offset: 54169},
						run: (*parser).callonStringExpressionInterpolation14,
						expr: &seqExpr{
							pos: position{line: 1664, col: 5, offset: 54169},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1664, col: 5, offset: 54169},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1664, col: 9, offset: 54173},
									label: "fmtDirectiveI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1664, col: 23, offset: 54187},
										expr: &ruleRefExpr{
											pos:  position{line: 1664, col: 23, offset: 54187},
											name: "fmtDirective",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1664, col: 37, offset: 54201},
									label: "parenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1664, col: 47, offset: 54211},
										name: "POS",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1691, col: 5, offset: 55204},
						run: (*parser).callonStringExpressionInterpolation22,
						expr: &seqExpr{
							pos: position{line: 1691, col: 5, offset: 55204},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1691, col: 5, offset: 55204},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1691, col: 9, offset: 55208},
									label: "fmtDirectiveI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1691, col: 23, offset: 55222},
										expr: &ruleRefExpr{
											pos:  position{line: 1691, col: 23, offset: 55222},
											name: "fmtDirective",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1691, col: 37, offset: 55236},
									label: "parenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1691, col: 47, offset: 55246},
										name: "POS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1691, col: 51, offset: 55250},
									label: "lBracePosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1691, col: 62, offset: 55261},
										name: "L_BRACE",
									},
								},
								&labeledExpr{
									pos:   position{line: 1691, col: 70, offset: 55269},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1691, col: 80, offset: 55279},
										name: "POS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1691, col: 84, offset: 55283},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1691, col: 90, offset: 55289},
										name: "SingleLineExpression",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "fmtDirective",
			pos:  position{line: 1721, col: 1, offset: 56369},
			expr: &choiceExpr{
				pos: position{line: 1721, col: 17, offset: 56385},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1721, col: 17, offset: 56385},
						run: (*parser).callonfmtDirective2,
						expr: &seqExpr{
							pos: position{line: 1721, col: 17, offset: 56385},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1721, col: 17, offset: 56385},
									val:        "%",
									ignoreCase: false,
									want:       "\"%\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1721, col: 21, offset: 56389},
									expr: &ruleRefExpr{
										pos:  position{line: 1721, col: 21, offset: 56389},
										name: "fmtFlag",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1721, col: 30, offset: 56398},
									expr: &seqExpr{
										pos: position{line: 1721, col: 31, offset: 56399},
										exprs: []interface{}{
											&charClassMatcher{
												pos:        position{line: 1721, col: 31, offset: 56399},
												val:        "[1-9]",
												ranges:     []rune{'1', '9'},
												ignoreCase: false,
												inverted:   false,
											},
											&zeroOrMoreExpr{
												pos: position{line: 1721, col: 36, offset: 56404},
												expr: &charClassMatcher{
													pos:        position{line: 1721, col: 36, offset: 56404},
													val:        "[0-9]",
													ranges:     []rune{'0', '9'},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1721, col: 45, offset: 56413},
									expr: &seqExpr{
										pos: position{line: 1721, col: 46, offset: 56414},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1721, col: 46, offset: 56414},
												val:        ".",
												ignoreCase: false,
												want:       "\".\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1721, col: 50, offset: 56418},
												expr: &charClassMatcher{
													pos:        position{line: 1721, col: 50, offset: 56418},
													val:        "[0-9]",
													ranges:     []rune{'0', '9'},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 1721, col: 59, offset: 56427},
									name: "fmtVerb",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1723, col: 5, offset: 56476},
						run: (*parser).callonfmtDirective18,
						expr: &seqExpr{
							pos: position{line: 1723, col: 5, offset: 56476},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1723, col: 5, offset: 56476},
									val:        "%",
									ignoreCase: false,
									want:       "\"%\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1723, col: 9, offset: 56480},
									expr: &charClassMatcher{
										pos:        position{line: 1723, col: 9, offset: 56480},
										val:        "[^`\"{]",
										chars:      []rune{'`', '"', '{'},
										ignoreCase: false,
										inverted:   true,
									},
								},
								&labeledExpr{
									pos:   position{line: 1723, col: 17, offset: 56488},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1723, col: 25, offset: 56496},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "fmtFlag",
			pos:  position{line: 1737, col: 1, offset: 57055},
			expr: &charClassMatcher{
				pos:        position{line: 1737, col: 12, offset: 57066},
				val:        "[+-# 0]",
				chars:      []rune{' ', '0'},
				ranges:     []rune{'+', '#'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "fmtVerb",
			pos:  position{line: 1738, col: 1, offset: 57074},
			expr: &choiceExpr{
				pos: position{line: 1738, col: 12, offset: 57085},
				alternatives: []interface{}{
					&charClassMatcher{
						pos:        position{line: 1738, col: 12, offset: 57085},
						val:        "[vT]",
						chars:      []rune{'v', 'T'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 1738, col: 19, offset: 57092},
						val:        "[t]",
						chars:      []rune{'t'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 1738, col: 25, offset: 57098},
						val:        "[bcdoOqxXU]",
						chars:      []rune{'b', 'c', 'd', 'o', 'O', 'q', 'x', 'X', 'U'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 1738, col: 39, offset: 57112},
						val:        "[beEfFgGxX]",
						chars:      []rune{'b', 'e', 'E', 'f', 'F', 'g', 'G', 'x', 'X'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 1738, col: 53, offset: 57126},
						val:        "[sqxX]",
						chars:      []rune{'s', 'q', 'x', 'X'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 1738, col: 62, offset: 57135},
						val:        "[p]",
						chars:      []rune{'p'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 1738, col: 68, offset: 57141},
						val:        "[p]",
						chars:      []rune{'p'},
						ignoreCase: false,
						inverted:   false,
					},
					&actionExpr{
						pos: position{line: 1738, col: 74, offset: 57147},
						run: (*parser).callonfmtVerb9,
						expr: &andExpr{
							pos: position{line: 1738, col: 74, offset: 57147},
							expr: &choiceExpr{
								pos: position{line: 1738, col: 76, offset: 57149},
								alternatives: []interface{}{
									&litMatcher{
										pos:        position{line: 1738, col: 76, offset: 57149},
										val:        "{",
										ignoreCase: false,
										want:       "\"{\"",
									},
									&litMatcher{
										pos:        position{line: 1738, col: 82, offset: 57155},
										val:        "\"",
										ignoreCase: false,
										want:       "\"\\\"\"",
									},
									&litMatcher{
										pos:        position{line: 1738, col: 88, offset: 57161},
										val:        "`",
										ignoreCase: false,
										want:       "\"`\"",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1750, col: 5, offset: 57686},
						run: (*parser).callonfmtVerb15,
						expr: &anyMatcher{
							line: 1750, col: 5, offset: 57686,
						},
					},
				},
			},
		},
		{
			name: "commaPos",
			pos:  position{line: 1768, col: 1, offset: 58400},
			expr: &choiceExpr{
				pos: position{line: 1768, col: 13, offset: 58412},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1768, col: 13, offset: 58412},
						run: (*parser).calloncommaPos2,
						expr: &seqExpr{
							pos: position{line: 1768, col: 13, offset: 58412},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 1768, col: 13, offset: 58412},
									expr: &litMatcher{
										pos:        position{line: 1768, col: 13, offset: 58412},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1768, col: 18, offset: 58417},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&labeledExpr{
									pos:   position{line: 1768, col: 22, offset: 58421},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 1768, col: 27, offset: 58426},
										name: "POS",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1768, col: 31, offset: 58430},
									expr: &ruleRefExpr{
										pos:  position{line: 1768, col: 31, offset: 58430},
										name: "WS",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1770, col: 5, offset: 58461},
						run: (*parser).calloncommaPos11,
						expr: &seqExpr{
							pos: position{line: 1770, col: 5, offset: 58461},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1770, col: 5, offset: 58461},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 1770, col: 10, offset: 58466},
										name: "POS",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1770, col: 14, offset: 58470},
									expr: &litMatcher{
										pos:        position{line: 1770, col: 14, offset: 58470},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TernaryExpression",
			pos:  position{line: 1774, col: 1, offset: 58501},
			expr: &choiceExpr{
				pos: position{line: 1774, col: 22, offset: 58522},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1774, col: 22, offset: 58522},
						run: (*parser).callonTernaryExpression2,
						expr: &seqExpr{
							pos: position{line: 1774, col: 22, offset: 58522},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1774, col: 22, offset: 58522},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1774, col: 27, offset: 58527},
									expr: &ruleRefExpr{
										pos:  position{line: 1774, col: 27, offset: 58527},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1774, col: 31, offset: 58531},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1774, col: 42, offset: 58542},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1774, col: 64, offset: 58564},
									expr: &litMatcher{
										pos:        position{line: 1774, col: 64, offset: 58564},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1774, col: 69, offset: 58569},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1774, col: 73, offset: 58573},
									expr: &ruleRefExpr{
										pos:  position{line: 1774, col: 73, offset: 58573},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1774, col: 77, offset: 58577},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1774, col: 85, offset: 58585},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1774, col: 107, offset: 58607},
									expr: &litMatcher{
										pos:        position{line: 1774, col: 107, offset: 58607},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1774, col: 112, offset: 58612},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1774, col: 116, offset: 58616},
									expr: &ruleRefExpr{
										pos:  position{line: 1774, col: 116, offset: 58616},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1774, col: 120, offset: 58620},
									label: "ifFalseI",
									expr: &ruleRefExpr{
										pos:  position{line: 1774, col: 129, offset: 58629},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1774, col: 151, offset: 58651},
									expr: &litMatcher{
										pos:        position{line: 1774, col: 151, offset: 58651},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1774, col: 156, offset: 58656},
									expr: &seqExpr{
										pos: position{line: 1774, col: 157, offset: 58657},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1774, col: 157, offset: 58657},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1774, col: 161, offset: 58661},
												expr: &ruleRefExpr{
													pos:  position{line: 1774, col: 161, offset: 58661},
													name: "WS",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1774, col: 167, offset: 58667},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1774, col: 178, offset: 58678},
										name: "R_PAREN",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1782, col: 5, offset: 58948},
						run: (*parser).callonTernaryExpression32,
						expr: &seqExpr{
							pos: position{line: 1782, col: 5, offset: 58948},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1782, col: 5, offset: 58948},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&labeledExpr{
									pos:   position{line: 1782, col: 10, offset: 58953},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1782, col: 20, offset: 58963},
										name: "POS",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1782, col: 24, offset: 58967},
									expr: &ruleRefExpr{
										pos:  position{line: 1782, col: 24, offset: 58967},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1782, col: 28, offset: 58971},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1782, col: 39, offset: 58982},
										name: "R_PAREN",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1796, col: 5, offset: 59562},
						run: (*parser).callonTernaryExpression41,
						expr: &seqExpr{
							pos: position{line: 1796, col: 5, offset: 59562},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1796, col: 5, offset: 59562},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1796, col: 10, offset: 59567},
									expr: &ruleRefExpr{
										pos:  position{line: 1796, col: 10, offset: 59567},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1796, col: 14, offset: 59571},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1796, col: 25, offset: 59582},
										name: "multiLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1796, col: 47, offset: 59604},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1796, col: 57, offset: 59614},
										name: "commaPos",
									},
								},
								&labeledExpr{
									pos:   position{line: 1796, col: 66, offset: 59623},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1796, col: 77, offset: 59634},
										name: "R_PAREN",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1811, col: 5, offset: 60249},
						run: (*parser).callonTernaryExpression52,
						expr: &seqExpr{
							pos: position{line: 1811, col: 5, offset: 60249},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1811, col: 5, offset: 60249},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1811, col: 10, offset: 60254},
									expr: &ruleRefExpr{
										pos:  position{line: 1811, col: 10, offset: 60254},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1811, col: 14, offset: 60258},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1811, col: 25, offset: 60269},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1811, col: 47, offset: 60291},
									expr: &litMatcher{
										pos:        position{line: 1811, col: 47, offset: 60291},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1811, col: 52, offset: 60296},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1811, col: 56, offset: 60300},
									expr: &ruleRefExpr{
										pos:  position{line: 1811, col: 56, offset: 60300},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1811, col: 60, offset: 60304},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1811, col: 68, offset: 60312},
										name: "multiLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1811, col: 90, offset: 60334},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1811, col: 100, offset: 60344},
										name: "commaPos",
									},
								},
								&labeledExpr{
									pos:   position{line: 1811, col: 109, offset: 60353},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1811, col: 120, offset: 60364},
										name: "R_PAREN",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineTernaryExpression",
			pos:  position{line: 1829, col: 1, offset: 61000},
			expr: &choiceExpr{
				pos: position{line: 1829, col: 32, offset: 61031},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1829, col: 32, offset: 61031},
						run: (*parser).callonSingleLineTernaryExpression2,
						expr: &seqExpr{
							pos: position{line: 1829, col: 32, offset: 61031},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1829, col: 32, offset: 61031},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1829, col: 37, offset: 61036},
									expr: &litMatcher{
										pos:        position{line: 1829, col: 37, offset: 61036},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1829, col: 42, offset: 61041},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1829, col: 53, offset: 61052},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1829, col: 76, offset: 61075},
									expr: &litMatcher{
										pos:        position{line: 1829, col: 76, offset: 61075},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1829, col: 81, offset: 61080},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1829, col: 85, offset: 61084},
									expr: &litMatcher{
										pos:        position{line: 1829, col: 85, offset: 61084},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1829, col: 90, offset: 61089},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1829, col: 98, offset: 61097},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1829, col: 121, offset: 61120},
									expr: &litMatcher{
										pos:        position{line: 1829, col: 121, offset: 61120},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1829, col: 126, offset: 61125},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1829, col: 130, offset: 61129},
									expr: &litMatcher{
										pos:        position{line: 1829, col: 130, offset: 61129},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1829, col: 135, offset: 61134},
									label: "ifFalseI",
									expr: &ruleRefExpr{
										pos:  position{line: 1829, col: 144, offset: 61143},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1829, col: 167, offset: 61166},
									expr: &litMatcher{
										pos:        position{line: 1829, col: 167, offset: 61166},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1829, col: 172, offset: 61171},
									expr: &seqExpr{
										pos: position{line: 1829, col: 173, offset: 61172},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1829, col: 173, offset: 61172},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1829, col: 177, offset: 61176},
												expr: &litMatcher{
													pos:        position{line: 1829, col: 177, offset: 61176},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1829, col: 184, offset: 61183},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1829, col: 195, offset: 61194},
										name: "R_PAREN",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1837, col: 5, offset: 61464},
						run: (*parser).callonSingleLineTernaryExpression32,
						expr: &seqExpr{
							pos: position{line: 1837, col: 5, offset: 61464},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1837, col: 5, offset: 61464},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&labeledExpr{
									pos:   position{line: 1837, col: 10, offset: 61469},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1837, col: 20, offset: 61479},
										name: "POS",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1837, col: 24, offset: 61483},
									expr: &litMatcher{
										pos:        position{line: 1837, col: 24, offset: 61483},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1837, col: 29, offset: 61488},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1837, col: 40, offset: 61499},
										name: "R_PAREN",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1851, col: 5, offset: 62079},
						run: (*parser).callonSingleLineTernaryExpression41,
						expr: &seqExpr{
							pos: position{line: 1851, col: 5, offset: 62079},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1851, col: 5, offset: 62079},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1851, col: 10, offset: 62084},
									expr: &litMatcher{
										pos:        position{line: 1851, col: 10, offset: 62084},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1851, col: 15, offset: 62089},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1851, col: 26, offset: 62100},
										name: "SingleLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1851, col: 49, offset: 62123},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1851, col: 59, offset: 62133},
										name: "commaPos",
									},
								},
								&labeledExpr{
									pos:   position{line: 1851, col: 68, offset: 62142},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1851, col: 79, offset: 62153},
										name: "R_PAREN",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1866, col: 5, offset: 62768},
						run: (*parser).callonSingleLineTernaryExpression52,
						expr: &seqExpr{
							pos: position{line: 1866, col: 5, offset: 62768},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1866, col: 5, offset: 62768},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1866, col: 10, offset: 62773},
									expr: &litMatcher{
										pos:        position{line: 1866, col: 10, offset: 62773},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1866, col: 15, offset: 62778},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1866, col: 26, offset: 62789},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1866, col: 49, offset: 62812},
									expr: &litMatcher{
										pos:        position{line: 1866, col: 49, offset: 62812},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1866, col: 54, offset: 62817},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1866, col: 58, offset: 62821},
									expr: &litMatcher{
										pos:        position{line: 1866, col: 58, offset: 62821},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1866, col: 63, offset: 62826},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1866, col: 71, offset: 62834},
										name: "SingleLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1866, col: 94, offset: 62857},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1866, col: 104, offset: 62867},
										name: "commaPos",
									},
								},
								&labeledExpr{
									pos:   position{line: 1866, col: 113, offset: 62876},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1866, col: 124, offset: 62887},
										name: "R_PAREN",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ChainExpression",
			pos:  position{line: 1888, col: 1, offset: 63714},
			expr: &choiceExpr{
				pos: position{line: 1888, col: 20, offset: 63733},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1888, col: 20, offset: 63733},
						run: (*parser).callonChainExpression2,
						expr: &seqExpr{
							pos: position{line: 1888, col: 20, offset: 63733},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1888, col: 20, offset: 63733},
									label: "derefsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1888, col: 28, offset: 63741},
										expr: &litMatcher{
											pos:        position{line: 1888, col: 28, offset: 63741},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1888, col: 33, offset: 63746},
									label: "rootI",
									expr: &ruleRefExpr{
										pos:  position{line: 1888, col: 39, offset: 63752},
										name: "chainExpressionRoot",
									},
								},
								&labeledExpr{
									pos:   position{line: 1888, col: 59, offset: 63772},
									label: "checkRootI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1888, col: 70, offset: 63783},
										expr: &litMatcher{
											pos:        position{line: 1888, col: 70, offset: 63783},
											val:        "?",
											ignoreCase: false,
											want:       "\"?\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1888, col: 75, offset: 63788},
									label: "chainI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1888, col: 82, offset: 63795},
										expr: &ruleRefExpr{
											pos:  position{line: 1888, col: 82, offset: 63795},
											name: "ChainExpressionItem",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1889, col: 20, offset: 63835},
									label: "defaultI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1889, col: 29, offset: 63844},
										expr: &seqExpr{
											pos: position{line: 1889, col: 30, offset: 63845},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 1889, col: 30, offset: 63845},
													expr: &litMatcher{
														pos:        position{line: 1889, col: 30, offset: 63845},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&labeledExpr{
													pos:   position{line: 1889, col: 35, offset: 63850},
													label: "defaultPosI",
													expr: &ruleRefExpr{
														pos:  position{line: 1889, col: 47, offset: 63862},
														name: "POS",
													},
												},
												&litMatcher{
													pos:        position{line: 1889, col: 51, offset: 63866},
													val:        "~",
													ignoreCase: false,
													want:       "\"~\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 1889, col: 55, offset: 63870},
													expr: &ruleRefExpr{
														pos:  position{line: 1889, col: 55, offset: 63870},
														name: "WS",
													},
												},
												&ruleRefExpr{
													pos:  position{line: 1889, col: 59, offset: 63874},
													name: "GoExpression",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1889, col: 74, offset: 63889},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1889, col: 82, offset: 63897},
										name: "POS",
									},
								},
								&andExpr{
									pos: position{line: 1889, col: 86, offset: 63901},
									expr: &choiceExpr{
										pos: position{line: 1889, col: 88, offset: 63903},
										alternatives: []interface{}{
											&ruleRefExpr{
												pos:  position{line: 1889, col: 88, offset: 63903},
												name: "EOL",
											},
											&seqExpr{
												pos: position{line: 1889, col: 94, offset: 63909},
												exprs: []interface{}{
													&zeroOrMoreExpr{
														pos: position{line: 1889, col: 94, offset: 63909},
														expr: &litMatcher{
															pos:        position{line: 1889, col: 94, offset: 63909},
															val:        " ",
															ignoreCase: false,
															want:       "\" \"",
														},
													},
													&ruleRefExpr{
														pos:  position{line: 1889, col: 99, offset: 63914},
														name: "expressionTerminator",
													},
												},
											},
										},
									},
								},
								&andCodeExpr{
									pos: position{line: 1889, col: 121, offset: 63936},
									run: (*parser).callonChainExpression35,
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1907, col: 5, offset: 64569},
						run: (*parser).callonChainExpression36,
						expr: &seqExpr{
							pos: position{line: 1907, col: 5, offset: 64569},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1907, col: 5, offset: 64569},
									label: "startPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1907, col: 15, offset: 64579},
										name: "POS",
									},
								},
								&labeledExpr{
									pos:   position{line: 1907, col: 19, offset: 64583},
									label: "derefsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1907, col: 27, offset: 64591},
										expr: &litMatcher{
											pos:        position{line: 1907, col: 27, offset: 64591},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1907, col: 32, offset: 64596},
									label: "rootI",
									expr: &ruleRefExpr{
										pos:  position{line: 1907, col: 38, offset: 64602},
										name: "chainExpressionRoot",
									},
								},
								&labeledExpr{
									pos:   position{line: 1907, col: 58, offset: 64622},
									label: "checkRootI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1907, col: 69, offset: 64633},
										expr: &litMatcher{
											pos:        position{line: 1907, col: 69, offset: 64633},
											val:        "?",
											ignoreCase: false,
											want:       "\"?\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1907, col: 74, offset: 64638},
									label: "chainI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1907, col: 81, offset: 64645},
										expr: &ruleRefExpr{
											pos:  position{line: 1907, col: 81, offset: 64645},
											name: "ChainExpressionItem",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1907, col: 102, offset: 64666},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1907, col: 110, offset: 64674},
										name: "POS",
									},
								},
								&andCodeExpr{
									pos: position{line: 1907, col: 114, offset: 64678},
									run: (*parser).callonChainExpression53,
								},
								&labeledExpr{
									pos:   position{line: 1909, col: 3, offset: 64785},
									label: "malStartPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1909, col: 16, offset: 64798},
										name: "POS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 1909, col: 20, offset: 64802},
									name: "GoExpression",
								},
								&labeledExpr{
									pos:   position{line: 1909, col: 33, offset: 64815},
									label: "malEndPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1909, col: 44, offset: 64826},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "chainExpressionRoot",
			pos:  position{line: 1950, col: 1, offset: 66266},
			expr: &choiceExpr{
				pos: position{line: 1950, col: 24, offset: 66289},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1950, col: 24, offset: 66289},
						run: (*parser).callonchainExpressionRoot2,
						expr: &seqExpr{
							pos: position{line: 1950, col: 24, offset: 66289},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1950, col: 24, offset: 66289},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 1950, col: 28, offset: 66293},
									expr: &ruleRefExpr{
										pos:  position{line: 1950, col: 28, offset: 66293},
										name: "chainExpressionRootParenContent",
									},
								},
								&litMatcher{
									pos:        position{line: 1950, col: 61, offset: 66326},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1955, col: 5, offset: 66439},
						run: (*parser).callonchainExpressionRoot8,
						expr: &labeledExpr{
							pos:   position{line: 1955, col: 5, offset: 66439},
							label: "identI",
							expr: &ruleRefExpr{
								pos:  position{line: 1955, col: 12, offset: 66446},
								name: "GoIdent",
							},
						},
					},
				},
			},
		},
		{
			name: "chainExpressionRootParenContent",
			pos:  position{line: 1962, col: 1, offset: 66601},
			expr: &choiceExpr{
				pos: position{line: 1962, col: 36, offset: 66636},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 1962, col: 36, offset: 66636},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 1962, col: 36, offset: 66636},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
							&ruleRefExpr{
								pos:  position{line: 1962, col: 40, offset: 66640},
								name: "chainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 1962, col: 72, offset: 66672},
								val:        ")",
								ignoreCase: false,
								want:       "\")\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 1963, col: 36, offset: 66713},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 1963, col: 36, offset: 66713},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
							&ruleRefExpr{
								pos:  position{line: 1963, col: 40, offset: 66717},
								name: "chainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 1963, col: 72, offset: 66749},
								val:        "]",
								ignoreCase: false,
								want:       "\"]\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 1964, col: 36, offset: 66790},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 1964, col: 36, offset: 66790},
								val:        "{",
								ignoreCase: false,
								want:       "\"{\"",
							},
							&ruleRefExpr{
								pos:  position{line: 1964, col: 40, offset: 66794},
								name: "chainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 1964, col: 72, offset: 66826},
								val:        "}",
								ignoreCase: false,
								want:       "\"}\"",
							},
						},
					},
					&oneOrMoreExpr{
						pos: position{line: 1965, col: 36, offset: 66867},
						expr: &charClassMatcher{
							pos:        position{line: 1965, col: 36, offset: 66867},
							val:        "[^({[\\]})]",
							chars:      []rune{'(', '{', '[', ']', '}', ')'},
							ignoreCase: false,
							inverted:   true,
						},
					},
				},
			},
		},
		{
			name: "SingleLineChainExpression",
			pos:  position{line: 1967, col: 1, offset: 66880},
			expr: &choiceExpr{
				pos: position{line: 1967, col: 30, offset: 66909},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1967, col: 30, offset: 66909},
						run: (*parser).callonSingleLineChainExpression2,
						expr: &seqExpr{
							pos: position{line: 1967, col: 30, offset: 66909},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1967, col: 30, offset: 66909},
									label: "derefsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1967, col: 38, offset: 66917},
										expr: &litMatcher{
											pos:        position{line: 1967, col: 38, offset: 66917},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1967, col: 43, offset: 66922},
									label: "rootI",
									expr: &ruleRefExpr{
										pos:  position{line: 1967, col: 49, offset: 66928},
										name: "chainExpressionRoot",
									},
								},
								&labeledExpr{
									pos:   position{line: 1967, col: 69, offset: 66948},
									label: "checkRootI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1967, col: 80, offset: 66959},
										expr: &litMatcher{
											pos:        position{line: 1967, col: 80, offset: 66959},
											val:        "?",
											ignoreCase: false,
											want:       "\"?\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1967, col: 85, offset: 66964},
									label: "chainI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1967, col: 92, offset: 66971},
										expr: &ruleRefExpr{
											pos:  position{line: 1967, col: 92, offset: 66971},
											name: "SingleLineChainExpressionItem",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1968, col: 30, offset: 67031},
									label: "defaultI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1968, col: 39, offset: 67040},
										expr: &seqExpr{
											pos: position{line: 1968, col: 40, offset: 67041},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 1968, col: 40, offset: 67041},
													expr: &litMatcher{
														pos:        position{line: 1968, col: 40, offset: 67041},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&labeledExpr{
													pos:   position{line: 1968, col: 45, offset: 67046},
													label: "defaultPosI",
													expr: &ruleRefExpr{
														pos:  position{line: 1968, col: 57, offset: 67058},
														name: "POS",
													},
												},
												&litMatcher{
													pos:        position{line: 1968, col: 61, offset: 67062},
													val:        "?!",
													ignoreCase: false,
													want:       "\"?!\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 1968, col: 66, offset: 67067},
													expr: &litMatcher{
														pos:        position{line: 1968, col: 66, offset: 67067},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&ruleRefExpr{
													pos:  position{line: 1968, col: 71, offset: 67072},
													name: "SingleLineGoExpression",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1968, col: 96, offset: 67097},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 1968, col: 104, offset: 67105},
										name: "POS",
									},
								},
								&andExpr{
									pos: position{line: 1968, col: 108, offset: 67109},
									expr: &choiceExpr{
										pos: position{line: 1968, col: 110, offset: 67111},
										alternatives: []interface{}{
											&ruleRefExpr{
												pos:  position{line: 1968, col: 110, offset: 67111},
												name: "EOL",
											},
											&ruleRefExpr{
												pos:  position{line: 1968, col: 116, offset: 67117},
												name: "expressionTerminator",
											},
										},
									},
								},
								&andCodeExpr{
									pos: position{line: 1968, col: 138, offset: 67139},
									run: (*parser).callonSingleLineChainExpression32,
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 1986, col: 5, offset: 67731},
						exprs: []interface{}{
							&labeledExpr{
								pos:   position{line: 1986, col: 5, offset: 67731},
								label: "startPosI",
								expr: &ruleRefExpr{
									pos:  position{line: 1986, col: 15, offset: 67741},
									name: "POS",
								},
							},
							&labeledExpr{
								pos:   position{line: 1986, col: 19, offset: 67745},
								label: "derefsI",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1986, col: 27, offset: 67753},
									expr: &litMatcher{
										pos:        position{line: 1986, col: 27, offset: 67753},
										val:        "*",
										ignoreCase: false,
										want:       "\"*\"",
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 1986, col: 32, offset: 67758},
								label: "rootI",
								expr: &ruleRefExpr{
									pos:  position{line: 1986, col: 38, offset: 67764},
									name: "chainExpressionRoot",
								},
							},
							&labeledExpr{
								pos:   position{line: 1986, col: 58, offset: 67784},
								label: "checkRootI",
								expr: &zeroOrOneExpr{
									pos: position{line: 1986, col: 69, offset: 67795},
									expr: &litMatcher{
										pos:        position{line: 1986, col: 69, offset: 67795},
										val:        "?",
										ignoreCase: false,
										want:       "\"?\"",
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 1986, col: 74, offset: 67800},
								label: "chainI",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1986, col: 81, offset: 67807},
									expr: &ruleRefExpr{
										pos:  position{line: 1986, col: 81, offset: 67807},
										name: "SingleLineChainExpressionItem",
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 1986, col: 112, offset: 67838},
								label: "endPosI",
								expr: &ruleRefExpr{
									pos:  position{line: 1986, col: 120, offset: 67846},
									name: "POS",
								},
							},
							&andCodeExpr{
								pos: position{line: 1986, col: 124, offset: 67850},
								run: (*parser).callonSingleLineChainExpression49,
							},
							&labeledExpr{
								pos:   position{line: 1988, col: 3, offset: 67916},
								label: "malStartPosI",
								expr: &ruleRefExpr{
									pos:  position{line: 1988, col: 16, offset: 67929},
									name: "POS",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 1988, col: 20, offset: 67933},
								name: "SingleLineGoExpression",
							},
							&labeledExpr{
								pos:   position{line: 1988, col: 43, offset: 67956},
								label: "malEndPosI",
								expr: &ruleRefExpr{
									pos:  position{line: 1988, col: 54, offset: 67967},
									name: "POS",
								},
							},
							&andCodeExpr{
								pos: position{line: 1988, col: 58, offset: 67971},
								run: (*parser).callonSingleLineChainExpression55,
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineChainExpressionRoot",
			pos:  position{line: 2016, col: 1, offset: 68991},
			expr: &choiceExpr{
				pos: position{line: 2016, col: 34, offset: 69024},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2016, col: 34, offset: 69024},
						run: (*parser).callonsingleLineChainExpressionRoot2,
						expr: &seqExpr{
							pos: position{line: 2016, col: 34, offset: 69024},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2016, col: 34, offset: 69024},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 2016, col: 38, offset: 69028},
									expr: &ruleRefExpr{
										pos:  position{line: 2016, col: 38, offset: 69028},
										name: "singleLineChainExpressionRootParenContent",
									},
								},
								&litMatcher{
									pos:        position{line: 2016, col: 81, offset: 69071},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2021, col: 5, offset: 69184},
						run: (*parser).callonsingleLineChainExpressionRoot8,
						expr: &labeledExpr{
							pos:   position{line: 2021, col: 5, offset: 69184},
							label: "identI",
							expr: &ruleRefExpr{
								pos:  position{line: 2021, col: 12, offset: 69191},
								name: "GoIdent",
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineChainExpressionRootParenContent",
			pos:  position{line: 2028, col: 1, offset: 69346},
			expr: &choiceExpr{
				pos: position{line: 2028, col: 46, offset: 69391},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2028, col: 46, offset: 69391},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2028, col: 46, offset: 69391},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2028, col: 50, offset: 69395},
								name: "singleLineChainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2028, col: 92, offset: 69437},
								val:        ")",
								ignoreCase: false,
								want:       "\")\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2029, col: 46, offset: 69488},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2029, col: 46, offset: 69488},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2029, col: 50, offset: 69492},
								name: "singleLineChainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2029, col: 92, offset: 69534},
								val:        "]",
								ignoreCase: false,
								want:       "\"]\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2030, col: 46, offset: 69585},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2030, col: 46, offset: 69585},
								val:        "{",
								ignoreCase: false,
								want:       "\"{\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2030, col: 50, offset: 69589},
								name: "singleLineChainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2030, col: 92, offset: 69631},
								val:        "}",
								ignoreCase: false,
								want:       "\"}\"",
							},
						},
					},
					&oneOrMoreExpr{
						pos: position{line: 2031, col: 46, offset: 69682},
						expr: &charClassMatcher{
							pos:        position{line: 2031, col: 46, offset: 69682},
							val:        "[^({[\\]})\\r\\n]",
							chars:      []rune{'(', '{', '[', ']', '}', ')', '\r', '\n'},
							ignoreCase: false,
							inverted:   true,
						},
					},
				},
			},
		},
		{
			name: "ChainExpressionItem",
			pos:  position{line: 2037, col: 1, offset: 69731},
			expr: &choiceExpr{
				pos: position{line: 2037, col: 34, offset: 69764},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2037, col: 34, offset: 69764},
						name: "IndexExpression",
					},
					&ruleRefExpr{
						pos:  position{line: 2037, col: 52, offset: 69782},
						name: "DotIdentExpression",
					},
					&ruleRefExpr{
						pos:  position{line: 2037, col: 73, offset: 69803},
						name: "ParenExpression",
					},
					&ruleRefExpr{
						pos:  position{line: 2037, col: 91, offset: 69821},
						name: "TypeAssertionExpression",
					},
				},
			},
		},
		{
			name: "SingleLineChainExpressionItem",
			pos:  position{line: 2038, col: 1, offset: 69845},
			expr: &choiceExpr{
				pos: position{line: 2038, col: 34, offset: 69878},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2038, col: 34, offset: 69878},
						name: "SingleLineIndexExpression",
					},
					&ruleRefExpr{
						pos:  position{line: 2038, col: 62, offset: 69906},
						name: "SingleLineDotIdentExpression",
					},
					&ruleRefExpr{
						pos:  position{line: 2039, col: 34, offset: 69970},
						name: "SingleLineParenExpression",
					},
					&ruleRefExpr{
						pos:  position{line: 2039, col: 62, offset: 69998},
						name: "SingleLineTypeAssertionExpression",
					},
				},
			},
		},
		{
			name: "IndexExpression",
			pos:  position{line: 2041, col: 1, offset: 70033},
			expr: &actionExpr{
				pos: position{line: 2041, col: 20, offset: 70052},
				run: (*parser).callonIndexExpression1,
				expr: &seqExpr{
					pos: position{line: 2041, col: 20, offset: 70052},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 2041, col: 20, offset: 70052},
							name: "L_BRACKET",
						},
						&zeroOrMoreExpr{
							pos: position{line: 2041, col: 30, offset: 70062},
							expr: &ruleRefExpr{
								pos:  position{line: 2041, col: 30, offset: 70062},
								name: "WS",
							},
						},
						&labeledExpr{
							pos:   position{line: 2041, col: 34, offset: 70066},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 2041, col: 40, offset: 70072},
								name: "indexExpressionIndex",
							},
						},
						&labeledExpr{
							pos:   position{line: 2041, col: 61, offset: 70093},
							label: "checkIndexI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2041, col: 73, offset: 70105},
								expr: &litMatcher{
									pos:        position{line: 2041, col: 73, offset: 70105},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2041, col: 78, offset: 70110},
							expr: &seqExpr{
								pos: position{line: 2041, col: 79, offset: 70111},
								exprs: []interface{}{
									&litMatcher{
										pos:        position{line: 2041, col: 79, offset: 70111},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2041, col: 83, offset: 70115},
										expr: &ruleRefExpr{
											pos:  position{line: 2041, col: 83, offset: 70115},
											name: "WS",
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2041, col: 89, offset: 70121},
							expr: &litMatcher{
								pos:        position{line: 2041, col: 89, offset: 70121},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2041, col: 94, offset: 70126},
							label: "rBracePosI",
							expr: &ruleRefExpr{
								pos:  position{line: 2041, col: 105, offset: 70137},
								name: "R_BRACKET",
							},
						},
						&labeledExpr{
							pos:   position{line: 2041, col: 115, offset: 70147},
							label: "checkValueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2041, col: 127, offset: 70159},
								expr: &litMatcher{
									pos:        position{line: 2041, col: 127, offset: 70159},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "indexExpressionIndexTerminator",
			pos:  position{line: 2051, col: 1, offset: 70407},
			expr: &choiceExpr{
				pos: position{line: 2051, col: 35, offset: 70441},
				alternatives: []interface{}{
					&charClassMatcher{
						pos:        position{line: 2051, col: 35, offset: 70441},
						val:        "[)}\\]]",
						chars:      []rune{')', '}', ']'},
						ignoreCase: false,
						inverted:   false,
					},
					&litMatcher{
						pos:        position{line: 2051, col: 44, offset: 70450},
						val:        "?",
						ignoreCase: false,
						want:       "\"?\"",
					},
					&litMatcher{
						pos:        position{line: 2051, col: 50, offset: 70456},
						val:        ",",
						ignoreCase: false,
						want:       "\",\"",
					},
					&seqExpr{
						pos: position{line: 2051, col: 56, offset: 70462},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2051, col: 56, offset: 70462},
								val:        ":",
								ignoreCase: false,
								want:       "\":\"",
							},
							&notExpr{
								pos: position{line: 2051, col: 60, offset: 70466},
								expr: &litMatcher{
									pos:        position{line: 2051, col: 61, offset: 70467},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "indexExpressionIndex",
			pos:  position{line: 2053, col: 1, offset: 70472},
			expr: &actionExpr{
				pos: position{line: 2053, col: 25, offset: 70496},
				run: (*parser).callonindexExpressionIndex1,
				expr: &labeledExpr{
					pos:   position{line: 2053, col: 25, offset: 70496},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 2053, col: 32, offset: 70503},
						expr: &choiceExpr{
							pos: position{line: 2054, col: 5, offset: 70509},
							alternatives: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 2054, col: 5, offset: 70509},
									name: "goParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 2054, col: 19, offset: 70523},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 2054, col: 38, offset: 70542},
									name: "TernaryExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 2054, col: 58, offset: 70562},
									name: "goRuneExpr",
								},
								&actionExpr{
									pos: position{line: 2055, col: 5, offset: 70579},
									run: (*parser).callonindexExpressionIndex9,
									expr: &seqExpr{
										pos: position{line: 2055, col: 5, offset: 70579},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 2055, col: 5, offset: 70579},
												label: "posI",
												expr: &ruleRefExpr{
													pos:  position{line: 2055, col: 10, offset: 70584},
													name: "POS",
												},
											},
											&notExpr{
												pos: position{line: 2055, col: 14, offset: 70588},
												expr: &ruleRefExpr{
													pos:  position{line: 2055, col: 15, offset: 70589},
													name: "indexExpressionIndexTerminator",
												},
											},
											&anyMatcher{
												line: 2055, col: 46, offset: 70620,
											},
											&zeroOrMoreExpr{
												pos: position{line: 2055, col: 48, offset: 70622},
												expr: &seqExpr{
													pos: position{line: 2055, col: 49, offset: 70623},
													exprs: []interface{}{
														&notExpr{
															pos: position{line: 2055, col: 49, offset: 70623},
															expr: &ruleRefExpr{
																pos:  position{line: 2055, col: 50, offset: 70624},
																name: "indexExpressionIndexTerminator",
															},
														},
														&charClassMatcher{
															pos:        position{line: 2055, col: 81, offset: 70655},
															val:        "[^'\"`?([{]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineIndexExpression",
			pos:  position{line: 2062, col: 1, offset: 70820},
			expr: &actionExpr{
				pos: position{line: 2062, col: 30, offset: 70849},
				run: (*parser).callonSingleLineIndexExpression1,
				expr: &seqExpr{
					pos: position{line: 2062, col: 30, offset: 70849},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 2062, col: 30, offset: 70849},
							name: "L_BRACKET",
						},
						&zeroOrMoreExpr{
							pos: position{line: 2062, col: 40, offset: 70859},
							expr: &ruleRefExpr{
								pos:  position{line: 2062, col: 40, offset: 70859},
								name: "WS",
							},
						},
						&labeledExpr{
							pos:   position{line: 2062, col: 44, offset: 70863},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 2062, col: 50, offset: 70869},
								name: "singleLineIndexExpressionIndex",
							},
						},
						&labeledExpr{
							pos:   position{line: 2062, col: 81, offset: 70900},
							label: "checkIndexI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2062, col: 93, offset: 70912},
								expr: &litMatcher{
									pos:        position{line: 2062, col: 93, offset: 70912},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2062, col: 98, offset: 70917},
							expr: &seqExpr{
								pos: position{line: 2062, col: 99, offset: 70918},
								exprs: []interface{}{
									&litMatcher{
										pos:        position{line: 2062, col: 99, offset: 70918},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2062, col: 103, offset: 70922},
										expr: &litMatcher{
											pos:        position{line: 2062, col: 103, offset: 70922},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2062, col: 110, offset: 70929},
							expr: &litMatcher{
								pos:        position{line: 2062, col: 110, offset: 70929},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2062, col: 115, offset: 70934},
							label: "rBracePosI",
							expr: &ruleRefExpr{
								pos:  position{line: 2062, col: 126, offset: 70945},
								name: "R_BRACKET",
							},
						},
						&labeledExpr{
							pos:   position{line: 2062, col: 136, offset: 70955},
							label: "checkValueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2062, col: 148, offset: 70967},
								expr: &litMatcher{
									pos:        position{line: 2062, col: 148, offset: 70967},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineIndexExpressionIndex",
			pos:  position{line: 2072, col: 1, offset: 71215},
			expr: &actionExpr{
				pos: position{line: 2072, col: 35, offset: 71249},
				run: (*parser).callonsingleLineIndexExpressionIndex1,
				expr: &labeledExpr{
					pos:   position{line: 2072, col: 35, offset: 71249},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 2072, col: 42, offset: 71256},
						expr: &choiceExpr{
							pos: position{line: 2073, col: 5, offset: 71262},
							alternatives: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 2073, col: 5, offset: 71262},
									name: "singleLineGoParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 2073, col: 29, offset: 71286},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 2073, col: 48, offset: 71305},
									name: "SingleLineTernaryExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 2073, col: 78, offset: 71335},
									name: "goRuneExpr",
								},
								&actionExpr{
									pos: position{line: 2074, col: 5, offset: 71352},
									run: (*parser).callonsingleLineIndexExpressionIndex9,
									expr: &seqExpr{
										pos: position{line: 2074, col: 5, offset: 71352},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 2074, col: 5, offset: 71352},
												label: "posI",
												expr: &ruleRefExpr{
													pos:  position{line: 2074, col: 10, offset: 71357},
													name: "POS",
												},
											},
											&notExpr{
												pos: position{line: 2074, col: 14, offset: 71361},
												expr: &ruleRefExpr{
													pos:  position{line: 2074, col: 15, offset: 71362},
													name: "indexExpressionIndexTerminator",
												},
											},
											&ruleRefExpr{
												pos:  position{line: 2074, col: 46, offset: 71393},
												name: "NOT_EOL",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2074, col: 54, offset: 71401},
												expr: &seqExpr{
													pos: position{line: 2074, col: 55, offset: 71402},
													exprs: []interface{}{
														&notExpr{
															pos: position{line: 2074, col: 55, offset: 71402},
															expr: &ruleRefExpr{
																pos:  position{line: 2074, col: 56, offset: 71403},
																name: "indexExpressionIndexTerminator",
															},
														},
														&notExpr{
															pos: position{line: 2074, col: 87, offset: 71434},
															expr: &ruleRefExpr{
																pos:  position{line: 2074, col: 88, offset: 71435},
																name: "EOL",
															},
														},
														&charClassMatcher{
															pos:        position{line: 2074, col: 92, offset: 71439},
															val:        "[^'\"`?([{]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DotIdentExpression",
			pos:  position{line: 2081, col: 1, offset: 71604},
			expr: &actionExpr{
				pos: position{line: 2081, col: 23, offset: 71626},
				run: (*parser).callonDotIdentExpression1,
				expr: &seqExpr{
					pos: position{line: 2081, col: 23, offset: 71626},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2081, col: 23, offset: 71626},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 2081, col: 27, offset: 71630},
							expr: &ruleRefExpr{
								pos:  position{line: 2081, col: 27, offset: 71630},
								name: "WS",
							},
						},
						&labeledExpr{
							pos:   position{line: 2081, col: 31, offset: 71634},
							label: "identI",
							expr: &ruleRefExpr{
								pos:  position{line: 2081, col: 38, offset: 71641},
								name: "GoIdent",
							},
						},
						&labeledExpr{
							pos:   position{line: 2081, col: 46, offset: 71649},
							label: "checkI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2081, col: 53, offset: 71656},
								expr: &litMatcher{
									pos:        position{line: 2081, col: 53, offset: 71656},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineDotIdentExpression",
			pos:  position{line: 2089, col: 1, offset: 71807},
			expr: &actionExpr{
				pos: position{line: 2089, col: 33, offset: 71839},
				run: (*parser).callonSingleLineDotIdentExpression1,
				expr: &seqExpr{
					pos: position{line: 2089, col: 33, offset: 71839},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2089, col: 33, offset: 71839},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 2089, col: 37, offset: 71843},
							expr: &litMatcher{
								pos:        position{line: 2089, col: 37, offset: 71843},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2089, col: 42, offset: 71848},
							label: "identI",
							expr: &ruleRefExpr{
								pos:  position{line: 2089, col: 49, offset: 71855},
								name: "GoIdent",
							},
						},
						&labeledExpr{
							pos:   position{line: 2089, col: 57, offset: 71863},
							label: "checkI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2089, col: 64, offset: 71870},
								expr: &litMatcher{
									pos:        position{line: 2089, col: 64, offset: 71870},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ParenExpression",
			pos:  position{line: 2097, col: 1, offset: 72021},
			expr: &actionExpr{
				pos: position{line: 2097, col: 20, offset: 72040},
				run: (*parser).callonParenExpression1,
				expr: &seqExpr{
					pos: position{line: 2097, col: 20, offset: 72040},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 2097, col: 20, offset: 72040},
							name: "L_PAREN",
						},
						&zeroOrMoreExpr{
							pos: position{line: 2097, col: 28, offset: 72048},
							expr: &litMatcher{
								pos:        position{line: 2097, col: 28, offset: 72048},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2097, col: 33, offset: 72053},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2097, col: 39, offset: 72059},
								expr: &ruleRefExpr{
									pos:  position{line: 2097, col: 39, offset: 72059},
									name: "parenExpressionArgs",
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2097, col: 60, offset: 72080},
							expr: &litMatcher{
								pos:        position{line: 2097, col: 60, offset: 72080},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2097, col: 65, offset: 72085},
							expr: &seqExpr{
								pos: position{line: 2097, col: 66, offset: 72086},
								exprs: []interface{}{
									&litMatcher{
										pos:        position{line: 2097, col: 66, offset: 72086},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2097, col: 70, offset: 72090},
										expr: &ruleRefExpr{
											pos:  position{line: 2097, col: 70, offset: 72090},
											name: "WS",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2097, col: 76, offset: 72096},
							label: "rParenPosI",
							expr: &ruleRefExpr{
								pos:  position{line: 2097, col: 87, offset: 72107},
								name: "R_PAREN",
							},
						},
						&labeledExpr{
							pos:   position{line: 2097, col: 95, offset: 72115},
							label: "checkI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2097, col: 102, offset: 72122},
								expr: &litMatcher{
									pos:        position{line: 2097, col: 102, offset: 72122},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "parenExpressionArgs",
			pos:  position{line: 2105, col: 1, offset: 72313},
			expr: &actionExpr{
				pos: position{line: 2105, col: 24, offset: 72336},
				run: (*parser).callonparenExpressionArgs1,
				expr: &seqExpr{
					pos: position{line: 2105, col: 24, offset: 72336},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 2105, col: 24, offset: 72336},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 2105, col: 31, offset: 72343},
								name: "GoExpression",
							},
						},
						&labeledExpr{
							pos:   position{line: 2105, col: 44, offset: 72356},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2105, col: 50, offset: 72362},
								expr: &seqExpr{
									pos: position{line: 2105, col: 51, offset: 72363},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 2105, col: 51, offset: 72363},
											expr: &litMatcher{
												pos:        position{line: 2105, col: 51, offset: 72363},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 2105, col: 56, offset: 72368},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2105, col: 60, offset: 72372},
											expr: &ruleRefExpr{
												pos:  position{line: 2105, col: 60, offset: 72372},
												name: "WS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2105, col: 64, offset: 72376},
											name: "GoExpression",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineParenExpression",
			pos:  position{line: 2117, col: 1, offset: 72643},
			expr: &actionExpr{
				pos: position{line: 2117, col: 30, offset: 72672},
				run: (*parser).callonSingleLineParenExpression1,
				expr: &seqExpr{
					pos: position{line: 2117, col: 30, offset: 72672},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 2117, col: 30, offset: 72672},
							name: "L_PAREN",
						},
						&zeroOrMoreExpr{
							pos: position{line: 2117, col: 38, offset: 72680},
							expr: &litMatcher{
								pos:        position{line: 2117, col: 38, offset: 72680},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2117, col: 43, offset: 72685},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2117, col: 49, offset: 72691},
								expr: &ruleRefExpr{
									pos:  position{line: 2117, col: 49, offset: 72691},
									name: "singleLinearenExpressionArgs",
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2117, col: 79, offset: 72721},
							expr: &litMatcher{
								pos:        position{line: 2117, col: 79, offset: 72721},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2117, col: 84, offset: 72726},
							expr: &seqExpr{
								pos: position{line: 2117, col: 85, offset: 72727},
								exprs: []interface{}{
									&litMatcher{
										pos:        position{line: 2117, col: 85, offset: 72727},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2117, col: 89, offset: 72731},
										expr: &litMatcher{
											pos:        position{line: 2117, col: 89, offset: 72731},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2117, col: 96, offset: 72738},
							label: "rParenPosI",
							expr: &ruleRefExpr{
								pos:  position{line: 2117, col: 107, offset: 72749},
								name: "R_PAREN",
							},
						},
						&labeledExpr{
							pos:   position{line: 2117, col: 115, offset: 72757},
							label: "checkI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2117, col: 122, offset: 72764},
								expr: &litMatcher{
									pos:        position{line: 2117, col: 122, offset: 72764},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLinearenExpressionArgs",
			pos:  position{line: 2125, col: 1, offset: 72955},
			expr: &actionExpr{
				pos: position{line: 2125, col: 33, offset: 72987},
				run: (*parser).callonsingleLinearenExpressionArgs1,
				expr: &seqExpr{
					pos: position{line: 2125, col: 33, offset: 72987},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 2125, col: 33, offset: 72987},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 2125, col: 40, offset: 72994},
								name: "SingleLineGoExpression",
							},
						},
						&labeledExpr{
							pos:   position{line: 2125, col: 63, offset: 73017},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2125, col: 69, offset: 73023},
								expr: &seqExpr{
									pos: position{line: 2125, col: 70, offset: 73024},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 2125, col: 70, offset: 73024},
											expr: &litMatcher{
												pos:        position{line: 2125, col: 70, offset: 73024},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 2125, col: 75, offset: 73029},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2125, col: 79, offset: 73033},
											expr: &litMatcher{
												pos:        position{line: 2125, col: 79, offset: 73033},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2125, col: 84, offset: 73038},
											name: "SingleLineGoExpression",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TypeAssertionExpression",
			pos:  position{line: 2137, col: 1, offset: 73315},
			expr: &actionExpr{
				pos: position{line: 2137, col: 28, offset: 73342},
				run: (*parser).callonTypeAssertionExpression1,
				expr: &seqExpr{
					pos: position{line: 2137, col: 28, offset: 73342},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2137, col: 28, offset: 73342},
							val:        ".(",
							ignoreCase: false,
							want:       "\".(\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 2137, col: 33, offset: 73347},
							expr: &litMatcher{
								pos:        position{line: 2137, col: 33, offset: 73347},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2137, col: 38, offset: 73352},
							label: "ptrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2137, col: 44, offset: 73358},
								expr: &litMatcher{
									pos:        position{line: 2137, col: 44, offset: 73358},
									val:        "*",
									ignoreCase: false,
									want:       "\"*\"",
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2137, col: 49, offset: 73363},
							expr: &litMatcher{
								pos:        position{line: 2137, col: 49, offset: 73363},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2137, col: 54, offset: 73368},
							label: "packageI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2137, col: 63, offset: 73377},
								expr: &seqExpr{
									pos: position{line: 2137, col: 64, offset: 73378},
									exprs: []interface{}{
										&ruleRefExpr{
											pos:  position{line: 2137, col: 64, offset: 73378},
											name: "GoIdent",
										},
										&litMatcher{
											pos:        position{line: 2137, col: 72, offset: 73386},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2137, col: 76, offset: 73390},
											expr: &litMatcher{
												pos:        position{line: 2137, col: 76, offset: 73390},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2137, col: 83, offset: 73397},
							label: "typeI",
							expr: &ruleRefExpr{
								pos:  position{line: 2137, col: 89, offset: 73403},
								name: "GoIdent",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2137, col: 97, offset: 73411},
							expr: &litMatcher{
								pos:        position{line: 2137, col: 97, offset: 73411},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2137, col: 102, offset: 73416},
							label: "rParenPosI",
							expr: &ruleRefExpr{
								pos:  position{line: 2137, col: 113, offset: 73427},
								name: "R_PAREN",
							},
						},
						&labeledExpr{
							pos:   position{line: 2137, col: 121, offset: 73435},
							label: "checkI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2137, col: 128, offset: 73442},
								expr: &litMatcher{
									pos:        position{line: 2137, col: 128, offset: 73442},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineTypeAssertionExpression",
			pos:  position{line: 2153, col: 1, offset: 73860},
			expr: &ruleRefExpr{
				pos:  position{line: 2153, col: 38, offset: 73897},
				name: "TypeAssertionExpression",
			},
		},
		{
			name: "Filter",
			pos:  position{line: 2155, col: 1, offset: 73922},
			expr: &choiceExpr{
				pos: position{line: 2155, col: 11, offset: 73932},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2155, col: 11, offset: 73932},
						name: "RawFilter",
					},
					&ruleRefExpr{
						pos:  position{line: 2155, col: 23, offset: 73944},
						name: "CommandFilter",
					},
					&ruleRefExpr{
						pos:  position{line: 2155, col: 39, offset: 73960},
						name: "BadFilter",
					},
				},
			},
		},
		{
			name: "RawFilter",
			pos:  position{line: 2161, col: 1, offset: 74156},
			expr: &actionExpr{
				pos: position{line: 2161, col: 14, offset: 74169},
				run: (*parser).callonRawFilter1,
				expr: &seqExpr{
					pos: position{line: 2161, col: 14, offset: 74169},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2161, col: 14, offset: 74169},
							val:        ":raw",
							ignoreCase: false,
							want:       "\":raw\"",
						},
						&ruleRefExpr{
							pos:  position{line: 2161, col: 21, offset: 74176},
							name: "EOL",
						},
						&labeledExpr{
							pos:   position{line: 2161, col: 25, offset: 74180},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2161, col: 31, offset: 74186},
								expr: &ruleRefExpr{
									pos:  position{line: 2161, col: 31, offset: 74186},
									name: "filterBody",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "CommandFilter",
			pos:  position{line: 2172, col: 1, offset: 74510},
			expr: &actionExpr{
				pos: position{line: 2172, col: 18, offset: 74527},
				run: (*parser).callonCommandFilter1,
				expr: &seqExpr{
					pos: position{line: 2172, col: 18, offset: 74527},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2172, col: 18, offset: 74527},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&labeledExpr{
							pos:   position{line: 2172, col: 22, offset: 74531},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2172, col: 28, offset: 74537},
								expr: &charClassMatcher{
									pos:        position{line: 2172, col: 28, offset: 74537},
									val:        "[^ \\t\\r\\n]",
									chars:      []rune{' ', '\t', '\r', '\n'},
									ignoreCase: false,
									inverted:   true,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2172, col: 40, offset: 74549},
							label: "argsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2172, col: 46, offset: 74555},
								expr: &seqExpr{
									pos: position{line: 2172, col: 47, offset: 74556},
									exprs: []interface{}{
										&oneOrMoreExpr{
											pos: position{line: 2172, col: 47, offset: 74556},
											expr: &litMatcher{
												pos:        position{line: 2172, col: 47, offset: 74556},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2172, col: 52, offset: 74561},
											name: "commandFilterArg",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 2172, col: 71, offset: 74580},
							name: "EOL",
						},
						&labeledExpr{
							pos:   position{line: 2172, col: 75, offset: 74584},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2172, col: 81, offset: 74590},
								expr: &ruleRefExpr{
									pos:  position{line: 2172, col: 81, offset: 74590},
									name: "filterBody",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "commandFilterArg",
			pos:  position{line: 2181, col: 1, offset: 74828},
			expr: &choiceExpr{
				pos: position{line: 2181, col: 21, offset: 74848},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2181, col: 21, offset: 74848},
						name: "stringCommandFilterArg",
					},
					&ruleRefExpr{
						pos:  position{line: 2181, col: 46, offset: 74873},
						name: "rawCommand",
					},
				},
			},
		},
		{
			name: "stringCommandFilterArg",
			pos:  position{line: 2183, col: 1, offset: 74885},
			expr: &actionExpr{
				pos: position{line: 2183, col: 27, offset: 74911},
				run: (*parser).callonstringCommandFilterArg1,
				expr: &labeledExpr{
					pos:   position{line: 2183, col: 27, offset: 74911},
					label: "stringI",
					expr: &ruleRefExpr{
						pos:  position{line: 2183, col: 35, offset: 74919},
						name: "String",
					},
				},
			},
		},
		{
			name: "rawCommand",
			pos:  position{line: 2187, col: 1, offset: 74998},
			expr: &actionExpr{
				pos: position{line: 2187, col: 15, offset: 75012},
				run: (*parser).callonrawCommand1,
				expr: &labeledExpr{
					pos:   position{line: 2187, col: 15, offset: 75012},
					label: "argI",
					expr: &oneOrMoreExpr{
						pos: position{line: 2187, col: 20, offset: 75017},
						expr: &charClassMatcher{
							pos:        position{line: 2187, col: 20, offset: 75017},
							val:        "[^ \\t\\r\\n]",
							chars:      []rune{' ', '\t', '\r', '\n'},
							ignoreCase: false,
							inverted:   true,
						},
					},
				},
			},
		},
		{
			name: "BadFilter",
			pos:  position{line: 2195, col: 1, offset: 75299},
			expr: &actionExpr{
				pos: position{line: 2195, col: 14, offset: 75312},
				run: (*parser).callonBadFilter1,
				expr: &seqExpr{
					pos: position{line: 2195, col: 14, offset: 75312},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2195, col: 14, offset: 75312},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&ruleRefExpr{
							pos:  position{line: 2195, col: 18, offset: 75316},
							name: "EOL",
						},
						&labeledExpr{
							pos:   position{line: 2195, col: 22, offset: 75320},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2195, col: 28, offset: 75326},
								expr: &ruleRefExpr{
									pos:  position{line: 2195, col: 28, offset: 75326},
									name: "filterBody",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "filterBody",
			pos:  position{line: 2213, col: 1, offset: 75867},
			expr: &actionExpr{
				pos: position{line: 2213, col: 15, offset: 75881},
				run: (*parser).callonfilterBody1,
				expr: &seqExpr{
					pos: position{line: 2213, col: 15, offset: 75881},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 2213, col: 15, offset: 75881},
							name: "INDENT",
						},
						&labeledExpr{
							pos:   position{line: 2213, col: 22, offset: 75888},
							label: "linesI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2213, col: 29, offset: 75895},
								expr: &seqExpr{
									pos: position{line: 2213, col: 30, offset: 75896},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 2213, col: 30, offset: 75896},
											expr: &ruleRefExpr{
												pos:  position{line: 2213, col: 30, offset: 75896},
												name: "NEW_LNS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2213, col: 39, offset: 75905},
											name: "filterLine",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 2213, col: 52, offset: 75918},
							name: "DEDENT",
						},
					},
				},
			},
		},
		{
			name: "filterLine",
			pos:  position{line: 2217, col: 1, offset: 75996},
			expr: &actionExpr{
				pos: position{line: 2217, col: 15, offset: 76010},
				run: (*parser).callonfilterLine1,
				expr: &seqExpr{
					pos: position{line: 2217, col: 15, offset: 76010},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 2217, col: 15, offset: 76010},
							name: "INDENTATION",
						},
						&labeledExpr{
							pos:   position{line: 2217, col: 27, offset: 76022},
							label: "posI",
							expr: &ruleRefExpr{
								pos:  position{line: 2217, col: 32, offset: 76027},
								name: "POS",
							},
						},
						&labeledExpr{
							pos:   position{line: 2217, col: 36, offset: 76031},
							label: "lineI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2217, col: 42, offset: 76037},
								expr: &ruleRefExpr{
									pos:  position{line: 2217, col: 42, offset: 76037},
									name: "NOT_EOL",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 2217, col: 51, offset: 76046},
							name: "EOL",
						},
					},
				},
			},
		},
		{
			name: "GoIdent",
			pos:  position{line: 2228, col: 1, offset: 76331},
			expr: &actionExpr{
				pos: position{line: 2228, col: 12, offset: 76342},
				run: (*parser).callonGoIdent1,
				expr: &labeledExpr{
					pos:   position{line: 2228, col: 12, offset: 76342},
					label: "ident",
					expr: &ruleRefExpr{
						pos:  position{line: 2228, col: 18, offset: 76348},
						name: "goIdentifier",
					},
				},
			},
		},
		{
			name: "GoType",
			pos:  position{line: 2236, col: 1, offset: 76616},
			expr: &actionExpr{
				pos: position{line: 2236, col: 11, offset: 76626},
				run: (*parser).callonGoType1,
				expr: &labeledExpr{
					pos:   position{line: 2236, col: 11, offset: 76626},
					label: "goTypeI",
					expr: &ruleRefExpr{
						pos:  position{line: 2236, col: 19, offset: 76634},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goNewline",
			pos:  position{line: 2248, col: 1, offset: 76955},
			expr: &litMatcher{
				pos:        position{line: 2248, col: 20, offset: 76974},
				val:        "\n",
				ignoreCase: false,
				want:       "\"\\n\"",
			},
		},
		{
			name: "goUnicodeChar",
			pos:  position{line: 2249, col: 1, offset: 76979},
			expr: &charClassMatcher{
				pos:        position{line: 2249, col: 20, offset: 76998},
				val:        "[^\\n]",
				chars:      []rune{'\n'},
				ignoreCase: false,
				inverted:   true,
			},
		},
		{
			name: "goUnicodeLetter",
			pos:  position{line: 2250, col: 1, offset: 77004},
			expr: &charClassMatcher{
				pos:        position{line: 2250, col: 20, offset: 77023},
				val:        "[\\pL]",
				classes:    []*unicode.RangeTable{rangeTable("L")},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "goUnicodeDigit",
			pos:  position{line: 2251, col: 1, offset: 77029},
			expr: &charClassMatcher{
				pos:        position{line: 2251, col: 20, offset: 77048},
				val:        "[\\p{Nd}]",
				classes:    []*unicode.RangeTable{rangeTable("Nd")},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "goLetter",
			pos:  position{line: 2257, col: 1, offset: 77087},
			expr: &choiceExpr{
				pos: position{line: 2257, col: 19, offset: 77105},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2257, col: 19, offset: 77105},
						name: "goUnicodeLetter",
					},
					&litMatcher{
						pos:        position{line: 2257, col: 37, offset: 77123},
						val:        "_",
						ignoreCase: false,
						want:       "\"_\"",
					},
				},
			},
		},
		{
			name: "goDecimalDigit",
			pos:  position{line: 2258, col: 1, offset: 77127},
			expr: &charClassMatcher{
				pos:        position{line: 2258, col: 19, offset: 77145},
				val:        "[0-9]",
				ranges:     []rune{'0', '9'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "goBinaryDigit",
			pos:  position{line: 2259, col: 1, offset: 77151},
			expr: &charClassMatcher{
				pos:        position{line: 2259, col: 19, offset: 77169},
				val:        "[0-1]",
				ranges:     []rune{'0', '1'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "goOctalDigit",
			pos:  position{line: 2260, col: 1, offset: 77175},
			expr: &charClassMatcher{
				pos:        position{line: 2260, col: 19, offset: 77193},
				val:        "[0-7]",
				ranges:     []rune{'0', '7'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "goHexDigit",
			pos:  position{line: 2261, col: 1, offset: 77199},
			expr: &charClassMatcher{
				pos:        position{line: 2261, col: 19, offset: 77217},
				val:        "[0-9A-Fa-f]",
				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "goIdentifier",
			pos:  position{line: 2267, col: 1, offset: 77252},
			expr: &seqExpr{
				pos: position{line: 2267, col: 17, offset: 77268},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2267, col: 17, offset: 77268},
						name: "goLetter",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2267, col: 26, offset: 77277},
						expr: &choiceExpr{
							pos: position{line: 2267, col: 27, offset: 77278},
							alternatives: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 2267, col: 27, offset: 77278},
									name: "goLetter",
								},
								&ruleRefExpr{
									pos:  position{line: 2267, col: 38, offset: 77289},
									name: "goUnicodeDigit",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goIntLit",
			pos:  position{line: 2273, col: 1, offset: 77334},
			expr: &choiceExpr{
				pos: position{line: 2273, col: 17, offset: 77350},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2273, col: 17, offset: 77350},
						name: "goDecimalLit",
					},
					&ruleRefExpr{
						pos:  position{line: 2273, col: 32, offset: 77365},
						name: "goBinaryLit",
					},
					&ruleRefExpr{
						pos:  position{line: 2273, col: 46, offset: 77379},
						name: "goOctalLit",
					},
					&ruleRefExpr{
						pos:  position{line: 2273, col: 59, offset: 77392},
						name: "goHexLit",
					},
				},
			},
		},
		{
			name: "goDecimalLit",
			pos:  position{line: 2274, col: 1, offset: 77401},
			expr: &choiceExpr{
				pos: position{line: 2274, col: 17, offset: 77417},
				alternatives: []interface{}{
					&litMatcher{
						pos:        position{line: 2274, col: 17, offset: 77417},
						val:        "0",
						ignoreCase: false,
						want:       "\"0\"",
					},
					&seqExpr{
						pos: position{line: 2274, col: 23, offset: 77423},
						exprs: []interface{}{
							&charClassMatcher{
								pos:        position{line: 2274, col: 23, offset: 77423},
								val:        "[0-9]",
								ranges:     []rune{'0', '9'},
								ignoreCase: false,
								inverted:   false,
							},
							&zeroOrOneExpr{
								pos: position{line: 2274, col: 29, offset: 77429},
								expr: &seqExpr{
									pos: position{line: 2274, col: 30, offset: 77430},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 2274, col: 30, offset: 77430},
											expr: &litMatcher{
												pos:        position{line: 2274, col: 30, offset: 77430},
												val:        "_",
												ignoreCase: false,
												want:       "\"_\"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2274, col: 35, offset: 77435},
											name: "goDecimalDigits",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goBinaryLit",
			pos:  position{line: 2275, col: 1, offset: 77453},
			expr: &seqExpr{
				pos: position{line: 2275, col: 17, offset: 77469},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2275, col: 17, offset: 77469},
						val:        "0",
						ignoreCase: false,
						want:       "\"0\"",
					},
					&charClassMatcher{
						pos:        position{line: 2275, col: 21, offset: 77473},
						val:        "[bB]",
						chars:      []rune{'b', 'B'},
						ignoreCase: false,
						inverted:   false,
					},
					&zeroOrOneExpr{
						pos: position{line: 2275, col: 26, offset: 77478},
						expr: &litMatcher{
							pos:        position{line: 2275, col: 26, offset: 77478},
							val:        "_",
							ignoreCase: false,
							want:       "\"_\"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2275, col: 31, offset: 77483},
						name: "goBinaryDigits",
					},
				},
			},
		},
		{
			name: "goOctalLit",
			pos:  position{line: 2276, col: 1, offset: 77498},
			expr: &seqExpr{
				pos: position{line: 2276, col: 17, offset: 77514},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2276, col: 17, offset: 77514},
						val:        "0",
						ignoreCase: false,
						want:       "\"0\"",
					},
					&charClassMatcher{
						pos:        position{line: 2276, col: 21, offset: 77518},
						val:        "[oO]",
						chars:      []rune{'o', 'O'},
						ignoreCase: false,
						inverted:   false,
					},
					&zeroOrOneExpr{
						pos: position{line: 2276, col: 26, offset: 77523},
						expr: &litMatcher{
							pos:        position{line: 2276, col: 26, offset: 77523},
							val:        "_",
							ignoreCase: false,
							want:       "\"_\"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2276, col: 31, offset: 77528},
						name: "goOctalDigits",
					},
				},
			},
		},
		{
			name: "goHexLit",
			pos:  position{line: 2277, col: 1, offset: 77542},
			expr: &seqExpr{
				pos: position{line: 2277, col: 17, offset: 77558},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2277, col: 17, offset: 77558},
						val:        "0",
						ignoreCase: false,
						want:       "\"0\"",
					},
					&charClassMatcher{
						pos:        position{line: 2277, col: 21, offset: 77562},
						val:        "[xX]",
						chars:      []rune{'x', 'X'},
						ignoreCase: false,
						inverted:   false,
					},
					&zeroOrOneExpr{
						pos: position{line: 2277, col: 26, offset: 77567},
						expr: &litMatcher{
							pos:        position{line: 2277, col: 26, offset: 77567},
							val:        "_",
							ignoreCase: false,
							want:       "\"_\"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2277, col: 31, offset: 77572},
						name: "goHexDigits",
					},
				},
			},
		},
		{
			name: "goDecimalDigits",
			pos:  position{line: 2279, col: 1, offset: 77585},
			expr: &seqExpr{
				pos: position{line: 2279, col: 20, offset: 77604},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2279, col: 20, offset: 77604},
						name: "goDecimalDigit",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2279, col: 35, offset: 77619},
						expr: &seqExpr{
							pos: position{line: 2279, col: 36, offset: 77620},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 2279, col: 36, offset: 77620},
									expr: &litMatcher{
										pos:        position{line: 2279, col: 36, offset: 77620},
										val:        "_",
										ignoreCase: false,
										want:       "\"_\"",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2279, col: 41, offset: 77625},
									name: "goDecimalDigit",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goBinaryDigits",
			pos:  position{line: 2280, col: 1, offset: 77642},
			expr: &seqExpr{
				pos: position{line: 2280, col: 20, offset: 77661},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2280, col: 20, offset: 77661},
						name: "goBinaryDigit",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2280, col: 34, offset: 77675},
						expr: &seqExpr{
							pos: position{line: 2280, col: 35, offset: 77676},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 2280, col: 35, offset: 77676},
									expr: &litMatcher{
										pos:        position{line: 2280, col: 35, offset: 77676},
										val:        "_",
										ignoreCase: false,
										want:       "\"_\"",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2280, col: 40, offset: 77681},
									name: "goBinaryDigit",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goOctalDigits",
			pos:  position{line: 2281, col: 1, offset: 77697},
			expr: &seqExpr{
				pos: position{line: 2281, col: 20, offset: 77716},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2281, col: 20, offset: 77716},
						name: "goOctalDigit",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2281, col: 33, offset: 77729},
						expr: &seqExpr{
							pos: position{line: 2281, col: 34, offset: 77730},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 2281, col: 34, offset: 77730},
									expr: &litMatcher{
										pos:        position{line: 2281, col: 34, offset: 77730},
										val:        "_",
										ignoreCase: false,
										want:       "\"_\"",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2281, col: 39, offset: 77735},
									name: "goOctalDigit",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goHexDigits",
			pos:  position{line: 2282, col: 1, offset: 77750},
			expr: &seqExpr{
				pos: position{line: 2282, col: 20, offset: 77769},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2282, col: 20, offset: 77769},
						name: "goHexDigit",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2282, col: 31, offset: 77780},
						expr: &seqExpr{
							pos: position{line: 2282, col: 32, offset: 77781},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 2282, col: 32, offset: 77781},
									expr: &litMatcher{
										pos:        position{line: 2282, col: 32, offset: 77781},
										val:        "_",
										ignoreCase: false,
										want:       "\"_\"",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2282, col: 37, offset: 77786},
									name: "goHexDigit",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goQualifiedIdent",
			pos:  position{line: 2284, col: 1, offset: 77800},
			expr: &seqExpr{
				pos: position{line: 2284, col: 21, offset: 77820},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2284, col: 21, offset: 77820},
						name: "goPackageName",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2284, col: 35, offset: 77834},
						expr: &litMatcher{
							pos:        position{line: 2284, col: 35, offset: 77834},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2284, col: 40, offset: 77839},
						val:        ".",
						ignoreCase: false,
						want:       "\".\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2284, col: 44, offset: 77843},
						expr: &litMatcher{
							pos:        position{line: 2284, col: 44, offset: 77843},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2284, col: 49, offset: 77848},
						name: "goIdentifier",
					},
				},
			},
		},
		{
			name: "goPackageName",
			pos:  position{line: 2285, col: 1, offset: 77861},
			expr: &ruleRefExpr{
				pos:  position{line: 2285, col: 21, offset: 77881},
				name: "goIdentifier",
			},
		},
		{
			name: "goFloatLit",
			pos:  position{line: 2291, col: 1, offset: 77929},
			expr: &choiceExpr{
				pos: position{line: 2291, col: 15, offset: 77943},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2291, col: 15, offset: 77943},
						name: "goDecimalFloatLit",
					},
					&ruleRefExpr{
						pos:  position{line: 2291, col: 35, offset: 77963},
						name: "goHexFloatLit",
					},
				},
			},
		},
		{
			name: "goDecimalFloatLit",
			pos:  position{line: 2293, col: 1, offset: 77978},
			expr: &choiceExpr{
				pos: position{line: 2293, col: 22, offset: 77999},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2293, col: 22, offset: 77999},
						exprs: []interface{}{
							&ruleRefExpr{
								pos:  position{line: 2293, col: 22, offset: 77999},
								name: "goDecimalDigits",
							},
							&litMatcher{
								pos:        position{line: 2293, col: 38, offset: 78015},
								val:        ".",
								ignoreCase: false,
								want:       "\".\"",
							},
							&zeroOrOneExpr{
								pos: position{line: 2293, col: 42, offset: 78019},
								expr: &ruleRefExpr{
									pos:  position{line: 2293, col: 42, offset: 78019},
									name: "goDecimalDigits",
								},
							},
							&zeroOrOneExpr{
								pos: position{line: 2293, col: 59, offset: 78036},
								expr: &ruleRefExpr{
									pos:  position{line: 2293, col: 59, offset: 78036},
									name: "goDecimalExponent",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 2294, col: 22, offset: 78078},
						exprs: []interface{}{
							&ruleRefExpr{
								pos:  position{line: 2294, col: 22, offset: 78078},
								name: "goDecimalDigits",
							},
							&ruleRefExpr{
								pos:  position{line: 2294, col: 38, offset: 78094},
								name: "goDecimalExponent",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2295, col: 22, offset: 78135},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2295, col: 22, offset: 78135},
								val:        ".",
								ignoreCase: false,
								want:       "\".\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2295, col: 26, offset: 78139},
								name: "goDecimalDigits",
							},
							&zeroOrOneExpr{
								pos: position{line: 2295, col: 42, offset: 78155},
								expr: &ruleRefExpr{
									pos:  position{line: 2295, col: 42, offset: 78155},
									name: "goDecimalExponent",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goDecimalExponent",
			pos:  position{line: 2296, col: 1, offset: 78174},
			expr: &seqExpr{
				pos: position{line: 2296, col: 22, offset: 78195},
				exprs: []interface{}{
					&charClassMatcher{
						pos:        position{line: 2296, col: 22, offset: 78195},
						val:        "[eE]",
						chars:      []rune{'e', 'E'},
						ignoreCase: false,
						inverted:   false,
					},
					&zeroOrOneExpr{
						pos: position{line: 2296, col: 27, offset: 78200},
						expr: &charClassMatcher{
							pos:        position{line: 2296, col: 27, offset: 78200},
							val:        "[+-]",
							chars:      []rune{'+', '-'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2296, col: 33, offset: 78206},
						name: "goDecimalDigits",
					},
				},
			},
		},
		{
			name: "goHexFloatLit",
			pos:  position{line: 2298, col: 1, offset: 78223},
			expr: &seqExpr{
				pos: position{line: 2298, col: 22, offset: 78244},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2298, col: 22, offset: 78244},
						val:        "0",
						ignoreCase: false,
						want:       "\"0\"",
					},
					&charClassMatcher{
						pos:        position{line: 2298, col: 26, offset: 78248},
						val:        "[xX]",
						chars:      []rune{'x', 'X'},
						ignoreCase: false,
						inverted:   false,
					},
					&ruleRefExpr{
						pos:  position{line: 2298, col: 31, offset: 78253},
						name: "goHexMantissa",
					},
					&ruleRefExpr{
						pos:  position{line: 2298, col: 45, offset: 78267},
						name: "goHexExponent",
					},
				},
			},
		},
		{
			name: "goHexMantissa",
			pos:  position{line: 2299, col: 1, offset: 78281},
			expr: &choiceExpr{
				pos: position{line: 2299, col: 22, offset: 78302},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2299, col: 22, offset: 78302},
						exprs: []interface{}{
							&zeroOrOneExpr{
								pos: position{line: 2299, col: 22, offset: 78302},
								expr: &litMatcher{
									pos:        position{line: 2299, col: 22, offset: 78302},
									val:        "_",
									ignoreCase: false,
									want:       "\"_\"",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 2299, col: 27, offset: 78307},
								name: "goHexDigits",
							},
							&litMatcher{
								pos:        position{line: 2299, col: 39, offset: 78319},
								val:        ".",
								ignoreCase: false,
								want:       "\".\"",
							},
							&zeroOrOneExpr{
								pos: position{line: 2299, col: 43, offset: 78323},
								expr: &ruleRefExpr{
									pos:  position{line: 2299, col: 43, offset: 78323},
									name: "goHexDigits",
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 2300, col: 22, offset: 78359},
						exprs: []interface{}{
							&zeroOrOneExpr{
								pos: position{line: 2300, col: 22, offset: 78359},
								expr: &litMatcher{
									pos:        position{line: 2300, col: 22, offset: 78359},
									val:        "_",
									ignoreCase: false,
									want:       "\"_\"",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 2300, col: 27, offset: 78364},
								name: "goHexDigits",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2301, col: 22, offset: 78399},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2301, col: 22, offset: 78399},
								val:        ".",
								ignoreCase: false,
								want:       "\".\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2301, col: 26, offset: 78403},
								name: "goHexDigits",
							},
						},
					},
				},
			},
		},
		{
			name: "goHexExponent",
			pos:  position{line: 2302, col: 1, offset: 78415},
			expr: &seqExpr{
				pos: position{line: 2302, col: 22, offset: 78436},
				exprs: []interface{}{
					&charClassMatcher{
						pos:        position{line: 2302, col: 22, offset: 78436},
						val:        "[pP]",
						chars:      []rune{'p', 'P'},
						ignoreCase: false,
						inverted:   false,
					},
					&zeroOrOneExpr{
						pos: position{line: 2302, col: 27, offset: 78441},
						expr: &charClassMatcher{
							pos:        position{line: 2302, col: 27, offset: 78441},
							val:        "[+-]",
							chars:      []rune{'+', '-'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2302, col: 33, offset: 78447},
						name: "goDecimalDigits",
					},
				},
			},
		},
		{
			name: "goImaginaryLit",
			pos:  position{line: 2308, col: 1, offset: 78493},
			expr: &seqExpr{
				pos: position{line: 2308, col: 19, offset: 78511},
				exprs: []interface{}{
					&choiceExpr{
						pos: position{line: 2308, col: 20, offset: 78512},
						alternatives: []interface{}{
							&ruleRefExpr{
								pos:  position{line: 2308, col: 20, offset: 78512},
								name: "goDecimalDigits",
							},
							&ruleRefExpr{
								pos:  position{line: 2308, col: 38, offset: 78530},
								name: "goIntLit",
							},
							&ruleRefExpr{
								pos:  position{line: 2308, col: 49, offset: 78541},
								name: "goFloatLit",
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2308, col: 61, offset: 78553},
						val:        "i",
						ignoreCase: false,
						want:       "\"i\"",
					},
				},
			},
		},
		{
			name: "goRuneLit",
			pos:  position{line: 2314, col: 1, offset: 78582},
			expr: &choiceExpr{
				pos: position{line: 2314, col: 14, offset: 78595},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2314, col: 14, offset: 78595},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2314, col: 14, offset: 78595},
								val:        "'",
								ignoreCase: false,
								want:       "\"'\"",
							},
							&choiceExpr{
								pos: position{line: 2314, col: 20, offset: 78601},
								alternatives: []interface{}{
									&ruleRefExpr{
										pos:  position{line: 2314, col: 20, offset: 78601},
										name: "goRuneUnicodeValue",
									},
									&ruleRefExpr{
										pos:  position{line: 2314, col: 41, offset: 78622},
										name: "goByteValue",
									},
									&ruleRefExpr{
										pos:  position{line: 2314, col: 55, offset: 78636},
										name: "goRecoverRuneEscape",
									},
								},
							},
							&litMatcher{
								pos:        position{line: 2314, col: 76, offset: 78657},
								val:        "'",
								ignoreCase: false,
								want:       "\"'\"",
							},
						},
					},
					&actionExpr{
						pos: position{line: 2315, col: 5, offset: 78668},
						run: (*parser).callongoRuneLit9,
						expr: &seqExpr{
							pos: position{line: 2315, col: 5, offset: 78668},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2315, col: 5, offset: 78668},
									val:        "'",
									ignoreCase: false,
									want:       "\"'\"",
								},
								&labeledExpr{
									pos:   position{line: 2315, col: 10, offset: 78673},
									label: "valsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2315, col: 16, offset: 78679},
										expr: &choiceExpr{
											pos: position{line: 2315, col: 17, offset: 78680},
											alternatives: []interface{}{
												&ruleRefExpr{
													pos:  position{line: 2315, col: 17, offset: 78680},
													name: "goRuneUnicodeValue",
												},
												&ruleRefExpr{
													pos:  position{line: 2315, col: 38, offset: 78701},
													name: "goByteValue",
												},
												&ruleRefExpr{
													pos:  position{line: 2315, col: 52, offset: 78715},
													name: "goRecoverRuneEscape",
												},
											},
										},
									},
								},
								&litMatcher{
									pos:        position{line: 2315, col: 74, offset: 78737},
									val:        "'",
									ignoreCase: false,
									want:       "\"'\"",
								},
								&labeledExpr{
									pos:   position{line: 2315, col: 79, offset: 78742},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 2315, col: 87, offset: 78750},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goRuneUnicodeValue",
			pos:  position{line: 2341, col: 1, offset: 79784},
			expr: &choiceExpr{
				pos: position{line: 2341, col: 24, offset: 79807},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2341, col: 24, offset: 79807},
						name: "goLittleUValue",
					},
					&ruleRefExpr{
						pos:  position{line: 2341, col: 41, offset: 79824},
						name: "goBigUValue",
					},
					&ruleRefExpr{
						pos:  position{line: 2341, col: 55, offset: 79838},
						name: "goRuneEscapedChar",
					},
					&charClassMatcher{
						pos:        position{line: 2341, col: 75, offset: 79858},
						val:        "[^'\\\\\\n]",
						chars:      []rune{'\'', '\\', '\n'},
						ignoreCase: false,
						inverted:   true,
					},
				},
			},
		},
		{
			name: "goByteValue",
			pos:  position{line: 2342, col: 1, offset: 79924},
			expr: &choiceExpr{
				pos: position{line: 2342, col: 24, offset: 79947},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2342, col: 24, offset: 79947},
						name: "goOctalByteValue",
					},
					&ruleRefExpr{
						pos:  position{line: 2342, col: 43, offset: 79966},
						name: "goHexByteValue",
					},
				},
			},
		},
		{
			name: "goOctalByteValue",
			pos:  position{line: 2343, col: 1, offset: 79981},
			expr: &seqExpr{
				pos: position{line: 2343, col: 24, offset: 80004},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2343, col: 24, offset: 80004},
						val:        "\\",
						ignoreCase: false,
						want:       "\"\\\\\"",
					},
					&ruleRefExpr{
						pos:  position{line: 2343, col: 29, offset: 80009},
						name: "goOctalDigit",
					},
					&ruleRefExpr{
						pos:  position{line: 2343, col: 42, offset: 80022},
						name: "goOctalDigit",
					},
					&ruleRefExpr{
						pos:  position{line: 2343, col: 55, offset: 80035},
						name: "goOctalDigit",
					},
				},
			},
		},
		{
			name: "goHexByteValue",
			pos:  position{line: 2344, col: 1, offset: 80048},
			expr: &choiceExpr{
				pos: position{line: 2344, col: 24, offset: 80071},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2344, col: 24, offset: 80071},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2344, col: 24, offset: 80071},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
							&litMatcher{
								pos:        position{line: 2344, col: 29, offset: 80076},
								val:        "x",
								ignoreCase: false,
								want:       "\"x\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2344, col: 33, offset: 80080},
								name: "goHexDigit",
							},
							&ruleRefExpr{
								pos:  position{line: 2344, col: 44, offset: 80091},
								name: "goHexDigit",
							},
						},
					},
					&actionExpr{
						pos: position{line: 2345, col: 5, offset: 80108},
						run: (*parser).callongoHexByteValue7,
						expr: &seqExpr{
							pos: position{line: 2345, col: 5, offset: 80108},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2345, col: 5, offset: 80108},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&litMatcher{
									pos:        position{line: 2345, col: 10, offset: 80113},
									val:        "x",
									ignoreCase: false,
									want:       "\"x\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 2345, col: 14, offset: 80117},
									expr: &ruleRefExpr{
										pos:  position{line: 2345, col: 14, offset: 80117},
										name: "goHexDigit",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2345, col: 26, offset: 80129},
									expr: &ruleRefExpr{
										pos:  position{line: 2345, col: 26, offset: 80129},
										name: "goHexDigit",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goLittleUValue",
			pos:  position{line: 2362, col: 1, offset: 80728},
			expr: &choiceExpr{
				pos: position{line: 2362, col: 19, offset: 80746},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2362, col: 19, offset: 80746},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2362, col: 19, offset: 80746},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
							&litMatcher{
								pos:        position{line: 2362, col: 24, offset: 80751},
								val:        "u",
								ignoreCase: false,
								want:       "\"u\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2362, col: 28, offset: 80755},
								name: "goHexDigit",
							},
							&ruleRefExpr{
								pos:  position{line: 2362, col: 39, offset: 80766},
								name: "goHexDigit",
							},
							&ruleRefExpr{
								pos:  position{line: 2362, col: 50, offset: 80777},
								name: "goHexDigit",
							},
							&ruleRefExpr{
								pos:  position{line: 2362, col: 61, offset: 80788},
								name: "goHexDigit",
							},
						},
					},
					&actionExpr{
						pos: position{line: 2363, col: 5, offset: 80805},
						run: (*parser).callongoLittleUValue9,
						expr: &seqExpr{
							pos: position{line: 2363, col: 5, offset: 80805},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2363, col: 5, offset: 80805},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&litMatcher{
									pos:        position{line: 2363, col: 10, offset: 80810},
									val:        "u",
									ignoreCase: false,
									want:       "\"u\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 2363, col: 14, offset: 80814},
									expr: &ruleRefExpr{
										pos:  position{line: 2363, col: 14, offset: 80814},
										name: "goHexDigit",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2363, col: 26, offset: 80826},
									expr: &ruleRefExpr{
										pos:  position{line: 2363, col: 26, offset: 80826},
										name: "goHexDigit",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2363, col: 38, offset: 80838},
									expr: &ruleRefExpr{
										pos:  position{line: 2363, col: 38, offset: 80838},
										name: "goHexDigit",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2363, col: 50, offset: 80850},
									expr: &ruleRefExpr{
										pos:  position{line: 2363, col: 50, offset: 80850},
										name: "goHexDigit",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goBigUValue",
			pos:  position{line: 2392, col: 1, offset: 81971},
			expr: &choiceExpr{
				pos: position{line: 2392, col: 16, offset: 81986},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2392, col: 16, offset: 81986},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2392, col: 16, offset: 81986},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
							&litMatcher{
								pos:        position{line: 2392, col: 21, offset: 81991},
								val:        "U",
								ignoreCase: false,
								want:       "\"U\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2392, col: 25, offset: 81995},
								name: "goHexDigit",
							},
							&ruleRefExpr{
								pos:  position{line: 2392, col: 36, offset: 82006},
								name: "goHexDigit",
							},
							&ruleRefExpr{
								pos:  position{line: 2392, col: 47, offset: 82017},
								name: "goHexDigit",
							},
							&ruleRefExpr{
								pos:  position{line: 2392, col: 58, offset: 82028},
								name: "goHexDigit",
							},
							&ruleRefExpr{
								pos:  position{line: 2392, col: 69, offset: 82039},
								name: "goHexDigit",
							},
							&ruleRefExpr{
								pos:  position{line: 2392, col: 80, offset: 82050},
								name: "goHexDigit",
							},
							&ruleRefExpr{
								pos:  position{line: 2392, col: 91, offset: 82061},
								name: "goHexDigit",
							},
							&ruleRefExpr{
								pos:  position{line: 2392, col: 102, offset: 82072},
								name: "goHexDigit",
							},
						},
					},
					&actionExpr{
						pos: position{line: 2393, col: 5, offset: 82089},
						run: (*parser).callongoBigUValue13,
						expr: &seqExpr{
							pos: position{line: 2393, col: 5, offset: 82089},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2393, col: 5, offset: 82089},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&litMatcher{
									pos:        position{line: 2393, col: 10, offset: 82094},
									val:        "U",
									ignoreCase: false,
									want:       "\"U\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 2393, col: 14, offset: 82098},
									expr: &ruleRefExpr{
										pos:  position{line: 2393, col: 14, offset: 82098},
										name: "goHexDigit",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2393, col: 26, offset: 82110},
									expr: &ruleRefExpr{
										pos:  position{line: 2393, col: 26, offset: 82110},
										name: "goHexDigit",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2393, col: 38, offset: 82122},
									expr: &ruleRefExpr{
										pos:  position{line: 2393, col: 38, offset: 82122},
										name: "goHexDigit",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2393, col: 50, offset: 82134},
									expr: &ruleRefExpr{
										pos:  position{line: 2393, col: 50, offset: 82134},
										name: "goHexDigit",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2393, col: 62, offset: 82146},
									expr: &ruleRefExpr{
										pos:  position{line: 2393, col: 62, offset: 82146},
										name: "goHexDigit",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2393, col: 74, offset: 82158},
									expr: &ruleRefExpr{
										pos:  position{line: 2393, col: 74, offset: 82158},
										name: "goHexDigit",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2393, col: 86, offset: 82170},
									expr: &ruleRefExpr{
										pos:  position{line: 2393, col: 86, offset: 82170},
										name: "goHexDigit",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2393, col: 98, offset: 82182},
									expr: &ruleRefExpr{
										pos:  position{line: 2393, col: 98, offset: 82182},
										name: "goHexDigit",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goRuneEscapedChar",
			pos:  position{line: 2427, col: 1, offset: 83544},
			expr: &seqExpr{
				pos: position{line: 2427, col: 24, offset: 83567},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2427, col: 24, offset: 83567},
						val:        "\\",
						ignoreCase: false,
						want:       "\"\\\\\"",
					},
					&charClassMatcher{
						pos:        position{line: 2427, col: 29, offset: 83572},
						val:        "[abfnrtv\\\\']",
						chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "goRecoverRuneEscape",
			pos:  position{line: 2428, col: 1, offset: 83627},
			expr: &choiceExpr{
				pos: position{line: 2428, col: 24, offset: 83650},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2428, col: 24, offset: 83650},
						run: (*parser).callongoRecoverRuneEscape2,
						expr: &seqExpr{
							pos: position{line: 2428, col: 24, offset: 83650},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2428, col: 24, offset: 83650},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&ruleRefExpr{
									pos:  position{line: 2428, col: 29, offset: 83655},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2428, col: 40, offset: 83666},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2428, col: 51, offset: 83677},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2428, col: 62, offset: 83688},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2428, col: 73, offset: 83699},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2428, col: 84, offset: 83710},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2428, col: 95, offset: 83721},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2428, col: 106, offset: 83732},
									name: "goHexDigit",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2452, col: 5, offset: 84666},
						run: (*parser).callongoRecoverRuneEscape13,
						expr: &seqExpr{
							pos: position{line: 2452, col: 5, offset: 84666},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2452, col: 5, offset: 84666},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&ruleRefExpr{
									pos:  position{line: 2452, col: 10, offset: 84671},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2452, col: 21, offset: 84682},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2452, col: 32, offset: 84693},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2452, col: 43, offset: 84704},
									name: "goHexDigit",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2473, col: 5, offset: 85507},
						run: (*parser).callongoRecoverRuneEscape20,
						expr: &seqExpr{
							pos: position{line: 2473, col: 5, offset: 85507},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2473, col: 5, offset: 85507},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&ruleRefExpr{
									pos:  position{line: 2473, col: 10, offset: 85512},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2473, col: 21, offset: 85523},
									name: "goHexDigit",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2491, col: 5, offset: 86192},
						run: (*parser).callongoRecoverRuneEscape25,
						expr: &seqExpr{
							pos: position{line: 2491, col: 5, offset: 86192},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2491, col: 5, offset: 86192},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 2491, col: 10, offset: 86197},
									expr: &ruleRefExpr{
										pos:  position{line: 2491, col: 10, offset: 86197},
										name: "NOT_EOL",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goRecoverInterpretedStringEscape",
			pos:  position{line: 2507, col: 1, offset: 86733},
			expr: &choiceExpr{
				pos: position{line: 2507, col: 37, offset: 86769},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2507, col: 37, offset: 86769},
						run: (*parser).callongoRecoverInterpretedStringEscape2,
						expr: &seqExpr{
							pos: position{line: 2507, col: 37, offset: 86769},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2507, col: 37, offset: 86769},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&ruleRefExpr{
									pos:  position{line: 2507, col: 42, offset: 86774},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2507, col: 53, offset: 86785},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2507, col: 64, offset: 86796},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2507, col: 75, offset: 86807},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2507, col: 86, offset: 86818},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2507, col: 97, offset: 86829},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2507, col: 108, offset: 86840},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2507, col: 119, offset: 86851},
									name: "goHexDigit",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2531, col: 5, offset: 87786},
						run: (*parser).callongoRecoverInterpretedStringEscape13,
						expr: &seqExpr{
							pos: position{line: 2531, col: 5, offset: 87786},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2531, col: 5, offset: 87786},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&ruleRefExpr{
									pos:  position{line: 2531, col: 10, offset: 87791},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2531, col: 21, offset: 87802},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2531, col: 32, offset: 87813},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2531, col: 43, offset: 87824},
									name: "goHexDigit",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2552, col: 5, offset: 88628},
						run: (*parser).callongoRecoverInterpretedStringEscape20,
						expr: &seqExpr{
							pos: position{line: 2552, col: 5, offset: 88628},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2552, col: 5, offset: 88628},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&ruleRefExpr{
									pos:  position{line: 2552, col: 10, offset: 88633},
									name: "goHexDigit",
								},
								&ruleRefExpr{
									pos:  position{line: 2552, col: 21, offset: 88644},
									name: "goHexDigit",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2570, col: 5, offset: 89314},
						run: (*parser).callongoRecoverInterpretedStringEscape25,
						expr: &seqExpr{
							pos: position{line: 2570, col: 5, offset: 89314},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2570, col: 5, offset: 89314},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 2570, col: 10, offset: 89319},
									expr: &ruleRefExpr{
										pos:  position{line: 2570, col: 10, offset: 89319},
										name: "NOT_EOL",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goStringLit",
			pos:  position{line: 2591, col: 1, offset: 89883},
			expr: &choiceExpr{
				pos: position{line: 2591, col: 16, offset: 89898},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2591, col: 16, offset: 89898},
						name: "goRawStringLit",
					},
					&ruleRefExpr{
						pos:  position{line: 2591, col: 33, offset: 89915},
						name: "goInterpretedStringLit",
					},
				},
			},
		},
		{
			name: "goRawStringLit",
			pos:  position{line: 2593, col: 1, offset: 89939},
			expr: &choiceExpr{
				pos: position{line: 2593, col: 19, offset: 89957},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2593, col: 19, offset: 89957},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2593, col: 19, offset: 89957},
								val:        "`",
								ignoreCase: false,
								want:       "\"`\"",
							},
							&zeroOrMoreExpr{
								pos: position{line: 2593, col: 23, offset: 89961},
								expr: &ruleRefExpr{
									pos:  position{line: 2593, col: 23, offset: 89961},
									name: "goRawStringUnicodeChar",
								},
							},
							&litMatcher{
								pos:        position{line: 2593, col: 47, offset: 89985},
								val:        "`",
								ignoreCase: false,
								want:       "\"`\"",
							},
						},
					},
					&actionExpr{
						pos: position{line: 2594, col: 5, offset: 89995},
						run: (*parser).callongoRawStringLit7,
						expr: &seqExpr{
							pos: position{line: 2594, col: 5, offset: 89995},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2594, col: 5, offset: 89995},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2594, col: 9, offset: 89999},
									expr: &ruleRefExpr{
										pos:  position{line: 2594, col: 9, offset: 89999},
										name: "goRawStringUnicodeChar",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2594, col: 33, offset: 90023},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goRawStringUnicodeChar",
			pos:  position{line: 2604, col: 1, offset: 90315},
			expr: &charClassMatcher{
				pos:        position{line: 2604, col: 27, offset: 90341},
				val:        "[^\\n`]",
				chars:      []rune{'\n', '`'},
				ignoreCase: false,
				inverted:   true,
			},
		},
		{
			name: "goInterpretedStringLit",
			pos:  position{line: 2606, col: 1, offset: 90399},
			expr: &choiceExpr{
				pos: position{line: 2606, col: 27, offset: 90425},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2606, col: 27, offset: 90425},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2606, col: 27, offset: 90425},
								val:        "\"",
								ignoreCase: false,
								want:       "\"\\\"\"",
							},
							&zeroOrMoreExpr{
								pos: position{line: 2606, col: 31, offset: 90429},
								expr: &choiceExpr{
									pos: position{line: 2606, col: 32, offset: 90430},
									alternatives: []interface{}{
										&ruleRefExpr{
											pos:  position{line: 2606, col: 32, offset: 90430},
											name: "goInterpretedStringUnicodeValue",
										},
										&ruleRefExpr{
											pos:  position{line: 2606, col: 66, offset: 90464},
											name: "goByteValue",
										},
										&ruleRefExpr{
											pos:  position{line: 2606, col: 80, offset: 90478},
											name: "goRecoverInterpretedStringEscape",
										},
									},
								},
							},
							&litMatcher{
								pos:        position{line: 2606, col: 115, offset: 90513},
								val:        "\"",
								ignoreCase: false,
								want:       "\"\\\"\"",
							},
						},
					},
					&actionExpr{
						pos: position{line: 2607, col: 5, offset: 90523},
						run: (*parser).callongoInterpretedStringLit10,
						expr: &seqExpr{
							pos: position{line: 2607, col: 5, offset: 90523},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2607, col: 5, offset: 90523},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2607, col: 9, offset: 90527},
									expr: &choiceExpr{
										pos: position{line: 2607, col: 10, offset: 90528},
										alternatives: []interface{}{
											&ruleRefExpr{
												pos:  position{line: 2607, col: 10, offset: 90528},
												name: "goInterpretedStringUnicodeValue",
											},
											&ruleRefExpr{
												pos:  position{line: 2607, col: 44, offset: 90562},
												name: "goByteValue",
											},
											&ruleRefExpr{
												pos:  position{line: 2607, col: 58, offset: 90576},
												name: "goRecoverInterpretedStringEscape",
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2607, col: 93, offset: 90611},
									name: "EOF",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goInterpretedStringUnicodeValue",
			pos:  position{line: 2617, col: 1, offset: 90908},
			expr: &choiceExpr{
				pos: position{line: 2617, col: 36, offset: 90943},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2617, col: 36, offset: 90943},
						name: "goLittleUValue",
					},
					&ruleRefExpr{
						pos:  position{line: 2617, col: 53, offset: 90960},
						name: "goBigUValue",
					},
					&ruleRefExpr{
						pos:  position{line: 2618, col: 5, offset: 90978},
						name: "goInterpretedStringEscapedChar",
					},
					&charClassMatcher{
						pos:        position{line: 2618, col: 38, offset: 91011},
						val:        "[^\"\\\\\\n]",
						chars:      []rune{'"', '\\', '\n'},
						ignoreCase: false,
						inverted:   true,
					},
				},
			},
		},
		{
			name: "goInterpretedStringEscapedChar",
			pos:  position{line: 2620, col: 1, offset: 91084},
			expr: &seqExpr{
				pos: position{line: 2620, col: 36, offset: 91119},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2620, col: 36, offset: 91119},
						val:        "\\",
						ignoreCase: false,
						want:       "\"\\\\\"",
					},
					&charClassMatcher{
						pos:        position{line: 2620, col: 41, offset: 91124},
						val:        "[abfnrtv\\\\\"]",
						chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "goType",
			pos:  position{line: 2626, col: 1, offset: 91196},
			expr: &choiceExpr{
				pos: position{line: 2626, col: 15, offset: 91210},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2626, col: 16, offset: 91211},
						exprs: []interface{}{
							&ruleRefExpr{
								pos:  position{line: 2626, col: 16, offset: 91211},
								name: "goTypeName",
							},
							&zeroOrMoreExpr{
								pos: position{line: 2626, col: 27, offset: 91222},
								expr: &litMatcher{
									pos:        position{line: 2626, col: 27, offset: 91222},
									val:        " ",
									ignoreCase: false,
									want:       "\" \"",
								},
							},
							&zeroOrOneExpr{
								pos: position{line: 2626, col: 32, offset: 91227},
								expr: &ruleRefExpr{
									pos:  position{line: 2626, col: 32, offset: 91227},
									name: "goTypeArgs",
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2626, col: 47, offset: 91242},
						name: "goTypeLit",
					},
					&seqExpr{
						pos: position{line: 2626, col: 59, offset: 91254},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2626, col: 59, offset: 91254},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
							&zeroOrMoreExpr{
								pos: position{line: 2626, col: 63, offset: 91258},
								expr: &litMatcher{
									pos:        position{line: 2626, col: 63, offset: 91258},
									val:        " ",
									ignoreCase: false,
									want:       "\" \"",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 2626, col: 68, offset: 91263},
								name: "goType",
							},
							&zeroOrMoreExpr{
								pos: position{line: 2626, col: 75, offset: 91270},
								expr: &litMatcher{
									pos:        position{line: 2626, col: 75, offset: 91270},
									val:        " ",
									ignoreCase: false,
									want:       "\" \"",
								},
							},
							&litMatcher{
								pos:        position{line: 2626, col: 80, offset: 91275},
								val:        ")",
								ignoreCase: false,
								want:       "\")\"",
							},
						},
					},
				},
			},
		},
		{
			name: "goTypeName",
			pos:  position{line: 2627, col: 1, offset: 91279},
			expr: &choiceExpr{
				pos: position{line: 2627, col: 15, offset: 91293},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2627, col: 15, offset: 91293},
						name: "goQualifiedIdent",
					},
					&ruleRefExpr{
						pos:  position{line: 2627, col: 34, offset: 91312},
						name: "goIdentifier",
					},
				},
			},
		},
		{
			name: "goTypeArgs",
			pos:  position{line: 2628, col: 1, offset: 91325},
			expr: &seqExpr{
				pos: position{line: 2628, col: 15, offset: 91339},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2628, col: 15, offset: 91339},
						val:        "[",
						ignoreCase: false,
						want:       "\"[\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2628, col: 19, offset: 91343},
						expr: &litMatcher{
							pos:        position{line: 2628, col: 19, offset: 91343},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2628, col: 24, offset: 91348},
						name: "goTypeList",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2628, col: 35, offset: 91359},
						expr: &litMatcher{
							pos:        position{line: 2628, col: 35, offset: 91359},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2628, col: 40, offset: 91364},
						expr: &seqExpr{
							pos: position{line: 2628, col: 41, offset: 91365},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2628, col: 41, offset: 91365},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2628, col: 45, offset: 91369},
									expr: &litMatcher{
										pos:        position{line: 2628, col: 45, offset: 91369},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2628, col: 52, offset: 91376},
						val:        "]",
						ignoreCase: false,
						want:       "\"]\"",
					},
				},
			},
		},
		{
			name: "goTypeList",
			pos:  position{line: 2629, col: 1, offset: 91380},
			expr: &seqExpr{
				pos: position{line: 2629, col: 15, offset: 91394},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2629, col: 15, offset: 91394},
						name: "goType",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2629, col: 22, offset: 91401},
						expr: &litMatcher{
							pos:        position{line: 2629, col: 22, offset: 91401},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2629, col: 27, offset: 91406},
						expr: &seqExpr{
							pos: position{line: 2629, col: 28, offset: 91407},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2629, col: 28, offset: 91407},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2629, col: 32, offset: 91411},
									expr: &litMatcher{
										pos:        position{line: 2629, col: 32, offset: 91411},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2629, col: 37, offset: 91416},
									name: "goType",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goTypeLit",
			pos:  position{line: 2630, col: 1, offset: 91425},
			expr: &choiceExpr{
				pos: position{line: 2630, col: 16, offset: 91440},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2630, col: 16, offset: 91440},
						name: "goArrayType",
					},
					&ruleRefExpr{
						pos:  position{line: 2630, col: 30, offset: 91454},
						name: "goStructType",
					},
					&ruleRefExpr{
						pos:  position{line: 2630, col: 45, offset: 91469},
						name: "goPointerType",
					},
					&ruleRefExpr{
						pos:  position{line: 2630, col: 61, offset: 91485},
						name: "goFunctionType",
					},
					&ruleRefExpr{
						pos:  position{line: 2630, col: 78, offset: 91502},
						name: "goInterfaceType",
					},
					&ruleRefExpr{
						pos:  position{line: 2630, col: 96, offset: 91520},
						name: "goSliceType",
					},
					&ruleRefExpr{
						pos:  position{line: 2630, col: 110, offset: 91534},
						name: "goMapType",
					},
					&ruleRefExpr{
						pos:  position{line: 2630, col: 122, offset: 91546},
						name: "goChannelType",
					},
				},
			},
		},
		{
			name: "goArrayType",
			pos:  position{line: 2636, col: 1, offset: 91584},
			expr: &seqExpr{
				pos: position{line: 2636, col: 18, offset: 91601},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2636, col: 18, offset: 91601},
						val:        "[",
						ignoreCase: false,
						want:       "\"[\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2636, col: 22, offset: 91605},
						expr: &litMatcher{
							pos:        position{line: 2636, col: 22, offset: 91605},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2636, col: 27, offset: 91610},
						name: "goArrayLength",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2636, col: 41, offset: 91624},
						expr: &litMatcher{
							pos:        position{line: 2636, col: 41, offset: 91624},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2636, col: 46, offset: 91629},
						val:        "]",
						ignoreCase: false,
						want:       "\"]\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2636, col: 50, offset: 91633},
						expr: &litMatcher{
							pos:        position{line: 2636, col: 50, offset: 91633},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2636, col: 55, offset: 91638},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "goArrayLength",
			pos:  position{line: 2637, col: 1, offset: 91652},
			expr: &seqExpr{
				pos: position{line: 2637, col: 18, offset: 91669},
				exprs: []interface{}{
					&oneOrMoreExpr{
						pos: position{line: 2637, col: 18, offset: 91669},
						expr: &charClassMatcher{
							pos:        position{line: 2637, col: 18, offset: 91669},
							val:        "[0-9]",
							ranges:     []rune{'0', '9'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2637, col: 25, offset: 91676},
						expr: &seqExpr{
							pos: position{line: 2637, col: 26, offset: 91677},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 2637, col: 26, offset: 91677},
									expr: &litMatcher{
										pos:        position{line: 2637, col: 26, offset: 91677},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&choiceExpr{
									pos: position{line: 2637, col: 32, offset: 91683},
									alternatives: []interface{}{
										&litMatcher{
											pos:        position{line: 2637, col: 32, offset: 91683},
											val:        "<<",
											ignoreCase: false,
											want:       "\"<<\"",
										},
										&litMatcher{
											pos:        position{line: 2637, col: 39, offset: 91690},
											val:        ">>",
											ignoreCase: false,
											want:       "\">>\"",
										},
										&litMatcher{
											pos:        position{line: 2637, col: 46, offset: 91697},
											val:        "+",
											ignoreCase: false,
											want:       "\"+\"",
										},
										&litMatcher{
											pos:        position{line: 2637, col: 52, offset: 91703},
											val:        "-",
											ignoreCase: false,
											want:       "\"-\"",
										},
										&litMatcher{
											pos:        position{line: 2637, col: 58, offset: 91709},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
										&litMatcher{
											pos:        position{line: 2637, col: 64, offset: 91715},
											val:        "/",
											ignoreCase: false,
											want:       "\"/\"",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2637, col: 69, offset: 91720},
									expr: &litMatcher{
										pos:        position{line: 2637, col: 69, offset: 91720},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2637, col: 74, offset: 91725},
									name: "goArrayLength",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goElementType",
			pos:  position{line: 2638, col: 1, offset: 91822},
			expr: &ruleRefExpr{
				pos:  position{line: 2638, col: 18, offset: 91839},
				name: "goType",
			},
		},
		{
			name: "goSliceType",
			pos:  position{line: 2644, col: 1, offset: 91869},
			expr: &seqExpr{
				pos: position{line: 2644, col: 16, offset: 91884},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2644, col: 16, offset: 91884},
						val:        "[]",
						ignoreCase: false,
						want:       "\"[]\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2644, col: 21, offset: 91889},
						expr: &litMatcher{
							pos:        position{line: 2644, col: 21, offset: 91889},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2644, col: 26, offset: 91894},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "goStructType",
			pos:  position{line: 2650, col: 1, offset: 91932},
			expr: &seqExpr{
				pos: position{line: 2650, col: 20, offset: 91951},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2650, col: 20, offset: 91951},
						val:        "struct",
						ignoreCase: false,
						want:       "\"struct\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2650, col: 29, offset: 91960},
						expr: &litMatcher{
							pos:        position{line: 2650, col: 29, offset: 91960},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2650, col: 34, offset: 91965},
						val:        "{",
						ignoreCase: false,
						want:       "\"{\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2650, col: 38, offset: 91969},
						expr: &seqExpr{
							pos: position{line: 2650, col: 39, offset: 91970},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 2650, col: 39, offset: 91970},
									expr: &ruleRefExpr{
										pos:  position{line: 2650, col: 39, offset: 91970},
										name: "WS",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2650, col: 43, offset: 91974},
									expr: &ruleRefExpr{
										pos:  position{line: 2650, col: 43, offset: 91974},
										name: "goFieldDecl",
									},
								},
								&choiceExpr{
									pos: position{line: 2650, col: 57, offset: 91988},
									alternatives: []interface{}{
										&litMatcher{
											pos:        position{line: 2650, col: 57, offset: 91988},
											val:        ";",
											ignoreCase: false,
											want:       "\";\"",
										},
										&ruleRefExpr{
											pos:  position{line: 2650, col: 63, offset: 91994},
											name: "V_WS",
										},
									},
								},
							},
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2650, col: 71, offset: 92002},
						expr: &ruleRefExpr{
							pos:  position{line: 2650, col: 71, offset: 92002},
							name: "WS",
						},
					},
					&litMatcher{
						pos:        position{line: 2650, col: 75, offset: 92006},
						val:        "}",
						ignoreCase: false,
						want:       "\"}\"",
					},
				},
			},
		},
		{
			name: "goFieldDecl",
			pos:  position{line: 2651, col: 1, offset: 92010},
			expr: &seqExpr{
				pos: position{line: 2651, col: 20, offset: 92029},
				exprs: []interface{}{
					&choiceExpr{
						pos: position{line: 2651, col: 21, offset: 92030},
						alternatives: []interface{}{
							&seqExpr{
								pos: position{line: 2651, col: 21, offset: 92030},
								exprs: []interface{}{
									&ruleRefExpr{
										pos:  position{line: 2651, col: 21, offset: 92030},
										name: "goIdentifierList",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2651, col: 38, offset: 92047},
										expr: &litMatcher{
											pos:        position{line: 2651, col: 38, offset: 92047},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&ruleRefExpr{
										pos:  position{line: 2651, col: 43, offset: 92052},
										name: "goType",
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 2651, col: 52, offset: 92061},
								name: "goEmbeddedField",
							},
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2651, col: 69, offset: 92078},
						expr: &ruleRefExpr{
							pos:  position{line: 2651, col: 69, offset: 92078},
							name: "goTag",
						},
					},
				},
			},
		},
		{
			name: "goEmbeddedField",
			pos:  position{line: 2652, col: 1, offset: 92085},
			expr: &seqExpr{
				pos: position{line: 2652, col: 20, offset: 92104},
				exprs: []interface{}{
					&zeroOrOneExpr{
						pos: position{line: 2652, col: 20, offset: 92104},
						expr: &litMatcher{
							pos:        position{line: 2652, col: 20, offset: 92104},
							val:        "*",
							ignoreCase: false,
							want:       "\"*\"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2652, col: 25, offset: 92109},
						expr: &litMatcher{
							pos:        position{line: 2652, col: 25, offset: 92109},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2652, col: 30, offset: 92114},
						name: "goTypeName",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2652, col: 41, offset: 92125},
						expr: &litMatcher{
							pos:        position{line: 2652, col: 41, offset: 92125},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2652, col: 46, offset: 92130},
						expr: &ruleRefExpr{
							pos:  position{line: 2652, col: 46, offset: 92130},
							name: "goTypeArgs",
						},
					},
				},
			},
		},
		{
			name: "goTag",
			pos:  position{line: 2653, col: 1, offset: 92142},
			expr: &ruleRefExpr{
				pos:  position{line: 2653, col: 20, offset: 92161},
				name: "goStringLit",
			},
		},
		{
			name: "goPointerType",
			pos:  position{line: 2659, col: 1, offset: 92198},
			expr: &seqExpr{
				pos: position{line: 2659, col: 18, offset: 92215},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2659, col: 18, offset: 92215},
						val:        "*",
						ignoreCase: false,
						want:       "\"*\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2659, col: 22, offset: 92219},
						expr: &litMatcher{
							pos:        position{line: 2659, col: 22, offset: 92219},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2659, col: 27, offset: 92224},
						name: "goBaseType",
					},
				},
			},
		},
		{
			name: "goBaseType",
			pos:  position{line: 2660, col: 1, offset: 92235},
			expr: &ruleRefExpr{
				pos:  position{line: 2660, col: 18, offset: 92252},
				name: "goType",
			},
		},
		{
			name: "goFunctionType",
			pos:  position{line: 2666, col: 1, offset: 92285},
			expr: &seqExpr{
				pos: position{line: 2666, col: 20, offset: 92304},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2666, col: 20, offset: 92304},
						val:        "func",
						ignoreCase: false,
						want:       "\"func\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2666, col: 27, offset: 92311},
						expr: &litMatcher{
							pos:        position{line: 2666, col: 27, offset: 92311},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2666, col: 32, offset: 92316},
						name: "goSignature",
					},
				},
			},
		},
		{
			name: "goSignature",
			pos:  position{line: 2667, col: 1, offset: 92328},
			expr: &seqExpr{
				pos: position{line: 2667, col: 20, offset: 92347},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2667, col: 20, offset: 92347},
						name: "goParameters",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2667, col: 33, offset: 92360},
						expr: &litMatcher{
							pos:        position{line: 2667, col: 33, offset: 92360},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2667, col: 38, offset: 92365},
						expr: &ruleRefExpr{
							pos:  position{line: 2667, col: 38, offset: 92365},
							name: "goResult",
						},
					},
				},
			},
		},
		{
			name: "goResult",
			pos:  position{line: 2668, col: 1, offset: 92375},
			expr: &choiceExpr{
				pos: position{line: 2668, col: 20, offset: 92394},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2668, col: 20, offset: 92394},
						name: "goParameters",
					},
					&ruleRefExpr{
						pos:  position{line: 2668, col: 35, offset: 92409},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goParameters",
			pos:  position{line: 2669, col: 1, offset: 92416},
			expr: &seqExpr{
				pos: position{line: 2669, col: 20, offset: 92435},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2669, col: 20, offset: 92435},
						val:        "(",
						ignoreCase: false,
						want:       "\"(\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2669, col: 24, offset: 92439},
						expr: &ruleRefExpr{
							pos:  position{line: 2669, col: 24, offset: 92439},
							name: "WS",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2669, col: 28, offset: 92443},
						expr: &seqExpr{
							pos: position{line: 2669, col: 29, offset: 92444},
							exprs: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 2669, col: 29, offset: 92444},
									name: "goParameterList",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2669, col: 45, offset: 92460},
									expr: &litMatcher{
										pos:        position{line: 2669, col: 45, offset: 92460},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2669, col: 50, offset: 92465},
									expr: &seqExpr{
										pos: position{line: 2669, col: 51, offset: 92466},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 2669, col: 51, offset: 92466},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2669, col: 55, offset: 92470},
												expr: &ruleRefExpr{
													pos:  position{line: 2669, col: 55, offset: 92470},
													name: "WS",
												},
											},
										},
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2669, col: 63, offset: 92478},
						val:        ")",
						ignoreCase: false,
						want:       "\")\"",
					},
				},
			},
		},
		{
			name: "goParameterList",
			pos:  position{line: 2670, col: 1, offset: 92482},
			expr: &seqExpr{
				pos: position{line: 2670, col: 20, offset: 92501},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2670, col: 20, offset: 92501},
						name: "goParameterDecl",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2670, col: 36, offset: 92517},
						expr: &litMatcher{
							pos:        position{line: 2670, col: 36, offset: 92517},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2670, col: 41, offset: 92522},
						expr: &seqExpr{
							pos: position{line: 2670, col: 42, offset: 92523},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2670, col: 42, offset: 92523},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2670, col: 46, offset: 92527},
									expr: &ruleRefExpr{
										pos:  position{line: 2670, col: 46, offset: 92527},
										name: "WS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2670, col: 50, offset: 92531},
									name: "goParameterDecl",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goParameterDecl",
			pos:  position{line: 2671, col: 1, offset: 92549},
			expr: &seqExpr{
				pos: position{line: 2671, col: 20, offset: 92568},
				exprs: []interface{}{
					&zeroOrOneExpr{
						pos: position{line: 2671, col: 20, offset: 92568},
						expr: &ruleRefExpr{
							pos:  position{line: 2671, col: 20, offset: 92568},
							name: "goIdentifierList",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2671, col: 38, offset: 92586},
						expr: &litMatcher{
							pos:        position{line: 2671, col: 38, offset: 92586},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2671, col: 43, offset: 92591},
						expr: &litMatcher{
							pos:        position{line: 2671, col: 43, offset: 92591},
							val:        "...",
							ignoreCase: false,
							want:       "\"...\"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2671, col: 50, offset: 92598},
						expr: &litMatcher{
							pos:        position{line: 2671, col: 50, offset: 92598},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2671, col: 55, offset: 92603},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goInterfaceType",
			pos:  position{line: 2677, col: 1, offset: 92637},
			expr: &seqExpr{
				pos: position{line: 2677, col: 21, offset: 92657},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2677, col: 21, offset: 92657},
						val:        "interface",
						ignoreCase: false,
						want:       "\"interface\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2677, col: 33, offset: 92669},
						expr: &litMatcher{
							pos:        position{line: 2677, col: 33, offset: 92669},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2677, col: 38, offset: 92674},
						val:        "{",
						ignoreCase: false,
						want:       "\"{\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2677, col: 42, offset: 92678},
						expr: &seqExpr{
							pos: position{line: 2677, col: 43, offset: 92679},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 2677, col: 43, offset: 92679},
									expr: &ruleRefExpr{
										pos:  position{line: 2677, col: 43, offset: 92679},
										name: "WS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2677, col: 47, offset: 92683},
									name: "goInterfaceElem",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2677, col: 63, offset: 92699},
									expr: &litMatcher{
										pos:        position{line: 2677, col: 63, offset: 92699},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&choiceExpr{
									pos: position{line: 2677, col: 69, offset: 92705},
									alternatives: []interface{}{
										&litMatcher{
											pos:        position{line: 2677, col: 69, offset: 92705},
											val:        ";",
											ignoreCase: false,
											want:       "\";\"",
										},
										&ruleRefExpr{
											pos:  position{line: 2677, col: 75, offset: 92711},
											name: "NEW_LNS",
										},
									},
								},
							},
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2677, col: 86, offset: 92722},
						expr: &ruleRefExpr{
							pos:  position{line: 2677, col: 86, offset: 92722},
							name: "WS",
						},
					},
					&litMatcher{
						pos:        position{line: 2677, col: 90, offset: 92726},
						val:        "}",
						ignoreCase: false,
						want:       "\"}\"",
					},
				},
			},
		},
		{
			name: "goInterfaceElem",
			pos:  position{line: 2678, col: 1, offset: 92730},
			expr: &choiceExpr{
				pos: position{line: 2678, col: 21, offset: 92750},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2678, col: 21, offset: 92750},
						name: "goMethodElem",
					},
					&ruleRefExpr{
						pos:  position{line: 2678, col: 36, offset: 92765},
						name: "goTypeElem",
					},
				},
			},
		},
		{
			name: "goMethodElem",
			pos:  position{line: 2679, col: 1, offset: 92776},
			expr: &seqExpr{
				pos: position{line: 2679, col: 21, offset: 92796},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2679, col: 21, offset: 92796},
						name: "goMethodName",
					},
					&ruleRefExpr{
						pos:  position{line: 2679, col: 34, offset: 92809},
						name: "goSignature",
					},
				},
			},
		},
		{
			name: "goMethodName",
			pos:  position{line: 2680, col: 1, offset: 92821},
			expr: &ruleRefExpr{
				pos:  position{line: 2680, col: 21, offset: 92841},
				name: "goIdentifier",
			},
		},
		{
			name: "goTypeElem",
			pos:  position{line: 2681, col: 1, offset: 92854},
			expr: &seqExpr{
				pos: position{line: 2681, col: 21, offset: 92874},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2681, col: 21, offset: 92874},
						name: "goTypeTerm",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2681, col: 32, offset: 92885},
						expr: &seqExpr{
							pos: position{line: 2681, col: 33, offset: 92886},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 2681, col: 33, offset: 92886},
									expr: &litMatcher{
										pos:        position{line: 2681, col: 33, offset: 92886},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 2681, col: 38, offset: 92891},
									val:        "|",
									ignoreCase: false,
									want:       "\"|\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2681, col: 42, offset: 92895},
									expr: &ruleRefExpr{
										pos:  position{line: 2681, col: 42, offset: 92895},
										name: "WS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2681, col: 46, offset: 92899},
									name: "goTypeTerm",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goTypeTerm",
			pos:  position{line: 2682, col: 1, offset: 92912},
			expr: &choiceExpr{
				pos: position{line: 2682, col: 21, offset: 92932},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2682, col: 21, offset: 92932},
						name: "goType",
					},
					&ruleRefExpr{
						pos:  position{line: 2682, col: 30, offset: 92941},
						name: "goUnderlyingType",
					},
				},
			},
		},
		{
			name: "goUnderlyingType",
			pos:  position{line: 2683, col: 1, offset: 92958},
			expr: &seqExpr{
				pos: position{line: 2683, col: 21, offset: 92978},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2683, col: 21, offset: 92978},
						val:        "~",
						ignoreCase: false,
						want:       "\"~\"",
					},
					&ruleRefExpr{
						pos:  position{line: 2683, col: 25, offset: 92982},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goMapType",
			pos:  position{line: 2689, col: 1, offset: 93010},
			expr: &seqExpr{
				pos: position{line: 2689, col: 14, offset: 93023},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2689, col: 14, offset: 93023},
						val:        "map",
						ignoreCase: false,
						want:       "\"map\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2689, col: 20, offset: 93029},
						expr: &litMatcher{
							pos:        position{line: 2689, col: 20, offset: 93029},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2689, col: 25, offset: 93034},
						val:        "[",
						ignoreCase: false,
						want:       "\"[\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2689, col: 29, offset: 93038},
						expr: &litMatcher{
							pos:        position{line: 2689, col: 29, offset: 93038},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2689, col: 34, offset: 93043},
						name: "goKeyType",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2689, col: 44, offset: 93053},
						expr: &litMatcher{
							pos:        position{line: 2689, col: 44, offset: 93053},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2689, col: 49, offset: 93058},
						val:        "]",
						ignoreCase: false,
						want:       "\"]\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2689, col: 53, offset: 93062},
						expr: &litMatcher{
							pos:        position{line: 2689, col: 53, offset: 93062},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2689, col: 58, offset: 93067},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "goKeyType",
			pos:  position{line: 2690, col: 1, offset: 93081},
			expr: &ruleRefExpr{
				pos:  position{line: 2690, col: 14, offset: 93094},
				name: "goType",
			},
		},
		{
			name: "goChannelType",
			pos:  position{line: 2696, col: 1, offset: 93126},
			expr: &seqExpr{
				pos: position{line: 2696, col: 18, offset: 93143},
				exprs: []interface{}{
					&zeroOrOneExpr{
						pos: position{line: 2696, col: 18, offset: 93143},
						expr: &seqExpr{
							pos: position{line: 2696, col: 19, offset: 93144},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2696, col: 19, offset: 93144},
									val:        "<-",
									ignoreCase: false,
									want:       "\"<-\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2696, col: 24, offset: 93149},
									expr: &litMatcher{
										pos:        position{line: 2696, col: 24, offset: 93149},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2696, col: 31, offset: 93156},
						val:        "chan",
						ignoreCase: false,
						want:       "\"chan\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2696, col: 38, offset: 93163},
						expr: &litMatcher{
							pos:        position{line: 2696, col: 38, offset: 93163},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2696, col: 43, offset: 93168},
						expr: &seqExpr{
							pos: position{line: 2696, col: 44, offset: 93169},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2696, col: 44, offset: 93169},
									val:        "<-",
									ignoreCase: false,
									want:       "\"<-\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2696, col: 49, offset: 93174},
									expr: &litMatcher{
										pos:        position{line: 2696, col: 49, offset: 93174},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2696, col: 56, offset: 93181},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "goIdentifierList",
			pos:  position{line: 2702, col: 1, offset: 93228},
			expr: &seqExpr{
				pos: position{line: 2702, col: 21, offset: 93248},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2702, col: 21, offset: 93248},
						name: "goIdentifier",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2702, col: 34, offset: 93261},
						expr: &litMatcher{
							pos:        position{line: 2702, col: 34, offset: 93261},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2702, col: 39, offset: 93266},
						expr: &seqExpr{
							pos: position{line: 2702, col: 40, offset: 93267},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2702, col: 40, offset: 93267},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2702, col: 44, offset: 93271},
									expr: &ruleRefExpr{
										pos:  position{line: 2702, col: 44, offset: 93271},
										name: "WS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2702, col: 48, offset: 93275},
									name: "goIdentifier",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "htmlNoncharacter",
			pos:  position{line: 2711, col: 1, offset: 93555},
			expr: &choiceExpr{
				pos: position{line: 2711, col: 21, offset: 93575},
				alternatives: []interface{}{
					&charClassMatcher{
						pos:        position{line: 2711, col: 21, offset: 93575},
						val:        "[\\ufdd0-\\ufdef]",
						ranges:     []rune{'\ufdd0', '\ufdef'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 2711, col: 39, offset: 93593},
						val:        "[\\ufffe\\uffff]",
						chars:      []rune{'\ufffe', '\uffff'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 2712, col: 5, offset: 93614},
						val:        "[\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff]",
						chars:      []rune{'\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 2713, col: 5, offset: 93703},
						val:        "[\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff]",
						chars:      []rune{'\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 2714, col: 5, offset: 93792},
						val:        "[\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff]",
						chars:      []rune{'\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff'},
						ignoreCase: false,
						inverted:   false,
					},
					&charClassMatcher{
						pos:        position{line: 2715, col: 5, offset: 93881},
						val:        "[\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff]",
						chars:      []rune{'\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "htmlASCIICodePoint",
			pos:  position{line: 2716, col: 1, offset: 93964},
			expr: &charClassMatcher{
				pos:        position{line: 2716, col: 27, offset: 93990},
				val:        "[\\u0000-\\u007f]",
				ranges:     []rune{'\x00', '\x7f'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "htmlASCIITabOrNewline",
			pos:  position{line: 2717, col: 1, offset: 94006},
			expr: &charClassMatcher{
				pos:        position{line: 2717, col: 27, offset: 94032},
				val:        "[\\u0009\\u000a\\u000d]",
				chars:      []rune{'\t', '\n', '\r'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "htmlASCIIWhitespace",
			pos:  position{line: 2718, col: 1, offset: 94053},
			expr: &charClassMatcher{
				pos:        position{line: 2718, col: 27, offset: 94079},
				val:        "[\\u0009\\u000a\\u000c\\u000d\\u0020]",
				chars:      []rune{'\t', '\n', '\f', '\r', ' '},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "htmlC0Control",
			pos:  position{line: 2719, col: 1, offset: 94112},
			expr: &charClassMatcher{
				pos:        position{line: 2719, col: 27, offset: 94138},
				val:        "[\\u0000-\\u001f]",
				ranges:     []rune{'\x00', '\x1f'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "htmlC0OrSpace",
			pos:  position{line: 2720, col: 1, offset: 94154},
			expr: &choiceExpr{
				pos: position{line: 2720, col: 27, offset: 94180},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2720, col: 27, offset: 94180},
						name: "htmlC0Control",
					},
					&litMatcher{
						pos:        position{line: 2720, col: 43, offset: 94196},
						val:        " ",
						ignoreCase: false,
						want:       "\" \"",
					},
				},
			},
		},
		{
			name: "htmlControl",
			pos:  position{line: 2721, col: 1, offset: 94205},
			expr: &choiceExpr{
				pos: position{line: 2721, col: 27, offset: 94231},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2721, col: 27, offset: 94231},
						name: "htmlC0Control",
					},
					&charClassMatcher{
						pos:        position{line: 2721, col: 43, offset: 94247},
						val:        "[\\u007f-\\u009f]",
						ranges:     []rune{'\x7f', '\u009f'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "htmlASCIIDigit",
			pos:  position{line: 2722, col: 1, offset: 94263},
			expr: &charClassMatcher{
				pos:        position{line: 2722, col: 27, offset: 94289},
				val:        "[\\u0030-\\u0039]",
				ranges:     []rune{'0', '9'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "htmlASCIIUpperHexDigit",
			pos:  position{line: 2723, col: 1, offset: 94305},
			expr: &choiceExpr{
				pos: position{line: 2723, col: 27, offset: 94331},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2723, col: 27, offset: 94331},
						name: "htmlASCIIDigit",
					},
					&charClassMatcher{
						pos:        position{line: 2723, col: 44, offset: 94348},
						val:        "[\\u0041-\\u0046]",
						ranges:     []rune{'A', 'F'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "htmlASCIILowerHexDigit",
			pos:  position{line: 2724, col: 1, offset: 94364},
			expr: &choiceExpr{
				pos: position{line: 2724, col: 27, offset: 94390},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2724, col: 27, offset: 94390},
						name: "htmlASCIIDigit",
					},
					&charClassMatcher{
						pos:        position{line: 2724, col: 44, offset: 94407},
						val:        "[\\u0061-\\u0066]",
						ranges:     []rune{'a', 'f'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "htmlASCIIHexDigit",
			pos:  position{line: 2725, col: 1, offset: 94423},
			expr: &choiceExpr{
				pos: position{line: 2725, col: 27, offset: 94449},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2725, col: 27, offset: 94449},
						name: "htmlASCIIUpperHexDigit",
					},
					&ruleRefExpr{
						pos:  position{line: 2725, col: 52, offset: 94474},
						name: "htmlASCIILowerHexDigit",
					},
				},
			},
		},
		{
			name: "htmlASCIIUpperAlpha",
			pos:  position{line: 2726, col: 1, offset: 94497},
			expr: &charClassMatcher{
				pos:        position{line: 2726, col: 27, offset: 94523},
				val:        "[\\u0041-\\u005a]",
				ranges:     []rune{'A', 'Z'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "htmlASCIILowerAlpha",
			pos:  position{line: 2727, col: 1, offset: 94539},
			expr: &charClassMatcher{
				pos:        position{line: 2727, col: 27, offset: 94565},
				val:        "[\\u0061-\\u007a]",
				ranges:     []rune{'a', 'z'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "htmlASCIIAlpha",
			pos:  position{line: 2728, col: 1, offset: 94581},
			expr: &choiceExpr{
				pos: position{line: 2728, col: 27, offset: 94607},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2728, col: 27, offset: 94607},
						name: "htmlASCIIUpperAlpha",
					},
					&ruleRefExpr{
						pos:  position{line: 2728, col: 49, offset: 94629},
						name: "htmlASCIILowerAlpha",
					},
				},
			},
		},
		{
			name: "htmlASCIIAlphanumeric",
			pos:  position{line: 2729, col: 1, offset: 94649},
			expr: &choiceExpr{
				pos: position{line: 2729, col: 27, offset: 94675},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2729, col: 27, offset: 94675},
						name: "htmlASCIIDigit",
					},
					&ruleRefExpr{
						pos:  position{line: 2729, col: 44, offset: 94692},
						name: "htmlASCIIAlpha",
					},
				},
			},
		},
		{
			name: "htmlTagName",
			pos:  position{line: 2736, col: 1, offset: 94935},
			expr: &oneOrMoreExpr{
				pos: position{line: 2736, col: 16, offset: 94950},
				expr: &ruleRefExpr{
					pos:  position{line: 2736, col: 16, offset: 94950},
					name: "htmlASCIIAlphanumeric",
				},
			},
		},
		{
			name: "htmlAttributeNameChar",
			pos:  position{line: 2743, col: 1, offset: 95205},
			expr: &seqExpr{
				pos: position{line: 2743, col: 26, offset: 95230},
				exprs: []interface{}{
					&notExpr{
						pos: position{line: 2743, col: 26, offset: 95230},
						expr: &choiceExpr{
							pos: position{line: 2743, col: 28, offset: 95232},
							alternatives: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 2743, col: 28, offset: 95232},
									name: "htmlControl",
								},
								&charClassMatcher{
									pos:        position{line: 2743, col: 42, offset: 95246},
									val:        "[\\u0020\\u0022\\u0027\\u003e\\u002f\\u003d]",
									chars:      []rune{' ', '"', '\'', '>', '/', '='},
									ignoreCase: false,
									inverted:   false,
								},
								&ruleRefExpr{
									pos:  position{line: 2743, col: 83, offset: 95287},
									name: "htmlNoncharacter",
								},
							},
						},
					},
					&anyMatcher{
						line: 2743, col: 101, offset: 95305,
					},
				},
			},
		},
		{
			name: "Include",
			pos:  position{line: 2745, col: 1, offset: 95308},
			expr: &actionExpr{
				pos: position{line: 2745, col: 12, offset: 95319},
				run: (*parser).callonInclude1,
				expr: &seqExpr{
					pos: position{line: 2745, col: 12, offset: 95319},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2745, col: 12, offset: 95319},
							val:        "include",
							ignoreCase: false,
							want:       "\"include\"",
						},
						&labeledExpr{
							pos:   position{line: 2745, col: 22, offset: 95329},
							label: "pathI",
							expr: &ruleRefExpr{
								pos:  position{line: 2745, col: 28, offset: 95335},
								name: "spacedDirPath",
							},
						},
					},
				},
			},
		},
		{
			name: "Mixin",
			pos:  position{line: 2756, col: 1, offset: 95631},
			expr: &choiceExpr{
				pos: position{line: 2756, col: 10, offset: 95640},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2756, col: 10, offset: 95640},
						run: (*parser).callonMixin2,
						expr: &seqExpr{
							pos: position{line: 2756, col: 10, offset: 95640},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2756, col: 10, offset: 95640},
									val:        "mixin",
									ignoreCase: false,
									want:       "\"mixin\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 2756, col: 18, offset: 95648},
									expr: &litMatcher{
										pos:        position{line: 2756, col: 18, offset: 95648},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2756, col: 23, offset: 95653},
									label: "nameI",
									expr: &ruleRefExpr{
										pos:  position{line: 2756, col: 29, offset: 95659},
										name: "MustIdent",
									},
								},
								&labeledExpr{
									pos:   position{line: 2756, col: 39, offset: 95669},
									label: "paramsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2756, col: 47, offset: 95677},
										expr: &ruleRefExpr{
											pos:  position{line: 2756, col: 47, offset: 95677},
											name: "mixinParamList",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2756, col: 63, offset: 95693},
									label: "bodyI",
									expr: &ruleRefExpr{
										pos:  position{line: 2756, col: 69, offset: 95699},
										name: "Beaitb",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2766, col: 5, offset: 95993},
						run: (*parser).callonMixin14,
						expr: &seqExpr{
							pos: position{line: 2766, col: 5, offset: 95993},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2766, col: 5, offset: 95993},
									val:        "mixin",
									ignoreCase: false,
									want:       "\"mixin\"",
								},
								&labeledExpr{
									pos:   position{line: 2766, col: 13, offset: 96001},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 2766, col: 18, offset: 96006},
										name: "POS",
									},
								},
								&labeledExpr{
									pos:   position{line: 2766, col: 22, offset: 96010},
									label: "bodyI",
									expr: &ruleRefExpr{
										pos:  position{line: 2766, col: 28, offset: 96016},
										name: "Beaitb",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParamList",
			pos:  position{line: 2782, col: 1, offset: 96429},
			expr: &choiceExpr{
				pos: position{line: 2782, col: 19, offset: 96447},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2782, col: 19, offset: 96447},
						run: (*parser).callonmixinParamList2,
						expr: &seqExpr{
							pos: position{line: 2782, col: 19, offset: 96447},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2782, col: 19, offset: 96447},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2782, col: 23, offset: 96451},
									expr: &ruleRefExpr{
										pos:  position{line: 2782, col: 23, offset: 96451},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 2782, col: 27, offset: 96455},
									label: "paramsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2782, col: 35, offset: 96463},
										expr: &ruleRefExpr{
											pos:  position{line: 2782, col: 35, offset: 96463},
											name: "mixinParams",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2782, col: 48, offset: 96476},
									expr: &ruleRefExpr{
										pos:  position{line: 2782, col: 48, offset: 96476},
										name: "_",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2782, col: 51, offset: 96479},
									expr: &seqExpr{
										pos: position{line: 2782, col: 52, offset: 96480},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 2782, col: 52, offset: 96480},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2782, col: 56, offset: 96484},
												expr: &ruleRefExpr{
													pos:  position{line: 2782, col: 56, offset: 96484},
													name: "WS",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2782, col: 62, offset: 96490},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 2782, col: 73, offset: 96501},
										name: "R_PAREN",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2788, col: 5, offset: 96691},
						run: (*parser).callonmixinParamList19,
						expr: &seqExpr{
							pos: position{line: 2788, col: 5, offset: 96691},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2788, col: 5, offset: 96691},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2788, col: 9, offset: 96695},
									expr: &ruleRefExpr{
										pos:  position{line: 2788, col: 9, offset: 96695},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 2788, col: 13, offset: 96699},
									label: "paramsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2788, col: 21, offset: 96707},
										expr: &ruleRefExpr{
											pos:  position{line: 2788, col: 21, offset: 96707},
											name: "mixinParams",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2788, col: 34, offset: 96720},
									expr: &seqExpr{
										pos: position{line: 2788, col: 35, offset: 96721},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 2788, col: 35, offset: 96721},
												expr: &ruleRefExpr{
													pos:  position{line: 2788, col: 35, offset: 96721},
													name: "_",
												},
											},
											&litMatcher{
												pos:        position{line: 2788, col: 38, offset: 96724},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2788, col: 44, offset: 96730},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 2788, col: 49, offset: 96735},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParams",
			pos:  position{line: 2807, col: 1, offset: 97275},
			expr: &actionExpr{
				pos: position{line: 2807, col: 16, offset: 97290},
				run: (*parser).callonmixinParams1,
				expr: &seqExpr{
					pos: position{line: 2807, col: 16, offset: 97290},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 2807, col: 16, offset: 97290},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 2807, col: 23, offset: 97297},
								name: "mixinParam",
							},
						},
						&labeledExpr{
							pos:   position{line: 2807, col: 34, offset: 97308},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2807, col: 40, offset: 97314},
								expr: &seqExpr{
									pos: position{line: 2807, col: 41, offset: 97315},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 2807, col: 41, offset: 97315},
											expr: &ruleRefExpr{
												pos:  position{line: 2807, col: 41, offset: 97315},
												name: "_",
											},
										},
										&litMatcher{
											pos:        position{line: 2807, col: 44, offset: 97318},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2807, col: 48, offset: 97322},
											expr: &ruleRefExpr{
												pos:  position{line: 2807, col: 48, offset: 97322},
												name: "WS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2807, col: 52, offset: 97326},
											name: "mixinParam",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParam",
			pos:  position{line: 2818, col: 1, offset: 97604},
			expr: &actionExpr{
				pos: position{line: 2818, col: 15, offset: 97618},
				run: (*parser).callonmixinParam1,
				expr: &seqExpr{
					pos: position{line: 2818, col: 15, offset: 97618},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 2818, col: 15, offset: 97618},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 2818, col: 21, offset: 97624},
								name: "MustIdentIfText",
							},
						},
						&labeledExpr{
							pos:   position{line: 2818, col: 37, offset: 97640},
							label: "posI",
							expr: &ruleRefExpr{
								pos:  position{line: 2818, col: 42, offset: 97645},
								name: "POS",
							},
						},
						&labeledExpr{
							pos:   position{line: 2818, col: 46, offset: 97649},
							label: "typeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2818, col: 52, offset: 97655},
								expr: &seqExpr{
									pos: position{line: 2818, col: 53, offset: 97656},
									exprs: []interface{}{
										&oneOrMoreExpr{
											pos: position{line: 2818, col: 53, offset: 97656},
											expr: &litMatcher{
												pos:        position{line: 2818, col: 53, offset: 97656},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2818, col: 58, offset: 97661},
											name: "GoType",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2818, col: 67, offset: 97670},
							label: "defaultI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2818, col: 76, offset: 97679},
								expr: &seqExpr{
									pos: position{line: 2818, col: 77, offset: 97680},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 2818, col: 77, offset: 97680},
											expr: &litMatcher{
												pos:        position{line: 2818, col: 77, offset: 97680},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2818, col: 82, offset: 97685},
											name: "mixinParamDefault",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParamDefault",
			pos:  position{line: 2856, col: 1, offset: 98905},
			expr: &choiceExpr{
				pos: position{line: 2856, col: 22, offset: 98926},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2856, col: 22, offset: 98926},
						run: (*parser).callonmixinParamDefault2,
						expr: &seqExpr{
							pos: position{line: 2856, col: 22, offset: 98926},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2856, col: 22, offset: 98926},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2856, col: 26, offset: 98930},
									expr: &litMatcher{
										pos:        position{line: 2856, col: 26, offset: 98930},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2856, col: 31, offset: 98935},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 2856, col: 37, offset: 98941},
										name: "GoExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2861, col: 5, offset: 99082},
						run: (*parser).callonmixinParamDefault9,
						expr: &seqExpr{
							pos: position{line: 2861, col: 5, offset: 99082},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2861, col: 5, offset: 99082},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&labeledExpr{
									pos:   position{line: 2861, col: 9, offset: 99086},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 2861, col: 14, offset: 99091},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Return",
			pos:  position{line: 2886, col: 1, offset: 99878},
			expr: &actionExpr{
				pos: position{line: 2886, col: 11, offset: 99888},
				run: (*parser).callonReturn1,
				expr: &seqExpr{
					pos: position{line: 2886, col: 11, offset: 99888},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2886, col: 11, offset: 99888},
							val:        "return",
							ignoreCase: false,
							want:       "\"return\"",
						},
						&labeledExpr{
							pos:   position{line: 2886, col: 20, offset: 99897},
							label: "errExprI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2886, col: 29, offset: 99906},
								expr: &ruleRefExpr{
									pos:  position{line: 2886, col: 29, offset: 99906},
									name: "Expression",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2886, col: 41, offset: 99918},
							expr: &ruleRefExpr{
								pos:  position{line: 2886, col: 41, offset: 99918},
								name: "unexpectedTokens",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 2886, col: 59, offset: 99936},
							name: "EOL",
						},
					},
				},
			},
		},
		{
			name: "MixinCall",
			pos:  position{line: 2897, col: 1, offset: 100241},
			expr: &actionExpr{
				pos: position{line: 2897, col: 14, offset: 100254},
				run: (*parser).callonMixinCall1,
				expr: &seqExpr{
					pos: position{line: 2897, col: 14, offset: 100254},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2897, col: 14, offset: 100254},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 2897, col: 18, offset: 100258},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2897, col: 29, offset: 100269},
								expr: &seqExpr{
									pos: position{line: 2897, col: 30, offset: 100270},
									exprs: []interface{}{
										&ruleRefExpr{
											pos:  position{line: 2897, col: 30, offset: 100270},
											name: "Ident",
										},
										&litMatcher{
											pos:        position{line: 2897, col: 36, offset: 100276},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2897, col: 42, offset: 100282},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 2897, col: 48, offset: 100288},
								name: "MustIdent",
							},
						},
						&labeledExpr{
							pos:   position{line: 2897, col: 58, offset: 100298},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2897, col: 64, offset: 100304},
								expr: &ruleRefExpr{
									pos:  position{line: 2897, col: 64, offset: 100304},
									name: "mixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2897, col: 78, offset: 100318},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 2897, col: 84, offset: 100324},
								name: "mixinCallBody",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineMixinCall",
			pos:  position{line: 2916, col: 1, offset: 100774},
			expr: &actionExpr{
				pos: position{line: 2916, col: 20, offset: 100793},
				run: (*parser).callonInlineMixinCall1,
				expr: &seqExpr{
					pos: position{line: 2916, col: 20, offset: 100793},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2916, col: 20, offset: 100793},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 2916, col: 24, offset: 100797},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2916, col: 35, offset: 100808},
								expr: &seqExpr{
									pos: position{line: 2916, col: 36, offset: 100809},
									exprs: []interface{}{
										&ruleRefExpr{
											pos:  position{line: 2916, col: 36, offset: 100809},
											name: "Ident",
										},
										&litMatcher{
											pos:        position{line: 2916, col: 42, offset: 100815},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2916, col: 48, offset: 100821},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 2916, col: 54, offset: 100827},
								name: "MustIdent",
							},
						},
						&labeledExpr{
							pos:   position{line: 2916, col: 64, offset: 100837},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2916, col: 70, offset: 100843},
								expr: &ruleRefExpr{
									pos:  position{line: 2916, col: 70, offset: 100843},
									name: "singleLineMixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2916, col: 94, offset: 100867},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 2916, col: 100, offset: 100873},
								name: "singleLineMixinCallBody",
							},
						},
					},
				},
			},
		},
		{
			name: "mixinArgList",
			pos:  position{line: 2935, col: 1, offset: 101333},
			expr: &choiceExpr{
				pos: position{line: 2935, col: 17, offset: 101349},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2935, col: 17, offset: 101349},
						run: (*parser).callonmixinArgList2,
						expr: &seqExpr{
							pos: position{line: 2935, col: 17, offset: 101349},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2935, col: 17, offset: 101349},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2935, col: 21, offset: 101353},
									expr: &ruleRefExpr{
										pos:  position{line: 2935, col: 21, offset: 101353},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 2935, col: 25, offset: 101357},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2935, col: 31, offset: 101363},
										expr: &ruleRefExpr{
											pos:  position{line: 2935, col: 31, offset: 101363},
											name: "mixinArgs",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2935, col: 42, offset: 101374},
									expr: &ruleRefExpr{
										pos:  position{line: 2935, col: 42, offset: 101374},
										name: "_",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2935, col: 45, offset: 101377},
									expr: &seqExpr{
										pos: position{line: 2935, col: 46, offset: 101378},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 2935, col: 46, offset: 101378},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2935, col: 50, offset: 101382},
												expr: &ruleRefExpr{
													pos:  position{line: 2935, col: 50, offset: 101382},
													name: "WS",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2935, col: 56, offset: 101388},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 2935, col: 67, offset: 101399},
										name: "R_PAREN",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2941, col: 5, offset: 101587},
						run: (*parser).callonmixinArgList19,
						expr: &seqExpr{
							pos: position{line: 2941, col: 5, offset: 101587},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2941, col: 5, offset: 101587},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2941, col: 9, offset: 101591},
									expr: &ruleRefExpr{
										pos:  position{line: 2941, col: 9, offset: 101591},
										name: "WS",
									},
								},
								&labeledExpr{
									pos:   position{line: 2941, col: 13, offset: 101595},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2941, col: 19, offset: 101601},
										expr: &ruleRefExpr{
											pos:  position{line: 2941, col: 19, offset: 101601},
											name: "mixinArgs",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2941, col: 30, offset: 101612},
									expr: &seqExpr{
										pos: position{line: 2941, col: 31, offset: 101613},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 2941, col: 31, offset: 101613},
												expr: &ruleRefExpr{
													pos:  position{line: 2941, col: 31, offset: 101613},
													name: "_",
												},
											},
											&litMatcher{
												pos:        position{line: 2941, col: 34, offset: 101616},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2941, col: 40, offset: 101622},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 2941, col: 45, offset: 101627},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinArgList",
			pos:  position{line: 2959, col: 1, offset: 102158},
			expr: &choiceExpr{
				pos: position{line: 2959, col: 27, offset: 102184},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2959, col: 27, offset: 102184},
						run: (*parser).callonsingleLineMixinArgList2,
						expr: &seqExpr{
							pos: position{line: 2959, col: 27, offset: 102184},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2959, col: 27, offset: 102184},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2959, col: 31, offset: 102188},
									expr: &litMatcher{
										pos:        position{line: 2959, col: 31, offset: 102188},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2959, col: 36, offset: 102193},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2959, col: 42, offset: 102199},
										expr: &ruleRefExpr{
											pos:  position{line: 2959, col: 42, offset: 102199},
											name: "singleLineMixinArgs",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2959, col: 63, offset: 102220},
									expr: &litMatcher{
										pos:        position{line: 2959, col: 63, offset: 102220},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2959, col: 68, offset: 102225},
									expr: &seqExpr{
										pos: position{line: 2959, col: 69, offset: 102226},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 2959, col: 69, offset: 102226},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2959, col: 73, offset: 102230},
												expr: &litMatcher{
													pos:        position{line: 2959, col: 73, offset: 102230},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2959, col: 80, offset: 102237},
									label: "rParenPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 2959, col: 91, offset: 102248},
										name: "R_PAREN",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2965, col: 5, offset: 102436},
						run: (*parser).callonsingleLineMixinArgList19,
						expr: &seqExpr{
							pos: position{line: 2965, col: 5, offset: 102436},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2965, col: 5, offset: 102436},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2965, col: 9, offset: 102440},
									expr: &litMatcher{
										pos:        position{line: 2965, col: 9, offset: 102440},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2965, col: 14, offset: 102445},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2965, col: 20, offset: 102451},
										expr: &ruleRefExpr{
											pos:  position{line: 2965, col: 20, offset: 102451},
											name: "singleLineMixinArgs",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2965, col: 41, offset: 102472},
									expr: &seqExpr{
										pos: position{line: 2965, col: 42, offset: 102473},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 2965, col: 42, offset: 102473},
												expr: &litMatcher{
													pos:        position{line: 2965, col: 42, offset: 102473},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 2965, col: 47, offset: 102478},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2965, col: 53, offset: 102484},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 2965, col: 58, offset: 102489},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinArgs",
			pos:  position{line: 2984, col: 1, offset: 103021},
			expr: &actionExpr{
				pos: position{line: 2984, col: 14, offset: 103034},
				run: (*parser).callonmixinArgs1,
				expr: &seqExpr{
					pos: position{line: 2984, col: 14, offset: 103034},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 2984, col: 14, offset: 103034},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 2984, col: 21, offset: 103041},
								name: "mixinArg",
							},
						},
						&labeledExpr{
							pos:   position{line: 2984, col: 30, offset: 103050},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2984, col: 36, offset: 103056},
								expr: &seqExpr{
									pos: position{line: 2984, col: 37, offset: 103057},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 2984, col: 37, offset: 103057},
											expr: &ruleRefExpr{
												pos:  position{line: 2984, col: 37, offset: 103057},
												name: "_",
											},
										},
										&litMatcher{
											pos:        position{line: 2984, col: 40, offset: 103060},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2984, col: 44, offset: 103064},
											expr: &ruleRefExpr{
												pos:  position{line: 2984, col: 44, offset: 103064},
												name: "WS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2984, col: 48, offset: 103068},
											name: "mixinArg",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinArgs",
			pos:  position{line: 2994, col: 1, offset: 103329},
			expr: &actionExpr{
				pos: position{line: 2994, col: 24, offset: 103352},
				run: (*parser).callonsingleLineMixinArgs1,
				expr: &seqExpr{
					pos: position{line: 2994, col: 24, offset: 103352},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 2994, col: 24, offset: 103352},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 2994, col: 31, offset: 103359},
								name: "singleLineMixinArg",
							},
						},
						&labeledExpr{
							pos:   position{line: 2994, col: 50, offset: 103378},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2994, col: 56, offset: 103384},
								expr: &seqExpr{
									pos: position{line: 2994, col: 57, offset: 103385},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 2994, col: 57, offset: 103385},
											expr: &litMatcher{
												pos:        position{line: 2994, col: 57, offset: 103385},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 2994, col: 62, offset: 103390},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2994, col: 66, offset: 103394},
											expr: &litMatcher{
												pos:        position{line: 2994, col: 66, offset: 103394},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2994, col: 71, offset: 103399},
											name: "singleLineMixinArg",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinArg",
			pos:  position{line: 3005, col: 1, offset: 103671},
			expr: &choiceExpr{
				pos: position{line: 3005, col: 13, offset: 103683},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3005, col: 13, offset: 103683},
						run: (*parser).callonmixinArg2,
						expr: &seqExpr{
							pos: position{line: 3005, col: 13, offset: 103683},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3005, col: 13, offset: 103683},
									label: "nameI",
									expr: &ruleRefExpr{
										pos:  position{line: 3005, col: 19, offset: 103689},
										name: "MustIdentIfText",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3005, col: 35, offset: 103705},
									expr: &litMatcher{
										pos:        position{line: 3005, col: 35, offset: 103705},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 3005, col: 40, offset: 103710},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3005, col: 44, offset: 103714},
									expr: &litMatcher{
										pos:        position{line: 3005, col: 44, offset: 103714},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3005, col: 49, offset: 103719},
									label: "valI",
									expr: &ruleRefExpr{
										pos:  position{line: 3005, col: 54, offset: 103724},
										name: "Expression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3010, col: 5, offset: 103851},
						run: (*parser).callonmixinArg13,
						expr: &seqExpr{
							pos: position{line: 3010, col: 5, offset: 103851},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3010, col: 5, offset: 103851},
									label: "nameI",
									expr: &ruleRefExpr{
										pos:  position{line: 3010, col: 11, offset: 103857},
										name: "MustIdentIfText",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3010, col: 27, offset: 103873},
									expr: &seqExpr{
										pos: position{line: 3010, col: 28, offset: 103874},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 3010, col: 28, offset: 103874},
												expr: &litMatcher{
													pos:        position{line: 3010, col: 28, offset: 103874},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 3010, col: 33, offset: 103879},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3010, col: 39, offset: 103885},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 3010, col: 44, offset: 103890},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinArg",
			pos:  position{line: 3025, col: 1, offset: 104379},
			expr: &choiceExpr{
				pos: position{line: 3025, col: 23, offset: 104401},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3025, col: 23, offset: 104401},
						run: (*parser).callonsingleLineMixinArg2,
						expr: &seqExpr{
							pos: position{line: 3025, col: 23, offset: 104401},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3025, col: 23, offset: 104401},
									label: "nameI",
									expr: &ruleRefExpr{
										pos:  position{line: 3025, col: 29, offset: 104407},
										name: "MustIdentIfText",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3025, col: 45, offset: 104423},
									expr: &litMatcher{
										pos:        position{line: 3025, col: 45, offset: 104423},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 3025, col: 50, offset: 104428},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3025, col: 54, offset: 104432},
									expr: &litMatcher{
										pos:        position{line: 3025, col: 54, offset: 104432},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3025, col: 59, offset: 104437},
									label: "valI",
									expr: &ruleRefExpr{
										pos:  position{line: 3025, col: 64, offset: 104442},
										name: "SingleLineExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3030, col: 5, offset: 104579},
						run: (*parser).callonsingleLineMixinArg13,
						expr: &seqExpr{
							pos: position{line: 3030, col: 5, offset: 104579},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3030, col: 5, offset: 104579},
									label: "nameI",
									expr: &ruleRefExpr{
										pos:  position{line: 3030, col: 11, offset: 104585},
										name: "MustIdentIfText",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3030, col: 27, offset: 104601},
									expr: &seqExpr{
										pos: position{line: 3030, col: 28, offset: 104602},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 3030, col: 28, offset: 104602},
												expr: &litMatcher{
													pos:        position{line: 3030, col: 28, offset: 104602},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 3030, col: 33, offset: 104607},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3030, col: 39, offset: 104613},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 3030, col: 44, offset: 104618},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallBody",
			pos:  position{line: 3046, col: 1, offset: 105108},
			expr: &choiceExpr{
				pos: position{line: 3046, col: 18, offset: 105125},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3046, col: 18, offset: 105125},
						run: (*parser).callonmixinCallBody2,
						expr: &labeledExpr{
							pos:   position{line: 3046, col: 18, offset: 105125},
							label: "shI",
							expr: &ruleRefExpr{
								pos:  position{line: 3046, col: 22, offset: 105129},
								name: "MixinMainBlockShorthand",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 3048, col: 5, offset: 105222},
						name: "Beaitb",
					},
				},
			},
		},
		{
			name: "singleLineMixinCallBody",
			pos:  position{line: 3049, col: 1, offset: 105229},
			expr: &ruleRefExpr{
				pos:  position{line: 3049, col: 28, offset: 105256},
				name: "Beait",
			},
		},
		{
			name: "MixinMainBlockShorthand",
			pos:  position{line: 3055, col: 1, offset: 105464},
			expr: &choiceExpr{
				pos: position{line: 3055, col: 28, offset: 105491},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3055, col: 28, offset: 105491},
						run: (*parser).callonMixinMainBlockShorthand2,
						expr: &seqExpr{
							pos: position{line: 3055, col: 28, offset: 105491},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3055, col: 28, offset: 105491},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 3055, col: 33, offset: 105496},
									expr: &ruleRefExpr{
										pos:  position{line: 3055, col: 33, offset: 105496},
										name: "unexpectedTokens",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 3055, col: 51, offset: 105514},
									name: "EOL",
								},
								&labeledExpr{
									pos:   position{line: 3055, col: 55, offset: 105518},
									label: "bodyI",
									expr: &ruleRefExpr{
										pos:  position{line: 3055, col: 61, offset: 105524},
										name: "Body",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3060, col: 5, offset: 105647},
						run: (*parser).callonMixinMainBlockShorthand10,
						expr: &seqExpr{
							pos: position{line: 3060, col: 5, offset: 105647},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3060, col: 5, offset: 105647},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 3060, col: 10, offset: 105652},
									expr: &ruleRefExpr{
										pos:  position{line: 3060, col: 10, offset: 105652},
										name: "unexpectedTokens",
									},
								},
								&labeledExpr{
									pos:   position{line: 3060, col: 28, offset: 105670},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 3060, col: 33, offset: 105675},
										name: "POS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 3060, col: 37, offset: 105679},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "spacedDirPath",
			pos:  position{line: 3080, col: 1, offset: 106281},
			expr: &choiceExpr{
				pos: position{line: 3080, col: 18, offset: 106298},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3080, col: 18, offset: 106298},
						run: (*parser).callonspacedDirPath2,
						expr: &seqExpr{
							pos: position{line: 3080, col: 18, offset: 106298},
							exprs: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 3080, col: 18, offset: 106298},
									expr: &litMatcher{
										pos:        position{line: 3080, col: 18, offset: 106298},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3080, col: 23, offset: 106303},
									label: "sI",
									expr: &ruleRefExpr{
										pos:  position{line: 3080, col: 26, offset: 106306},
										name: "String",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3082, col: 5, offset: 106338},
						run: (*parser).callonspacedDirPath8,
						expr: &seqExpr{
							pos: position{line: 3082, col: 5, offset: 106338},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 3082, col: 5, offset: 106338},
									expr: &litMatcher{
										pos:        position{line: 3082, col: 5, offset: 106338},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3082, col: 10, offset: 106343},
									label: "pathI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3082, col: 16, offset: 106349},
										expr: &ruleRefExpr{
											pos:  position{line: 3082, col: 16, offset: 106349},
											name: "NOT_EOL",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "dirPath",
			pos:  position{line: 3094, col: 1, offset: 106713},
			expr: &choiceExpr{
				pos: position{line: 3094, col: 12, offset: 106724},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 3094, col: 12, offset: 106724},
						name: "String",
					},
					&actionExpr{
						pos: position{line: 3094, col: 21, offset: 106733},
						run: (*parser).callondirPath3,
						expr: &labeledExpr{
							pos:   position{line: 3094, col: 21, offset: 106733},
							label: "pathI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3094, col: 27, offset: 106739},
								expr: &ruleRefExpr{
									pos:  position{line: 3094, col: 27, offset: 106739},
									name: "NOT_EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Extend",
			pos:  position{line: 3110, col: 1, offset: 107257},
			expr: &actionExpr{
				pos: position{line: 3110, col: 11, offset: 107267},
				run: (*parser).callonExtend1,
				expr: &seqExpr{
					pos: position{line: 3110, col: 11, offset: 107267},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 3110, col: 11, offset: 107267},
							val:        "extend",
							ignoreCase: false,
							want:       "\"extend\"",
						},
						&labeledExpr{
							pos:   position{line: 3110, col: 20, offset: 107276},
							label: "extendI",
							expr: &ruleRefExpr{
								pos:  position{line: 3110, col: 28, offset: 107284},
								name: "spacedDirPath",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 3110, col: 42, offset: 107298},
							name: "EOL",
						},
					},
				},
			},
		},
		{
			name: "Imports",
			pos:  position{line: 3118, col: 1, offset: 107563},
			expr: &actionExpr{
				pos: position{line: 3118, col: 12, offset: 107574},
				run: (*parser).callonImports1,
				expr: &labeledExpr{
					pos:   position{line: 3118, col: 12, offset: 107574},
					label: "importsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 3118, col: 21, offset: 107583},
						expr: &seqExpr{
							pos: position{line: 3118, col: 22, offset: 107584},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 3118, col: 22, offset: 107584},
									expr: &ruleRefExpr{
										pos:  position{line: 3118, col: 22, offset: 107584},
										name: "NEW_LNS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 3118, col: 31, offset: 107593},
									name: "Import",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Import",
			pos:  position{line: 3132, col: 1, offset: 107873},
			expr: &choiceExpr{
				pos: position{line: 3132, col: 11, offset: 107883},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3132, col: 11, offset: 107883},
						run: (*parser).callonImport2,
						expr: &seqExpr{
							pos: position{line: 3132, col: 11, offset: 107883},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3132, col: 11, offset: 107883},
									val:        "import",
									ignoreCase: false,
									want:       "\"import\"",
								},
								&ruleRefExpr{
									pos:  position{line: 3132, col: 20, offset: 107892},
									name: "EOL",
								},
								&labeledExpr{
									pos:   position{line: 3132, col: 24, offset: 107896},
									label: "specsI",
									expr: &ruleRefExpr{
										pos:  position{line: 3132, col: 31, offset: 107903},
										name: "importBlock",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3137, col: 5, offset: 108027},
						run: (*parser).callonImport8,
						expr: &seqExpr{
							pos: position{line: 3137, col: 5, offset: 108027},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3137, col: 5, offset: 108027},
									val:        "import",
									ignoreCase: false,
									want:       "\"import\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 3137, col: 14, offset: 108036},
									expr: &litMatcher{
										pos:        position{line: 3137, col: 14, offset: 108036},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3137, col: 19, offset: 108041},
									label: "specI",
									expr: &ruleRefExpr{
										pos:  position{line: 3137, col: 25, offset: 108047},
										name: "importSpec",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3142, col: 5, offset: 108186},
						run: (*parser).callonImport15,
						expr: &seqExpr{
							pos: position{line: 3142, col: 5, offset: 108186},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3142, col: 5, offset: 108186},
									val:        "import",
									ignoreCase: false,
									want:       "\"import\"",
								},
								&labeledExpr{
									pos:   position{line: 3142, col: 14, offset: 108195},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 3142, col: 19, offset: 108200},
										name: "POS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 3142, col: 23, offset: 108204},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "importBlock",
			pos:  position{line: 3153, col: 1, offset: 108535},
			expr: &actionExpr{
				pos: position{line: 3153, col: 16, offset: 108550},
				run: (*parser).callonimportBlock1,
				expr: &seqExpr{
					pos: position{line: 3153, col: 16, offset: 108550},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 3153, col: 16, offset: 108550},
							name: "INDENT",
						},
						&labeledExpr{
							pos:   position{line: 3153, col: 23, offset: 108557},
							label: "importsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3153, col: 32, offset: 108566},
								expr: &seqExpr{
									pos: position{line: 3153, col: 33, offset: 108567},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 3153, col: 33, offset: 108567},
											expr: &ruleRefExpr{
												pos:  position{line: 3153, col: 33, offset: 108567},
												name: "NEW_LNS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3153, col: 42, offset: 108576},
											name: "INDENTATION",
										},
										&ruleRefExpr{
											pos:  position{line: 3153, col: 54, offset: 108588},
											name: "importSpec",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 3153, col: 67, offset: 108601},
							name: "DEDENT",
						},
					},
				},
			},
		},
		{
			name: "importSpec",
			pos:  position{line: 3157, col: 1, offset: 108681},
			expr: &actionExpr{
				pos: position{line: 3157, col: 15, offset: 108695},
				run: (*parser).callonimportSpec1,
				expr: &seqExpr{
					pos: position{line: 3157, col: 15, offset: 108695},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3157, col: 15, offset: 108695},
							label: "aliasI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3157, col: 22, offset: 108702},
								expr: &seqExpr{
									pos: position{line: 3157, col: 23, offset: 108703},
									exprs: []interface{}{
										&ruleRefExpr{
											pos:  position{line: 3157, col: 23, offset: 108703},
											name: "importAlias",
										},
										&oneOrMoreExpr{
											pos: position{line: 3157, col: 35, offset: 108715},
											expr: &litMatcher{
												pos:        position{line: 3157, col: 35, offset: 108715},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3157, col: 42, offset: 108722},
							label: "pathI",
							expr: &ruleRefExpr{
								pos:  position{line: 3157, col: 48, offset: 108728},
								name: "dirPath",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 3157, col: 56, offset: 108736},
							name: "EOL",
						},
					},
				},
			},
		},
		{
			name: "importAlias",
			pos:  position{line: 3170, col: 1, offset: 108968},
			expr: &choiceExpr{
				pos: position{line: 3170, col: 16, offset: 108983},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3170, col: 16, offset: 108983},
						run: (*parser).callonimportAlias2,
						expr: &litMatcher{
							pos:        position{line: 3170, col: 16, offset: 108983},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 3172, col: 5, offset: 109052},
						name: "GoIdent",
					},
					&actionExpr{
						pos: position{line: 3172, col: 15, offset: 109062},
						run: (*parser).callonimportAlias5,
						expr: &seqExpr{
							pos: position{line: 3172, col: 15, offset: 109062},
							exprs: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 3172, col: 15, offset: 109062},
									expr: &charClassMatcher{
										pos:        position{line: 3172, col: 15, offset: 109062},
										val:        "[^\"`' ]",
										chars:      []rune{'"', '`', '\'', ' '},
										ignoreCase: false,
										inverted:   true,
									},
								},
								&labeledExpr{
									pos:   position{line: 3172, col: 24, offset: 109071},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 3172, col: 32, offset: 109079},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Uses",
			pos:  position{line: 3190, col: 1, offset: 109649},
			expr: &actionExpr{
				pos: position{line: 3190, col: 9, offset: 109657},
				run: (*parser).callonUses1,
				expr: &labeledExpr{
					pos:   position{line: 3190, col: 9, offset: 109657},
					label: "usesI",
					expr: &oneOrMoreExpr{
						pos: position{line: 3190, col: 15, offset: 109663},
						expr: &seqExpr{
							pos: position{line: 3190, col: 16, offset: 109664},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 3190, col: 16, offset: 109664},
									expr: &ruleRefExpr{
										pos:  position{line: 3190, col: 16, offset: 109664},
										name: "NEW_LNS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 3190, col: 25, offset: 109673},
									name: "Use",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Use",
			pos:  position{line: 3204, col: 1, offset: 109938},
			expr: &choiceExpr{
				pos: position{line: 3204, col: 8, offset: 109945},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3204, col: 8, offset: 109945},
						run: (*parser).callonUse2,
						expr: &seqExpr{
							pos: position{line: 3204, col: 8, offset: 109945},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3204, col: 8, offset: 109945},
									val:        "use",
									ignoreCase: false,
									want:       "\"use\"",
								},
								&labeledExpr{
									pos:   position{line: 3204, col: 15, offset: 109952},
									label: "specsI",
									expr: &ruleRefExpr{
										pos:  position{line: 3204, col: 22, offset: 109959},
										name: "useBlock",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3209, col: 5, offset: 110071},
						run: (*parser).callonUse7,
						expr: &seqExpr{
							pos: position{line: 3209, col: 5, offset: 110071},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3209, col: 5, offset: 110071},
									val:        "use",
									ignoreCase: false,
									want:       "\"use\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 3209, col: 11, offset: 110077},
									expr: &litMatcher{
										pos:        position{line: 3209, col: 11, offset: 110077},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3209, col: 16, offset: 110082},
									label: "specI",
									expr: &ruleRefExpr{
										pos:  position{line: 3209, col: 22, offset: 110088},
										name: "useSpec",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3214, col: 5, offset: 110212},
						run: (*parser).callonUse14,
						expr: &seqExpr{
							pos: position{line: 3214, col: 5, offset: 110212},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3214, col: 5, offset: 110212},
									val:        "use",
									ignoreCase: false,
									want:       "\"use\"",
								},
								&labeledExpr{
									pos:   position{line: 3214, col: 11, offset: 110218},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 3214, col: 16, offset: 110223},
										name: "POS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 3214, col: 20, offset: 110227},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "useBlock",
			pos:  position{line: 3225, col: 1, offset: 110546},
			expr: &actionExpr{
				pos: position{line: 3225, col: 13, offset: 110558},
				run: (*parser).callonuseBlock1,
				expr: &seqExpr{
					pos: position{line: 3225, col: 13, offset: 110558},
					exprs: []interface{}{
						&ruleRefExpr{
							pos:  position{line: 3225, col: 13, offset: 110558},
							name: "INDENT",
						},
						&labeledExpr{
							pos:   position{line: 3225, col: 20, offset: 110565},
							label: "usesI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3225, col: 26, offset: 110571},
								expr: &seqExpr{
									pos: position{line: 3225, col: 27, offset: 110572},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 3225, col: 27, offset: 110572},
											expr: &ruleRefExpr{
												pos:  position{line: 3225, col: 27, offset: 110572},
												name: "NEW_LNS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3225, col: 36, offset: 110581},
											name: "INDENTATION",
										},
										&ruleRefExpr{
											pos:  position{line: 3225, col: 48, offset: 110593},
											name: "useSpec",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 3225, col: 58, offset: 110603},
							name: "DEDENT",
						},
					},
				},
			},
		},
		{
			name: "useSpec",
			pos:  position{line: 3229, col: 1, offset: 110677},
			expr: &actionExpr{
				pos: position{line: 3229, col: 12, offset: 110688},
				run: (*parser).callonuseSpec1,
				expr: &seqExpr{
					pos: position{line: 3229, col: 12, offset: 110688},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3229, col: 12, offset: 110688},
							label: "aliasI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3229, col: 19, offset: 110695},
								expr: &seqExpr{
									pos: position{line: 3229, col: 20, offset: 110696},
									exprs: []interface{}{
										&ruleRefExpr{
											pos:  position{line: 3229, col: 20, offset: 110696},
											name: "useAlias",
										},
										&oneOrMoreExpr{
											pos: position{line: 3229, col: 29, offset: 110705},
											expr: &litMatcher{
												pos:        position{line: 3229, col: 29, offset: 110705},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3229, col: 36, offset: 110712},
							label: "pathI",
							expr: &ruleRefExpr{
								pos:  position{line: 3229, col: 42, offset: 110718},
								name: "dirPath",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 3229, col: 50, offset: 110726},
							name: "EOL",
						},
					},
				},
			},
		},
		{
			name: "useAlias",
			pos:  position{line: 3242, col: 1, offset: 110953},
			expr: &choiceExpr{
				pos: position{line: 3242, col: 13, offset: 110965},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3242, col: 13, offset: 110965},
						run: (*parser).callonuseAlias2,
						expr: &litMatcher{
							pos:        position{line: 3242, col: 13, offset: 110965},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 3244, col: 5, offset: 111032},
						name: "Ident",
					},
					&actionExpr{
						pos: position{line: 3244, col: 13, offset: 111040},
						run: (*parser).callonuseAlias5,
						expr: &seqExpr{
							pos: position{line: 3244, col: 13, offset: 111040},
							exprs: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 3244, col: 13, offset: 111040},
									expr: &charClassMatcher{
										pos:        position{line: 3244, col: 13, offset: 111040},
										val:        "[^\"`' ]",
										chars:      []rune{'"', '`', '\'', ' '},
										ignoreCase: false,
										inverted:   true,
									},
								},
								&labeledExpr{
									pos:   position{line: 3244, col: 22, offset: 111049},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 3244, col: 30, offset: 111057},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Func",
			pos:  position{line: 3262, col: 1, offset: 111626},
			expr: &choiceExpr{
				pos: position{line: 3262, col: 9, offset: 111634},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3262, col: 9, offset: 111634},
						run: (*parser).callonFunc2,
						expr: &seqExpr{
							pos: position{line: 3262, col: 9, offset: 111634},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3262, col: 9, offset: 111634},
									val:        "func",
									ignoreCase: false,
									want:       "\"func\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 3262, col: 16, offset: 111641},
									expr: &litMatcher{
										pos:        position{line: 3262, col: 16, offset: 111641},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3262, col: 21, offset: 111646},
									label: "nameI",
									expr: &ruleRefExpr{
										pos:  position{line: 3262, col: 27, offset: 111652},
										name: "GoIdent",
									},
								},
								&labeledExpr{
									pos:   position{line: 3262, col: 35, offset: 111660},
									label: "paramsI",
									expr: &choiceExpr{
										pos: position{line: 3263, col: 5, offset: 111674},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 3263, col: 5, offset: 111674},
												run: (*parser).callonFunc11,
												expr: &seqExpr{
													pos: position{line: 3263, col: 5, offset: 111674},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 3263, col: 5, offset: 111674},
															label: "lParenPosI",
															expr: &ruleRefExpr{
																pos:  position{line: 3263, col: 16, offset: 111685},
																name: "L_PAREN",
															},
														},
														&labeledExpr{
															pos:   position{line: 3263, col: 24, offset: 111693},
															label: "paramsI",
															expr: &choiceExpr{
																pos: position{line: 3264, col: 9, offset: 111711},
																alternatives: []interface{}{
																	&actionExpr{
																		pos: position{line: 3264, col: 9, offset: 111711},
																		run: (*parser).callonFunc17,
																		expr: &seqExpr{
																			pos: position{line: 3264, col: 9, offset: 111711},
																			exprs: []interface{}{
																				&zeroOrMoreExpr{
																					pos: position{line: 3264, col: 9, offset: 111711},
																					expr: &ruleRefExpr{
																						pos:  position{line: 3264, col: 9, offset: 111711},
																						name: "WS",
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 3264, col: 13, offset: 111715},
																					label: "paramsI",
																					expr: &zeroOrOneExpr{
																						pos: position{line: 3264, col: 21, offset: 111723},
																						expr: &ruleRefExpr{
																							pos:  position{line: 3264, col: 21, offset: 111723},
																							name: "funcParamList",
																						},
																					},
																				},
																				&zeroOrMoreExpr{
																					pos: position{line: 3264, col: 36, offset: 111738},
																					expr: &litMatcher{
																						pos:        position{line: 3264, col: 36, offset: 111738},
																						val:        " ",
																						ignoreCase: false,
																						want:       "\" \"",
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 3264, col: 41, offset: 111743},
																					expr: &seqExpr{
																						pos: position{line: 3264, col: 42, offset: 111744},
																						exprs: []interface{}{
																							&litMatcher{
																								pos:        position{line: 3264, col: 42, offset: 111744},
																								val:        ",",
																								ignoreCase: false,
																								want:       "\",\"",
																							},
																							&zeroOrMoreExpr{
																								pos: position{line: 3264, col: 46, offset: 111748},
																								expr: &ruleRefExpr{
																									pos:  position{line: 3264, col: 46, offset: 111748},
																									name: "WS",
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 3266, col: 13, offset: 111832},
																		run: (*parser).callonFunc31,
																		expr: &seqExpr{
																			pos: position{line: 3266, col: 13, offset: 111832},
																			exprs: []interface{}{
																				&zeroOrMoreExpr{
																					pos: position{line: 3266, col: 13, offset: 111832},
																					expr: &charClassMatcher{
																						pos:        position{line: 3266, col: 13, offset: 111832},
																						val:        "[^)]",
																						chars:      []rune{')'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 3266, col: 19, offset: 111838},
																					label: "endPosI",
																					expr: &ruleRefExpr{
																						pos:  position{line: 3266, col: 27, offset: 111846},
																						name: "POS",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 3276, col: 7, offset: 112231},
															label: "rParenPosI",
															expr: &ruleRefExpr{
																pos:  position{line: 3276, col: 18, offset: 112242},
																name: "R_PAREN",
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 3282, col: 9, offset: 112451},
												run: (*parser).callonFunc39,
												expr: &zeroOrMoreExpr{
													pos: position{line: 3282, col: 9, offset: 112451},
													expr: &ruleRefExpr{
														pos:  position{line: 3282, col: 9, offset: 112451},
														name: "NOT_EOL",
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 3292, col: 3, offset: 112751},
									name: "EOL",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3301, col: 5, offset: 112995},
						run: (*parser).callonFunc43,
						expr: &seqExpr{
							pos: position{line: 3301, col: 5, offset: 112995},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3301, col: 5, offset: 112995},
									val:        "func",
									ignoreCase: false,
									want:       "\"func\"",
								},
								&labeledExpr{
									pos:   position{line: 3301, col: 12, offset: 113002},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 3301, col: 17, offset: 113007},
										name: "POS",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 3301, col: 21, offset: 113011},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "funcParamList",
			pos:  position{line: 3313, col: 1, offset: 113351},
			expr: &choiceExpr{
				pos: position{line: 3313, col: 18, offset: 113368},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 3313, col: 18, offset: 113368},
						name: "funcOtherParamList",
					},
					&ruleRefExpr{
						pos:  position{line: 3313, col: 39, offset: 113389},
						name: "funcOnlyVariadicParamList",
					},
				},
			},
		},
		{
			name: "funcOnlyVariadicParamList",
			pos:  position{line: 3314, col: 1, offset: 113415},
			expr: &actionExpr{
				pos: position{line: 3314, col: 30, offset: 113444},
				run: (*parser).callonfuncOnlyVariadicParamList1,
				expr: &labeledExpr{
					pos:   position{line: 3314, col: 30, offset: 113444},
					label: "variadicI",
					expr: &ruleRefExpr{
						pos:  position{line: 3314, col: 40, offset: 113454},
						name: "funcVariadicParam",
					},
				},
			},
		},
		{
			name: "funcOtherParamList",
			pos:  position{line: 3317, col: 1, offset: 113537},
			expr: &actionExpr{
				pos: position{line: 3317, col: 23, offset: 113559},
				run: (*parser).callonfuncOtherParamList1,
				expr: &seqExpr{
					pos: position{line: 3317, col: 23, offset: 113559},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3317, col: 23, offset: 113559},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 3317, col: 30, offset: 113566},
								name: "funcParam",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3317, col: 40, offset: 113576},
							expr: &litMatcher{
								pos:        position{line: 3317, col: 40, offset: 113576},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 3317, col: 45, offset: 113581},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3317, col: 51, offset: 113587},
								expr: &seqExpr{
									pos: position{line: 3317, col: 52, offset: 113588},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 3317, col: 52, offset: 113588},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 3317, col: 56, offset: 113592},
											expr: &ruleRefExpr{
												pos:  position{line: 3317, col: 56, offset: 113592},
												name: "WS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3317, col: 60, offset: 113596},
											name: "funcParam",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3317, col: 72, offset: 113608},
							label: "variadicI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3317, col: 82, offset: 113618},
								expr: &seqExpr{
									pos: position{line: 3317, col: 83, offset: 113619},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 3317, col: 83, offset: 113619},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 3317, col: 87, offset: 113623},
											expr: &ruleRefExpr{
												pos:  position{line: 3317, col: 87, offset: 113623},
												name: "WS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3317, col: 91, offset: 113627},
											name: "funcVariadicParam",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "funcParam",
			pos:  position{line: 3338, col: 1, offset: 114078},
			expr: &choiceExpr{
				pos: position{line: 3338, col: 14, offset: 114091},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3338, col: 14, offset: 114091},
						run: (*parser).callonfuncParam2,
						expr: &seqExpr{
							pos: position{line: 3338, col: 14, offset: 114091},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3338, col: 14, offset: 114091},
									label: "namesI",
									expr: &ruleRefExpr{
										pos:  position{line: 3338, col: 21, offset: 114098},
										name: "funcIdentList",
									},
								},
								&oneOrMoreExpr{
									pos: position{line: 3338, col: 35, offset: 114112},
									expr: &litMatcher{
										pos:        position{line: 3338, col: 35, offset: 114112},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3338, col: 40, offset: 114117},
									label: "typeI",
									expr: &ruleRefExpr{
										pos:  position{line: 3338, col: 46, offset: 114123},
										name: "funcType",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3343, col: 5, offset: 114251},
						run: (*parser).callonfuncParam10,
						expr: &labeledExpr{
							pos:   position{line: 3343, col: 5, offset: 114251},
							label: "typeI",
							expr: &ruleRefExpr{
								pos:  position{line: 3343, col: 11, offset: 114257},
								name: "funcType",
							},
						},
					},
				},
			},
		},
		{
			name: "funcVariadicParam",
			pos:  position{line: 3348, col: 1, offset: 114343},
			expr: &actionExpr{
				pos: position{line: 3348, col: 22, offset: 114364},
				run: (*parser).callonfuncVariadicParam1,
				expr: &seqExpr{
					pos: position{line: 3348, col: 22, offset: 114364},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3348, col: 22, offset: 114364},
							label: "nameI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3348, col: 28, offset: 114370},
								expr: &seqExpr{
									pos: position{line: 3348, col: 29, offset: 114371},
									exprs: []interface{}{
										&ruleRefExpr{
											pos:  position{line: 3348, col: 29, offset: 114371},
											name: "GoIdent",
										},
										&oneOrMoreExpr{
											pos: position{line: 3348, col: 37, offset: 114379},
											expr: &litMatcher{
												pos:        position{line: 3348, col: 37, offset: 114379},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 3348, col: 44, offset: 114386},
							val:        "...",
							ignoreCase: false,
							want:       "\"...\"",
						},
						&labeledExpr{
							pos:   position{line: 3348, col: 50, offset: 114392},
							label: "typeI",
							expr: &ruleRefExpr{
								pos:  position{line: 3348, col: 56, offset: 114398},
								name: "funcType",
							},
						},
					},
				},
			},
		},
		{
			name: "funcIdentList",
			pos:  position{line: 3361, col: 1, offset: 114654},
			expr: &actionExpr{
				pos: position{line: 3361, col: 18, offset: 114671},
				run: (*parser).callonfuncIdentList1,
				expr: &seqExpr{
					pos: position{line: 3361, col: 18, offset: 114671},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3361, col: 18, offset: 114671},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 3361, col: 25, offset: 114678},
								name: "GoIdent",
							},
						},
						&labeledExpr{
							pos:   position{line: 3361, col: 33, offset: 114686},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3361, col: 39, offset: 114692},
								expr: &seqExpr{
									pos: position{line: 3361, col: 40, offset: 114693},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3361, col: 40, offset: 114693},
											expr: &litMatcher{
												pos:        position{line: 3361, col: 40, offset: 114693},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 3361, col: 45, offset: 114698},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 3361, col: 49, offset: 114702},
											expr: &ruleRefExpr{
												pos:  position{line: 3361, col: 49, offset: 114702},
												name: "WS",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3361, col: 53, offset: 114706},
											name: "GoIdent",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "funcType",
			pos:  position{line: 3373, col: 1, offset: 114977},
			expr: &choiceExpr{
				pos: position{line: 3373, col: 13, offset: 114989},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 3373, col: 13, offset: 114989},
						name: "GoType",
					},
					&actionExpr{
						pos: position{line: 3373, col: 22, offset: 114998},
						run: (*parser).callonfuncType3,
						expr: &seqExpr{
							pos: position{line: 3373, col: 22, offset: 114998},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3373, col: 22, offset: 114998},
									label: "typeI",
									expr: &oneOrMoreExpr{
										pos: position{line: 3373, col: 28, offset: 115004},
										expr: &charClassMatcher{
											pos:        position{line: 3373, col: 28, offset: 115004},
											val:        "[^,)]",
											chars:      []rune{',', ')'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3373, col: 35, offset: 115011},
									label: "endPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 3373, col: 43, offset: 115019},
										name: "POS",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineText",
			pos:  position{line: 3391, col: 1, offset: 115529},
			expr: &actionExpr{
				pos: position{line: 3391, col: 15, offset: 115543},
				run: (*parser).callonInlineText1,
				expr: &seqExpr{
					pos: position{line: 3391, col: 15, offset: 115543},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 3391, col: 15, offset: 115543},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
						&labeledExpr{
							pos:   position{line: 3391, col: 19, offset: 115547},
							label: "lineI",
							expr: &ruleRefExpr{
								pos:  position{line: 3391, col: 25, offset: 115553},
								name: "TextLine",
							},
						},
					},
				},
			},
		},
		{
			name: "ArrowBlock",
			pos:  position{line: 3402, col: 1, offset: 115855},
			expr: &choiceExpr{
				pos: position{line: 3402, col: 15, offset: 115869},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3402, col: 15, offset: 115869},
						run: (*parser).callonArrowBlock2,
						expr: &seqExpr{
							pos: position{line: 3402, col: 15, offset: 115869},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3402, col: 15, offset: 115869},
									val:        "> ",
									ignoreCase: false,
									want:       "\"> \"",
								},
								&labeledExpr{
									pos:   position{line: 3402, col: 20, offset: 115874},
									label: "firstLineI",
									expr: &choiceExpr{
										pos: position{line: 3402, col: 32, offset: 115886},
										alternatives: []interface{}{
											&ruleRefExpr{
												pos:  position{line: 3402, col: 32, offset: 115886},
												name: "TextLine",
											},
											&ruleRefExpr{
												pos:  position{line: 3402, col: 43, offset: 115897},
												name: "EOL",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3402, col: 48, offset: 115902},
									label: "additionalLinesI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3402, col: 65, offset: 115919},
										expr: &seqExpr{
											pos: position{line: 3402, col: 66, offset: 115920},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3402, col: 66, offset: 115920},
													expr: &ruleRefExpr{
														pos:  position{line: 3402, col: 66, offset: 115920},
														name: "NEW_LNS",
													},
												},
												&ruleRefExpr{
													pos:  position{line: 3402, col: 75, offset: 115929},
													name: "INDENTATION2",
												},
												&ruleRefExpr{
													pos:  position{line: 3402, col: 88, offset: 115942},
													name: "TextLine",
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3423, col: 5, offset: 116457},
						run: (*parser).callonArrowBlock16,
						expr: &seqExpr{
							pos: position{line: 3423, col: 5, offset: 116457},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3423, col: 5, offset: 116457},
									val:        ">",
									ignoreCase: false,
									want:       "\">\"",
								},
								&ruleRefExpr{
									pos:  position{line: 3423, col: 9, offset: 116461},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineArrowBlock",
			pos:  position{line: 3427, col: 1, offset: 116520},
			expr: &choiceExpr{
				pos: position{line: 3427, col: 21, offset: 116540},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3427, col: 21, offset: 116540},
						run: (*parser).callonInlineArrowBlock2,
						expr: &seqExpr{
							pos: position{line: 3427, col: 21, offset: 116540},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3427, col: 21, offset: 116540},
									val:        "> ",
									ignoreCase: false,
									want:       "\"> \"",
								},
								&labeledExpr{
									pos:   position{line: 3427, col: 26, offset: 116545},
									label: "lineI",
									expr: &ruleRefExpr{
										pos:  position{line: 3427, col: 32, offset: 116551},
										name: "TextLine",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3432, col: 5, offset: 116686},
						run: (*parser).callonInlineArrowBlock7,
						expr: &seqExpr{
							pos: position{line: 3432, col: 5, offset: 116686},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3432, col: 5, offset: 116686},
									val:        ">",
									ignoreCase: false,
									want:       "\">\"",
								},
								&labeledExpr{
									pos:   position{line: 3432, col: 9, offset: 116690},
									label: "posI",
									expr: &ruleRefExpr{
										pos:  position{line: 3432, col: 14, offset: 116695},
										name: "POS",
									},
								},
								&labeledExpr{
									pos:   position{line: 3432, col: 18, offset: 116699},
									label: "lineI",
									expr: &ruleRefExpr{
										pos:  position{line: 3432, col: 24, offset: 116705},
										name: "TextLine",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TextLine",
			pos:  position{line: 3450, col: 1, offset: 117285},
			expr: &actionExpr{
				pos: position{line: 3450, col: 13, offset: 117297},
				run: (*parser).callonTextLine1,
				expr: &seqExpr{
					pos: position{line: 3450, col: 13, offset: 117297},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3450, col: 13, offset: 117297},
							label: "itemsI",
							expr: &oneOrMoreExpr{
								pos: position{line: 3450, col: 20, offset: 117304},
								expr: &ruleRefExpr{
									pos:  position{line: 3450, col: 20, offset: 117304},
									name: "TextItem",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 3450, col: 30, offset: 117314},
							name: "EOL",
						},
					},
				},
			},
		},
		{
			name: "TextItem",
			pos:  position{line: 3458, col: 1, offset: 117571},
			expr: &choiceExpr{
				pos: position{line: 3458, col: 13, offset: 117583},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 3458, col: 13, offset: 117583},
						name: "Text",
					},
					&ruleRefExpr{
						pos:  position{line: 3458, col: 20, offset: 117590},
						name: "Interpolation",
					},
				},
			},
		},
		{
			name: "Text",
			pos:  position{line: 3464, col: 1, offset: 117784},
			expr: &actionExpr{
				pos: position{line: 3464, col: 9, offset: 117792},
				run: (*parser).callonText1,
				expr: &labeledExpr{
					pos:   position{line: 3464, col: 9, offset: 117792},
					label: "textI",
					expr: &oneOrMoreExpr{
						pos: position{line: 3464, col: 15, offset: 117798},
						expr: &choiceExpr{
							pos: position{line: 3464, col: 16, offset: 117799},
							alternatives: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 3464, col: 16, offset: 117799},
									expr: &seqExpr{
										pos: position{line: 3464, col: 17, offset: 117800},
										exprs: []interface{}{
											&notExpr{
												pos: position{line: 3464, col: 17, offset: 117800},
												expr: &ruleRefExpr{
													pos:  position{line: 3464, col: 18, offset: 117801},
													name: "EOL",
												},
											},
											&charClassMatcher{
												pos:        position{line: 3464, col: 22, offset: 117805},
												val:        "[^#]",
												chars:      []rune{'#'},
												ignoreCase: false,
												inverted:   true,
											},
										},
									},
								},
								&litMatcher{
									pos:        position{line: 3464, col: 31, offset: 117814},
									val:        "##",
									ignoreCase: false,
									want:       "\"##\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Interpolation",
			pos:  position{line: 3475, col: 1, offset: 118102},
			expr: &choiceExpr{
				pos: position{line: 3475, col: 18, offset: 118119},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 3475, col: 18, offset: 118119},
						name: "SimpleInterpolation",
					},
					&ruleRefExpr{
						pos:  position{line: 3475, col: 40, offset: 118141},
						name: "ElementInterpolation",
					},
					&ruleRefExpr{
						pos:  position{line: 3475, col: 63, offset: 118164},
						name: "MixinCallInterpolation",
					},
					&ruleRefExpr{
						pos:  position{line: 3475, col: 88, offset: 118189},
						name: "BadInterpolation",
					},
				},
			},
		},
		{
			name: "BadInterpolation",
			pos:  position{line: 3477, col: 1, offset: 118207},
			expr: &actionExpr{
				pos: position{line: 3477, col: 21, offset: 118227},
				run: (*parser).callonBadInterpolation1,
				expr: &litMatcher{
					pos:        position{line: 3477, col: 21, offset: 118227},
					val:        "#",
					ignoreCase: false,
					want:       "\"#\"",
				},
			},
		},
		{
			name: "SimpleInterpolation",
			pos:  position{line: 3501, col: 1, offset: 119074},
			expr: &choiceExpr{
				pos: position{line: 3501, col: 24, offset: 119097},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3501, col: 24, offset: 119097},
						run: (*parser).callonSimpleInterpolation2,
						expr: &seqExpr{
							pos: position{line: 3501, col: 24, offset: 119097},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3501, col: 24, offset: 119097},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 3501, col: 28, offset: 119101},
									label: "noEscapeI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3501, col: 38, offset: 119111},
										expr: &litMatcher{
											pos:        position{line: 3501, col: 38, offset: 119111},
											val:        "!",
											ignoreCase: false,
											want:       "\"!\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3501, col: 43, offset: 119116},
									label: "valueI",
									expr: &ruleRefExpr{
										pos:  position{line: 3501, col: 50, offset: 119123},
										name: "textInterpolationValue",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3507, col: 5, offset: 119311},
						run: (*parser).callonSimpleInterpolation10,
						expr: &seqExpr{
							pos: position{line: 3507, col: 5, offset: 119311},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3507, col: 5, offset: 119311},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 3507, col: 9, offset: 119315},
									label: "valueI",
									expr: &choiceExpr{
										pos: position{line: 3507, col: 17, offset: 119323},
										alternatives: []interface{}{
											&ruleRefExpr{
												pos:  position{line: 3507, col: 17, offset: 119323},
												name: "expressionInterpolationValue",
											},
											&ruleRefExpr{
												pos:  position{line: 3507, col: 48, offset: 119354},
												name: "fmtExpressionInterpolationValue",
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ElementInterpolation",
			pos:  position{line: 3518, col: 1, offset: 119710},
			expr: &actionExpr{
				pos: position{line: 3518, col: 25, offset: 119734},
				run: (*parser).callonElementInterpolation1,
				expr: &seqExpr{
					pos: position{line: 3518, col: 25, offset: 119734},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 3518, col: 25, offset: 119734},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&labeledExpr{
							pos:   position{line: 3518, col: 29, offset: 119738},
							label: "elPosI",
							expr: &ruleRefExpr{
								pos:  position{line: 3518, col: 36, offset: 119745},
								name: "POS",
							},
						},
						&labeledExpr{
							pos:   position{line: 3518, col: 40, offset: 119749},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 3518, col: 46, offset: 119755},
								name: "htmlTagName",
							},
						},
						&labeledExpr{
							pos:   position{line: 3518, col: 58, offset: 119767},
							label: "attrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3518, col: 65, offset: 119774},
								expr: &ruleRefExpr{
									pos:  position{line: 3518, col: 65, offset: 119774},
									name: "SingleLineAttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3518, col: 96, offset: 119805},
							label: "valueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3518, col: 103, offset: 119812},
								expr: &ruleRefExpr{
									pos:  position{line: 3518, col: 103, offset: 119812},
									name: "elementInterpolationValue",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "elementInterpolationValue",
			pos:  position{line: 3531, col: 1, offset: 120218},
			expr: &choiceExpr{
				pos: position{line: 3531, col: 30, offset: 120247},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 3531, col: 30, offset: 120247},
						name: "textInterpolationValue",
					},
					&ruleRefExpr{
						pos:  position{line: 3531, col: 55, offset: 120272},
						name: "expressionInterpolationValue",
					},
					&actionExpr{
						pos: position{line: 3531, col: 86, offset: 120303},
						run: (*parser).callonelementInterpolationValue4,
						expr: &litMatcher{
							pos:        position{line: 3531, col: 86, offset: 120303},
							val:        "/",
							ignoreCase: false,
							want:       "\"/\"",
						},
					},
				},
			},
		},
		{
			name: "MixinCallInterpolation",
			pos:  position{line: 3539, col: 1, offset: 120551},
			expr: &actionExpr{
				pos: position{line: 3539, col: 27, offset: 120577},
				run: (*parser).callonMixinCallInterpolation1,
				expr: &seqExpr{
					pos: position{line: 3539, col: 27, offset: 120577},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 3539, col: 27, offset: 120577},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&labeledExpr{
							pos:   position{line: 3539, col: 31, offset: 120581},
							label: "mcPosI",
							expr: &ruleRefExpr{
								pos:  position{line: 3539, col: 38, offset: 120588},
								name: "POS",
							},
						},
						&litMatcher{
							pos:        position{line: 3539, col: 42, offset: 120592},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 3539, col: 46, offset: 120596},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3539, col: 57, offset: 120607},
								expr: &seqExpr{
									pos: position{line: 3539, col: 58, offset: 120608},
									exprs: []interface{}{
										&ruleRefExpr{
											pos:  position{line: 3539, col: 58, offset: 120608},
											name: "Ident",
										},
										&litMatcher{
											pos:        position{line: 3539, col: 64, offset: 120614},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3539, col: 70, offset: 120620},
							label: "nameI",
							expr: &ruleRefExpr{
								pos:  position{line: 3539, col: 76, offset: 120626},
								name: "MustIdent",
							},
						},
						&labeledExpr{
							pos:   position{line: 3539, col: 86, offset: 120636},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3539, col: 92, offset: 120642},
								expr: &ruleRefExpr{
									pos:  position{line: 3539, col: 92, offset: 120642},
									name: "singleLineMixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3539, col: 116, offset: 120666},
							label: "valueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3539, col: 123, offset: 120673},
								expr: &ruleRefExpr{
									pos:  position{line: 3539, col: 123, offset: 120673},
									name: "mixinCallInterpolationValue",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallInterpolationValue",
			pos:  position{line: 3561, col: 1, offset: 121291},
			expr: &choiceExpr{
				pos: position{line: 3561, col: 32, offset: 121322},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 3561, col: 32, offset: 121322},
						name: "textInterpolationValue",
					},
					&ruleRefExpr{
						pos:  position{line: 3561, col: 57, offset: 121347},
						name: "expressionInterpolationValue",
					},
				},
			},
		},
		{
			name: "textInterpolationValue",
			pos:  position{line: 3570, col: 1, offset: 121600},
			expr: &choiceExpr{
				pos: position{line: 3570, col: 27, offset: 121626},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3570, col: 27, offset: 121626},
						run: (*parser).callontextInterpolationValue2,
						expr: &seqExpr{
							pos: position{line: 3570, col: 27, offset: 121626},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3570, col: 27, offset: 121626},
									label: "lBracketPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 3570, col: 40, offset: 121639},
										name: "L_BRACKET",
									},
								},
								&labeledExpr{
									pos:   position{line: 3570, col: 50, offset: 121649},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3570, col: 56, offset: 121655},
										expr: &charClassMatcher{
											pos:        position{line: 3570, col: 56, offset: 121655},
											val:        "[^\\]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3570, col: 67, offset: 121666},
									label: "rBracketPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 3570, col: 80, offset: 121679},
										name: "R_BRACKET",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3576, col: 5, offset: 121877},
						run: (*parser).callontextInterpolationValue11,
						expr: &seqExpr{
							pos: position{line: 3576, col: 5, offset: 121877},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3576, col: 5, offset: 121877},
									label: "lBracketPosI",
									expr: &ruleRefExpr{
										pos:  position{line: 3576, col: 18, offset: 121890},
										name: "L_BRACKET",
									},
								},
								&labeledExpr{
									pos:   position{line: 3576, col: 28, offset: 121900},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3576, col: 34, offset: 121906},
										expr: &charClassMatcher{
											pos:        position{line: 3576, col: 34, offset: 121906},
											val:        "[^\\]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 3576, col: 45, offset: 121917},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "expressionInterpolationValue",
			pos:  position{line: 3604, col: 1, offset: 122728},
			expr: &choiceExpr{
				pos: position{line: 3604, col: 33, offset: 122760},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3604, col: 33, offset: 122760},
						run: (*parser).callonexpressionInterpolationValue2,
						expr: &seqExpr{
							pos: position{line: 3604, col: 33, offset: 122760},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3604, col: 33, offset: 122760},
									label: "lBracePosI",
									expr: &ruleRefExpr{
										pos:  position{line: 3604, col: 44, offset: 122771},
										name: "L_BRACE",
									},
								},
								&labeledExpr{
									pos:   position{line: 3604, col: 52, offset: 122779},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 3604, col: 58, offset: 122785},
										name: "SingleLineExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 3604, col: 79, offset: 122806},
									label: "rBracePosI",
									expr: &ruleRefExpr{
										pos:  position{line: 3604, col: 90, offset: 122817},
										name: "R_BRACE",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3610, col: 5, offset: 123027},
						run: (*parser).callonexpressionInterpolationValue10,
						expr: &seqExpr{
							pos: position{line: 3610, col: 5, offset: 123027},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3610, col: 5, offset: 123027},
									label: "lBracePosI",
									expr: &ruleRefExpr{
										pos:  position{line: 3610, col: 16, offset: 123038},
										name: "L_BRACE",
									},
								},
								&labeledExpr{
									pos:   position{line: 3610, col: 24, offset: 123046},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 3610, col: 30, offset: 123052},
										name: "SingleLineExpression",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 3610, col: 51, offset: 123073},
									name: "EOL",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "fmtExpressionInterpolationValue",
			pos:  position{line: 3634, col: 1, offset: 123869},
			expr: &actionExpr{
				pos: position{line: 3634, col: 36, offset: 123904},
				run: (*parser).callonfmtExpressionInterpolationValue1,
				expr: &seqExpr{
					pos: position{line: 3634, col: 36, offset: 123904},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3634, col: 36, offset: 123904},
							label: "fmtDirectiveI",
							expr: &ruleRefExpr{
								pos:  position{line: 3634, col: 50, offset: 123918},
								name: "fmtDirective",
							},
						},
						&labeledExpr{
							pos:   position{line: 3634, col: 63, offset: 123931},
							label: "eivI",
							expr: &ruleRefExpr{
								pos:  position{line: 3634, col: 68, offset: 123936},
								name: "expressionInterpolationValue",
							},
						},
					},
				},
			},
		},
		{
			name: "EOF",
			pos:  position{line: 3644, col: 1, offset: 124280},
			expr: &notExpr{
				pos: position{line: 3644, col: 12, offset: 124291},
				expr: &anyMatcher{
					line: 3644, col: 13, offset: 124292,
				},
			},
		},
		{
			name: "EOL",
			pos:  position{line: 3645, col: 1, offset: 124294},
			expr: &seqExpr{
				pos: position{line: 3645, col: 12, offset: 124305},
				exprs: []interface{}{
					&zeroOrMoreExpr{
						pos: position{line: 3645, col: 12, offset: 124305},
						expr: &ruleRefExpr{
							pos:  position{line: 3645, col: 12, offset: 124305},
							name: "_",
						},
					},
					&choiceExpr{
						pos: position{line: 3645, col: 16, offset: 124309},
						alternatives: []interface{}{
							&seqExpr{
								pos: position{line: 3645, col: 16, offset: 124309},
								exprs: []interface{}{
									&zeroOrOneExpr{
										pos: position{line: 3645, col: 16, offset: 124309},
										expr: &litMatcher{
											pos:        position{line: 3645, col: 16, offset: 124309},
											val:        "\r",
											ignoreCase: false,
											want:       "\"\\r\"",
										},
									},
									&litMatcher{
										pos:        position{line: 3645, col: 22, offset: 124315},
										val:        "\n",
										ignoreCase: false,
										want:       "\"\\n\"",
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 3645, col: 29, offset: 124322},
								name: "EOF",
							},
						},
					},
				},
			},
		},
		{
			name: "NOT_EOL",
			pos:  position{line: 3646, col: 1, offset: 124327},
			expr: &charClassMatcher{
				pos:        position{line: 3646, col: 12, offset: 124338},
				val:        "[^\\r\\n]",
				chars:      []rune{'\r', '\n'},
				ignoreCase: false,
				inverted:   true,
			},
		},
		{
			name: "POS",
			pos:  position{line: 3648, col: 1, offset: 124347},
			expr: &actionExpr{
				pos: position{line: 3648, col: 8, offset: 124354},
				run: (*parser).callonPOS1,
				expr: &choiceExpr{
					pos: position{line: 3648, col: 9, offset: 124355},
					alternatives: []interface{}{
						&andExpr{
							pos: position{line: 3648, col: 9, offset: 124355},
							expr: &anyMatcher{
								line: 3648, col: 10, offset: 124356,
							},
						},
						&notExpr{
							pos: position{line: 3648, col: 14, offset: 124360},
							expr: &anyMatcher{
								line: 3648, col: 15, offset: 124361,
							},
						},
					},
				},
			},
		},
		{
			name:        "_",
			displayName: "\"horizontal whitespace\"",
			pos:         position{line: 3656, col: 1, offset: 124577},
			expr: &ruleRefExpr{
				pos:  position{line: 3656, col: 36, offset: 124612},
				name: "H_WS",
			},
		},
		{
			name:        "H_WS",
			displayName: "\"horizontal whitespace\"",
			pos:         position{line: 3657, col: 1, offset: 124617},
			expr: &charClassMatcher{
				pos:        position{line: 3657, col: 36, offset: 124652},
				val:        "[ \\t]",
				chars:      []rune{' ', '\t'},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name:        "V_WS",
			displayName: "\"vertical whitespace\"",
			pos:         position{line: 3658, col: 1, offset: 124658},
			expr: &seqExpr{
				pos: position{line: 3658, col: 36, offset: 124693},
				exprs: []interface{}{
					&zeroOrOneExpr{
						pos: position{line: 3658, col: 36, offset: 124693},
						expr: &litMatcher{
							pos:        position{line: 3658, col: 36, offset: 124693},
							val:        "\r",
							ignoreCase: false,
							want:       "\"\\r\"",
						},
					},
					&litMatcher{
						pos:        position{line: 3658, col: 42, offset: 124699},
						val:        "\n",
						ignoreCase: false,
						want:       "\"\\n\"",
					},
				},
			},
		},
		{
			name:        "NEW_LNS",
			displayName: "\"newlines\"",
			pos:         position{line: 3659, col: 1, offset: 124704},
			expr: &oneOrMoreExpr{
				pos: position{line: 3659, col: 36, offset: 124739},
				expr: &seqExpr{
					pos: position{line: 3659, col: 37, offset: 124740},
					exprs: []interface{}{
						&zeroOrMoreExpr{
							pos: position{line: 3659, col: 37, offset: 124740},
							expr: &ruleRefExpr{
								pos:  position{line: 3659, col: 37, offset: 124740},
								name: "_",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 3659, col: 40, offset: 124743},
							name: "V_WS",
						},
					},
				},
			},
		},
		{
			name:        "WS",
			displayName: "\"whitespace\"",
			pos:         position{line: 3661, col: 1, offset: 124751},
			expr: &choiceExpr{
				pos: position{line: 3661, col: 20, offset: 124770},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 3661, col: 20, offset: 124770},
						name: "_",
					},
					&ruleRefExpr{
						pos:  position{line: 3661, col: 24, offset: 124774},
						name: "V_WS",
					},
				},
			},
		},
		{
			name: "L_PAREN",
			pos:  position{line: 3667, col: 1, offset: 124979},
			expr: &actionExpr{
				pos: position{line: 3667, col: 12, offset: 124990},
				run: (*parser).callonL_PAREN1,
				expr: &litMatcher{
					pos:        position{line: 3667, col: 12, offset: 124990},
					val:        "(",
					ignoreCase: false,
					want:       "\"(\"",
				},
			},
		},
		{
			name: "R_PAREN",
			pos:  position{line: 3668, col: 1, offset: 125017},
			expr: &actionExpr{
				pos: position{line: 3668, col: 12, offset: 125028},
				run: (*parser).callonR_PAREN1,
				expr: &litMatcher{
					pos:        position{line: 3668, col: 12, offset: 125028},
					val:        ")",
					ignoreCase: false,
					want:       "\")\"",
				},
			},
		},
		{
			name: "L_BRACE",
			pos:  position{line: 3670, col: 1, offset: 125056},
			expr: &actionExpr{
				pos: position{line: 3670, col: 12, offset: 125067},
				run: (*parser).callonL_BRACE1,
				expr: &litMatcher{
					pos:        position{line: 3670, col: 12, offset: 125067},
					val:        "{",
					ignoreCase: false,
					want:       "\"{\"",
				},
			},
		},
		{
			name: "R_BRACE",
			pos:  position{line: 3671, col: 1, offset: 125094},
			expr: &actionExpr{
				pos: position{line: 3671, col: 12, offset: 125105},
				run: (*parser).callonR_BRACE1,
				expr: &litMatcher{
					pos:        position{line: 3671, col: 12, offset: 125105},
					val:        "}",
					ignoreCase: false,
					want:       "\"}\"",
				},
			},
		},
		{
			name: "L_BRACKET",
			pos:  position{line: 3673, col: 1, offset: 125133},
			expr: &actionExpr{
				pos: position{line: 3673, col: 14, offset: 125146},
				run: (*parser).callonL_BRACKET1,
				expr: &litMatcher{
					pos:        position{line: 3673, col: 14, offset: 125146},
					val:        "[",
					ignoreCase: false,
					want:       "\"[\"",
				},
			},
		},
		{
			name: "R_BRACKET",
			pos:  position{line: 3674, col: 1, offset: 125173},
			expr: &actionExpr{
				pos: position{line: 3674, col: 14, offset: 125186},
				run: (*parser).callonR_BRACKET1,
				expr: &litMatcher{
					pos:        position{line: 3674, col: 14, offset: 125186},
					val:        "]",
					ignoreCase: false,
					want:       "\"]\"",
				},
			},
		},
		{
			name: "INDENTATION",
			pos:  position{line: 3746, col: 1, offset: 128530},
			expr: &seqExpr{
				pos: position{line: 3746, col: 16, offset: 128545},
				exprs: []interface{}{
					&actionExpr{
						pos: position{line: 3746, col: 17, offset: 128546},
						run: (*parser).callonINDENTATION2,
						expr: &zeroOrMoreExpr{
							pos: position{line: 3746, col: 17, offset: 128546},
							expr: &ruleRefExpr{
								pos:  position{line: 3746, col: 17, offset: 128546},
								name: "_",
							},
						},
					},
					&andCodeExpr{
						pos: position{line: 3746, col: 41, offset: 128570},
						run: (*parser).callonINDENTATION5,
					},
					&choiceExpr{
						pos: position{line: 3798, col: 5, offset: 130480},
						alternatives: []interface{}{
							&andCodeExpr{
								pos: position{line: 3798, col: 5, offset: 130480},
								run: (*parser).callonINDENTATION7,
							},
							&seqExpr{
								pos: position{line: 3800, col: 9, offset: 130563},
								exprs: []interface{}{
									&andCodeExpr{
										pos: position{line: 3800, col: 9, offset: 130563},
										run: (*parser).callonINDENTATION9,
									},
									&stateCodeExpr{
										pos: position{line: 3802, col: 7, offset: 130686},
										run: (*parser).callonINDENTATION10,
									},
								},
							},
							&seqExpr{
								pos: position{line: 3809, col: 9, offset: 131022},
								exprs: []interface{}{
									&andCodeExpr{
										pos: position{line: 3809, col: 9, offset: 131022},
										run: (*parser).callonINDENTATION12,
									},
									&andCodeExpr{
										pos: position{line: 3811, col: 7, offset: 131130},
										run: (*parser).callonINDENTATION13,
									},
									&choiceExpr{
										pos: position{line: 3864, col: 9, offset: 133465},
										alternatives: []interface{}{
											&seqExpr{
												pos: position{line: 3864, col: 9, offset: 133465},
												exprs: []interface{}{
													&andCodeExpr{
														pos: position{line: 3864, col: 9, offset: 133465},
														run: (*parser).callonINDENTATION16,
													},
													&andCodeExpr{
														pos: position{line: 3868, col: 11, offset: 133715},
														run: (*parser).callonINDENTATION17,
													},
													&stateCodeExpr{
														pos: position{line: 3934, col: 11, offset: 136921},
														run: (*parser).callonINDENTATION18,
													},
												},
											},
											&seqExpr{
												pos: position{line: 3942, col: 13, offset: 137274},
												exprs: []interface{}{
													&andCodeExpr{
														pos: position{line: 3942, col: 13, offset: 137274},
														run: (*parser).callonINDENTATION20,
													},
													&andCodeExpr{
														pos: position{line: 3946, col: 11, offset: 137529},
														run: (*parser).callonINDENTATION21,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "INDENTATION_IGNORE_ADDITIONAL",
			pos:  position{line: 3968, col: 1, offset: 138226},
			expr: &choiceExpr{
				pos: position{line: 3968, col: 34, offset: 138259},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 3968, col: 34, offset: 138259},
						exprs: []interface{}{
							&andCodeExpr{
								pos: position{line: 3968, col: 34, offset: 138259},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL3,
							},
							&ruleRefExpr{
								pos:  position{line: 3971, col: 3, offset: 138396},
								name: "INDENTATION",
							},
						},
					},
					&seqExpr{
						pos: position{line: 3971, col: 17, offset: 138410},
						exprs: []interface{}{
							&andCodeExpr{
								pos: position{line: 3971, col: 17, offset: 138410},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL6,
							},
							&ruleRefExpr{
								pos:  position{line: 3973, col: 3, offset: 138476},
								name: "_INDENTATION_IGNORE_ADDITIONAL",
							},
						},
					},
				},
			},
		},
		{
			name: "_INDENTATION_IGNORE_ADDITIONAL",
			pos:  position{line: 3975, col: 1, offset: 138508},
			expr: &choiceExpr{
				pos: position{line: 3975, col: 35, offset: 138542},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 3976, col: 5, offset: 138548},
						exprs: []interface{}{
							&choiceExpr{
								pos: position{line: 3977, col: 9, offset: 138558},
								alternatives: []interface{}{
									&seqExpr{
										pos: position{line: 3977, col: 9, offset: 138558},
										exprs: []interface{}{
											&andCodeExpr{
												pos: position{line: 3977, col: 9, offset: 138558},
												run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL5,
											},
											&choiceExpr{
												pos: position{line: 3982, col: 13, offset: 138822},
												alternatives: []interface{}{
													&seqExpr{
														pos: position{line: 3982, col: 13, offset: 138822},
														exprs: []interface{}{
															&andExpr{
																pos: position{line: 3982, col: 13, offset: 138822},
																expr: &ruleRefExpr{
																	pos:  position{line: 3982, col: 14, offset: 138823},
																	name: "_",
																},
															},
															&andCodeExpr{
																pos: position{line: 3982, col: 16, offset: 138825},
																run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL10,
															},
														},
													},
													&seqExpr{
														pos: position{line: 3993, col: 17, offset: 139219},
														exprs: []interface{}{
															&notExpr{
																pos: position{line: 3993, col: 17, offset: 139219},
																expr: &ruleRefExpr{
																	pos:  position{line: 3993, col: 18, offset: 139220},
																	name: "_",
																},
															},
															&andCodeExpr{
																pos: position{line: 3993, col: 20, offset: 139222},
																run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL14,
															},
														},
													},
												},
											},
											&stateCodeExpr{
												pos: position{line: 4058, col: 11, offset: 142453},
												run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL15,
											},
										},
									},
									&seqExpr{
										pos: position{line: 4065, col: 13, offset: 142775},
										exprs: []interface{}{
											&andCodeExpr{
												pos: position{line: 4065, col: 13, offset: 142775},
												run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL17,
											},
											&andCodeExpr{
												pos: position{line: 4069, col: 11, offset: 143030},
												run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL18,
											},
										},
									},
								},
							},
							&stateCodeExpr{
								pos: position{line: 4074, col: 7, offset: 143211},
								run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL19,
							},
						},
					},
					&seqExpr{
						pos: position{line: 4078, col: 5, offset: 143288},
						exprs: []interface{}{
							&labeledExpr{
								pos:   position{line: 4078, col: 5, offset: 143288},
								label: "spaceI",
								expr: &actionExpr{
									pos: position{line: 4078, col: 13, offset: 143296},
									run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL22,
									expr: &ruleRefExpr{
										pos:  position{line: 4078, col: 13, offset: 143296},
										name: "_",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 4078, col: 39, offset: 143322},
								run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL24,
							},
							&stateCodeExpr{
								pos: position{line: 4128, col: 3, offset: 145154},
								run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL25,
							},
							&ruleRefExpr{
								pos:  position{line: 4131, col: 3, offset: 145256},
								name: "_INDENTATION_IGNORE_ADDITIONAL",
							},
						},
					},
				},
			},
		},
		{
			name: "INDENT",
			pos:  position{line: 4133, col: 1, offset: 145288},
			expr: &stateCodeExpr{
				pos: position{line: 4133, col: 11, offset: 145298},
				run: (*parser).callonINDENT1,
			},
		},
		{
			name: "DEDENT",
			pos:  position{line: 4138, col: 1, offset: 145393},
			expr: &stateCodeExpr{
				pos: position{line: 4138, col: 11, offset: 145403},
				run: (*parser).callonDEDENT1,
			},
		},
		{
			name: "INDENTATION2",
			pos:  position{line: 4151, col: 1, offset: 145925},
			expr: &choiceExpr{
				pos: position{line: 4151, col: 17, offset: 145941},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 4151, col: 17, offset: 145941},
						exprs: []interface{}{
							&andCodeExpr{
								pos: position{line: 4151, col: 17, offset: 145941},
								run: (*parser).callonINDENTATION23,
							},
							&litMatcher{
								pos:        position{line: 4153, col: 3, offset: 146002},
								val:        "  ",
								ignoreCase: false,
								want:       "\"  \"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 4153, col: 10, offset: 146009},
						exprs: []interface{}{
							&ruleRefExpr{
								pos:  position{line: 4153, col: 10, offset: 146009},
								name: "INDENTATION_IGNORE_ADDITIONAL",
							},
							&litMatcher{
								pos:        position{line: 4153, col: 40, offset: 146039},
								val:        "  ",
								ignoreCase: false,
								want:       "\"  \"",
							},
						},
					},
				},
			},
		},
	},
}

func (c *current) onFile1(extendComments, extendI, importsAndCommentsI, usesAndCommentsI, globalCodeAndFuncI, doctypeCommentsI, doctypeI, scopeI interface{}) (interface{}, error) {
	var f file.File

	f.TopLevelComments = append(f.TopLevelComments, castedOrZero[[]file.CorgiComment](extendComments)...)

	f.Extend = ptrOrNil[file.Extend](extendI)

	if importsAndCommentsI != nil {
		f.Imports = getTuple[[]file.Import](importsAndCommentsI, 0)
		f.TopLevelComments = append(f.TopLevelComments, getTuple[[]file.CorgiComment](importsAndCommentsI, 1)...)
	}

	if usesAndCommentsI != nil {
		f.Uses = getTuple[[]file.Use](usesAndCommentsI, 0)
		f.TopLevelComments = append(f.TopLevelComments, getTuple[[]file.CorgiComment](usesAndCommentsI, 1)...)
	}

	if globalCodeAndFuncI != nil {
		partFile := globalCodeAndFuncI.(file.File)

		f.TopLevelComments = append(f.TopLevelComments, partFile.TopLevelComments...)
		f.GlobalCode = partFile.GlobalCode
		f.Func = partFile.Func
	}

	f.Scope = castedOrZero[file.Scope](scopeI)

	if doctypeI != nil {
		f.Scope = append(file.Scope{doctypeI.(file.Doctype)}, f.Scope...)
	}

	if doctypeCommentsI != nil {
		comments := doctypeCommentsI.([]file.CorgiComment)

		commentScope := make(file.Scope, len(comments))
		for i, comment := range comments {
			commentScope[i] = comment
		}

		f.Scope = append(commentScope, f.Scope...)
	}

	return &f, nil
}

func (p *parser) callonFile1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile1(stack["extendComments"], stack["extendI"], stack["importsAndCommentsI"], stack["usesAndCommentsI"], stack["globalCodeAndFuncI"], stack["doctypeCommentsI"], stack["doctypeI"], stack["scopeI"])
}

func (c *current) onimportsAndComments1(valsI interface{}) (interface{}, error) {
	tuples := islice(valsI)

	var comments []file.CorgiComment
	var imports []file.Import

	for _, t := range tuples {
		comments = append(comments, castedOrZero[[]file.CorgiComment](islice(t)[0])...)
		imports = append(imports, getTuple[[]file.Import](t, -1)...)
	}

	return []any{imports, comments}, nil
}

func (p *parser) callonimportsAndComments1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments1(stack["valsI"])
}

func (c *current) onusesAndComments1(valsI interface{}) (interface{}, error) {
	tuples := islice(valsI)

	var comments []file.CorgiComment
	var uses []file.Use

	for _, t := range tuples {
		comments = append(comments, castedOrZero[[]file.CorgiComment](islice(t)[0])...)
		uses = append(uses, getTuple[[]file.Use](t, -1)...)
	}

	return []any{uses, comments}, nil
}

func (p *parser) callonusesAndComments1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments1(stack["valsI"])
}

func (c *current) oncodesAndComments1(valsI interface{}) (interface{}, error) {
	tuples := islice(valsI)

	var comments []file.CorgiComment
	var codes []file.Code

	for _, t := range tuples {
		comments = append(comments, castedOrZero[[]file.CorgiComment](islice(t)[0])...)
		codes = append(codes, getTuple[[]file.Code](t, -1)...)
	}

	return []any{codes, comments}, nil
}

func (p *parser) calloncodesAndComments1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncodesAndComments1(stack["valsI"])
}

func (c *current) onglobalCodeAndFunc1(codesAndCommentsI, commentsI, funcI interface{}) (interface{}, error) {
	var f file.File

	if codesAndCommentsI != nil {
		f.GlobalCode = getTuple[[]file.Code](codesAndCommentsI, 0)
		f.TopLevelComments = append(f.TopLevelComments, getTuple[[]file.CorgiComment](codesAndCommentsI, 1)...)
	}

	if commentsI != nil {
		f.TopLevelComments = append(f.TopLevelComments, commentsI.([]file.CorgiComment)...)
	}

	fun := funcI.(file.Func)
	f.Func = &fun

	return f, nil
}

func (p *parser) callonglobalCodeAndFunc1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onglobalCodeAndFunc1(stack["codesAndCommentsI"], stack["commentsI"], stack["funcI"])
}

func (c *current) oninit1() error {
	c.state["Indentation.Level"] = 0       // the lvl we are in rn
	c.state["Indentation.Char"] = byte(0)  // the char used for indentation
	c.state["Indentation.Repetitions"] = 0 // num of repetitions of char per lvl
	c.state["Indentation.RefLine"] = 0     // the line no where we got char and repetitions from

	// a stack containing the actual number of repetitions of char per lvl
	// used to recover from inconsistent indentations errs
	c.state["Indentation.ActualRepetitions"] = &stack.Stack[int]{}
	c.state["Indentation.TotalRepetitions"] = 0 // sum of the stack above

	// used by INDENTATION_NO_INCREASE to count how many chars it has found
	c.state["Indentation.CharCount"] = 0
	return nil
}

func (p *parser) calloninit1() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oninit1()
}

func (c *current) onScope1(itemsI interface{}) (interface{}, error) {
	itemTuples := islice(itemsI)

	scope := make(file.Scope, 0, len(itemTuples))
	for _, it := range itemTuples {
		tuple := islice(it)
		if si, ok := tuple[len(tuple)-1].(file.ScopeItem); ok {
			scope = append(scope, si)
		}
	}

	return scope, nil
}

func (p *parser) callonScope1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope1(stack["itemsI"])
}

func (c *current) onscopeDoctype1(doctypeI interface{}) (interface{}, error) {
	return doctypeI, &corgierr.Error{
		Message: "`doctype` not first item",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             pos(c),
			ToEOL:             true,
			Annotation:        "cannot place doctype directive here",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "`doctype`s may only be placed as the first element after the `func` declaration\n" +
					"remove this `doctype` and move it right under the `func` of your file, if there isn't a doctype there already",
			},
		},
	}
}

func (p *parser) callonscopeDoctype1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeDoctype1(stack["doctypeI"])
}

func (c *current) onBody1(scopeI interface{}) (interface{}, error) {
	return scopeI, nil
}

func (p *parser) callonBody1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBody1(stack["scopeI"])
}

func (c *current) onBeaitb2(scopeItemI interface{}) (interface{}, error) {
	return file.Scope{scopeItemI.(file.ScopeItem)}, nil
}

func (p *parser) callonBeaitb2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb2(stack["scopeItemI"])
}

func (c *current) onBeaitb7(bodyI interface{}) (interface{}, error) {
	return bodyI, nil
}

func (p *parser) callonBeaitb7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb7(stack["bodyI"])
}

func (c *current) onBeaitb12() (interface{}, error) {
	return file.Scope(nil), nil
}

func (p *parser) callonBeaitb12() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb12()
}

func (c *current) onBeaitb14(lineI, bodyI interface{}) (interface{}, error) {
	return file.Scope{file.BadItem{
			Line:     concat(lineI),
			Body:     castedOrZero[file.Scope](bodyI),
			Position: pos(c),
		}}, &corgierr.Error{
			Message: "unexpected tokens",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				ToEOL:      true,
				Annotation: "expected a block expansion (`:`), an assign (`=` or `!=`), inline text, a body, or nothing",
			}),
		}
}

func (p *parser) callonBeaitb14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb14(stack["lineI"], stack["bodyI"])
}

func (c *current) onBeait2(scopeItemI interface{}) (interface{}, error) {
	return file.Scope{scopeItemI.(file.ScopeItem)}, nil
}

func (p *parser) callonBeait2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeait2(stack["scopeItemI"])
}

func (c *current) onBeait7() (interface{}, error) {
	return file.Scope(nil), nil
}

func (p *parser) callonBeait7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeait7()
}

func (c *current) onBeait9(lineI interface{}) (interface{}, error) {
	return file.Scope{file.BadItem{
			Line:     concat(lineI),
			Position: pos(c),
		}}, &corgierr.Error{
			Message: "unexpected tokens",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				ToEOL:      true,
				Annotation: "expected a block expansion (`:`), an assign (`=` or `!=`), inline text, or nothing",
			}),
		}
}

func (p *parser) callonBeait9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeait9(stack["lineI"])
}

func (c *current) onBadItem1(lineI, bodyI interface{}) (interface{}, error) {
	line := concat(lineI)

	firstWordLen := strings.IndexByte(line, ' ')
	if firstWordLen <= 0 {
		firstWordLen = len([]rune(line))
	}

	return file.BadItem{
			Line:     line,
			Body:     castedOrZero[file.Scope](bodyI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unrecognized directive or invalid element name",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Len:        firstWordLen,
				Annotation: "expected a valid corgi directive or an element name",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "if this is supposed to be an element name, make sure it conforms to the HTML spec"},
				{
					Suggestion: "use a valid corgi directive",
					ShouldBe: "a block (`block`, `append`, `prepend`), code (`-`), a conditional (`if`, `else if`, `else`, `switch`),\n" +
						"a loop (`for`), a filter (`:`), an include (`include`), a mixin (`mixin`), a mixin call (`+`),\n" +
						"a Go import (`import`), a corgi use (`use`), the func header (`func`),\n" +
						"an assign (`=`, `!=`), an arrow block (`>`)",
				},
			},
		}
}

func (p *parser) callonBadItem1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBadItem1(stack["lineI"], stack["bodyI"])
}

func (c *current) onBlock1(blockI, bodyI interface{}) (interface{}, error) {
	block := blockI.(file.Block)
	block.Body = bodyI.(file.Scope)
	return block, nil
}

func (p *parser) callonBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock1(stack["blockI"], stack["bodyI"])
}

func (c *current) onInlineBlock1(blockI, scopeI interface{}) (interface{}, error) {
	block := blockI.(file.Block)
	block.Body = castedOrZero[file.Scope](scopeI)
	return block, nil
}

func (p *parser) callonInlineBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock1(stack["blockI"], stack["scopeI"])
}

func (c *current) onPrepend1(blockI, bodyI interface{}) (interface{}, error) {
	block := blockI.(file.Block)
	block.Body = bodyI.(file.Scope)
	return block, nil
}

func (p *parser) callonPrepend1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend1(stack["blockI"], stack["bodyI"])
}

func (c *current) onAppend1(blockI, bodyI interface{}) (interface{}, error) {
	block := blockI.(file.Block)
	block.Body = bodyI.(file.Scope)
	return block, nil
}

func (p *parser) callonAppend1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend1(stack["blockI"], stack["bodyI"])
}

func (c *current) onblockDirective1(nameI interface{}) (interface{}, error) {
	name := nameI.(file.Ident)
	return file.Block{
		Type:     file.BlockTypeBlock,
		Name:     name,
		Position: pos(c),
	}, nil
}

func (p *parser) callonblockDirective1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onblockDirective1(stack["nameI"])
}

func (c *current) onprependDirective1(nameI interface{}) (interface{}, error) {
	name := nameI.(file.Ident)
	return file.Block{
		Type:     file.BlockTypePrepend,
		Name:     name,
		Position: pos(c),
	}, nil
}

func (p *parser) callonprependDirective1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onprependDirective1(stack["nameI"])
}

func (c *current) onappendDirective1(nameI interface{}) (interface{}, error) {
	name := nameI.(file.Ident)
	return file.Block{
		Type:     file.BlockTypeAppend,
		Name:     name,
		Position: pos(c),
	}, nil
}

func (p *parser) callonappendDirective1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onappendDirective1(stack["nameI"])
}

func (c *current) onblockName2(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonblockName2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onblockName2(stack["identI"])
}

func (c *current) onblockName8() (interface{}, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonblockName8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onblockName8()
}

func (c *current) onBlockExpansion1(sI interface{}) (interface{}, error) {
	return file.BlockExpansion{
		Item:     sI.(file.ScopeItem),
		Position: pos(c),
	}, nil
}

func (p *parser) callonBlockExpansion1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockExpansion1(stack["sI"])
}

func (c *current) onspacedBlockExpansionItem2(sI interface{}) (interface{}, error) {
	return sI, nil
}

func (p *parser) callonspacedBlockExpansionItem2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onspacedBlockExpansionItem2(stack["sI"])
}

func (c *current) onspacedBlockExpansionItem8(posI, sI interface{}) (interface{}, error) {
	var fromThe string
	switch sI.(type) {
	case file.Block:
		fromThe = "block"
	case file.Element:
		fromThe = "inline element"
	case file.DivShorthand:
		fromThe = "div shorthand"
	case file.MixinCall:
		fromThe = "mixin call"
	case file.And:
		fromThe = "&"
	default:
		fromThe = "rest"
	}

	return file.BlockExpansion{
			Item:     sI.(file.ScopeItem),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing space",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a space here, separating the `:` from the " + fromThe,
			}),
		}
}

func (p *parser) callonspacedBlockExpansionItem8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onspacedBlockExpansionItem8(stack["posI"], stack["sI"])
}

func (c *current) onbadBlockExpansion1(lineI interface{}) (interface{}, error) {
	firstWordLen := strings.IndexByte(string(c.text), ' ')
	if firstWordLen <= 0 {
		firstWordLen = len([]rune(string(c.text)))
	}

	bi := file.BadItem{
		Line:     concat(lineI),
		Position: pos(c),
	}

	var suggestions []corgierr.Suggestion
	if bi.Line != "" {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "if this is supposed to be an element name, make sure it conforms to the HTML spec",
		})
	}

	return bi, &corgierr.Error{
		Message: "malformed block expansion",
		ErrorAnnotation: anno(c, annotation{
			Start: pos(c),
			Len:   firstWordLen,
			Annotation: "expected a block directive, an inline element, an inline arrow block,\n" +
				"a mixin call, or inline &-attributes",
		}),
		Suggestions: suggestions,
	}
}

func (p *parser) callonbadBlockExpansion1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onbadBlockExpansion1(stack["lineI"])
}

func (c *current) onCodes1(codesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.Code](codesI, 1), nil
}

func (p *parser) callonCodes1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCodes1(stack["codesI"])
}

func (c *current) onCode2(firstLineI, additionalLinesI interface{}) (interface{}, error) {
	additionalLineTuples := islice(additionalLinesI)

	lines := make([]file.CodeLine, 1+len(additionalLineTuples))
	lines[0] = firstLineI.(file.CodeLine)
	for i, lt := range additionalLineTuples {
		lines[i+1] = getTuple[file.CodeLine](lt, -1)
	}

	return file.Code{
		Lines:    lines,
		Position: pos(c),
	}, nil
}

func (p *parser) callonCode2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode2(stack["firstLineI"], stack["additionalLinesI"])
}

func (c *current) onCode14(posI interface{}) (interface{}, error) {
	return file.Code{Position: pos(c)}, &corgierr.Error{
		Message: "empty code block",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected code here",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "either write some code, or delete this line"},
		},
	}
}

func (p *parser) callonCode14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode14(stack["posI"])
}

func (c *current) oncodeSpec1(code interface{}) (interface{}, error) {
	return file.CodeLine{Code: concat(code), Position: pos(c)}, nil
}

func (p *parser) calloncodeSpec1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncodeSpec1(stack["code"])
}

func (c *current) oncondition2(condI interface{}) (interface{}, error) {
	return condI, nil
}

func (p *parser) calloncondition2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition2(stack["condI"])
}

func (c *current) oncondition8(posI interface{}) (interface{}, error) {
	return file.Expression{}, &corgierr.Error{
		Message: "missing condition",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			Annotation:  "expected an expression here",
		}),
	}
}

func (p *parser) calloncondition8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition8(stack["posI"])
}

func (c *current) oncondition14(posI interface{}) (interface{}, error) {
	return file.Expression{}, &corgierr.Error{
		Message: "missing condition",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an expression here",
		}),
	}
}

func (p *parser) calloncondition14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition14(stack["posI"])
}

func (c *current) onthen2(scopeI interface{}) (interface{}, error) {
	return scopeI, nil
}

func (p *parser) callonthen2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen2(stack["scopeI"])
}

func (c *current) onthen7(beI interface{}) (interface{}, error) {
	return file.Scope{beI.(file.BlockExpansion)}, nil
}

func (p *parser) callonthen7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen7(stack["beI"])
}

func (c *current) onthen10() (interface{}, error) {
	return file.Scope(nil), &corgierr.Error{
		Message: "missing body",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected an indented body or a block expansion",
		}),
	}
}

func (p *parser) callonthen10() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen10()
}

func (c *current) onthen14() (interface{}, error) {
	return c.text, nil
}

func (p *parser) callonthen14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen14()
}

func (c *current) onthen17() (bool, error) {
	return true, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected an indented body or a block expansion",
		}),
	}

}

func (p *parser) callonthen17() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen17()
}

func (c *current) onIf1(condI, thenI, elseIfsI, elseI interface{}) (interface{}, error) {
	return file.If{
		Condition: condI.(file.Expression),
		Then:      thenI.(file.Scope),
		ElseIfs:   typedSlice[file.ElseIf](elseIfsI),
		Else:      ptrOrNil[file.Else](elseI),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonIf1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIf1(stack["condI"], stack["thenI"], stack["elseIfsI"], stack["elseI"])
}

func (c *current) onElseIf1(posI, condI, thenI interface{}) (interface{}, error) {
	return file.ElseIf{
		Condition: condI.(file.Expression),
		Then:      thenI.(file.Scope),
		Position:  posI.(file.Position),
	}, nil
}

func (p *parser) callonElseIf1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf1(stack["posI"], stack["condI"], stack["thenI"])
}

func (c *current) onElse1(thenI interface{}) (interface{}, error) {
	return file.Else{
		Then:     thenI.(file.Scope),
		Position: pos(c),
	}, nil
}

func (p *parser) callonElse1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse1(stack["thenI"])
}

func (c *current) onIfBlock1(nameI, thenI, elseIfsI, elseI interface{}) (interface{}, error) {
	return file.IfBlock{
		Name:     nameI.(file.Ident),
		Then:     thenI.(file.Scope),
		ElseIfs:  typedSlice[file.ElseIfBlock](elseIfsI),
		Else:     ptrOrNil[file.Else](elseI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonIfBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock1(stack["nameI"], stack["thenI"], stack["elseIfsI"], stack["elseI"])
}

func (c *current) onElseIfBlock1(posI, nameI, thenI interface{}) (interface{}, error) {
	return file.ElseIfBlock{
		Name:     nameI.(file.Ident),
		Then:     thenI.(file.Scope),
		Position: posI.(file.Position),
	}, nil
}

func (p *parser) callonElseIfBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock1(stack["posI"], stack["nameI"], stack["thenI"])
}

func (c *current) onElseBlock1(thenI interface{}) (interface{}, error) {
	return file.Else{
		Then:     thenI.(file.Scope),
		Position: pos(c),
	}, nil
}

func (p *parser) callonElseBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseBlock1(stack["thenI"])
}

func (c *current) onSwitch1(comparatorI, bodyI interface{}) (interface{}, error) {
	body := bodyI.(file.Switch)

	s := file.Switch{
		Comparator: comparatorI.(*file.Expression),
		Cases:      body.Cases,
		Default:    body.Default,
		Position:   pos(c),
	}

	if len(s.Cases) == 0 {
		return s, &corgierr.Error{
			Message: "switch must have at least one case",
			ErrorAnnotation: anno(c, annotation{
				ContextEndDelta: 1,
				Start:           pos(c),
				ToEOL:           true,
				Annotation:      "expected switch to have at least one non-default case",
			}),
		}
	}

	return s, nil
}

func (p *parser) callonSwitch1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSwitch1(stack["comparatorI"], stack["bodyI"])
}

func (c *current) onswitchComparator2() (interface{}, error) {
	return (*file.Expression)(nil), nil
}

func (p *parser) callonswitchComparator2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchComparator2()
}

func (c *current) onswitchComparator4(compI interface{}) (interface{}, error) {
	comp := compI.(file.Expression)
	return &comp, nil
}

func (p *parser) callonswitchComparator4() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchComparator4(stack["compI"])
}

func (c *current) onswitchComparator11(compI, startPosI interface{}) (interface{}, error) {
	comp := compI.(file.Expression)
	return &comp, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			Annotation: "expression was terminated here, but should span entire line",
		}),
	}
}

func (p *parser) callonswitchComparator11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchComparator11(stack["compI"], stack["startPosI"])
}

func (c *current) onswitchBody1(itms interface{}) (interface{}, error) {
	tupleTuples := islice(itms)

	s := file.Switch{Cases: make([]file.Case, 0, len(tupleTuples))}

	var err error
	for _, tupleTuple := range tupleTuples {
		tuple := getTuple[any](tupleTuple, -1)

		switchCase, ok := getTuple[file.Case](tuple, 0), getTuple[bool](tuple, -1)
		if switchCase.Expression != nil || !ok {
			s.Cases = append(s.Cases, switchCase)
		} else {
			if s.Default != nil {
				err = &corgierr.Error{
					Message: "multiple default cases in switch",
					ErrorAnnotation: anno(c, annotation{
						Start:      switchCase.Position,
						Len:        len("default"),
						Annotation: "second default case",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      s.Default.Position,
							Len:        len("default"),
							Annotation: "first default case",
						}),
					},
				}
			} else {
				s.Default = &switchCase
			}
		}
	}

	return s, err
}

func (p *parser) callonswitchBody1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody1(stack["itms"])
}

func (c *current) onswitchBodyItem2(caseI interface{}) (interface{}, error) {
	return []any{caseI, true}, nil
}

func (p *parser) callonswitchBodyItem2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBodyItem2(stack["caseI"])
}

func (c *current) onswitchBodyItem7(caseI interface{}) (interface{}, error) {
	return []any{caseI, false}, nil
}

func (p *parser) callonswitchBodyItem7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBodyItem7(stack["caseI"])
}

func (c *current) onCase1(condI, thenI interface{}) (interface{}, error) {
	return file.Case{
		Expression: ptrOrNil[file.Expression](condI),
		Then:       thenI.(file.Scope),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonCase1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCase1(stack["condI"], stack["thenI"])
}

func (c *current) onDefault1(thenI interface{}) (interface{}, error) {
	return file.Case{
		Then:     thenI.(file.Scope),
		Position: pos(c),
	}, nil
}

func (p *parser) callonDefault1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDefault1(stack["thenI"])
}

func (c *current) onBadCase1(bodyI interface{}) (interface{}, error) {
	firstWordLen := strings.IndexByte(string(c.text), ' ')
	if firstWordLen <= 0 {
		firstWordLen = len([]rune(string(c.text)))
	}

	return file.Case{
			Then:     castedOrZero[file.Scope](bodyI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unrecognized directive in switch body",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Len:        firstWordLen,
				Annotation: "expected a case or a default",
			}),
		}
}

func (p *parser) callonBadCase1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBadCase1(stack["bodyI"])
}

func (c *current) onFor1(exprI, bodyI interface{}) (interface{}, error) {
	return file.For{
		Expression: exprI.(*file.Expression),
		Body:       bodyI.(file.Scope),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonFor1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFor1(stack["exprI"], stack["bodyI"])
}

func (c *current) onIdent2(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonIdent2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIdent2(stack["identI"])
}

func (c *current) onIdent5(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonIdent5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIdent5(stack["identI"], stack["endPosI"])
}

func (c *current) onMustIdent2(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonMustIdent2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMustIdent2(stack["identI"])
}

func (c *current) onMustIdent5(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMustIdent5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMustIdent5(stack["posI"])
}

func (c *current) onMustIdent17(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMustIdent17() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMustIdent17(stack["identI"], stack["endPosI"])
}

func (c *current) onMustIdentIfText2(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonMustIdentIfText2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMustIdentIfText2(stack["identI"])
}

func (c *current) onMustIdentIfText5(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMustIdentIfText5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMustIdentIfText5(stack["identI"], stack["endPosI"])
}

func (c *current) onrawString2(strI interface{}) (interface{}, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonrawString2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onrawString2(stack["strI"])
}

func (c *current) onrawString9(strI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonrawString9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onrawString9(stack["strI"])
}

func (c *current) oninterpretedString2(strI interface{}) (interface{}, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) calloninterpretedString2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oninterpretedString2(stack["strI"])
}

func (c *current) oninterpretedString12(strI, endPosI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) calloninterpretedString12() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oninterpretedString12(stack["strI"], stack["endPosI"])
}

func (c *current) onsingleQuoteString1(strI, endPosI interface{}) (interface{}, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonsingleQuoteString1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleQuoteString1(stack["strI"], stack["endPosI"])
}

func (c *current) onCorgiComments1(commentsI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.CorgiComment](commentsI, -1), nil
}

func (p *parser) callonCorgiComments1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCorgiComments1(stack["commentsI"])
}

func (c *current) onCorgiComment1(linesI interface{}) (interface{}, error) {
	return file.CorgiComment{
		Lines:    linesI.([]file.CorgiCommentLine),
		Position: pos(c),
	}, nil
}

func (p *parser) callonCorgiComment1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCorgiComment1(stack["linesI"])
}

func (c *current) oncorgiCommentLines2(linesI interface{}) (interface{}, error) {
	return linesI, nil
}

func (p *parser) calloncorgiCommentLines2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentLines2(stack["linesI"])
}

func (c *current) oncorgiCommentLines9(lineI interface{}) (interface{}, error) {
	return []file.CorgiCommentLine{lineI.(file.CorgiCommentLine)}, nil
}

func (p *parser) calloncorgiCommentLines9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentLines9(stack["lineI"])
}

func (c *current) oncorgiCommentBlock1(linesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.CorgiCommentLine](linesI, -1), nil
}

func (p *parser) calloncorgiCommentBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentBlock1(stack["linesI"])
}

func (c *current) oncorgiCommentLine1(commentI interface{}) (interface{}, error) {
	return file.CorgiCommentLine{Comment: concat(commentI), Position: pos(c)}, nil
}

func (p *parser) calloncorgiCommentLine1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentLine1(stack["commentI"])
}

func (c *current) onDoctype2() (interface{}, error) {
	return file.Doctype{Position: pos(c)}, nil
}

func (p *parser) callonDoctype2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoctype2()
}

func (c *current) onDoctype6() (interface{}, error) {
	return file.Doctype{Position: pos(c)}, &corgierr.Error{
		Message: "the corgi doctype directive does not start with a `!`",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "remove this",
		}),
		ShouldBe: "`doctype html`",
	}
}

func (p *parser) callonDoctype6() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoctype6()
}

func (c *current) onbehindDoctype5(startPosI interface{}) (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			ToEOL:      true,
			Annotation: "doctypes other than the HTML5 doctype are not supported",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonbehindDoctype5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onbehindDoctype5(stack["startPosI"])
}

func (c *current) onbehindDoctype13() (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected `html`",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonbehindDoctype13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onbehindDoctype13()
}

func (c *current) onHTMLComment6(linesI interface{}) (interface{}, error) {
	return linesI, nil

}

func (p *parser) callonHTMLComment6() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLComment6(stack["linesI"])
}

func (c *current) onHTMLComment11(lineI interface{}) (interface{}, error) {
	return []file.HTMLCommentLine{lineI.(file.HTMLCommentLine)}, nil

}

func (p *parser) callonHTMLComment11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLComment11(stack["lineI"])
}

func (c *current) onHTMLComment1(linesI interface{}) (interface{}, error) {
	return file.HTMLComment{
		Lines:    linesI.([]file.HTMLCommentLine),
		Position: pos(c),
	}, nil
}

func (p *parser) callonHTMLComment1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLComment1(stack["linesI"])
}

func (c *current) onhtmlCommentBlock1(linesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.HTMLCommentLine](linesI, -1), nil
}

func (p *parser) callonhtmlCommentBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onhtmlCommentBlock1(stack["linesI"])
}

func (c *current) onhtmlCommentLine1(commentI interface{}) (interface{}, error) {
	return file.HTMLCommentLine{Comment: concat(commentI), Position: pos(c)}, nil
}

func (p *parser) callonhtmlCommentLine1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onhtmlCommentLine1(stack["commentI"])
}

func (c *current) onElement1(nameI, attrsI, voidI, bodyI interface{}) (interface{}, error) {
	return file.Element{
		Name:       concat(nameI),
		Attributes: typedSlice[file.AttributeCollection](attrsI),
		Body:       bodyI.(file.Scope),
		Void:       voidI != nil,
		Position:   pos(c),
	}, nil
}

func (p *parser) callonElement1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElement1(stack["nameI"], stack["attrsI"], stack["voidI"], stack["bodyI"])
}

func (c *current) onInlineElement1(nameI, attrsI, voidI, bodyI interface{}) (interface{}, error) {
	return file.Element{
		Name:       concat(nameI),
		Attributes: typedSlice[file.AttributeCollection](attrsI),
		Body:       bodyI.(file.Scope),
		Void:       voidI != nil,
		Position:   pos(c),
	}, nil
}

func (p *parser) callonInlineElement1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineElement1(stack["nameI"], stack["attrsI"], stack["voidI"], stack["bodyI"])
}

func (c *current) onDivShorthand1(firstAttrI, moreAttrsI, bodyI interface{}) (interface{}, error) {
	return file.DivShorthand{
		Attributes: append([]file.AttributeCollection{firstAttrI.(file.AttributeCollection)}, typedSlice[file.AttributeCollection](moreAttrsI)...),
		Body:       bodyI.(file.Scope),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonDivShorthand1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand1(stack["firstAttrI"], stack["moreAttrsI"], stack["bodyI"])
}

func (c *current) onInlineDivShorthand1(firstAttrI, moreAttrsI, bodyI interface{}) (interface{}, error) {
	return file.DivShorthand{
		Attributes: append([]file.AttributeCollection{firstAttrI.(file.AttributeCollection)}, typedSlice[file.AttributeCollection](moreAttrsI)...),
		Body:       bodyI.(file.Scope),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonInlineDivShorthand1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand1(stack["firstAttrI"], stack["moreAttrsI"], stack["bodyI"])
}

func (c *current) onAnd2(collsI interface{}) (interface{}, error) {
	return file.And{
		Attributes: typedSlice[file.AttributeCollection](collsI),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonAnd2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd2(stack["collsI"])
}

func (c *current) onAnd9(posI interface{}) (interface{}, error) {
	return file.And{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "`&` with no attributes",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an attribute here",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "write a class shorthand", Example: "`&.woof`"},
				{Suggestion: "write an id shorthand", Example: "`&#bark`"},
				{Suggestion: "write an attribute list", Example: "`&(src=\"bark/woof\", title=\"howl\")`"},
			},
		}
}

func (p *parser) callonAnd9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd9(stack["posI"])
}

func (c *current) onAnd15(collsI, posI interface{}) (interface{}, error) {
	return file.And{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "bad attribute syntax",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "this is not a valid attribute (list)",
			}),
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "if there is, remove any whitespace between class/id shorthands and attribute lists",
					Example:    "`&#bark .woof (title=\"howl\")`",
					ShouldBe:   "`&#bark.woof(title=\"howl\")`",
				},
				{Suggestion: "write a class shorthand", Example: "`&.woof`"},
				{Suggestion: "write an id shorthand", Example: "`&#bark`"},
				{Suggestion: "write an attribute list", Example: "`&(src=\"bark/woof\", title=\"howl\")`"},
			},
		}
}

func (p *parser) callonAnd15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd15(stack["collsI"], stack["posI"])
}

func (c *current) onInlineAnd2(collsI interface{}) (interface{}, error) {
	return file.And{
		Attributes: typedSlice[file.AttributeCollection](collsI),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonInlineAnd2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineAnd2(stack["collsI"])
}

func (c *current) onInlineAnd9(posI interface{}) (interface{}, error) {
	return file.And{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "`&` with no attributes",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an attribute here",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "write a class shorthand", Example: "`&.woof`"},
				{Suggestion: "write an id shorthand", Example: "`&#bark`"},
				{Suggestion: "write an attribute list", Example: "`&(src=\"bark/woof\", title=\"howl\")`"},
			},
		}
}

func (p *parser) callonInlineAnd9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineAnd9(stack["posI"])
}

func (c *current) onInlineAnd15(collsI, posI interface{}) (interface{}, error) {
	return file.And{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "bad attribute syntax",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "this is not a valid attribute (list)",
			}),
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "if there is, remove any whitespace between class/id shorthands and attribute lists",
					Example:    "`&#bark .woof (title=\"howl\")`",
					ShouldBe:   "`&#bark.woof(title=\"howl\")`",
				},
				{Suggestion: "write a class shorthand", Example: "`&.woof`"},
				{Suggestion: "write an id shorthand", Example: "`&#bark`"},
				{Suggestion: "write an attribute list", Example: "`&(src=\"bark/woof\", title=\"howl\")`"},
			},
		}
}

func (p *parser) callonInlineAnd15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineAnd15(stack["collsI"], stack["posI"])
}

func (c *current) onIDShorthand2(idI interface{}) (interface{}, error) {
	return file.IDShorthand{
		ID:       concat(idI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonIDShorthand2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIDShorthand2(stack["idI"])
}

func (c *current) onIDShorthand8(posI interface{}) (interface{}, error) {
	return file.IDShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "id shorthand: missing id",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an id here",
		}),
	}
}

func (p *parser) callonIDShorthand8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIDShorthand8(stack["posI"])
}

func (c *current) onClassShorthand2(nameI interface{}) (interface{}, error) {
	return file.ClassShorthand{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonClassShorthand2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onClassShorthand2(stack["nameI"])
}

func (c *current) onClassShorthand8(posI interface{}) (interface{}, error) {
	return file.ClassShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "class shorthand: missing class name",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected a class name here",
		}),
	}
}

func (p *parser) callonClassShorthand8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onClassShorthand8(stack["posI"])
}

func (c *current) onAttributeList2(attributesI, rParenPosI interface{}) (interface{}, error) {
	return file.AttributeList{
		LParenPos:  pos(c),
		Attributes: castedOrZero[[]file.Attribute](attributesI),
		RParenPos:  rParenPosI.(file.Position),
	}, nil
}

func (p *parser) callonAttributeList2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList2(stack["attributesI"], stack["rParenPosI"])
}

func (c *current) onAttributeList19(attributesI, posI interface{}) (interface{}, error) {
	return file.AttributeList{
			LParenPos:  pos(c),
			Attributes: castedOrZero[[]file.Attribute](attributesI),
		}, &corgierr.Error{
			Message: "attribute list: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonAttributeList19() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList19(stack["attributesI"], stack["posI"])
}

func (c *current) onattributes1(firstI, restI interface{}) (interface{}, error) {
	restIs := islice(restI)
	attributes := make([]file.Attribute, 1+len(restIs))
	attributes[0] = firstI.(file.Attribute)
	for i, ai := range restIs {
		attributes[i+1] = getTuple[file.Attribute](ai, -1)
	}

	return attributes, nil
}

func (p *parser) callonattributes1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onattributes1(stack["firstI"], stack["restI"])
}

func (c *current) onSingleLineAttributeList2(attributesI, rParenPosI interface{}) (interface{}, error) {
	return file.AttributeList{
		LParenPos:  pos(c),
		Attributes: castedOrZero[[]file.Attribute](attributesI),
		RParenPos:  rParenPosI.(file.Position),
	}, nil
}

func (p *parser) callonSingleLineAttributeList2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeList2(stack["attributesI"], stack["rParenPosI"])
}

func (c *current) onSingleLineAttributeList19(attributesI, posI interface{}) (interface{}, error) {
	return file.AttributeList{
			LParenPos:  pos(c),
			Attributes: castedOrZero[[]file.Attribute](attributesI),
		}, &corgierr.Error{
			Message: "attribute list: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonSingleLineAttributeList19() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeList19(stack["attributesI"], stack["posI"])
}

func (c *current) onsingleLineAttributes1(firstI, restI interface{}) (interface{}, error) {
	restIs := islice(restI)
	attributes := make([]file.Attribute, 1+len(restIs))
	attributes[0] = firstI.(file.Attribute)
	for i, ai := range restIs {
		attributes[i+1] = getTuple[file.Attribute](ai, -1)
	}

	return attributes, nil
}

func (p *parser) callonsingleLineAttributes1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineAttributes1(stack["firstI"], stack["restI"])
}

func (c *current) onsimpleValueAttribute2(nameI, assignPosI, posI, exprI interface{}) (interface{}, error) {
	return file.SimpleAttribute{
		Name:      concat(nameI),
		AssignPos: ptr(assignPosI.(file.Position)),
		Value:     ptrOrNil[file.Expression](exprI),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonsimpleValueAttribute2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute2(stack["nameI"], stack["assignPosI"], stack["posI"], stack["exprI"])
}

func (c *current) onsimpleValueAttribute17(nameI, assignPosI, posI interface{}) (interface{}, error) {
	return file.SimpleAttribute{
			Name:      concat(nameI),
			AssignPos: ptrOrNil[file.Position](assignPosI),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "attribute: missing value expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an expression here",
			}),
		}
}

func (p *parser) callonsimpleValueAttribute17() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute17(stack["nameI"], stack["assignPosI"], stack["posI"])
}

func (c *current) onsingleLineSimpleValueAttribute2(nameI, assignPosI, exprI interface{}) (interface{}, error) {
	return file.SimpleAttribute{
		Name:      concat(nameI),
		AssignPos: ptrOrNil[file.Position](assignPosI),
		Value:     ptrOrNil[file.Expression](exprI),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonsingleLineSimpleValueAttribute2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute2(stack["nameI"], stack["assignPosI"], stack["exprI"])
}

func (c *current) onsingleLineSimpleValueAttribute15(nameI, assignPosI, posI interface{}) (interface{}, error) {
	return file.SimpleAttribute{
			Name:      concat(nameI),
			AssignPos: ptrOrNil[file.Position](assignPosI),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "attribute: missing value expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an expression or a mixin call here",
			}),
		}
}

func (p *parser) callonsingleLineSimpleValueAttribute15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute15(stack["nameI"], stack["assignPosI"], stack["posI"])
}

func (c *current) onsimpleBooleanAttribute1(nameI interface{}) (interface{}, error) {
	return file.SimpleAttribute{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonsimpleBooleanAttribute1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleBooleanAttribute1(stack["nameI"])
}

func (c *current) onAndPlaceholder1() (interface{}, error) {
	return file.AndPlaceholder{Position: pos(c)}, nil
}

func (p *parser) callonAndPlaceholder1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAndPlaceholder1()
}

func (c *current) onMixinCallAttribute1(nameI, assignPosI, callI interface{}) (interface{}, error) {
	call := callI.(file.MixinCallAttribute)
	return file.MixinCallAttribute{
		Name:      concat(nameI),
		AssignPos: assignPosI.(file.Position),
		MixinCall: call.MixinCall,
		Value:     call.Value,
		Position:  pos(c),
	}, nil
}

func (p *parser) callonMixinCallAttribute1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallAttribute1(stack["nameI"], stack["assignPosI"], stack["callI"])
}

func (c *current) onSingleLineMixinCallAttribute1(nameI, assignPosI, callI interface{}) (interface{}, error) {
	call := callI.(file.MixinCallAttribute)
	return file.MixinCallAttribute{
		Name:      concat(nameI),
		AssignPos: assignPosI.(file.Position),
		MixinCall: call.MixinCall,
		Value:     call.Value,
		Position:  pos(c),
	}, nil
}

func (p *parser) callonSingleLineMixinCallAttribute1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineMixinCallAttribute1(stack["nameI"], stack["assignPosI"], stack["callI"])
}

func (c *current) onmixinCallAttributeCall1(namespaceI, nameI, argsI, valueI interface{}) (interface{}, error) {
	args := castedOrZero[file.MixinCall](argsI)

	var namespace *file.Ident
	if namespaceI != nil {
		namespace = ptr(getTuple[file.Ident](namespaceI, 0))
	}

	return file.MixinCallAttribute{
		MixinCall: file.MixinCall{
			Namespace: namespace,
			Name:      nameI.(file.Ident),
			LParenPos: args.LParenPos,
			Args:      args.Args,
			RParenPos: args.RParenPos,
			Position:  pos(c),
		},
		Value: castedOrZero[file.InterpolationValue](valueI),
	}, nil
}

func (p *parser) callonmixinCallAttributeCall1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["valueI"])
}

func (c *current) onsingleLineMixinCallAttributeCall1(namespaceI, nameI, argsI, valueI interface{}) (interface{}, error) {
	args := castedOrZero[file.MixinCall](argsI)

	var namespace *file.Ident
	if namespaceI != nil {
		namespace = ptr(getTuple[file.Ident](namespaceI, 0))
	}

	return file.MixinCallAttribute{
		MixinCall: file.MixinCall{
			Namespace: namespace,
			Name:      nameI.(file.Ident),
			LParenPos: args.LParenPos,
			Args:      args.Args,
			RParenPos: args.RParenPos,
			Position:  pos(c),
		},
		Value: castedOrZero[file.InterpolationValue](valueI),
	}, nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["valueI"])
}

func (c *current) onunexpectedTokens1() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "here",
		}),
	}
}

func (p *parser) callonunexpectedTokens1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onunexpectedTokens1()
}

func (c *current) onExpression2(cExprI interface{}) (interface{}, error) {
	return file.Expression{Expressions: []file.ExpressionItem{cExprI.(file.ChainExpression)}}, nil
}

func (p *parser) callonExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExpression2(stack["cExprI"])
}

func (c *current) onSingleLineExpression2(cExprI interface{}) (interface{}, error) {
	return file.Expression{Expressions: []file.ExpressionItem{cExprI.(file.ChainExpression)}}, nil
}

func (p *parser) callonSingleLineExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineExpression2(stack["cExprI"])
}

func (c *current) onGoExpression9(posI interface{}) (interface{}, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonGoExpression9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression9(stack["posI"])
}

func (c *current) onGoExpression1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonGoExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression1(stack["exprsI"])
}

func (c *current) ongoParenExpr2(exprI interface{}) (interface{}, error) {
	exprIs := islice(exprI)
	if exprIs[1] == nil {
		return file.GoExpression{
			Expression: concat(exprIs[0]) + concat(exprIs[3]),
			Position:   pos(c),
		}, nil
	}

	expr := exprIs[1].(file.Expression)

	exprs := make([]file.ExpressionItem, len(expr.Expressions)+ /* open/closing paren */ 2)
	copy(exprs[1:], expr.Expressions)
	exprs[0] = file.GoExpression{
		Expression: concat(exprIs[0]), // opening paren
		Position:   pos(c),
	}
	exprs[len(exprs)-1] = file.GoExpression{
		Expression: concat(exprIs[3]), // closing paren
		Position:   exprIs[2].(file.Position),
	}

	return exprs, nil
}

func (p *parser) callongoParenExpr2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoParenExpr2(stack["exprI"])
}

func (c *current) ongoParenExpr23(parenI, startPosI, exprI interface{}) (interface{}, error) {
	openParen := string(char(parenI))

	closeParen := ")"
	if openParen == "[" {
		closeParen = "]"
	} else if openParen == "{" {
		closeParen = "}"
	}

	exprs := append([]file.ExpressionItem{file.GoExpression{
		Expression: openParen,
		Position:   pos(c),
	}}, castedOrZero[file.Expression](exprI).Expressions...)

	return exprs, &corgierr.Error{
		Message: "unclosed `" + openParen + "` in expression",
		ErrorAnnotation: anno(c, annotation{
			ContextLen: 3,
			Start:      startPosI.(file.Position),
			EOLDelta:   1,
			Annotation: "expected a `" + closeParen + "` somewhere here or on a line below",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      pos(c),
				Annotation: "for the `" + openParen + "` you opened here",
			}),
		},
	}
}

func (p *parser) callongoParenExpr23() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoParenExpr23(stack["parenI"], stack["startPosI"], stack["exprI"])
}

func (c *current) ongoRuneExpr1(posI interface{}) (interface{}, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil
}

func (p *parser) callongoRuneExpr1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoRuneExpr1(stack["posI"])
}

func (c *current) ongoSubExpression9(posI interface{}) (interface{}, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callongoSubExpression9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression9(stack["posI"])
}

func (c *current) ongoSubExpression1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callongoSubExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression1(stack["exprsI"])
}

func (c *current) onmultiLineGoExpression9(posI interface{}) (interface{}, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonmultiLineGoExpression9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression9(stack["posI"])
}

func (c *current) onmultiLineGoExpression1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonmultiLineGoExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression1(stack["exprsI"])
}

func (c *current) onSingleLineGoExpression9(posI interface{}) (interface{}, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonSingleLineGoExpression9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression9(stack["posI"])
}

func (c *current) onSingleLineGoExpression1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonSingleLineGoExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression1(stack["exprsI"])
}

func (c *current) onsingleLineGoParenExpr2(exprI interface{}) (interface{}, error) {
	exprIs := islice(exprI)
	if exprIs[1] == nil {
		return file.GoExpression{
			Expression: concat(exprIs[0]) + concat(exprIs[3]),
			Position:   pos(c),
		}, nil
	}

	expr := exprIs[1].(file.Expression)

	exprs := make([]file.ExpressionItem, len(expr.Expressions)+ /* open/closing paren */ 2)
	copy(exprs[1:], expr.Expressions)
	exprs[0] = file.GoExpression{
		Expression: concat(exprIs[0]),
		Position:   pos(c),
	}
	exprs[len(exprs)-1] = file.GoExpression{
		Expression: concat(exprIs[3]),
		Position:   exprIs[2].(file.Position),
	}

	return exprs, nil
}

func (p *parser) callonsingleLineGoParenExpr2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoParenExpr2(stack["exprI"])
}

func (c *current) onsingleLineGoParenExpr23(parenI, startPosI, exprI interface{}) (interface{}, error) {
	openParen := string(char(parenI))

	closeParen := ")"
	if openParen == "[" {
		closeParen = "]"
	} else if openParen == "{" {
		closeParen = "}"
	}

	exprs := append([]file.ExpressionItem{file.GoExpression{
		Expression: openParen,
		Position:   pos(c),
	}}, castedOrZero[file.Expression](exprI).Expressions...)

	return exprs, &corgierr.Error{
		Message: "unclosed `" + openParen + "` in expression",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			EOLDelta:   1,
			Annotation: "expected a `" + closeParen + "` somewhere here",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      pos(c),
				Annotation: "for the `" + openParen + "` you opened here",
			}),
		},
	}
}

func (p *parser) callonsingleLineGoParenExpr23() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoParenExpr23(stack["parenI"], stack["startPosI"], stack["exprI"])
}

func (c *current) onsingleLineGoSubExpression9(posI interface{}) (interface{}, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonsingleLineGoSubExpression9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression9(stack["posI"])
}

func (c *current) onsingleLineGoSubExpression1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonsingleLineGoSubExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression1(stack["exprsI"])
}

func (c *current) onIfExpression2(cExprI interface{}) (interface{}, error) {
	cExpr := cExprI.(file.ChainExpression)
	expr := file.Expression{Expressions: []file.ExpressionItem{cExpr}}
	if cExpr.Default != nil {
		return expr, &corgierr.Error{
			Message: "chain expression with default as conditional",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "here", // todo: span the entire len of the expression
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remove the default"},
			},
		}
	}

	return expr, nil
}

func (p *parser) callonIfExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression2(stack["cExprI"])
}

func (c *current) onIfExpression13(posI interface{}) (interface{}, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonIfExpression13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression13(stack["posI"])
}

func (c *current) onIfExpression5(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonIfExpression5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression5(stack["exprsI"])
}

func (c *current) onForExpression2(rExprI interface{}) (interface{}, error) {
	return &file.Expression{Expressions: []file.ExpressionItem{rExprI.(file.RangeExpression)}}, nil
}

func (p *parser) callonForExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onForExpression2(stack["rExprI"])
}

func (c *current) onForExpression5(exprI interface{}) (interface{}, error) {
	return ptr(exprI.(file.Expression)), nil
}

func (p *parser) callonForExpression5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onForExpression5(stack["exprI"])
}

func (c *current) onForExpression8() (interface{}, error) {
	return (*file.Expression)(nil), nil
}

func (p *parser) callonForExpression8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onForExpression8()
}

func (c *current) onRangeExpression1(varsI, orderedI, exprI interface{}) (interface{}, error) {
	re := file.RangeExpression{
		Ordered:         orderedI != nil,
		Position:        pos(c),
		RangeExpression: exprI.(file.Expression),
	}

	if partRE, ok := varsI.(file.RangeExpression); ok {
		re.Var1 = partRE.Var1
		re.Var2 = partRE.Var2
		re.EqPos = partRE.EqPos
		re.Declares = partRE.Declares
	}

	return re, nil
}

func (p *parser) callonRangeExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRangeExpression1(stack["varsI"], stack["orderedI"], stack["exprI"])
}

func (c *current) onrangeExpressionVars1(var1I, var2I, eqPosI, declaresI interface{}) (interface{}, error) {
	var1 := var1I.(file.GoIdent)

	var var2 *file.GoIdent
	if var2I != nil {
		var2Val := getTuple[file.GoIdent](var2I, -1)
		var2 = &var2Val
	}

	return file.RangeExpression{
		Var1:     &var1,
		Var2:     var2,
		EqPos:    eqPosI.(file.Position),
		Declares: declaresI != nil,
	}, nil
}

func (p *parser) callonrangeExpressionVars1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onrangeExpressionVars1(stack["var1I"], stack["var2I"], stack["eqPosI"], stack["declaresI"])
}

func (c *current) onInterpretedStringExpression2(contentsI interface{}) (interface{}, error) {
	return file.StringExpression{
		Quote:    '"',
		Contents: typedSlice[file.StringExpressionItem](contentsI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInterpretedStringExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpression2(stack["contentsI"])
}

func (c *current) onInterpretedStringExpression9(startPosI, contentsI interface{}) (interface{}, error) {
	return file.StringExpression{
			Quote:    '"',
			Contents: typedSlice[file.StringExpressionItem](contentsI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				ToEOL:      true,
				Annotation: "expected a `\"` somewhere here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the string literal started here",
				}),
			},
		}
}

func (p *parser) callonInterpretedStringExpression9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpression9(stack["startPosI"], stack["contentsI"])
}

func (c *current) onRawStringExpression2(contentsI interface{}) (interface{}, error) {
	return file.StringExpression{
		Quote:    '`',
		Contents: typedSlice[file.StringExpressionItem](contentsI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonRawStringExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawStringExpression2(stack["contentsI"])
}

func (c *current) onRawStringExpression9(startPosI, contentsI interface{}) (interface{}, error) {
	return file.StringExpression{
			Quote:    '`',
			Contents: typedSlice[file.StringExpressionItem](contentsI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				ToEOL:      true,
				Annotation: "expected a ``` somewhere here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the string literal started here",
				}),
			},
		}
}

func (p *parser) callonRawStringExpression9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawStringExpression9(stack["startPosI"], stack["contentsI"])
}

func (c *current) onInterpretedStringExpressionText1() (interface{}, error) {
	return file.StringExpressionText{
		Text:     string(c.text),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInterpretedStringExpressionText1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionText1()
}

func (c *current) onRawStringExpressionText1() (interface{}, error) {
	return file.StringExpressionText{
		Text:     string(c.text),
		Position: pos(c),
	}, nil
}

func (p *parser) callonRawStringExpressionText1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawStringExpressionText1()
}

func (c *current) onStringExpressionInterpolation2(fmtDirectiveI, lBracePosI, exprI, rBracePosI interface{}) (interface{}, error) {
	return file.StringExpressionInterpolation{
		FormatDirective: castedOrZero[string](fmtDirectiveI),
		Expression:      exprI.(file.Expression),
		LBracePos:       lBracePosI.(file.Position),
		RBracePos:       rBracePosI.(file.Position),
		Position:        pos(c),
	}, nil
}

func (p *parser) callonStringExpressionInterpolation2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation2(stack["fmtDirectiveI"], stack["lBracePosI"], stack["exprI"], stack["rBracePosI"])
}

func (c *current) onStringExpressionInterpolation14(fmtDirectiveI, parenPosI interface{}) (interface{}, error) {
	return file.StringExpressionInterpolation{
			FormatDirective: castedOrZero[string](fmtDirectiveI),
			Position:        pos(c),
		}, &corgierr.Error{
			Message: "interpolation is missing an expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      parenPosI.(file.Position),
				Annotation: "expected a `" + lbrace + "` here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the interpolation started here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "add an expression enclosed in braces",
					Code:       "`" + string(c.text) + "{1+1}`",
				},
				{
					Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation",
					Code:       "`#" + string(c.text) + "`",
				},
			},
		}
}

func (p *parser) callonStringExpressionInterpolation14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation14(stack["fmtDirectiveI"], stack["parenPosI"])
}

func (c *current) onStringExpressionInterpolation22(fmtDirectiveI, parenPosI, lBracePosI, startPosI, exprI interface{}) (interface{}, error) {
	return file.StringExpressionInterpolation{
			FormatDirective: castedOrZero[string](fmtDirectiveI),
			Expression:      exprI.(file.Expression),
			LBracePos:       lBracePosI.(file.Position),
			Position:        pos(c),
		}, &corgierr.Error{
			Message: "unclosed string interpolation",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				EOLDelta:   1,
				Annotation: "expected a `" + rbrace + "` somewhere here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					End:        startPosI.(file.Position),
					Annotation: "for the interpolation started here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "add the missing `" + rbrace + "`"},
				{
					Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation",
					Code:       "`#" + string(c.text) + "`",
				},
			},
		}
}

func (p *parser) callonStringExpressionInterpolation22() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation22(stack["fmtDirectiveI"], stack["parenPosI"], stack["lBracePosI"], stack["startPosI"], stack["exprI"])
}

func (c *current) onfmtDirective2() (interface{}, error) {
	return string(c.text[1:]), nil
}

func (p *parser) callonfmtDirective2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfmtDirective2()
}

func (c *current) onfmtDirective18(endPosI interface{}) (interface{}, error) {
	return string(c.text[1:]), &corgierr.Error{
		Message: "invalid format directive",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "invalid formatter",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on how to write a formatting placeholder"},
			{Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation"},
		},
	}
}

func (p *parser) callonfmtDirective18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfmtDirective18(stack["endPosI"])
}

func (c *current) onfmtVerb9() (interface{}, error) {
	return []byte(nil), &corgierr.Error{
		Message: "missing format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected a formatting verb here",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonfmtVerb9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfmtVerb9()
}

func (c *current) onfmtVerb15() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "this is not a valid verb",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonfmtVerb15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfmtVerb15()
}

func (c *current) oncommaPos2(posI interface{}) (interface{}, error) {
	return posI, nil
}

func (p *parser) calloncommaPos2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncommaPos2(stack["posI"])
}

func (c *current) oncommaPos11(posI interface{}) (interface{}, error) {
	return posI, nil
}

func (p *parser) calloncommaPos11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncommaPos11(stack["posI"])
}

func (c *current) onTernaryExpression2(conditionI, ifTrueI, ifFalseI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
		Condition: conditionI.(file.Expression),
		IfTrue:    ifTrueI.(file.Expression),
		IfFalse:   ifFalseI.(file.Expression),
		RParenPos: rParenPosI.(file.Position),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonTernaryExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression2(stack["conditionI"], stack["ifTrueI"], stack["ifFalseI"], stack["rParenPosI"])
}

func (c *current) onTernaryExpression32(startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected a condition, an if-true value, and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonTernaryExpression32() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression32(stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onTernaryExpression41(conditionI, startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-true value and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonTernaryExpression41() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression41(stack["conditionI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onTernaryExpression52(conditionI, ifTrueI, startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			IfTrue:    ifTrueI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonTernaryExpression52() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression52(stack["conditionI"], stack["ifTrueI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression2(conditionI, ifTrueI, ifFalseI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
		Condition: conditionI.(file.Expression),
		IfTrue:    ifTrueI.(file.Expression),
		IfFalse:   ifFalseI.(file.Expression),
		RParenPos: rParenPosI.(file.Position),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonSingleLineTernaryExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression2(stack["conditionI"], stack["ifTrueI"], stack["ifFalseI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression32(startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected a condition, an if-true value, and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonSingleLineTernaryExpression32() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression32(stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression41(conditionI, startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-true value and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonSingleLineTernaryExpression41() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression41(stack["conditionI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression52(conditionI, ifTrueI, startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			IfTrue:    ifTrueI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonSingleLineTernaryExpression52() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression52(stack["conditionI"], stack["ifTrueI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onChainExpression35(derefsI, rootI, checkRootI, chainI, defaultI, endPosI interface{}) (bool, error) {
	return checkRootI != nil || chainExprItmsCheck(typedSlice[file.ChainExpressionItem](chainI)) || defaultI != nil, nil
}

func (p *parser) callonChainExpression35() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression35(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onChainExpression2(derefsI, rootI, checkRootI, chainI, defaultI, endPosI interface{}) (interface{}, error) {
	expr := file.ChainExpression{
		Root:       rootI.(file.GoExpression),
		CheckRoot:  checkRootI != nil,
		Chain:      typedSlice[file.ChainExpressionItem](chainI),
		DerefCount: len(islice(derefsI)),
		Position:   pos(c),
	}
	if defaultI != nil {
		defaultOpPos := getTuple[file.Position](defaultI, 1)
		expr.DefaultOpPos = &defaultOpPos
		defaultVal := getTuple[file.Expression](defaultI, -1)
		expr.Default = &defaultVal
	}

	return expr, nil
}

func (p *parser) callonChainExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression2(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onChainExpression53(startPosI, derefsI, rootI, checkRootI, chainI, endPosI interface{}) (bool, error) {
	return checkRootI != nil || chainExprItmsCheck(typedSlice[file.ChainExpressionItem](chainI)), nil
}

func (p *parser) callonChainExpression53() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression53(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"])
}

func (c *current) onChainExpression36(startPosI, derefsI, rootI, checkRootI, chainI, endPosI, malStartPosI, malEndPosI interface{}) (interface{}, error) {
	expr := file.ChainExpression{
		Root:       rootI.(file.GoExpression),
		CheckRoot:  checkRootI != nil,
		Chain:      typedSlice[file.ChainExpressionItem](chainI),
		DerefCount: len(islice(derefsI)),
		Position:   pos(c),
	}

	var multiline string
	if malEndPosI.(file.Position).Line > malStartPosI.(file.Position).Line {
		multiline += " and the lines below"
	}

	return expr, &corgierr.Error{
		Message: "malformed chain expression",
		ErrorAnnotation: anno(c, annotation{
			Start:      malStartPosI.(file.Position),
			End:        malEndPosI.(file.Position),
			Annotation: "unable to parse this" + multiline + " part",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        malStartPosI.(file.Position),
				Annotation: "this is valid",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "did you mean to put a default here? default values start with the `~` operator",
				Example:    "`woof?.bark[12?] ~ someDefault`",
			},
			{
				Suggestion: "remember that chain expressions cannot be embedded in Go expressions;\n" +
					"you can either write a chain expression or a Go expression",
			},
		},
	}
}

func (p *parser) callonChainExpression36() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression36(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"], stack["malStartPosI"], stack["malEndPosI"])
}

func (c *current) onchainExpressionRoot2() (interface{}, error) {
	return file.GoExpression{
		Expression: string(c.text),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonchainExpressionRoot2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onchainExpressionRoot2()
}

func (c *current) onchainExpressionRoot8(identI interface{}) (interface{}, error) {
	ident := identI.(file.GoIdent)
	return file.GoExpression{
		Expression: ident.Ident,
		Position:   ident.Position,
	}, nil
}

func (p *parser) callonchainExpressionRoot8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onchainExpressionRoot8(stack["identI"])
}

func (c *current) onSingleLineChainExpression32(derefsI, rootI, checkRootI, chainI, defaultI, endPosI interface{}) (bool, error) {
	return checkRootI != nil || len(islice(chainI)) > 0 || defaultI != nil, nil
}

func (p *parser) callonSingleLineChainExpression32() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression32(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpression2(derefsI, rootI, checkRootI, chainI, defaultI, endPosI interface{}) (interface{}, error) {
	expr := file.ChainExpression{
		Root:       rootI.(file.GoExpression),
		CheckRoot:  checkRootI != nil,
		Chain:      typedSlice[file.ChainExpressionItem](chainI),
		DerefCount: len(islice(derefsI)),
		Position:   pos(c),
	}
	if defaultI != nil {
		defaultOpPos := getTuple[file.Position](defaultI, 1)
		expr.DefaultOpPos = &defaultOpPos
		defaultVal := getTuple[file.Expression](defaultI, -1)
		expr.Default = &defaultVal
	}

	return expr, nil
}

func (p *parser) callonSingleLineChainExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression2(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpression49(startPosI, derefsI, rootI, checkRootI, chainI, endPosI interface{}) (bool, error) {
	return checkRootI != nil || len(islice(chainI)) > 0, nil
}

func (p *parser) callonSingleLineChainExpression49() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression49(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpression55(startPosI, derefsI, rootI, checkRootI, chainI, endPosI, malStartPosI, malEndPosI interface{}) (bool, error) {
	return false, &corgierr.Error{
		Message: "malformed chain expression",
		ErrorAnnotation: anno(c, annotation{
			Start:      malStartPosI.(file.Position),
			End:        malEndPosI.(file.Position),
			Annotation: "unable to parse this part",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        malStartPosI.(file.Position),
				Annotation: "this is valid",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "did you mean to put a default here? default values start with the `~` operator",
				Example:    "`woof?.bark[12?] ~ someDefault`",
			},
			{
				Suggestion: "remember that chain expressions cannot be embedded in Go expressions;\n" +
					"you can either write a chain expression or a Go expression",
			},
		},
	}
}

func (p *parser) callonSingleLineChainExpression55() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression55(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"], stack["malStartPosI"], stack["malEndPosI"])
}

func (c *current) onsingleLineChainExpressionRoot2() (interface{}, error) {
	return file.GoExpression{
		Expression: string(c.text),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonsingleLineChainExpressionRoot2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineChainExpressionRoot2()
}

func (c *current) onsingleLineChainExpressionRoot8(identI interface{}) (interface{}, error) {
	ident := identI.(file.GoIdent)
	return file.GoExpression{
		Expression: ident.Ident,
		Position:   ident.Position,
	}, nil
}

func (p *parser) callonsingleLineChainExpressionRoot8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineChainExpressionRoot8(stack["identI"])
}

func (c *current) onIndexExpression1(exprI, checkIndexI, rBracePosI, checkValueI interface{}) (interface{}, error) {
	return file.IndexExpression{
		LBracePos:  pos(c),
		Index:      exprI.(file.Expression),
		RBracePos:  rBracePosI.(file.Position),
		CheckIndex: checkIndexI != nil,
		CheckValue: checkValueI != nil,
	}, nil
}

func (p *parser) callonIndexExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIndexExpression1(stack["exprI"], stack["checkIndexI"], stack["rBracePosI"], stack["checkValueI"])
}

func (c *current) onindexExpressionIndex9(posI interface{}) (interface{}, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonindexExpressionIndex9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex9(stack["posI"])
}

func (c *current) onindexExpressionIndex1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonindexExpressionIndex1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex1(stack["exprsI"])
}

func (c *current) onSingleLineIndexExpression1(exprI, checkIndexI, rBracePosI, checkValueI interface{}) (interface{}, error) {
	return file.IndexExpression{
		LBracePos:  pos(c),
		Index:      exprI.(file.Expression),
		RBracePos:  rBracePosI.(file.Position),
		CheckIndex: checkIndexI != nil,
		CheckValue: checkValueI != nil,
	}, nil
}

func (p *parser) callonSingleLineIndexExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIndexExpression1(stack["exprI"], stack["checkIndexI"], stack["rBracePosI"], stack["checkValueI"])
}

func (c *current) onsingleLineIndexExpressionIndex9(posI interface{}) (interface{}, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonsingleLineIndexExpressionIndex9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex9(stack["posI"])
}

func (c *current) onsingleLineIndexExpressionIndex1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonsingleLineIndexExpressionIndex1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex1(stack["exprsI"])
}

func (c *current) onDotIdentExpression1(identI, checkI interface{}) (interface{}, error) {
	return file.DotIdentExpression{
		Ident:    identI.(file.GoIdent),
		Check:    checkI != nil,
		Position: pos(c),
	}, nil
}

func (p *parser) callonDotIdentExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDotIdentExpression1(stack["identI"], stack["checkI"])
}

func (c *current) onSingleLineDotIdentExpression1(identI, checkI interface{}) (interface{}, error) {
	return file.DotIdentExpression{
		Ident:    identI.(file.GoIdent),
		Check:    checkI != nil,
		Position: pos(c),
	}, nil
}

func (p *parser) callonSingleLineDotIdentExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineDotIdentExpression1(stack["identI"], stack["checkI"])
}

func (c *current) onParenExpression1(argsI, rParenPosI, checkI interface{}) (interface{}, error) {
	return file.ParenExpression{
		LParenPos: pos(c),
		Args:      castedOrZero[[]file.Expression](argsI),
		RParenPos: pos(c),
		Check:     checkI != nil,
	}, nil
}

func (p *parser) callonParenExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onParenExpression1(stack["argsI"], stack["rParenPosI"], stack["checkI"])
}

func (c *current) onparenExpressionArgs1(firstI, restI interface{}) (interface{}, error) {
	restTuples := islice(restI)

	args := make([]file.Expression, 1+len(restTuples))
	args[0] = firstI.(file.Expression)
	for i, at := range restTuples {
		args[i+1] = getTuple[file.Expression](at, -1)
	}

	return args, nil
}

func (p *parser) callonparenExpressionArgs1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onparenExpressionArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onSingleLineParenExpression1(argsI, rParenPosI, checkI interface{}) (interface{}, error) {
	return file.ParenExpression{
		LParenPos: pos(c),
		Args:      castedOrZero[[]file.Expression](argsI),
		RParenPos: pos(c),
		Check:     checkI != nil,
	}, nil
}

func (p *parser) callonSingleLineParenExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineParenExpression1(stack["argsI"], stack["rParenPosI"], stack["checkI"])
}

func (c *current) onsingleLinearenExpressionArgs1(firstI, restI interface{}) (interface{}, error) {
	restTuples := islice(restI)

	args := make([]file.Expression, 1+len(restTuples))
	args[0] = firstI.(file.Expression)
	for i, at := range restTuples {
		args[i+1] = getTuple[file.Expression](at, -1)
	}

	return args, nil
}

func (p *parser) callonsingleLinearenExpressionArgs1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLinearenExpressionArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onTypeAssertionExpression1(ptrsI, packageI, typeI, rParenPosI, checkI interface{}) (interface{}, error) {
	var packageIdent *file.GoIdent
	if packageI != nil {
		packageIdentVal := getTuple[file.GoIdent](packageI, 0)
		packageIdent = &packageIdentVal
	}

	return file.TypeAssertionExpression{
		PointerCount: len(islice(ptrsI)),
		Package:      packageIdent,
		Type:         typeI.(file.GoIdent),
		RParenPos:    rParenPosI.(file.Position),
		Check:        checkI != nil,
	}, nil
}

func (p *parser) callonTypeAssertionExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTypeAssertionExpression1(stack["ptrsI"], stack["packageI"], stack["typeI"], stack["rParenPosI"], stack["checkI"])
}

func (c *current) onRawFilter1(bodyI interface{}) (interface{}, error) {
	return file.RawFilter{
		Body:     castedOrZero[[]file.FilterLine](bodyI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonRawFilter1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawFilter1(stack["bodyI"])
}

func (c *current) onCommandFilter1(nameI, argsI, bodyI interface{}) (interface{}, error) {
	return file.CommandFilter{
		Name:     concat(nameI),
		Args:     typedSliceFromTuples[file.CommandFilterArg](argsI, -1),
		Body:     castedOrZero[[]file.FilterLine](bodyI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonCommandFilter1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter1(stack["nameI"], stack["argsI"], stack["bodyI"])
}

func (c *current) onstringCommandFilterArg1(stringI interface{}) (interface{}, error) {
	return file.StringCommandFilterArg(stringI.(file.String)), nil
}

func (p *parser) callonstringCommandFilterArg1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onstringCommandFilterArg1(stack["stringI"])
}

func (c *current) onrawCommand1(argI interface{}) (interface{}, error) {
	return file.RawCommandFilterArg{Value: concat(argI), Position: pos(c)}, nil
}

func (p *parser) callonrawCommand1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onrawCommand1(stack["argI"])
}

func (c *current) onBadFilter1(bodyI interface{}) (interface{}, error) {
	return file.CommandFilter{
			Position: pos(c),
			Body:     castedOrZero[[]file.FilterLine](bodyI),
		}, &corgierr.Error{
			Message: "bad filter",
			ErrorAnnotation: anno(c, annotation{
				Start:       pos(c),
				StartOffset: 1,
				Annotation:  "expected `raw` or a command name",
			}),
		}
}

func (p *parser) callonBadFilter1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBadFilter1(stack["bodyI"])
}

func (c *current) onfilterBody1(linesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.FilterLine](linesI, -1), nil
}

func (p *parser) callonfilterBody1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfilterBody1(stack["linesI"])
}

func (c *current) onfilterLine1(posI, lineI interface{}) (interface{}, error) {
	return file.FilterLine{
		Line:     concat(lineI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonfilterLine1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfilterLine1(stack["posI"], stack["lineI"])
}

func (c *current) onGoIdent1(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonGoIdent1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoIdent1(stack["ident"])
}

func (c *current) onGoType1(goTypeI interface{}) (interface{}, error) {
	return file.GoType{Type: concat(goTypeI), Position: pos(c)}, nil
}

func (p *parser) callonGoType1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoType1(stack["goTypeI"])
}

func (c *current) ongoRuneLit9(valsI, endPosI interface{}) (interface{}, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callongoRuneLit9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoRuneLit9(stack["valsI"], stack["endPosI"])
}

func (c *current) ongoHexByteValue7() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callongoHexByteValue7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoHexByteValue7()
}

func (c *current) ongoLittleUValue9() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoLittleUValue9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoLittleUValue9()
}

func (c *current) ongoBigUValue13() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoBigUValue13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoBigUValue13()
}

func (c *current) ongoRecoverRuneEscape2() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoRecoverRuneEscape2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoRecoverRuneEscape2()
}

func (c *current) ongoRecoverRuneEscape13() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoRecoverRuneEscape13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoRecoverRuneEscape13()
}

func (c *current) ongoRecoverRuneEscape20() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoRecoverRuneEscape20() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoRecoverRuneEscape20()
}

func (c *current) ongoRecoverRuneEscape25() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callongoRecoverRuneEscape25() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoRecoverRuneEscape25()
}

func (c *current) ongoRecoverInterpretedStringEscape2() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoRecoverInterpretedStringEscape2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoRecoverInterpretedStringEscape2()
}

func (c *current) ongoRecoverInterpretedStringEscape13() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoRecoverInterpretedStringEscape13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoRecoverInterpretedStringEscape13()
}

func (c *current) ongoRecoverInterpretedStringEscape20() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoRecoverInterpretedStringEscape20() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoRecoverInterpretedStringEscape20()
}

func (c *current) ongoRecoverInterpretedStringEscape25() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callongoRecoverInterpretedStringEscape25() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoRecoverInterpretedStringEscape25()
}

func (c *current) ongoRawStringLit7() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "unclosed string literal",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			EOLDelta:   1,
			Annotation: "expected a ``` somewhere here",
		}),
	}
}

func (p *parser) callongoRawStringLit7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoRawStringLit7()
}

func (c *current) ongoInterpretedStringLit10() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "unclosed string literal",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			EOLDelta:   1,
			Annotation: "expected a `\"` somewhere here",
		}),
	}

}

func (p *parser) callongoInterpretedStringLit10() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoInterpretedStringLit10()
}

func (c *current) onInclude1(pathI interface{}) (interface{}, error) {
	return file.Include{
		Path:     pathI.(file.String),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInclude1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInclude1(stack["pathI"])
}

func (c *current) onMixin2(nameI, paramsI, bodyI interface{}) (interface{}, error) {
	params := castedOrZero[file.Mixin](paramsI)
	return file.Mixin{
		Name:      nameI.(file.Ident),
		LParenPos: params.LParenPos,
		Params:    params.Params,
		RParenPos: params.RParenPos,
		Body:      bodyI.(file.Scope),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonMixin2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin2(stack["nameI"], stack["paramsI"], stack["bodyI"])
}

func (c *current) onMixin14(posI, bodyI interface{}) (interface{}, error) {
	return file.Mixin{
			Body:     bodyI.(file.Scope),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "mixin: missing name",
			ErrorAnnotation: anno(c, annotation{
				Start:       posI.(file.Position),
				StartOffset: 1,
				Annotation:  "expected the name of the mixin here",
			}),
			Example: "`mixin woof\n" +
				"  > bark`",
		}
}

func (p *parser) callonMixin14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin14(stack["posI"], stack["bodyI"])
}

func (c *current) onmixinParamList2(paramsI, rParenPosI interface{}) (interface{}, error) {
	return file.Mixin{
		LParenPos: ptr(pos(c)),
		Params:    castedOrZero[[]file.MixinParam](paramsI),
		RParenPos: ptr(rParenPosI.(file.Position)),
	}, nil
}

func (p *parser) callonmixinParamList2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamList2(stack["paramsI"], stack["rParenPosI"])
}

func (c *current) onmixinParamList19(paramsI, posI interface{}) (interface{}, error) {
	return file.Mixin{
			LParenPos: ptr(pos(c)),
			Params:    castedOrZero[[]file.MixinParam](paramsI),
		}, &corgierr.Error{
			Message: "mixin parameters: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonmixinParamList19() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamList19(stack["paramsI"], stack["posI"])
}

func (c *current) onmixinParams1(firstI, restI interface{}) (interface{}, error) {
	restIs := islice(restI)
	mixinParams := make([]file.MixinParam, 1+len(restIs))
	mixinParams[0] = firstI.(file.MixinParam)
	for i, ai := range restIs {
		mixinParams[i+1] = getTuple[file.MixinParam](ai, -1)
	}

	return mixinParams, nil
}

func (p *parser) callonmixinParams1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParams1(stack["firstI"], stack["restI"])
}

func (c *current) onmixinParam1(nameI, posI, typeI, defaultI interface{}) (interface{}, error) {
	defaultTuple := islice(defaultI)
	var paramDefault file.MixinParam
	if len(defaultTuple) == 2 {
		paramDefault = defaultTuple[1].(file.MixinParam)
	}

	typeTuple := islice(typeI)
	var paramType *file.GoType
	if len(typeTuple) == 2 {
		paramType = ptr(typeTuple[1].(file.GoType))
	}

	p := file.MixinParam{
		Name:      nameI.(file.Ident),
		Type:      paramType,
		AssignPos: paramDefault.AssignPos,
		Default:   paramDefault.Default,
		Position:  pos(c),
	}
	if p.Type == nil && p.Default == nil {
		return p, &corgierr.Error{
			Message: "mixin param: need either a type or a default",
			ErrorAnnotation: anno(c, annotation{
				Start:       posI.(file.Position),
				StartOffset: 1,
				Annotation:  "expected either a type or a default here",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "give this param a type", Code: "`" + p.Name.Ident + " string`"},
				{Suggestion: "give this param a default with an inferrable type", Code: "`" + p.Name.Ident + "=\"woof\"`"},
			},
		}
	}

	return p, nil
}

func (p *parser) callonmixinParam1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam1(stack["nameI"], stack["posI"], stack["typeI"], stack["defaultI"])
}

func (c *current) onmixinParamDefault2(exprI interface{}) (interface{}, error) {
	return file.MixinParam{
		AssignPos: ptr(pos(c)),
		Default:   ptrOrNil[file.Expression](exprI),
	}, nil
}

func (p *parser) callonmixinParamDefault2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamDefault2(stack["exprI"])
}

func (c *current) onmixinParamDefault9(posI interface{}) (interface{}, error) {
	return file.MixinParam{
			AssignPos: ptr(pos(c)),
		}, &corgierr.Error{
			Message: "mixin param: missing default",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "because of this `=`",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remove the `=`, if you didn't mean to define a default"},
			},
		}
}

func (p *parser) callonmixinParamDefault9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamDefault9(stack["posI"])
}

func (c *current) onReturn1(errExprI interface{}) (interface{}, error) {
	return file.Return{
		Err:      ptrOrNil[file.Expression](errExprI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonReturn1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onReturn1(stack["errExprI"])
}

func (c *current) onMixinCall1(namespaceI, nameI, argsI, bodyI interface{}) (interface{}, error) {
	args := castedOrZero[file.MixinCall](argsI)

	var namespace *file.Ident
	if namespaceI != nil {
		namespace = ptr(getTuple[file.Ident](namespaceI, 0))
	}

	return file.MixinCall{
		Namespace: namespace,
		Name:      nameI.(file.Ident),
		LParenPos: args.LParenPos,
		Args:      args.Args,
		RParenPos: args.RParenPos,
		Body:      bodyI.(file.Scope),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonMixinCall1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["bodyI"])
}

func (c *current) onInlineMixinCall1(namespaceI, nameI, argsI, bodyI interface{}) (interface{}, error) {
	args := castedOrZero[file.MixinCall](argsI)

	var namespace *file.Ident
	if namespaceI != nil {
		namespace = ptr(getTuple[file.Ident](namespaceI, 0))
	}

	return file.MixinCall{
		Namespace: namespace,
		Name:      nameI.(file.Ident),
		LParenPos: args.LParenPos,
		Args:      args.Args,
		RParenPos: args.RParenPos,
		Body:      bodyI.(file.Scope),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonInlineMixinCall1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["bodyI"])
}

func (c *current) onmixinArgList2(argsI, rParenPosI interface{}) (interface{}, error) {
	return file.MixinCall{
		LParenPos: ptr(pos(c)),
		Args:      castedOrZero[[]file.MixinArg](argsI),
		RParenPos: ptr(rParenPosI.(file.Position)),
	}, nil
}

func (p *parser) callonmixinArgList2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgList2(stack["argsI"], stack["rParenPosI"])
}

func (c *current) onmixinArgList19(argsI, posI interface{}) (interface{}, error) {
	return file.MixinCall{
			LParenPos: ptr(pos(c)),
			Args:      castedOrZero[[]file.MixinArg](argsI),
		}, &corgierr.Error{
			Message: "mixin args: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonmixinArgList19() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgList19(stack["argsI"], stack["posI"])
}

func (c *current) onsingleLineMixinArgList2(argsI, rParenPosI interface{}) (interface{}, error) {
	return file.MixinCall{
		LParenPos: ptr(pos(c)),
		Args:      castedOrZero[[]file.MixinArg](argsI),
		RParenPos: ptr(rParenPosI.(file.Position)),
	}, nil
}

func (p *parser) callonsingleLineMixinArgList2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgList2(stack["argsI"], stack["rParenPosI"])
}

func (c *current) onsingleLineMixinArgList19(argsI, posI interface{}) (interface{}, error) {
	return file.MixinCall{
			LParenPos: ptr(pos(c)),
			Args:      castedOrZero[[]file.MixinArg](argsI),
		}, &corgierr.Error{
			Message: "mixin args: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonsingleLineMixinArgList19() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgList19(stack["argsI"], stack["posI"])
}

func (c *current) onmixinArgs1(firstI, restI interface{}) (interface{}, error) {
	restIs := islice(restI)
	mixinArgs := make([]file.MixinArg, 1+len(restIs))
	mixinArgs[0] = firstI.(file.MixinArg)
	for i, ai := range restIs {
		mixinArgs[i+1] = getTuple[file.MixinArg](ai, -1)
	}

	return mixinArgs, nil
}

func (p *parser) callonmixinArgs1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onsingleLineMixinArgs1(firstI, restI interface{}) (interface{}, error) {
	restIs := islice(restI)
	mixinArgs := make([]file.MixinArg, 1+len(restIs))
	mixinArgs[0] = firstI.(file.MixinArg)
	for i, ai := range restIs {
		mixinArgs[i+1] = getTuple[file.MixinArg](ai, -1)
	}

	return mixinArgs, nil
}

func (p *parser) callonsingleLineMixinArgs1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onmixinArg2(nameI, valI interface{}) (interface{}, error) {
	return file.MixinArg{
		Name:  nameI.(file.Ident),
		Value: valI.(file.Expression),
	}, nil
}

func (p *parser) callonmixinArg2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg2(stack["nameI"], stack["valI"])
}

func (c *current) onmixinArg13(nameI, posI interface{}) (interface{}, error) {
	return file.MixinArg{
			Name: nameI.(file.Ident),
		}, &corgierr.Error{
			Message: "missing mixin argument value",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a value here",
			}),
			Example: "`argName=123`",
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remember that you always need to write the name of the arg before it's value"},
			},
		}
}

func (p *parser) callonmixinArg13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg13(stack["nameI"], stack["posI"])
}

func (c *current) onsingleLineMixinArg2(nameI, valI interface{}) (interface{}, error) {
	return file.MixinArg{
		Name:  nameI.(file.Ident),
		Value: valI.(file.Expression),
	}, nil
}

func (p *parser) callonsingleLineMixinArg2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg2(stack["nameI"], stack["valI"])
}

func (c *current) onsingleLineMixinArg13(nameI, posI interface{}) (interface{}, error) {
	return file.MixinArg{
			Name: nameI.(file.Ident),
		}, &corgierr.Error{
			Message: "missing mixin argument value",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a value here",
			}),
			Example: "`argName=123`",
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remember that you always need to write the name of the arg before it's value"},
			},
		}
}

func (p *parser) callonsingleLineMixinArg13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg13(stack["nameI"], stack["posI"])
}

func (c *current) onmixinCallBody2(shI interface{}) (interface{}, error) {
	return file.Scope{shI.(file.MixinMainBlockShorthand)}, nil
}

func (p *parser) callonmixinCallBody2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallBody2(stack["shI"])
}

func (c *current) onMixinMainBlockShorthand2(bodyI interface{}) (interface{}, error) {
	return file.MixinMainBlockShorthand{
		Body:     bodyI.(file.Scope),
		Position: pos(c),
	}, nil
}

func (p *parser) callonMixinMainBlockShorthand2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand2(stack["bodyI"])
}

func (c *current) onMixinMainBlockShorthand10(posI interface{}) (interface{}, error) {
	return file.MixinMainBlockShorthand{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing body",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an indented body",
			}),
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "if you want the `_` block to write nothing,\n" +
						"use a block directive inside the body of the mixin call",
					Example: "`+woof\n" +
						"  block _`",
				},
			},
		}
}

func (p *parser) callonMixinMainBlockShorthand10() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand10(stack["posI"])
}

func (c *current) onspacedDirPath2(sI interface{}) (interface{}, error) {
	return sI, nil
}

func (p *parser) callonspacedDirPath2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onspacedDirPath2(stack["sI"])
}

func (c *current) onspacedDirPath8(pathI interface{}) (interface{}, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonspacedDirPath8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onspacedDirPath8(stack["pathI"])
}

func (c *current) ondirPath3(pathI interface{}) (interface{}, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callondirPath3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ondirPath3(stack["pathI"])
}

func (c *current) onExtend1(extendI interface{}) (interface{}, error) {
	return file.Extend{Path: extendI.(file.String), Position: pos(c)}, nil
}

func (p *parser) callonExtend1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExtend1(stack["extendI"])
}

func (c *current) onImports1(importsI interface{}) (interface{}, error) {
	impTuples := islice(importsI)
	if impTuples == nil {
		return []file.Import(nil), nil
	}

	var imps []file.Import
	for _, impTuple := range impTuples {
		imps = append(imps, getTuple[file.Import](impTuple, 1))
	}

	return imps, nil
}

func (p *parser) callonImports1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onImports1(stack["importsI"])
}

func (c *current) onImport2(specsI interface{}) (interface{}, error) {
	return file.Import{
		Imports:  specsI.([]file.ImportSpec),
		Position: pos(c),
	}, nil
}

func (p *parser) callonImport2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onImport2(stack["specsI"])
}

func (c *current) onImport8(specI interface{}) (interface{}, error) {
	return file.Import{
		Imports:  []file.ImportSpec{specI.(file.ImportSpec)},
		Position: pos(c),
	}, nil
}

func (p *parser) callonImport8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onImport8(stack["specI"])
}

func (c *current) onImport15(posI interface{}) (interface{}, error) {
	return file.Import{Position: pos(c)}, &corgierr.Error{
		Message: "missing import path",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			Annotation:  "expected an import path, optionally preceded by an import alias",
		}),
	}
}

func (p *parser) callonImport15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onImport15(stack["posI"])
}

func (c *current) onimportBlock1(importsI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.ImportSpec](importsI, -1), nil
}

func (p *parser) callonimportBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportBlock1(stack["importsI"])
}

func (c *current) onimportSpec1(aliasI, pathI interface{}) (interface{}, error) {
	var spec file.ImportSpec
	spec.Position = pos(c)

	if aliasI != nil {
		alias := getTuple[file.GoIdent](aliasI, 0)
		spec.Alias = &alias
	}

	spec.Path = pathI.(file.String)
	return spec, nil
}

func (p *parser) callonimportSpec1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportSpec1(stack["aliasI"], stack["pathI"])
}

func (c *current) onimportAlias2() (interface{}, error) {
	return file.GoIdent{Ident: ".", Position: pos(c)}, nil
}

func (p *parser) callonimportAlias2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportAlias2()
}

func (c *current) onimportAlias5(endPosI interface{}) (interface{}, error) {
	return file.GoIdent{
			Ident:    string(c.text),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid import alias",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
		}
}

func (p *parser) callonimportAlias5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportAlias5(stack["endPosI"])
}

func (c *current) onUses1(usesI interface{}) (interface{}, error) {
	useTuples := islice(usesI)
	if useTuples == nil {
		return []file.Use(nil), nil
	}

	var uses []file.Use
	for _, useTuple := range useTuples {
		uses = append(uses, getTuple[file.Use](useTuple, 1))
	}

	return uses, nil
}

func (p *parser) callonUses1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUses1(stack["usesI"])
}

func (c *current) onUse2(specsI interface{}) (interface{}, error) {
	return file.Use{
		Uses:     specsI.([]file.UseSpec),
		Position: pos(c),
	}, nil
}

func (p *parser) callonUse2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUse2(stack["specsI"])
}

func (c *current) onUse7(specI interface{}) (interface{}, error) {
	return file.Use{
		Uses:     []file.UseSpec{specI.(file.UseSpec)},
		Position: pos(c),
	}, nil
}

func (p *parser) callonUse7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUse7(stack["specI"])
}

func (c *current) onUse14(posI interface{}) (interface{}, error) {
	return file.Use{Position: pos(c)}, &corgierr.Error{
		Message: "missing use path",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			Annotation:  "expected an use path, optionally preceded by an use alias",
		}),
	}
}

func (p *parser) callonUse14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUse14(stack["posI"])
}

func (c *current) onuseBlock1(usesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.UseSpec](usesI, -1), nil
}

func (p *parser) callonuseBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onuseBlock1(stack["usesI"])
}

func (c *current) onuseSpec1(aliasI, pathI interface{}) (interface{}, error) {
	var spec file.UseSpec
	spec.Position = pos(c)

	if aliasI != nil {
		alias := getTuple[file.Ident](aliasI, 0)
		spec.Alias = &alias
	}

	spec.Path = pathI.(file.String)
	return spec, nil
}

func (p *parser) callonuseSpec1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onuseSpec1(stack["aliasI"], stack["pathI"])
}

func (c *current) onuseAlias2() (interface{}, error) {
	return file.Ident{Ident: ".", Position: pos(c)}, nil
}

func (p *parser) callonuseAlias2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onuseAlias2()
}

func (c *current) onuseAlias5(endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    string(c.text),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid import alias",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
		}
}

func (p *parser) callonuseAlias5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onuseAlias5(stack["endPosI"])
}

func (c *current) onFunc17(paramsI interface{}) (interface{}, error) {
	return castedOrZero[[]file.FuncParam](paramsI), nil

}

func (p *parser) callonFunc17() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc17(stack["paramsI"])
}

func (c *current) onFunc31(endPosI interface{}) (interface{}, error) {
	return ([]file.FuncParam)(nil), &corgierr.Error{
		Message: "invalid parameter list",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "this is not correct, maybe a missing comma?",
		}),
	}

}

func (p *parser) callonFunc31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc31(stack["endPosI"])
}

func (c *current) onFunc11(lParenPosI, paramsI, rParenPosI interface{}) (interface{}, error) {
	return file.Func{
		LParenPos: lParenPosI.(file.Position),
		Params:    paramsI.([]file.FuncParam),
		RParenPos: rParenPosI.(file.Position),
	}, nil

}

func (p *parser) callonFunc11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc11(stack["lParenPosI"], stack["paramsI"], stack["rParenPosI"])
}

func (c *current) onFunc39() (interface{}, error) {
	return file.Func{}, &corgierr.Error{
		Message: "missing `(` or `)` or invalid param list",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "here",
		}),
	}

}

func (p *parser) callonFunc39() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc39()
}

func (c *current) onFunc2(nameI, paramsI interface{}) (interface{}, error) {
	params := paramsI.(file.Func)
	return file.Func{
		Name:      nameI.(file.GoIdent),
		LParenPos: params.LParenPos,
		Params:    params.Params,
		RParenPos: params.RParenPos,
		Position:  pos(c),
	}, nil
}

func (p *parser) callonFunc2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc2(stack["nameI"], stack["paramsI"])
}

func (c *current) onFunc43(posI interface{}) (interface{}, error) {
	return file.Func{Position: pos(c)}, &corgierr.Error{
		Message: "missing func name",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected an identifier followed by a parameter list",
		}),
	}
}

func (p *parser) callonFunc43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc43(stack["posI"])
}

func (c *current) onfuncOnlyVariadicParamList1(variadicI interface{}) (interface{}, error) {
	return []file.FuncParam{variadicI.(file.FuncParam)}, nil
}

func (p *parser) callonfuncOnlyVariadicParamList1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncOnlyVariadicParamList1(stack["variadicI"])
}

func (c *current) onfuncOtherParamList1(firstI, restI, variadicI interface{}) (interface{}, error) {
	restTuples := islice(restI)

	n := 1 + len(restTuples)
	if variadicI != nil {
		n++
	}
	params := make([]file.FuncParam, 1, n)
	params[0] = firstI.(file.FuncParam)

	for _, t := range restTuples {
		params = append(params, getTuple[file.FuncParam](t, -1))
	}

	if variadicI != nil {
		params = append(params, getTuple[file.FuncParam](variadicI, -1))
	}

	return params, nil
}

func (p *parser) callonfuncOtherParamList1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncOtherParamList1(stack["firstI"], stack["restI"], stack["variadicI"])
}

func (c *current) onfuncParam2(namesI, typeI interface{}) (interface{}, error) {
	return file.FuncParam{
		Names: namesI.([]file.GoIdent),
		Type:  typeI.(file.GoType),
	}, nil
}

func (p *parser) callonfuncParam2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam2(stack["namesI"], stack["typeI"])
}

func (c *current) onfuncParam10(typeI interface{}) (interface{}, error) {
	return file.FuncParam{
		Type: typeI.(file.GoType),
	}, nil
}

func (p *parser) callonfuncParam10() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam10(stack["typeI"])
}

func (c *current) onfuncVariadicParam1(nameI, typeI interface{}) (interface{}, error) {
	var names []file.GoIdent
	if nameI != nil {
		names = []file.GoIdent{getTuple[file.GoIdent](nameI, 0)}
	}

	return file.FuncParam{
		Names:    names,
		Variadic: true,
		Type:     typeI.(file.GoType),
	}, nil
}

func (p *parser) callonfuncVariadicParam1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncVariadicParam1(stack["nameI"], stack["typeI"])
}

func (c *current) onfuncIdentList1(firstI, restI interface{}) (interface{}, error) {
	restTuples := islice(restI)
	idents := make([]file.GoIdent, 1, 1+len(restTuples))
	idents[0] = firstI.(file.GoIdent)

	for _, t := range restTuples {
		idents = append(idents, getTuple[file.GoIdent](t, -1))
	}

	return idents, nil
}

func (p *parser) callonfuncIdentList1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncIdentList1(stack["firstI"], stack["restI"])
}

func (c *current) onfuncType3(typeI, endPosI interface{}) (interface{}, error) {
	return file.GoType{
			Type:     concat(typeI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid type",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "not a valid Go type",
			}),
		}
}

func (p *parser) callonfuncType3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncType3(stack["typeI"], stack["endPosI"])
}

func (c *current) onInlineText1(lineI interface{}) (interface{}, error) {
	return file.InlineText{
		Text:     lineI.(file.TextLine),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineText1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineText1(stack["lineI"])
}

func (c *current) onArrowBlock2(firstLineI, additionalLinesI interface{}) (interface{}, error) {
	firstLine, firstLineOk := firstLineI.(file.TextLine)
	additionalLineTuples := islice(additionalLinesI)

	n := len(additionalLineTuples)
	if firstLineOk {
		n++
	}

	lines := make([]file.TextLine, 0, n)
	if firstLineOk {
		lines = append(lines, firstLine)
	}
	for _, lt := range additionalLineTuples {
		lines = append(lines, getTuple[file.TextLine](lt, -1))
	}

	return file.ArrowBlock{
		Lines:    lines,
		Position: pos(c),
	}, nil
}

func (p *parser) callonArrowBlock2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onArrowBlock2(stack["firstLineI"], stack["additionalLinesI"])
}

func (c *current) onArrowBlock16() (interface{}, error) {
	return file.ArrowBlock{Position: pos(c)}, nil
}

func (p *parser) callonArrowBlock16() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onArrowBlock16()
}

func (c *current) onInlineArrowBlock2(lineI interface{}) (interface{}, error) {
	return file.ArrowBlock{
		Lines:    []file.TextLine{lineI.(file.TextLine)},
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineArrowBlock2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineArrowBlock2(stack["lineI"])
}

func (c *current) onInlineArrowBlock7(posI, lineI interface{}) (interface{}, error) {
	return file.ArrowBlock{
			Lines:    []file.TextLine{lineI.(file.TextLine)},
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing space",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a space here, separating the `>` from the text",
			}),
			Example: "`> woof`",
		}
}

func (p *parser) callonInlineArrowBlock7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineArrowBlock7(stack["posI"], stack["lineI"])
}

func (c *current) onTextLine1(itemsI interface{}) (interface{}, error) {
	return file.TextLine(typedSlice[file.TextItem](itemsI)), nil
}

func (p *parser) callonTextLine1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTextLine1(stack["itemsI"])
}

func (c *current) onText1(textI interface{}) (interface{}, error) {
	return file.Text{
		Text:     concat(textI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonText1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onText1(stack["textI"])
}

func (c *current) onBadInterpolation1() (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "bad interpolation",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "start of interpolation",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:       pos(c),
				StartOffset: 1,
				Annotation:  "expected a `#`, `[`, `" + lbrace + "`, a mixin call, or an element name here",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
		},
	}
}

func (p *parser) callonBadInterpolation1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBadInterpolation1()
}

func (c *current) onSimpleInterpolation2(noEscapeI, valueI interface{}) (interface{}, error) {
	return file.SimpleInterpolation{
		NoEscape: noEscapeI != nil,
		Value:    valueI.(file.InterpolationValue),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSimpleInterpolation2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation2(stack["noEscapeI"], stack["valueI"])
}

func (c *current) onSimpleInterpolation10(valueI interface{}) (interface{}, error) {
	return file.SimpleInterpolation{
		Value:    valueI.(file.InterpolationValue),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSimpleInterpolation10() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation10(stack["valueI"])
}

func (c *current) onElementInterpolation1(elPosI, nameI, attrsI, valueI interface{}) (interface{}, error) {
	return file.ElementInterpolation{
		Element: file.Element{
			Name:       concat(nameI),
			Attributes: typedSlice[file.AttributeCollection](attrsI),
			Void:       castedOrZero[bool](valueI),
			Position:   elPosI.(file.Position),
		},
		Value:    castedOrZero[file.InterpolationValue](valueI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonElementInterpolation1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElementInterpolation1(stack["elPosI"], stack["nameI"], stack["attrsI"], stack["valueI"])
}

func (c *current) onelementInterpolationValue4() (interface{}, error) {
	return true, nil // hacky, but whatev
}

func (p *parser) callonelementInterpolationValue4() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue4()
}

func (c *current) onMixinCallInterpolation1(mcPosI, namespaceI, nameI, argsI, valueI interface{}) (interface{}, error) {
	args := castedOrZero[file.MixinCall](argsI)

	var namespace *file.Ident
	if namespaceI != nil {
		namespace = ptr(getTuple[file.Ident](namespaceI, 0))
	}

	return file.MixinCallInterpolation{
		MixinCall: file.MixinCall{
			Namespace: namespace,
			Name:      nameI.(file.Ident),
			LParenPos: args.LParenPos,
			Args:      args.Args,
			RParenPos: args.RParenPos,
			Position:  mcPosI.(file.Position),
		},
		Value:    castedOrZero[file.InterpolationValue](valueI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonMixinCallInterpolation1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation1(stack["mcPosI"], stack["namespaceI"], stack["nameI"], stack["argsI"], stack["valueI"])
}

func (c *current) ontextInterpolationValue2(lBracketPosI, textI, rBracketPosI interface{}) (interface{}, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
		RBracketPos: rBracketPosI.(file.Position),
	}, nil
}

func (p *parser) callontextInterpolationValue2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ontextInterpolationValue2(stack["lBracketPosI"], stack["textI"], stack["rBracketPosI"])
}

func (c *current) ontextInterpolationValue11(lBracketPosI, textI interface{}) (interface{}, error) {
	return file.TextInterpolationValue{
			LBracketPos: lBracketPosI.(file.Position),
			Text:        concat(textI),
		}, &corgierr.Error{
			Message: "unclosed text interpolation",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "`[` opened here, but never closeed",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:       pos(c),
					StartOffset: 1,
					EOLDelta:    1,
					Annotation:  "expected a `]` somewhere here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
			},
		}
}

func (p *parser) callontextInterpolationValue11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ontextInterpolationValue11(stack["lBracketPosI"], stack["textI"])
}

func (c *current) onexpressionInterpolationValue2(lBracePosI, exprI, rBracePosI interface{}) (interface{}, error) {
	return file.ExpressionInterpolationValue{
		LBracePos:  lBracePosI.(file.Position),
		Expression: exprI.(file.Expression),
		RBracePos:  rBracePosI.(file.Position),
	}, nil
}

func (p *parser) callonexpressionInterpolationValue2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue2(stack["lBracePosI"], stack["exprI"], stack["rBracePosI"])
}

func (c *current) onexpressionInterpolationValue10(lBracePosI, exprI interface{}) (interface{}, error) {
	return file.ExpressionInterpolationValue{
			LBracePos:  lBracePosI.(file.Position),
			Expression: exprI.(file.Expression),
		}, &corgierr.Error{
			Message: "unclosed expression interpolation",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "`{` opened here, but never closeed",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:       pos(c),
					StartOffset: 1,
					EOLDelta:    1,
					Annotation:  "expected a `}` somewhere here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
			},
		}
}

func (p *parser) callonexpressionInterpolationValue10() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue10(stack["lBracePosI"], stack["exprI"])
}

func (c *current) onfmtExpressionInterpolationValue1(fmtDirectiveI, eivI interface{}) (interface{}, error) {
	eiv := eivI.(file.ExpressionInterpolationValue)
	eiv.FormatDirective = fmtDirectiveI.(string)
	return eiv, nil
}

func (p *parser) callonfmtExpressionInterpolationValue1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfmtExpressionInterpolationValue1(stack["fmtDirectiveI"], stack["eivI"])
}

func (c *current) onPOS1() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonPOS1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPOS1()
}

func (c *current) onL_PAREN1() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonL_PAREN1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onL_PAREN1()
}

func (c *current) onR_PAREN1() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonR_PAREN1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onR_PAREN1()
}

func (c *current) onL_BRACE1() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonL_BRACE1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onL_BRACE1()
}

func (c *current) onR_BRACE1() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonR_BRACE1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onR_BRACE1()
}

func (c *current) onL_BRACKET1() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonL_BRACKET1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onL_BRACKET1()
}

func (c *current) onR_BRACKET1() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonR_BRACKET1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onR_BRACKET1()
}

func (c *current) onINDENTATION2() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonINDENTATION2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION2()
}

func (c *current) onINDENTATION5() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonINDENTATION5() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION5()
}

func (c *current) onINDENTATION7() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonINDENTATION7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION7()
}

func (c *current) onINDENTATION9() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0 && len(c.text) > 0, nil

}

func (p *parser) callonINDENTATION9() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION9()
}

func (c *current) onINDENTATION10() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonINDENTATION10() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION10()
}

func (c *current) onINDENTATION12() (bool, error) {
	// this is NOT our first indentation
	return c.state["Indentation.RefLine"].(int) != 0, nil

}

func (p *parser) callonINDENTATION12() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION12()
}

func (c *current) onINDENTATION13() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonINDENTATION13() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION13()
}

func (c *current) onINDENTATION16() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonINDENTATION16() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION16()
}

func (c *current) onINDENTATION17() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonINDENTATION17() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION17()
}

func (c *current) onINDENTATION18() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonINDENTATION18() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION18()
}

func (c *current) onINDENTATION20() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonINDENTATION20() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION20()
}

func (c *current) onINDENTATION21() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	} else if actualCount < expectCount {
		return false, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonINDENTATION21() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION21()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL3() (bool, error) {
	// this is our first ever indentation, INDENTATION will handle it
	return c.state["Indentation.Repetitions"].(int) == 0, nil
}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL3() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL3()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL6() (bool, error) {
	return c.state["Indentation.Repetitions"].(int) > 0, nil
}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL6()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL5() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL5() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL5()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL10() (bool, error) {
	refReps := c.state["Indentation.Repetitions"].(int)
	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	want := totalReps + refReps
	have := c.state["Indentation.CharCount"].(int)
	if want == have {
		return true, nil
	}

	return false, nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL10() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL10()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL14() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	have := c.state["Indentation.CharCount"].(int)
	want := totalReps + refReps
	if have == want {
		return true, nil
	} else if have <= totalReps {
		return false, nil
	}

	if indentChar == ' ' {
		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               have - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d spaces", have-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two spaces for a single indentation, use four for a two-level indentation",
				},
			},
		}
	}

	return true, &corgierr.Error{
		Message: "inconsistent indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
			Len:               have - totalReps,
			Annotation:        fmt.Sprintf("however, here you used %d tabs", have-totalReps),
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: refLine, Col: 1},
				Len:               refReps,
				Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "be consistent in your indentation:\n" +
					"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
			},
		},
	}

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL14()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL15() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	have := c.state["Indentation.CharCount"].(int)

	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(have - totalReps)
	c.state["Indentation.TotalRepetitions"] = have
	return nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL15() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL15()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL17() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL17() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL17()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL18() (bool, error) {
	want := c.state["Indentation.TotalRepetitions"].(int)
	have := c.state["Indentation.CharCount"].(int)
	return want == have, nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL18()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL19() error {
	c.state["Indentation.CharCount"] = 0
	return nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL19() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL19()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL22() (interface{}, error) {
	return c.text, nil
}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL22() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL22()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL24(spaceI interface{}) (bool, error) {
	space := byte(char(spaceI))

	indentChar := c.state["Indentation.Char"].(byte)
	if indentChar != space {
		refLine := c.state["Indentation.RefLine"].(int)
		reps := c.state["Indentation.Repetitions"].(int)

		if indentChar == ' ' {
			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      pos(c),
					Annotation: "this is a tab",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               reps,
						Annotation:        "these are spaces",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}

		panic(&corgierr.Error{
			Message: "mix of tabs and spaces for indentation",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "this is a space",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               reps,
					Annotation:        "these are tabs",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "use only tabs OR spaces for indentation, but not both"},
			},
		})
	}

	return true, nil
}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL24() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL24(stack["spaceI"])
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL25(spaceI interface{}) error {
	c.state["Indentation.CharCount"] = c.state["Indentation.CharCount"].(int) + 1
	return nil
}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL25() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL25(stack["spaceI"])
}

func (c *current) onINDENT1() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonINDENT1() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENT1()
}

func (c *current) onDEDENT1() error {
	lvl := c.state["Indentation.Level"].(int)
	c.state["Indentation.Level"] = lvl - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonDEDENT1() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDEDENT1()
}

func (c *current) onINDENTATION23() (bool, error) {
	return c.state["Indentation.Level"].(int) == 0, nil
}

func (p *parser) callonINDENTATION23() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION23()
}

var (
	// errNoRule is returned when the grammar to parse has no rule.
	errNoRule = errors.New("grammar has no rule")

	// errInvalidEntrypoint is returned when the specified entrypoint rule
	// does not exit.
	errInvalidEntrypoint = errors.New("invalid entrypoint")

	// errInvalidEncoding is returned when the source is not properly
	// utf8-encoded.
	errInvalidEncoding = errors.New("invalid encoding")

	// errMaxExprCnt is used to signal that the maximum number of
	// expressions have been parsed.
	errMaxExprCnt = errors.New("max number of expresssions parsed")
)

// Option is a function that can set an option on the parser. It returns
// the previous setting as an Option.
type Option func(*parser) Option

// MaxExpressions creates an Option to stop parsing after the provided
// number of expressions have been parsed, if the value is 0 then the parser will
// parse for as many steps as needed (possibly an infinite number).
//
// The default for maxExprCnt is 0.
func MaxExpressions(maxExprCnt uint64) Option {
	return func(p *parser) Option {
		oldMaxExprCnt := p.maxExprCnt
		p.maxExprCnt = maxExprCnt
		return MaxExpressions(oldMaxExprCnt)
	}
}

// Entrypoint creates an Option to set the rule name to use as entrypoint.
// The rule name must have been specified in the -alternate-entrypoints
// if generating the parser with the -optimize-grammar flag, otherwise
// it may have been optimized out. Passing an empty string sets the
// entrypoint to the first rule in the grammar.
//
// The default is to start parsing at the first rule in the grammar.
func Entrypoint(ruleName string) Option {
	return func(p *parser) Option {
		oldEntrypoint := p.entrypoint
		p.entrypoint = ruleName
		if ruleName == "" {
			p.entrypoint = g.rules[0].name
		}
		return Entrypoint(oldEntrypoint)
	}
}

// AllowInvalidUTF8 creates an Option to allow invalid UTF-8 bytes.
// Every invalid UTF-8 byte is treated as a utf8.RuneError (U+FFFD)
// by character class matchers and is matched by the any matcher.
// The returned matched value, c.text and c.offset are NOT affected.
//
// The default is false.
func AllowInvalidUTF8(b bool) Option {
	return func(p *parser) Option {
		old := p.allowInvalidUTF8
		p.allowInvalidUTF8 = b
		return AllowInvalidUTF8(old)
	}
}

// Recover creates an Option to set the recover flag to b. When set to
// true, this causes the parser to recover from panics and convert it
// to an error. Setting it to false can be useful while debugging to
// access the full stack trace.
//
// The default is true.
func Recover(b bool) Option {
	return func(p *parser) Option {
		old := p.recover
		p.recover = b
		return Recover(old)
	}
}

// GlobalStore creates an Option to set a key to a certain value in
// the globalStore.
func GlobalStore(key string, value interface{}) Option {
	return func(p *parser) Option {
		old := p.cur.globalStore[key]
		p.cur.globalStore[key] = value
		return GlobalStore(key, old)
	}
}

// InitState creates an Option to set a key to a certain value in
// the global "state" store.
func InitState(key string, value interface{}) Option {
	return func(p *parser) Option {
		old := p.cur.state[key]
		p.cur.state[key] = value
		return InitState(key, old)
	}
}

// ParseFile parses the file identified by filename.
func ParseFile(filename string, opts ...Option) (i interface{}, err error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer func() {
		if closeErr := f.Close(); closeErr != nil {
			err = closeErr
		}
	}()
	return ParseReader(filename, f, opts...)
}

// ParseReader parses the data from r using filename as information in the
// error messages.
func ParseReader(filename string, r io.Reader, opts ...Option) (interface{}, error) {
	b, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}

	return Parse(filename, b, opts...)
}

// Parse parses the data from b using filename as information in the
// error messages.
func Parse(filename string, b []byte, opts ...Option) (interface{}, error) {
	return newParser(filename, b, opts...).parse(g)
}

// position records a position in the text.
type position struct {
	line, col, offset int
}

func (p position) String() string {
	return strconv.Itoa(p.line) + ":" + strconv.Itoa(p.col) + " [" + strconv.Itoa(p.offset) + "]"
}

// savepoint stores all state required to go back to this point in the
// parser.
type savepoint struct {
	position
	rn rune
	w  int
}

type current struct {
	pos  position // start position of the match
	text []byte   // raw text of the match

	// state is a store for arbitrary key,value pairs that the user wants to be
	// tied to the backtracking of the parser.
	// This is always rolled back if a parsing rule fails.
	state storeDict

	// globalStore is a general store for the user to store arbitrary key-value
	// pairs that they need to manage and that they do not want tied to the
	// backtracking of the parser. This is only modified by the user and never
	// rolled back by the parser. It is always up to the user to keep this in a
	// consistent state.
	globalStore storeDict
}

type storeDict map[string]interface{}

// the AST types...

type grammar struct {
	pos   position
	rules []*rule
}

type rule struct {
	pos         position
	name        string
	displayName string
	expr        interface{}
}

type choiceExpr struct {
	pos          position
	alternatives []interface{}
}

type actionExpr struct {
	pos  position
	expr interface{}
	run  func(*parser) (interface{}, error)
}

type recoveryExpr struct {
	pos          position
	expr         interface{}
	recoverExpr  interface{}
	failureLabel []string
}

type seqExpr struct {
	pos   position
	exprs []interface{}
}

type throwExpr struct {
	pos   position
	label string
}

type labeledExpr struct {
	pos   position
	label string
	expr  interface{}
}

type expr struct {
	pos  position
	expr interface{}
}

type andExpr expr
type notExpr expr
type zeroOrOneExpr expr
type zeroOrMoreExpr expr
type oneOrMoreExpr expr

type ruleRefExpr struct {
	pos  position
	name string
}

type stateCodeExpr struct {
	pos position
	run func(*parser) error
}

type andCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type notCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type litMatcher struct {
	pos        position
	val        string
	ignoreCase bool
	want       string
}

type charClassMatcher struct {
	pos             position
	val             string
	basicLatinChars [128]bool
	chars           []rune
	ranges          []rune
	classes         []*unicode.RangeTable
	ignoreCase      bool
	inverted        bool
}

type anyMatcher position

// errList cumulates the errors found by the parser.
type errList []error

func (e *errList) add(err error) {
	*e = append(*e, err)
}

func (e errList) err() error {
	if len(e) == 0 {
		return nil
	}
	e.dedupe()
	return e
}

func (e *errList) dedupe() {
	var cleaned []error
	set := make(map[string]bool)
	for _, err := range *e {
		if msg := err.Error(); !set[msg] {
			set[msg] = true
			cleaned = append(cleaned, err)
		}
	}
	*e = cleaned
}

func (e errList) Error() string {
	switch len(e) {
	case 0:
		return ""
	case 1:
		return e[0].Error()
	default:
		var buf bytes.Buffer

		for i, err := range e {
			if i > 0 {
				buf.WriteRune('\n')
			}
			buf.WriteString(err.Error())
		}
		return buf.String()
	}
}

// parserError wraps an error with a prefix indicating the rule in which
// the error occurred. The original error is stored in the Inner field.
type parserError struct {
	Inner    error
	pos      position
	prefix   string
	expected []string
}

// Error returns the error message.
func (p *parserError) Error() string {
	return p.prefix + ": " + p.Inner.Error()
}

// newParser creates a parser with the specified input source and options.
func newParser(filename string, b []byte, opts ...Option) *parser {
	stats := Stats{
		ChoiceAltCnt: make(map[string]map[string]int),
	}

	p := &parser{
		filename: filename,
		errs:     new(errList),
		data:     b,
		pt:       savepoint{position: position{line: 1}},
		recover:  true,
		cur: current{
			state:       make(storeDict),
			globalStore: make(storeDict),
		},
		maxFailPos:      position{col: 1, line: 1},
		maxFailExpected: make([]string, 0, 20),
		Stats:           &stats,
		// start rule is rule [0] unless an alternate entrypoint is specified
		entrypoint: g.rules[0].name,
	}
	p.setOptions(opts)

	if p.maxExprCnt == 0 {
		p.maxExprCnt = math.MaxUint64
	}

	return p
}

// setOptions applies the options to the parser.
func (p *parser) setOptions(opts []Option) {
	for _, opt := range opts {
		opt(p)
	}
}

type resultTuple struct {
	v   interface{}
	b   bool
	end savepoint
}

const choiceNoMatch = -1

// Stats stores some statistics, gathered during parsing
type Stats struct {
	// ExprCnt counts the number of expressions processed during parsing
	// This value is compared to the maximum number of expressions allowed
	// (set by the MaxExpressions option).
	ExprCnt uint64

	// ChoiceAltCnt is used to count for each ordered choice expression,
	// which alternative is used how may times.
	// These numbers allow to optimize the order of the ordered choice expression
	// to increase the performance of the parser
	//
	// The outer key of ChoiceAltCnt is composed of the name of the rule as well
	// as the line and the column of the ordered choice.
	// The inner key of ChoiceAltCnt is the number (one-based) of the matching alternative.
	// For each alternative the number of matches are counted. If an ordered choice does not
	// match, a special counter is incremented. The name of this counter is set with
	// the parser option Statistics.
	// For an alternative to be included in ChoiceAltCnt, it has to match at least once.
	ChoiceAltCnt map[string]map[string]int
}

type parser struct {
	filename string
	pt       savepoint
	cur      current

	data []byte
	errs *errList

	depth   int
	recover bool

	// rules table, maps the rule identifier to the rule node
	rules map[string]*rule
	// variables stack, map of label to value
	vstack []map[string]interface{}
	// rule stack, allows identification of the current rule in errors
	rstack []*rule

	// parse fail
	maxFailPos            position
	maxFailExpected       []string
	maxFailInvertExpected bool

	// max number of expressions to be parsed
	maxExprCnt uint64
	// entrypoint for the parser
	entrypoint string

	allowInvalidUTF8 bool

	*Stats

	choiceNoMatch string
	// recovery expression stack, keeps track of the currently available recovery expression, these are traversed in reverse
	recoveryStack []map[string]interface{}
}

// push a variable set on the vstack.
func (p *parser) pushV() {
	if cap(p.vstack) == len(p.vstack) {
		// create new empty slot in the stack
		p.vstack = append(p.vstack, nil)
	} else {
		// slice to 1 more
		p.vstack = p.vstack[:len(p.vstack)+1]
	}

	// get the last args set
	m := p.vstack[len(p.vstack)-1]
	if m != nil && len(m) == 0 {
		// empty map, all good
		return
	}

	m = make(map[string]interface{})
	p.vstack[len(p.vstack)-1] = m
}

// pop a variable set from the vstack.
func (p *parser) popV() {
	// if the map is not empty, clear it
	m := p.vstack[len(p.vstack)-1]
	if len(m) > 0 {
		// GC that map
		p.vstack[len(p.vstack)-1] = nil
	}
	p.vstack = p.vstack[:len(p.vstack)-1]
}

// push a recovery expression with its labels to the recoveryStack
func (p *parser) pushRecovery(labels []string, expr interface{}) {
	if cap(p.recoveryStack) == len(p.recoveryStack) {
		// create new empty slot in the stack
		p.recoveryStack = append(p.recoveryStack, nil)
	} else {
		// slice to 1 more
		p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)+1]
	}

	m := make(map[string]interface{}, len(labels))
	for _, fl := range labels {
		m[fl] = expr
	}
	p.recoveryStack[len(p.recoveryStack)-1] = m
}

// pop a recovery expression from the recoveryStack
func (p *parser) popRecovery() {
	// GC that map
	p.recoveryStack[len(p.recoveryStack)-1] = nil

	p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)-1]
}

func (p *parser) addErr(err error) {
	p.addErrAt(err, p.pt.position, []string{})
}

func (p *parser) addErrAt(err error, pos position, expected []string) {
	var buf bytes.Buffer
	if p.filename != "" {
		buf.WriteString(p.filename)
	}
	if buf.Len() > 0 {
		buf.WriteString(":")
	}
	buf.WriteString(fmt.Sprintf("%d:%d (%d)", pos.line, pos.col, pos.offset))
	if len(p.rstack) > 0 {
		if buf.Len() > 0 {
			buf.WriteString(": ")
		}
		rule := p.rstack[len(p.rstack)-1]
		if rule.displayName != "" {
			buf.WriteString("rule " + rule.displayName)
		} else {
			buf.WriteString("rule " + rule.name)
		}
	}
	pe := &parserError{Inner: err, pos: pos, prefix: buf.String(), expected: expected}
	p.errs.add(pe)
}

func (p *parser) failAt(fail bool, pos position, want string) {
	// process fail if parsing fails and not inverted or parsing succeeds and invert is set
	if fail == p.maxFailInvertExpected {
		if pos.offset < p.maxFailPos.offset {
			return
		}

		if pos.offset > p.maxFailPos.offset {
			p.maxFailPos = pos
			p.maxFailExpected = p.maxFailExpected[:0]
		}

		if p.maxFailInvertExpected {
			want = "!" + want
		}
		p.maxFailExpected = append(p.maxFailExpected, want)
	}
}

// read advances the parser to the next rune.
func (p *parser) read() {
	p.pt.offset += p.pt.w
	rn, n := utf8.DecodeRune(p.data[p.pt.offset:])
	p.pt.rn = rn
	p.pt.w = n
	p.pt.col++
	if rn == '\n' {
		p.pt.line++
		p.pt.col = 0
	}

	if rn == utf8.RuneError && n == 1 { // see utf8.DecodeRune
		if !p.allowInvalidUTF8 {
			p.addErr(errInvalidEncoding)
		}
	}
}

// restore parser position to the savepoint pt.
func (p *parser) restore(pt savepoint) {
	if pt.offset == p.pt.offset {
		return
	}
	p.pt = pt
}

// Cloner is implemented by any value that has a Clone method, which returns a
// copy of the value. This is mainly used for types which are not passed by
// value (e.g map, slice, chan) or structs that contain such types.
//
// This is used in conjunction with the global state feature to create proper
// copies of the state to allow the parser to properly restore the state in
// the case of backtracking.
type Cloner interface {
	Clone() interface{}
}

var statePool = &sync.Pool{
	New: func() interface{} { return make(storeDict) },
}

func (sd storeDict) Discard() {
	for k := range sd {
		delete(sd, k)
	}
	statePool.Put(sd)
}

// clone and return parser current state.
func (p *parser) cloneState() storeDict {

	state := statePool.Get().(storeDict)
	for k, v := range p.cur.state {
		if c, ok := v.(Cloner); ok {
			state[k] = c.Clone()
		} else {
			state[k] = v
		}
	}
	return state
}

// restore parser current state to the state storeDict.
// every restoreState should applied only one time for every cloned state
func (p *parser) restoreState(state storeDict) {
	p.cur.state.Discard()
	p.cur.state = state
}

// get the slice of bytes from the savepoint start to the current position.
func (p *parser) sliceFrom(start savepoint) []byte {
	return p.data[start.position.offset:p.pt.position.offset]
}

func (p *parser) buildRulesTable(g *grammar) {
	p.rules = make(map[string]*rule, len(g.rules))
	for _, r := range g.rules {
		p.rules[r.name] = r
	}
}

func (p *parser) parse(g *grammar) (val interface{}, err error) {
	if len(g.rules) == 0 {
		p.addErr(errNoRule)
		return nil, p.errs.err()
	}

	// TODO : not super critical but this could be generated
	p.buildRulesTable(g)

	if p.recover {
		// panic can be used in action code to stop parsing immediately
		// and return the panic as an error.
		defer func() {
			if e := recover(); e != nil {
				val = nil
				switch e := e.(type) {
				case error:
					p.addErr(e)
				default:
					p.addErr(fmt.Errorf("%v", e))
				}
				err = p.errs.err()
			}
		}()
	}

	startRule, ok := p.rules[p.entrypoint]
	if !ok {
		p.addErr(errInvalidEntrypoint)
		return nil, p.errs.err()
	}

	p.read() // advance to first rune
	val, ok = p.parseRule(startRule)
	if !ok {
		if len(*p.errs) == 0 {
			// If parsing fails, but no errors have been recorded, the expected values
			// for the farthest parser position are returned as error.
			maxFailExpectedMap := make(map[string]struct{}, len(p.maxFailExpected))
			for _, v := range p.maxFailExpected {
				maxFailExpectedMap[v] = struct{}{}
			}
			expected := make([]string, 0, len(maxFailExpectedMap))
			eof := false
			if _, ok := maxFailExpectedMap["!."]; ok {
				delete(maxFailExpectedMap, "!.")
				eof = true
			}
			for k := range maxFailExpectedMap {
				expected = append(expected, k)
			}
			sort.Strings(expected)
			if eof {
				expected = append(expected, "EOF")
			}
			p.addErrAt(errors.New("no match found, expected: "+listJoin(expected, ", ", "or")), p.maxFailPos, expected)
		}

		return nil, p.errs.err()
	}
	return val, p.errs.err()
}

func listJoin(list []string, sep string, lastSep string) string {
	switch len(list) {
	case 0:
		return ""
	case 1:
		return list[0]
	default:
		return strings.Join(list[:len(list)-1], sep) + " " + lastSep + " " + list[len(list)-1]
	}
}

func (p *parser) parseRule(rule *rule) (interface{}, bool) {
	p.rstack = append(p.rstack, rule)
	p.pushV()
	val, ok := p.parseExpr(rule.expr)
	p.popV()
	p.rstack = p.rstack[:len(p.rstack)-1]
	return val, ok
}

func (p *parser) parseExpr(expr interface{}) (interface{}, bool) {

	p.ExprCnt++
	if p.ExprCnt > p.maxExprCnt {
		panic(errMaxExprCnt)
	}

	var val interface{}
	var ok bool
	switch expr := expr.(type) {
	case *actionExpr:
		val, ok = p.parseActionExpr(expr)
	case *andCodeExpr:
		val, ok = p.parseAndCodeExpr(expr)
	case *andExpr:
		val, ok = p.parseAndExpr(expr)
	case *anyMatcher:
		val, ok = p.parseAnyMatcher(expr)
	case *charClassMatcher:
		val, ok = p.parseCharClassMatcher(expr)
	case *choiceExpr:
		val, ok = p.parseChoiceExpr(expr)
	case *labeledExpr:
		val, ok = p.parseLabeledExpr(expr)
	case *litMatcher:
		val, ok = p.parseLitMatcher(expr)
	case *notCodeExpr:
		val, ok = p.parseNotCodeExpr(expr)
	case *notExpr:
		val, ok = p.parseNotExpr(expr)
	case *oneOrMoreExpr:
		val, ok = p.parseOneOrMoreExpr(expr)
	case *recoveryExpr:
		val, ok = p.parseRecoveryExpr(expr)
	case *ruleRefExpr:
		val, ok = p.parseRuleRefExpr(expr)
	case *seqExpr:
		val, ok = p.parseSeqExpr(expr)
	case *stateCodeExpr:
		val, ok = p.parseStateCodeExpr(expr)
	case *throwExpr:
		val, ok = p.parseThrowExpr(expr)
	case *zeroOrMoreExpr:
		val, ok = p.parseZeroOrMoreExpr(expr)
	case *zeroOrOneExpr:
		val, ok = p.parseZeroOrOneExpr(expr)
	default:
		panic(fmt.Sprintf("unknown expression type %T", expr))
	}
	return val, ok
}

func (p *parser) parseActionExpr(act *actionExpr) (interface{}, bool) {
	start := p.pt
	val, ok := p.parseExpr(act.expr)
	if ok {
		p.cur.pos = start.position
		p.cur.text = p.sliceFrom(start)
		state := p.cloneState()
		actVal, err := act.run(p)
		if err != nil {
			p.addErrAt(err, start.position, []string{})
		}
		p.restoreState(state)

		val = actVal
	}
	return val, ok
}

func (p *parser) parseAndCodeExpr(and *andCodeExpr) (interface{}, bool) {
	state := p.cloneState()

	ok, err := and.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, ok
}

func (p *parser) parseAndExpr(and *andExpr) (interface{}, bool) {
	pt := p.pt
	state := p.cloneState()
	p.pushV()
	_, ok := p.parseExpr(and.expr)
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, ok
}

func (p *parser) parseAnyMatcher(any *anyMatcher) (interface{}, bool) {
	if p.pt.rn == utf8.RuneError && p.pt.w == 0 {
		// EOF - see utf8.DecodeRune
		p.failAt(false, p.pt.position, ".")
		return nil, false
	}
	start := p.pt
	p.read()
	p.failAt(true, start.position, ".")
	return p.sliceFrom(start), true
}

func (p *parser) parseCharClassMatcher(chr *charClassMatcher) (interface{}, bool) {
	cur := p.pt.rn
	start := p.pt

	// can't match EOF
	if cur == utf8.RuneError && p.pt.w == 0 { // see utf8.DecodeRune
		p.failAt(false, start.position, chr.val)
		return nil, false
	}

	if chr.ignoreCase {
		cur = unicode.ToLower(cur)
	}

	// try to match in the list of available chars
	for _, rn := range chr.chars {
		if rn == cur {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of ranges
	for i := 0; i < len(chr.ranges); i += 2 {
		if cur >= chr.ranges[i] && cur <= chr.ranges[i+1] {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of Unicode classes
	for _, cl := range chr.classes {
		if unicode.Is(cl, cur) {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	if chr.inverted {
		p.read()
		p.failAt(true, start.position, chr.val)
		return p.sliceFrom(start), true
	}
	p.failAt(false, start.position, chr.val)
	return nil, false
}

func (p *parser) parseChoiceExpr(ch *choiceExpr) (interface{}, bool) {
	for altI, alt := range ch.alternatives {
		// dummy assignment to prevent compile error if optimized
		_ = altI

		state := p.cloneState()

		p.pushV()
		val, ok := p.parseExpr(alt)
		p.popV()
		if ok {
			return val, ok
		}
		p.restoreState(state)
	}
	return nil, false
}

func (p *parser) parseLabeledExpr(lab *labeledExpr) (interface{}, bool) {
	p.pushV()
	val, ok := p.parseExpr(lab.expr)
	p.popV()
	if ok && lab.label != "" {
		m := p.vstack[len(p.vstack)-1]
		m[lab.label] = val
	}
	return val, ok
}

func (p *parser) parseLitMatcher(lit *litMatcher) (interface{}, bool) {
	start := p.pt
	for _, want := range lit.val {
		cur := p.pt.rn
		if lit.ignoreCase {
			cur = unicode.ToLower(cur)
		}
		if cur != want {
			p.failAt(false, start.position, lit.want)
			p.restore(start)
			return nil, false
		}
		p.read()
	}
	p.failAt(true, start.position, lit.want)
	return p.sliceFrom(start), true
}

func (p *parser) parseNotCodeExpr(not *notCodeExpr) (interface{}, bool) {
	state := p.cloneState()

	ok, err := not.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, !ok
}

func (p *parser) parseNotExpr(not *notExpr) (interface{}, bool) {
	pt := p.pt
	state := p.cloneState()
	p.pushV()
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	_, ok := p.parseExpr(not.expr)
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, !ok
}

func (p *parser) parseOneOrMoreExpr(expr *oneOrMoreExpr) (interface{}, bool) {
	var vals []interface{}

	for {
		p.pushV()
		val, ok := p.parseExpr(expr.expr)
		p.popV()
		if !ok {
			if len(vals) == 0 {
				// did not match once, no match
				return nil, false
			}
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseRecoveryExpr(recover *recoveryExpr) (interface{}, bool) {

	p.pushRecovery(recover.failureLabel, recover.recoverExpr)
	val, ok := p.parseExpr(recover.expr)
	p.popRecovery()

	return val, ok
}

func (p *parser) parseRuleRefExpr(ref *ruleRefExpr) (interface{}, bool) {
	if ref.name == "" {
		panic(fmt.Sprintf("%s: invalid rule: missing name", ref.pos))
	}

	rule := p.rules[ref.name]
	if rule == nil {
		p.addErr(fmt.Errorf("undefined rule: %s", ref.name))
		return nil, false
	}
	return p.parseRule(rule)
}

func (p *parser) parseSeqExpr(seq *seqExpr) (interface{}, bool) {
	vals := make([]interface{}, 0, len(seq.exprs))

	pt := p.pt
	state := p.cloneState()
	for _, expr := range seq.exprs {
		val, ok := p.parseExpr(expr)
		if !ok {
			p.restoreState(state)
			p.restore(pt)
			return nil, false
		}
		vals = append(vals, val)
	}
	return vals, true
}

func (p *parser) parseStateCodeExpr(state *stateCodeExpr) (interface{}, bool) {
	err := state.run(p)
	if err != nil {
		p.addErr(err)
	}
	return nil, true
}

func (p *parser) parseThrowExpr(expr *throwExpr) (interface{}, bool) {

	for i := len(p.recoveryStack) - 1; i >= 0; i-- {
		if recoverExpr, ok := p.recoveryStack[i][expr.label]; ok {
			if val, ok := p.parseExpr(recoverExpr); ok {
				return val, ok
			}
		}
	}

	return nil, false
}

func (p *parser) parseZeroOrMoreExpr(expr *zeroOrMoreExpr) (interface{}, bool) {
	var vals []interface{}

	for {
		p.pushV()
		val, ok := p.parseExpr(expr.expr)
		p.popV()
		if !ok {
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseZeroOrOneExpr(expr *zeroOrOneExpr) (interface{}, bool) {
	p.pushV()
	val, _ := p.parseExpr(expr.expr)
	p.popV()
	// whether it matched or not, consider it a match
	return val, true
}

func rangeTable(class string) *unicode.RangeTable {
	if rt, ok := unicode.Categories[class]; ok {
		return rt
	}
	if rt, ok := unicode.Properties[class]; ok {
		return rt
	}
	if rt, ok := unicode.Scripts[class]; ok {
		return rt
	}

	// cannot happen
	panic(fmt.Sprintf("invalid Unicode class: %s", class))
}
