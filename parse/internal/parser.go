// Code generated by pigeon; DO NOT EDIT.

package internal

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"

	"github.com/mavolin/corgi/corgierr"
	"github.com/mavolin/corgi/file"
	"github.com/mavolin/corgi/internal/stack"
)

type ErrList = errList
type ParserError = parserError

var g = &grammar{
	rules: []*rule{
		{
			name: "File",
			pos:  position{line: 8, col: 1, offset: 89},
			expr: &actionExpr{
				pos: position{line: 9, col: 5, offset: 101},
				run: (*parser).callonFile1,
				expr: &seqExpr{
					pos: position{line: 9, col: 5, offset: 101},
					exprs: []any{
						&stateCodeExpr{
							pos: position{line: 134, col: 9, offset: 3826},
							run: (*parser).callonFile3,
						},
						&zeroOrOneExpr{
							pos: position{line: 10, col: 5, offset: 110},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 11, col: 5, offset: 123},
							label: "extendAndCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 11, col: 24, offset: 142},
								expr: &ruleRefExpr{
									pos:  position{line: 11, col: 24, offset: 142},
									name: "extendAndComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 11, col: 43, offset: 161},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 12, col: 5, offset: 174},
							label: "importsAndCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 12, col: 25, offset: 194},
								expr: &ruleRefExpr{
									pos:  position{line: 12, col: 25, offset: 194},
									name: "importsAndComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 12, col: 45, offset: 214},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 13, col: 5, offset: 227},
							label: "usesAndCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 13, col: 22, offset: 244},
								expr: &ruleRefExpr{
									pos:  position{line: 13, col: 22, offset: 244},
									name: "usesAndComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 13, col: 39, offset: 261},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 14, col: 5, offset: 274},
							label: "globalCodeAndFuncI",
							expr: &zeroOrOneExpr{
								pos: position{line: 14, col: 24, offset: 293},
								expr: &ruleRefExpr{
									pos:  position{line: 14, col: 24, offset: 293},
									name: "globalCodeAndFunc",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 14, col: 43, offset: 312},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 15, col: 5, offset: 325},
							label: "preScopeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 15, col: 15, offset: 335},
								expr: &ruleRefExpr{
									pos:  position{line: 15, col: 15, offset: 335},
									name: "preScope",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 15, col: 25, offset: 345},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 16, col: 5, offset: 358},
							label: "scopeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 16, col: 12, offset: 365},
								expr: &ruleRefExpr{
									pos:  position{line: 16, col: 12, offset: 365},
									name: "Scope",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 16, col: 19, offset: 372},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&notExpr{
							pos: position{line: 3795, col: 12, offset: 129142},
							expr: &anyMatcher{
								line: 3795, col: 13, offset: 129143,
							},
						},
					},
				},
			},
		},
		{
			name: "extendAndComments",
			pos:  position{line: 51, col: 1, offset: 1502},
			expr: &actionExpr{
				pos: position{line: 51, col: 22, offset: 1523},
				run: (*parser).callonextendAndComments1,
				expr: &seqExpr{
					pos: position{line: 51, col: 22, offset: 1523},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 51, col: 22, offset: 1523},
							label: "commsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 51, col: 29, offset: 1530},
								expr: &ruleRefExpr{
									pos:  position{line: 51, col: 29, offset: 1530},
									name: "CorgiComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 51, col: 44, offset: 1545},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 51, col: 53, offset: 1554},
							label: "extI",
							expr: &actionExpr{
								pos: position{line: 3253, col: 11, offset: 111834},
								run: (*parser).callonextendAndComments15,
								expr: &seqExpr{
									pos: position{line: 3253, col: 11, offset: 111834},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 3253, col: 11, offset: 111834},
											val:        "extend",
											ignoreCase: false,
											want:       "\"extend\"",
										},
										&labeledExpr{
											pos:   position{line: 3253, col: 20, offset: 111843},
											label: "extendI",
											expr: &choiceExpr{
												pos: position{line: 3223, col: 18, offset: 110865},
												alternatives: []any{
													&actionExpr{
														pos: position{line: 3223, col: 18, offset: 110865},
														run: (*parser).callonextendAndComments20,
														expr: &seqExpr{
															pos: position{line: 3223, col: 18, offset: 110865},
															exprs: []any{
																&oneOrMoreExpr{
																	pos: position{line: 3223, col: 18, offset: 110865},
																	expr: &litMatcher{
																		pos:        position{line: 3223, col: 18, offset: 110865},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&labeledExpr{
																	pos:   position{line: 3223, col: 23, offset: 110870},
																	label: "sI",
																	expr: &choiceExpr{
																		pos: position{line: 822, col: 11, offset: 25102},
																		alternatives: []any{
																			&actionExpr{
																				pos: position{line: 828, col: 14, offset: 25189},
																				run: (*parser).callonextendAndComments26,
																				expr: &seqExpr{
																					pos: position{line: 828, col: 14, offset: 25189},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 828, col: 14, offset: 25189},
																							val:        "`",
																							ignoreCase: false,
																							want:       "\"`\"",
																						},
																						&labeledExpr{
																							pos:   position{line: 828, col: 18, offset: 25193},
																							label: "strI",
																							expr: &zeroOrMoreExpr{
																								pos: position{line: 828, col: 23, offset: 25198},
																								expr: &charClassMatcher{
																									pos:        position{line: 2747, col: 27, offset: 94906},
																									val:        "[^\\n`]",
																									chars:      []rune{'\n', '`'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 828, col: 47, offset: 25222},
																							val:        "`",
																							ignoreCase: false,
																							want:       "\"`\"",
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 830, col: 5, offset: 25314},
																				run: (*parser).callonextendAndComments33,
																				expr: &seqExpr{
																					pos: position{line: 830, col: 5, offset: 25314},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 830, col: 5, offset: 25314},
																							val:        "`",
																							ignoreCase: false,
																							want:       "\"`\"",
																						},
																						&labeledExpr{
																							pos:   position{line: 830, col: 9, offset: 25318},
																							label: "strI",
																							expr: &zeroOrMoreExpr{
																								pos: position{line: 830, col: 14, offset: 25323},
																								expr: &charClassMatcher{
																									pos:        position{line: 2747, col: 27, offset: 94906},
																									val:        "[^\\n`]",
																									chars:      []rune{'\n', '`'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																						&andExpr{
																							pos: position{line: 830, col: 38, offset: 25347},
																							expr: &seqExpr{
																								pos: position{line: 3796, col: 12, offset: 129156},
																								exprs: []any{
																									&zeroOrMoreExpr{
																										pos: position{line: 3796, col: 12, offset: 129156},
																										expr: &charClassMatcher{
																											pos:        position{line: 3808, col: 36, offset: 129503},
																											val:        "[ \\t]",
																											chars:      []rune{' ', '\t'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&choiceExpr{
																										pos: position{line: 3796, col: 16, offset: 129160},
																										alternatives: []any{
																											&seqExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												exprs: []any{
																													&zeroOrOneExpr{
																														pos: position{line: 3796, col: 16, offset: 129160},
																														expr: &litMatcher{
																															pos:        position{line: 3796, col: 16, offset: 129160},
																															val:        "\r",
																															ignoreCase: false,
																															want:       "\"\\r\"",
																														},
																													},
																													&litMatcher{
																														pos:        position{line: 3796, col: 22, offset: 129166},
																														val:        "\n",
																														ignoreCase: false,
																														want:       "\"\\n\"",
																													},
																												},
																											},
																											&notExpr{
																												pos: position{line: 3795, col: 12, offset: 129142},
																												expr: &anyMatcher{
																													line: 3795, col: 13, offset: 129143,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 849, col: 22, offset: 25751},
																				run: (*parser).callonextendAndComments50,
																				expr: &seqExpr{
																					pos: position{line: 849, col: 22, offset: 25751},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 849, col: 22, offset: 25751},
																							val:        "\"",
																							ignoreCase: false,
																							want:       "\"\\\"\"",
																						},
																						&labeledExpr{
																							pos:   position{line: 849, col: 26, offset: 25755},
																							label: "strI",
																							expr: &zeroOrMoreExpr{
																								pos: position{line: 849, col: 31, offset: 25760},
																								expr: &choiceExpr{
																									pos: position{line: 849, col: 32, offset: 25761},
																									alternatives: []any{
																										&seqExpr{
																											pos: position{line: 2486, col: 24, offset: 84569},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 2486, col: 24, offset: 84569},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2403, col: 19, offset: 81758},
																													val:        "[0-7]",
																													ranges:     []rune{'0', '7'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2403, col: 19, offset: 81758},
																													val:        "[0-7]",
																													ranges:     []rune{'0', '7'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2403, col: 19, offset: 81758},
																													val:        "[0-7]",
																													ranges:     []rune{'0', '7'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&seqExpr{
																											pos: position{line: 2487, col: 24, offset: 84636},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 2487, col: 24, offset: 84636},
																													val:        "\\x",
																													ignoreCase: false,
																													want:       "\"\\\\x\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2488, col: 5, offset: 84673},
																											run: (*parser).callonextendAndComments65,
																											expr: &seqExpr{
																												pos: position{line: 2488, col: 5, offset: 84673},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2488, col: 5, offset: 84673},
																														val:        "\\x",
																														ignoreCase: false,
																														want:       "\"\\\\x\"",
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2488, col: 14, offset: 84682},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2488, col: 26, offset: 84694},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																												},
																											},
																										},
																										&seqExpr{
																											pos: position{line: 2505, col: 19, offset: 85311},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 2505, col: 19, offset: 85311},
																													val:        "\\u",
																													ignoreCase: false,
																													want:       "\"\\\\u\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2506, col: 5, offset: 85370},
																											run: (*parser).callonextendAndComments78,
																											expr: &seqExpr{
																												pos: position{line: 2506, col: 5, offset: 85370},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2506, col: 5, offset: 85370},
																														val:        "\\u",
																														ignoreCase: false,
																														want:       "\"\\\\u\"",
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2506, col: 14, offset: 85379},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2506, col: 26, offset: 85391},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2506, col: 38, offset: 85403},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2506, col: 50, offset: 85415},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																												},
																											},
																										},
																										&seqExpr{
																											pos: position{line: 2535, col: 16, offset: 86551},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 2535, col: 16, offset: 86551},
																													val:        "\\U",
																													ignoreCase: false,
																													want:       "\"\\\\U\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2536, col: 5, offset: 86654},
																											run: (*parser).callonextendAndComments99,
																											expr: &seqExpr{
																												pos: position{line: 2536, col: 5, offset: 86654},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2536, col: 5, offset: 86654},
																														val:        "\\U",
																														ignoreCase: false,
																														want:       "\"\\\\U\"",
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 14, offset: 86663},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 26, offset: 86675},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 38, offset: 86687},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 50, offset: 86699},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 62, offset: 86711},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 74, offset: 86723},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 86, offset: 86735},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 98, offset: 86747},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																												},
																											},
																										},
																										&seqExpr{
																											pos: position{line: 2763, col: 36, offset: 95684},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 2763, col: 36, offset: 95684},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2763, col: 41, offset: 95689},
																													val:        "[abfnrtv\\\\\"]",
																													chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&charClassMatcher{
																											pos:        position{line: 2761, col: 38, offset: 95576},
																											val:        "[^\"\\\\\\n]",
																											chars:      []rune{'"', '\\', '\n'},
																											ignoreCase: false,
																											inverted:   true,
																										},
																										&actionExpr{
																											pos: position{line: 2650, col: 37, offset: 91334},
																											run: (*parser).callonextendAndComments122,
																											expr: &seqExpr{
																												pos: position{line: 2650, col: 37, offset: 91334},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2650, col: 37, offset: 91334},
																														val:        "\\",
																														ignoreCase: false,
																														want:       "\"\\\\\"",
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2674, col: 5, offset: 92351},
																											run: (*parser).callonextendAndComments133,
																											expr: &seqExpr{
																												pos: position{line: 2674, col: 5, offset: 92351},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2674, col: 5, offset: 92351},
																														val:        "\\",
																														ignoreCase: false,
																														want:       "\"\\\\\"",
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2695, col: 5, offset: 93193},
																											run: (*parser).callonextendAndComments140,
																											expr: &seqExpr{
																												pos: position{line: 2695, col: 5, offset: 93193},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2695, col: 5, offset: 93193},
																														val:        "\\",
																														ignoreCase: false,
																														want:       "\"\\\\\"",
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2713, col: 5, offset: 93879},
																											run: (*parser).callonextendAndComments145,
																											expr: &seqExpr{
																												pos: position{line: 2713, col: 5, offset: 93879},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2713, col: 5, offset: 93879},
																														val:        "\\",
																														ignoreCase: false,
																														want:       "\"\\\\\"",
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2713, col: 10, offset: 93884},
																														expr: &charClassMatcher{
																															pos:        position{line: 3797, col: 12, offset: 129189},
																															val:        "[^\\r\\n]",
																															chars:      []rune{'\r', '\n'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 849, col: 115, offset: 25844},
																							val:        "\"",
																							ignoreCase: false,
																							want:       "\"\\\"\"",
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 851, col: 5, offset: 25936},
																				run: (*parser).callonextendAndComments151,
																				expr: &seqExpr{
																					pos: position{line: 851, col: 5, offset: 25936},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 851, col: 5, offset: 25936},
																							val:        "\"",
																							ignoreCase: false,
																							want:       "\"\\\"\"",
																						},
																						&labeledExpr{
																							pos:   position{line: 851, col: 9, offset: 25940},
																							label: "strI",
																							expr: &zeroOrMoreExpr{
																								pos: position{line: 851, col: 14, offset: 25945},
																								expr: &choiceExpr{
																									pos: position{line: 851, col: 15, offset: 25946},
																									alternatives: []any{
																										&seqExpr{
																											pos: position{line: 2486, col: 24, offset: 84569},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 2486, col: 24, offset: 84569},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2403, col: 19, offset: 81758},
																													val:        "[0-7]",
																													ranges:     []rune{'0', '7'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2403, col: 19, offset: 81758},
																													val:        "[0-7]",
																													ranges:     []rune{'0', '7'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2403, col: 19, offset: 81758},
																													val:        "[0-7]",
																													ranges:     []rune{'0', '7'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&seqExpr{
																											pos: position{line: 2487, col: 24, offset: 84636},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 2487, col: 24, offset: 84636},
																													val:        "\\x",
																													ignoreCase: false,
																													want:       "\"\\\\x\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2488, col: 5, offset: 84673},
																											run: (*parser).callonextendAndComments166,
																											expr: &seqExpr{
																												pos: position{line: 2488, col: 5, offset: 84673},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2488, col: 5, offset: 84673},
																														val:        "\\x",
																														ignoreCase: false,
																														want:       "\"\\\\x\"",
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2488, col: 14, offset: 84682},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2488, col: 26, offset: 84694},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																												},
																											},
																										},
																										&seqExpr{
																											pos: position{line: 2505, col: 19, offset: 85311},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 2505, col: 19, offset: 85311},
																													val:        "\\u",
																													ignoreCase: false,
																													want:       "\"\\\\u\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2506, col: 5, offset: 85370},
																											run: (*parser).callonextendAndComments179,
																											expr: &seqExpr{
																												pos: position{line: 2506, col: 5, offset: 85370},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2506, col: 5, offset: 85370},
																														val:        "\\u",
																														ignoreCase: false,
																														want:       "\"\\\\u\"",
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2506, col: 14, offset: 85379},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2506, col: 26, offset: 85391},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2506, col: 38, offset: 85403},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2506, col: 50, offset: 85415},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																												},
																											},
																										},
																										&seqExpr{
																											pos: position{line: 2535, col: 16, offset: 86551},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 2535, col: 16, offset: 86551},
																													val:        "\\U",
																													ignoreCase: false,
																													want:       "\"\\\\U\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2536, col: 5, offset: 86654},
																											run: (*parser).callonextendAndComments200,
																											expr: &seqExpr{
																												pos: position{line: 2536, col: 5, offset: 86654},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2536, col: 5, offset: 86654},
																														val:        "\\U",
																														ignoreCase: false,
																														want:       "\"\\\\U\"",
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 14, offset: 86663},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 26, offset: 86675},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 38, offset: 86687},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 50, offset: 86699},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 62, offset: 86711},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 74, offset: 86723},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 86, offset: 86735},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2536, col: 98, offset: 86747},
																														expr: &charClassMatcher{
																															pos:        position{line: 2404, col: 19, offset: 81782},
																															val:        "[0-9A-Fa-f]",
																															ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																												},
																											},
																										},
																										&seqExpr{
																											pos: position{line: 2763, col: 36, offset: 95684},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 2763, col: 36, offset: 95684},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2763, col: 41, offset: 95689},
																													val:        "[abfnrtv\\\\\"]",
																													chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&charClassMatcher{
																											pos:        position{line: 2761, col: 38, offset: 95576},
																											val:        "[^\"\\\\\\n]",
																											chars:      []rune{'"', '\\', '\n'},
																											ignoreCase: false,
																											inverted:   true,
																										},
																										&actionExpr{
																											pos: position{line: 2650, col: 37, offset: 91334},
																											run: (*parser).callonextendAndComments223,
																											expr: &seqExpr{
																												pos: position{line: 2650, col: 37, offset: 91334},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2650, col: 37, offset: 91334},
																														val:        "\\",
																														ignoreCase: false,
																														want:       "\"\\\\\"",
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2674, col: 5, offset: 92351},
																											run: (*parser).callonextendAndComments234,
																											expr: &seqExpr{
																												pos: position{line: 2674, col: 5, offset: 92351},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2674, col: 5, offset: 92351},
																														val:        "\\",
																														ignoreCase: false,
																														want:       "\"\\\\\"",
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2695, col: 5, offset: 93193},
																											run: (*parser).callonextendAndComments241,
																											expr: &seqExpr{
																												pos: position{line: 2695, col: 5, offset: 93193},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2695, col: 5, offset: 93193},
																														val:        "\\",
																														ignoreCase: false,
																														want:       "\"\\\\\"",
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2404, col: 19, offset: 81782},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 2713, col: 5, offset: 93879},
																											run: (*parser).callonextendAndComments246,
																											expr: &seqExpr{
																												pos: position{line: 2713, col: 5, offset: 93879},
																												exprs: []any{
																													&litMatcher{
																														pos:        position{line: 2713, col: 5, offset: 93879},
																														val:        "\\",
																														ignoreCase: false,
																														want:       "\"\\\\\"",
																													},
																													&zeroOrOneExpr{
																														pos: position{line: 2713, col: 10, offset: 93884},
																														expr: &charClassMatcher{
																															pos:        position{line: 3797, col: 12, offset: 129189},
																															val:        "[^\\r\\n]",
																															chars:      []rune{'\r', '\n'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 851, col: 98, offset: 26029},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonextendAndComments252,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																						&andExpr{
																							pos: position{line: 851, col: 110, offset: 26041},
																							expr: &seqExpr{
																								pos: position{line: 3796, col: 12, offset: 129156},
																								exprs: []any{
																									&zeroOrMoreExpr{
																										pos: position{line: 3796, col: 12, offset: 129156},
																										expr: &charClassMatcher{
																											pos:        position{line: 3808, col: 36, offset: 129503},
																											val:        "[ \\t]",
																											chars:      []rune{' ', '\t'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&choiceExpr{
																										pos: position{line: 3796, col: 16, offset: 129160},
																										alternatives: []any{
																											&seqExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												exprs: []any{
																													&zeroOrOneExpr{
																														pos: position{line: 3796, col: 16, offset: 129160},
																														expr: &litMatcher{
																															pos:        position{line: 3796, col: 16, offset: 129160},
																															val:        "\r",
																															ignoreCase: false,
																															want:       "\"\\r\"",
																														},
																													},
																													&litMatcher{
																														pos:        position{line: 3796, col: 22, offset: 129166},
																														val:        "\n",
																														ignoreCase: false,
																														want:       "\"\\n\"",
																													},
																												},
																											},
																											&notExpr{
																												pos: position{line: 3795, col: 12, offset: 129142},
																												expr: &anyMatcher{
																													line: 3795, col: 13, offset: 129143,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 870, col: 22, offset: 26447},
																				run: (*parser).callonextendAndComments269,
																				expr: &seqExpr{
																					pos: position{line: 870, col: 22, offset: 26447},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 870, col: 22, offset: 26447},
																							val:        "'",
																							ignoreCase: false,
																							want:       "\"'\"",
																						},
																						&labeledExpr{
																							pos:   position{line: 870, col: 27, offset: 26452},
																							label: "strI",
																							expr: &zeroOrMoreExpr{
																								pos: position{line: 870, col: 32, offset: 26457},
																								expr: &charClassMatcher{
																									pos:        position{line: 870, col: 32, offset: 26457},
																									val:        "[^\\\\r\\n]",
																									chars:      []rune{'\'', '\r', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 870, col: 42, offset: 26467},
																							val:        "'",
																							ignoreCase: false,
																							want:       "\"'\"",
																						},
																						&labeledExpr{
																							pos:   position{line: 870, col: 47, offset: 26472},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonextendAndComments277,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 3225, col: 5, offset: 110905},
														run: (*parser).callonextendAndComments283,
														expr: &seqExpr{
															pos: position{line: 3225, col: 5, offset: 110905},
															exprs: []any{
																&zeroOrMoreExpr{
																	pos: position{line: 3225, col: 5, offset: 110905},
																	expr: &litMatcher{
																		pos:        position{line: 3225, col: 5, offset: 110905},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&labeledExpr{
																	pos:   position{line: 3225, col: 10, offset: 110910},
																	label: "pathI",
																	expr: &zeroOrMoreExpr{
																		pos: position{line: 3225, col: 16, offset: 110916},
																		expr: &charClassMatcher{
																			pos:        position{line: 3797, col: 12, offset: 129189},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&zeroOrMoreExpr{
											pos: position{line: 3796, col: 12, offset: 129156},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&choiceExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											alternatives: []any{
												&seqExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													exprs: []any{
														&zeroOrOneExpr{
															pos: position{line: 3796, col: 16, offset: 129160},
															expr: &litMatcher{
																pos:        position{line: 3796, col: 16, offset: 129160},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3796, col: 22, offset: 129166},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
												&notExpr{
													pos: position{line: 3795, col: 12, offset: 129142},
													expr: &anyMatcher{
														line: 3795, col: 13, offset: 129143,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "importsAndComments",
			pos:  position{line: 55, col: 1, offset: 1656},
			expr: &actionExpr{
				pos: position{line: 55, col: 23, offset: 1678},
				run: (*parser).callonimportsAndComments1,
				expr: &labeledExpr{
					pos:   position{line: 55, col: 23, offset: 1678},
					label: "valsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 55, col: 29, offset: 1684},
						expr: &seqExpr{
							pos: position{line: 55, col: 30, offset: 1685},
							exprs: []any{
								&zeroOrOneExpr{
									pos: position{line: 55, col: 30, offset: 1685},
									expr: &ruleRefExpr{
										pos:  position{line: 55, col: 30, offset: 1685},
										name: "CorgiComments",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 55, col: 45, offset: 1700},
									expr: &oneOrMoreExpr{
										pos: position{line: 3810, col: 36, offset: 129590},
										expr: &seqExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 3810, col: 37, offset: 129591},
													expr: &charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3809, col: 36, offset: 129544},
													expr: &litMatcher{
														pos:        position{line: 3809, col: 36, offset: 129544},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3809, col: 42, offset: 129550},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 3261, col: 12, offset: 112141},
									run: (*parser).callonimportsAndComments15,
									expr: &labeledExpr{
										pos:   position{line: 3261, col: 12, offset: 112141},
										label: "importsI",
										expr: &oneOrMoreExpr{
											pos: position{line: 3261, col: 21, offset: 112150},
											expr: &seqExpr{
												pos: position{line: 3261, col: 22, offset: 112151},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3261, col: 22, offset: 112151},
														expr: &oneOrMoreExpr{
															pos: position{line: 3810, col: 36, offset: 129590},
															expr: &seqExpr{
																pos: position{line: 3810, col: 37, offset: 129591},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3810, col: 37, offset: 129591},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 3809, col: 36, offset: 129544},
																		expr: &litMatcher{
																			pos:        position{line: 3809, col: 36, offset: 129544},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3809, col: 42, offset: 129550},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
														},
													},
													&choiceExpr{
														pos: position{line: 3275, col: 11, offset: 112450},
														alternatives: []any{
															&actionExpr{
																pos: position{line: 3275, col: 11, offset: 112450},
																run: (*parser).callonimportsAndComments28,
																expr: &seqExpr{
																	pos: position{line: 3275, col: 11, offset: 112450},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 3275, col: 11, offset: 112450},
																			val:        "import",
																			ignoreCase: false,
																			want:       "\"import\"",
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 3796, col: 12, offset: 129156},
																			expr: &charClassMatcher{
																				pos:        position{line: 3808, col: 36, offset: 129503},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																		&choiceExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			alternatives: []any{
																				&seqExpr{
																					pos: position{line: 3796, col: 16, offset: 129160},
																					exprs: []any{
																						&zeroOrOneExpr{
																							pos: position{line: 3796, col: 16, offset: 129160},
																							expr: &litMatcher{
																								pos:        position{line: 3796, col: 16, offset: 129160},
																								val:        "\r",
																								ignoreCase: false,
																								want:       "\"\\r\"",
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 3796, col: 22, offset: 129166},
																							val:        "\n",
																							ignoreCase: false,
																							want:       "\"\\n\"",
																						},
																					},
																				},
																				&notExpr{
																					pos: position{line: 3795, col: 12, offset: 129142},
																					expr: &anyMatcher{
																						line: 3795, col: 13, offset: 129143,
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 3275, col: 24, offset: 112463},
																			label: "specsI",
																			expr: &actionExpr{
																				pos: position{line: 3296, col: 16, offset: 113117},
																				run: (*parser).callonimportsAndComments41,
																				expr: &seqExpr{
																					pos: position{line: 3296, col: 16, offset: 113117},
																					exprs: []any{
																						&stateCodeExpr{
																							pos: position{line: 4284, col: 11, offset: 150129},
																							run: (*parser).callonimportsAndComments43,
																						},
																						&labeledExpr{
																							pos:   position{line: 3296, col: 23, offset: 113124},
																							label: "importsI",
																							expr: &oneOrMoreExpr{
																								pos: position{line: 3296, col: 32, offset: 113133},
																								expr: &seqExpr{
																									pos: position{line: 3296, col: 33, offset: 113134},
																									exprs: []any{
																										&zeroOrOneExpr{
																											pos: position{line: 3296, col: 33, offset: 113134},
																											expr: &oneOrMoreExpr{
																												pos: position{line: 3810, col: 36, offset: 129590},
																												expr: &seqExpr{
																													pos: position{line: 3810, col: 37, offset: 129591},
																													exprs: []any{
																														&zeroOrMoreExpr{
																															pos: position{line: 3810, col: 37, offset: 129591},
																															expr: &charClassMatcher{
																																pos:        position{line: 3808, col: 36, offset: 129503},
																																val:        "[ \\t]",
																																chars:      []rune{' ', '\t'},
																																ignoreCase: false,
																																inverted:   false,
																															},
																														},
																														&zeroOrOneExpr{
																															pos: position{line: 3809, col: 36, offset: 129544},
																															expr: &litMatcher{
																																pos:        position{line: 3809, col: 36, offset: 129544},
																																val:        "\r",
																																ignoreCase: false,
																																want:       "\"\\r\"",
																															},
																														},
																														&litMatcher{
																															pos:        position{line: 3809, col: 42, offset: 129550},
																															val:        "\n",
																															ignoreCase: false,
																															want:       "\"\\n\"",
																														},
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 3897, col: 17, offset: 133397},
																											run: (*parser).callonimportsAndComments55,
																											expr: &zeroOrMoreExpr{
																												pos: position{line: 3897, col: 17, offset: 133397},
																												expr: &charClassMatcher{
																													pos:        position{line: 3808, col: 36, offset: 129503},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&andCodeExpr{
																											pos: position{line: 3897, col: 41, offset: 133421},
																											run: (*parser).callonimportsAndComments58,
																										},
																										&choiceExpr{
																											pos: position{line: 3949, col: 5, offset: 135331},
																											alternatives: []any{
																												&andCodeExpr{
																													pos: position{line: 3949, col: 5, offset: 135331},
																													run: (*parser).callonimportsAndComments60,
																												},
																												&seqExpr{
																													pos: position{line: 3951, col: 9, offset: 135414},
																													exprs: []any{
																														&andCodeExpr{
																															pos: position{line: 3951, col: 9, offset: 135414},
																															run: (*parser).callonimportsAndComments62,
																														},
																														&stateCodeExpr{
																															pos: position{line: 3953, col: 7, offset: 135537},
																															run: (*parser).callonimportsAndComments63,
																														},
																													},
																												},
																												&seqExpr{
																													pos: position{line: 3960, col: 9, offset: 135873},
																													exprs: []any{
																														&andCodeExpr{
																															pos: position{line: 3960, col: 9, offset: 135873},
																															run: (*parser).callonimportsAndComments65,
																														},
																														&andCodeExpr{
																															pos: position{line: 3962, col: 7, offset: 135981},
																															run: (*parser).callonimportsAndComments66,
																														},
																														&choiceExpr{
																															pos: position{line: 4015, col: 9, offset: 138316},
																															alternatives: []any{
																																&seqExpr{
																																	pos: position{line: 4015, col: 9, offset: 138316},
																																	exprs: []any{
																																		&andCodeExpr{
																																			pos: position{line: 4015, col: 9, offset: 138316},
																																			run: (*parser).callonimportsAndComments69,
																																		},
																																		&andCodeExpr{
																																			pos: position{line: 4019, col: 11, offset: 138566},
																																			run: (*parser).callonimportsAndComments70,
																																		},
																																		&stateCodeExpr{
																																			pos: position{line: 4085, col: 11, offset: 141772},
																																			run: (*parser).callonimportsAndComments71,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 4093, col: 13, offset: 142125},
																																	exprs: []any{
																																		&andCodeExpr{
																																			pos: position{line: 4093, col: 13, offset: 142125},
																																			run: (*parser).callonimportsAndComments73,
																																		},
																																		&andCodeExpr{
																																			pos: position{line: 4097, col: 11, offset: 142380},
																																			run: (*parser).callonimportsAndComments74,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 3300, col: 15, offset: 113262},
																											run: (*parser).callonimportsAndComments75,
																											expr: &seqExpr{
																												pos: position{line: 3300, col: 15, offset: 113262},
																												exprs: []any{
																													&labeledExpr{
																														pos:   position{line: 3300, col: 15, offset: 113262},
																														label: "aliasI",
																														expr: &zeroOrOneExpr{
																															pos: position{line: 3300, col: 22, offset: 113269},
																															expr: &seqExpr{
																																pos: position{line: 3300, col: 23, offset: 113270},
																																exprs: []any{
																																	&choiceExpr{
																																		pos: position{line: 3313, col: 16, offset: 113550},
																																		alternatives: []any{
																																			&actionExpr{
																																				pos: position{line: 3313, col: 16, offset: 113550},
																																				run: (*parser).callonimportsAndComments81,
																																				expr: &litMatcher{
																																					pos:        position{line: 3313, col: 16, offset: 113550},
																																					val:        ".",
																																					ignoreCase: false,
																																					want:       "\".\"",
																																				},
																																			},
																																			&actionExpr{
																																				pos: position{line: 2371, col: 12, offset: 80907},
																																				run: (*parser).callonimportsAndComments83,
																																				expr: &labeledExpr{
																																					pos:   position{line: 2371, col: 12, offset: 80907},
																																					label: "ident",
																																					expr: &seqExpr{
																																						pos: position{line: 2410, col: 17, offset: 81833},
																																						exprs: []any{
																																							&charClassMatcher{
																																								pos:        position{line: 2393, col: 20, offset: 81588},
																																								val:        "[_\\pL]",
																																								chars:      []rune{'_'},
																																								classes:    []*unicode.RangeTable{rangeTable("L")},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																							&zeroOrMoreExpr{
																																								pos: position{line: 2410, col: 26, offset: 81842},
																																								expr: &charClassMatcher{
																																									pos:        position{line: 2393, col: 20, offset: 81588},
																																									val:        "[_\\pL\\pNd]",
																																									chars:      []rune{'_'},
																																									classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																																									ignoreCase: false,
																																									inverted:   false,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&actionExpr{
																																				pos: position{line: 3315, col: 15, offset: 113629},
																																				run: (*parser).callonimportsAndComments89,
																																				expr: &seqExpr{
																																					pos: position{line: 3315, col: 15, offset: 113629},
																																					exprs: []any{
																																						&oneOrMoreExpr{
																																							pos: position{line: 3315, col: 15, offset: 113629},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3315, col: 15, offset: 113629},
																																								val:        "[^\"`\\ ]",
																																								chars:      []rune{'"', '`', '\'', ' '},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																						},
																																						&labeledExpr{
																																							pos:   position{line: 3315, col: 24, offset: 113638},
																																							label: "endPosI",
																																							expr: &actionExpr{
																																								pos: position{line: 3799, col: 8, offset: 129205},
																																								run: (*parser).callonimportsAndComments94,
																																								expr: &choiceExpr{
																																									pos: position{line: 3799, col: 9, offset: 129206},
																																									alternatives: []any{
																																										&andExpr{
																																											pos: position{line: 3799, col: 9, offset: 129206},
																																											expr: &anyMatcher{
																																												line: 3799, col: 10, offset: 129207,
																																											},
																																										},
																																										&notExpr{
																																											pos: position{line: 3799, col: 14, offset: 129211},
																																											expr: &anyMatcher{
																																												line: 3799, col: 15, offset: 129212,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																	&oneOrMoreExpr{
																																		pos: position{line: 3300, col: 35, offset: 113282},
																																		expr: &litMatcher{
																																			pos:        position{line: 3300, col: 35, offset: 113282},
																																			val:        " ",
																																			ignoreCase: false,
																																			want:       "\" \"",
																																		},
																																	},
																																},
																															},
																														},
																													},
																													&labeledExpr{
																														pos:   position{line: 3300, col: 42, offset: 113289},
																														label: "pathI",
																														expr: &choiceExpr{
																															pos: position{line: 3237, col: 12, offset: 111291},
																															alternatives: []any{
																																&actionExpr{
																																	pos: position{line: 828, col: 14, offset: 25189},
																																	run: (*parser).callonimportsAndComments104,
																																	expr: &seqExpr{
																																		pos: position{line: 828, col: 14, offset: 25189},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 828, col: 14, offset: 25189},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 828, col: 18, offset: 25193},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 828, col: 23, offset: 25198},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 2747, col: 27, offset: 94906},
																																						val:        "[^\\n`]",
																																						chars:      []rune{'\n', '`'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 828, col: 47, offset: 25222},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 830, col: 5, offset: 25314},
																																	run: (*parser).callonimportsAndComments111,
																																	expr: &seqExpr{
																																		pos: position{line: 830, col: 5, offset: 25314},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 830, col: 5, offset: 25314},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 830, col: 9, offset: 25318},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 830, col: 14, offset: 25323},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 2747, col: 27, offset: 94906},
																																						val:        "[^\\n`]",
																																						chars:      []rune{'\n', '`'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&andExpr{
																																				pos: position{line: 830, col: 38, offset: 25347},
																																				expr: &seqExpr{
																																					pos: position{line: 3796, col: 12, offset: 129156},
																																					exprs: []any{
																																						&zeroOrMoreExpr{
																																							pos: position{line: 3796, col: 12, offset: 129156},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3808, col: 36, offset: 129503},
																																								val:        "[ \\t]",
																																								chars:      []rune{' ', '\t'},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																						},
																																						&choiceExpr{
																																							pos: position{line: 3796, col: 16, offset: 129160},
																																							alternatives: []any{
																																								&seqExpr{
																																									pos: position{line: 3796, col: 16, offset: 129160},
																																									exprs: []any{
																																										&zeroOrOneExpr{
																																											pos: position{line: 3796, col: 16, offset: 129160},
																																											expr: &litMatcher{
																																												pos:        position{line: 3796, col: 16, offset: 129160},
																																												val:        "\r",
																																												ignoreCase: false,
																																												want:       "\"\\r\"",
																																											},
																																										},
																																										&litMatcher{
																																											pos:        position{line: 3796, col: 22, offset: 129166},
																																											val:        "\n",
																																											ignoreCase: false,
																																											want:       "\"\\n\"",
																																										},
																																									},
																																								},
																																								&notExpr{
																																									pos: position{line: 3795, col: 12, offset: 129142},
																																									expr: &anyMatcher{
																																										line: 3795, col: 13, offset: 129143,
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 849, col: 22, offset: 25751},
																																	run: (*parser).callonimportsAndComments128,
																																	expr: &seqExpr{
																																		pos: position{line: 849, col: 22, offset: 25751},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 849, col: 22, offset: 25751},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 849, col: 26, offset: 25755},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 849, col: 31, offset: 25760},
																																					expr: &choiceExpr{
																																						pos: position{line: 849, col: 32, offset: 25761},
																																						alternatives: []any{
																																							&seqExpr{
																																								pos: position{line: 2486, col: 24, offset: 84569},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2486, col: 24, offset: 84569},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2487, col: 24, offset: 84636},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2487, col: 24, offset: 84636},
																																										val:        "\\x",
																																										ignoreCase: false,
																																										want:       "\"\\\\x\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2488, col: 5, offset: 84673},
																																								run: (*parser).callonimportsAndComments143,
																																								expr: &seqExpr{
																																									pos: position{line: 2488, col: 5, offset: 84673},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2488, col: 5, offset: 84673},
																																											val:        "\\x",
																																											ignoreCase: false,
																																											want:       "\"\\\\x\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2488, col: 14, offset: 84682},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2488, col: 26, offset: 84694},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2505, col: 19, offset: 85311},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2505, col: 19, offset: 85311},
																																										val:        "\\u",
																																										ignoreCase: false,
																																										want:       "\"\\\\u\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2506, col: 5, offset: 85370},
																																								run: (*parser).callonimportsAndComments156,
																																								expr: &seqExpr{
																																									pos: position{line: 2506, col: 5, offset: 85370},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2506, col: 5, offset: 85370},
																																											val:        "\\u",
																																											ignoreCase: false,
																																											want:       "\"\\\\u\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 14, offset: 85379},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 26, offset: 85391},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 38, offset: 85403},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 50, offset: 85415},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2535, col: 16, offset: 86551},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2535, col: 16, offset: 86551},
																																										val:        "\\U",
																																										ignoreCase: false,
																																										want:       "\"\\\\U\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2536, col: 5, offset: 86654},
																																								run: (*parser).callonimportsAndComments177,
																																								expr: &seqExpr{
																																									pos: position{line: 2536, col: 5, offset: 86654},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2536, col: 5, offset: 86654},
																																											val:        "\\U",
																																											ignoreCase: false,
																																											want:       "\"\\\\U\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 14, offset: 86663},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 26, offset: 86675},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 38, offset: 86687},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 50, offset: 86699},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 62, offset: 86711},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 74, offset: 86723},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 86, offset: 86735},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 98, offset: 86747},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2763, col: 36, offset: 95684},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2763, col: 36, offset: 95684},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2763, col: 41, offset: 95689},
																																										val:        "[abfnrtv\\\\\"]",
																																										chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&charClassMatcher{
																																								pos:        position{line: 2761, col: 38, offset: 95576},
																																								val:        "[^\"\\\\\\n]",
																																								chars:      []rune{'"', '\\', '\n'},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																							&actionExpr{
																																								pos: position{line: 2650, col: 37, offset: 91334},
																																								run: (*parser).callonimportsAndComments200,
																																								expr: &seqExpr{
																																									pos: position{line: 2650, col: 37, offset: 91334},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2650, col: 37, offset: 91334},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2674, col: 5, offset: 92351},
																																								run: (*parser).callonimportsAndComments211,
																																								expr: &seqExpr{
																																									pos: position{line: 2674, col: 5, offset: 92351},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2674, col: 5, offset: 92351},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2695, col: 5, offset: 93193},
																																								run: (*parser).callonimportsAndComments218,
																																								expr: &seqExpr{
																																									pos: position{line: 2695, col: 5, offset: 93193},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2695, col: 5, offset: 93193},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2713, col: 5, offset: 93879},
																																								run: (*parser).callonimportsAndComments223,
																																								expr: &seqExpr{
																																									pos: position{line: 2713, col: 5, offset: 93879},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2713, col: 5, offset: 93879},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2713, col: 10, offset: 93884},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 3797, col: 12, offset: 129189},
																																												val:        "[^\\r\\n]",
																																												chars:      []rune{'\r', '\n'},
																																												ignoreCase: false,
																																												inverted:   true,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 849, col: 115, offset: 25844},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 851, col: 5, offset: 25936},
																																	run: (*parser).callonimportsAndComments229,
																																	expr: &seqExpr{
																																		pos: position{line: 851, col: 5, offset: 25936},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 851, col: 5, offset: 25936},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 851, col: 9, offset: 25940},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 851, col: 14, offset: 25945},
																																					expr: &choiceExpr{
																																						pos: position{line: 851, col: 15, offset: 25946},
																																						alternatives: []any{
																																							&seqExpr{
																																								pos: position{line: 2486, col: 24, offset: 84569},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2486, col: 24, offset: 84569},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2487, col: 24, offset: 84636},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2487, col: 24, offset: 84636},
																																										val:        "\\x",
																																										ignoreCase: false,
																																										want:       "\"\\\\x\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2488, col: 5, offset: 84673},
																																								run: (*parser).callonimportsAndComments244,
																																								expr: &seqExpr{
																																									pos: position{line: 2488, col: 5, offset: 84673},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2488, col: 5, offset: 84673},
																																											val:        "\\x",
																																											ignoreCase: false,
																																											want:       "\"\\\\x\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2488, col: 14, offset: 84682},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2488, col: 26, offset: 84694},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2505, col: 19, offset: 85311},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2505, col: 19, offset: 85311},
																																										val:        "\\u",
																																										ignoreCase: false,
																																										want:       "\"\\\\u\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2506, col: 5, offset: 85370},
																																								run: (*parser).callonimportsAndComments257,
																																								expr: &seqExpr{
																																									pos: position{line: 2506, col: 5, offset: 85370},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2506, col: 5, offset: 85370},
																																											val:        "\\u",
																																											ignoreCase: false,
																																											want:       "\"\\\\u\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 14, offset: 85379},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 26, offset: 85391},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 38, offset: 85403},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 50, offset: 85415},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2535, col: 16, offset: 86551},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2535, col: 16, offset: 86551},
																																										val:        "\\U",
																																										ignoreCase: false,
																																										want:       "\"\\\\U\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2536, col: 5, offset: 86654},
																																								run: (*parser).callonimportsAndComments278,
																																								expr: &seqExpr{
																																									pos: position{line: 2536, col: 5, offset: 86654},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2536, col: 5, offset: 86654},
																																											val:        "\\U",
																																											ignoreCase: false,
																																											want:       "\"\\\\U\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 14, offset: 86663},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 26, offset: 86675},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 38, offset: 86687},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 50, offset: 86699},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 62, offset: 86711},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 74, offset: 86723},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 86, offset: 86735},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 98, offset: 86747},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2763, col: 36, offset: 95684},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2763, col: 36, offset: 95684},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2763, col: 41, offset: 95689},
																																										val:        "[abfnrtv\\\\\"]",
																																										chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&charClassMatcher{
																																								pos:        position{line: 2761, col: 38, offset: 95576},
																																								val:        "[^\"\\\\\\n]",
																																								chars:      []rune{'"', '\\', '\n'},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																							&actionExpr{
																																								pos: position{line: 2650, col: 37, offset: 91334},
																																								run: (*parser).callonimportsAndComments301,
																																								expr: &seqExpr{
																																									pos: position{line: 2650, col: 37, offset: 91334},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2650, col: 37, offset: 91334},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2674, col: 5, offset: 92351},
																																								run: (*parser).callonimportsAndComments312,
																																								expr: &seqExpr{
																																									pos: position{line: 2674, col: 5, offset: 92351},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2674, col: 5, offset: 92351},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2695, col: 5, offset: 93193},
																																								run: (*parser).callonimportsAndComments319,
																																								expr: &seqExpr{
																																									pos: position{line: 2695, col: 5, offset: 93193},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2695, col: 5, offset: 93193},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2713, col: 5, offset: 93879},
																																								run: (*parser).callonimportsAndComments324,
																																								expr: &seqExpr{
																																									pos: position{line: 2713, col: 5, offset: 93879},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2713, col: 5, offset: 93879},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2713, col: 10, offset: 93884},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 3797, col: 12, offset: 129189},
																																												val:        "[^\\r\\n]",
																																												chars:      []rune{'\r', '\n'},
																																												ignoreCase: false,
																																												inverted:   true,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 851, col: 98, offset: 26029},
																																				label: "endPosI",
																																				expr: &actionExpr{
																																					pos: position{line: 3799, col: 8, offset: 129205},
																																					run: (*parser).callonimportsAndComments330,
																																					expr: &choiceExpr{
																																						pos: position{line: 3799, col: 9, offset: 129206},
																																						alternatives: []any{
																																							&andExpr{
																																								pos: position{line: 3799, col: 9, offset: 129206},
																																								expr: &anyMatcher{
																																									line: 3799, col: 10, offset: 129207,
																																								},
																																							},
																																							&notExpr{
																																								pos: position{line: 3799, col: 14, offset: 129211},
																																								expr: &anyMatcher{
																																									line: 3799, col: 15, offset: 129212,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&andExpr{
																																				pos: position{line: 851, col: 110, offset: 26041},
																																				expr: &seqExpr{
																																					pos: position{line: 3796, col: 12, offset: 129156},
																																					exprs: []any{
																																						&zeroOrMoreExpr{
																																							pos: position{line: 3796, col: 12, offset: 129156},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3808, col: 36, offset: 129503},
																																								val:        "[ \\t]",
																																								chars:      []rune{' ', '\t'},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																						},
																																						&choiceExpr{
																																							pos: position{line: 3796, col: 16, offset: 129160},
																																							alternatives: []any{
																																								&seqExpr{
																																									pos: position{line: 3796, col: 16, offset: 129160},
																																									exprs: []any{
																																										&zeroOrOneExpr{
																																											pos: position{line: 3796, col: 16, offset: 129160},
																																											expr: &litMatcher{
																																												pos:        position{line: 3796, col: 16, offset: 129160},
																																												val:        "\r",
																																												ignoreCase: false,
																																												want:       "\"\\r\"",
																																											},
																																										},
																																										&litMatcher{
																																											pos:        position{line: 3796, col: 22, offset: 129166},
																																											val:        "\n",
																																											ignoreCase: false,
																																											want:       "\"\\n\"",
																																										},
																																									},
																																								},
																																								&notExpr{
																																									pos: position{line: 3795, col: 12, offset: 129142},
																																									expr: &anyMatcher{
																																										line: 3795, col: 13, offset: 129143,
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 870, col: 22, offset: 26447},
																																	run: (*parser).callonimportsAndComments347,
																																	expr: &seqExpr{
																																		pos: position{line: 870, col: 22, offset: 26447},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 870, col: 22, offset: 26447},
																																				val:        "'",
																																				ignoreCase: false,
																																				want:       "\"'\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 870, col: 27, offset: 26452},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 870, col: 32, offset: 26457},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 870, col: 32, offset: 26457},
																																						val:        "[^\\\\r\\n]",
																																						chars:      []rune{'\'', '\r', '\n'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 870, col: 42, offset: 26467},
																																				val:        "'",
																																				ignoreCase: false,
																																				want:       "\"'\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 870, col: 47, offset: 26472},
																																				label: "endPosI",
																																				expr: &actionExpr{
																																					pos: position{line: 3799, col: 8, offset: 129205},
																																					run: (*parser).callonimportsAndComments355,
																																					expr: &choiceExpr{
																																						pos: position{line: 3799, col: 9, offset: 129206},
																																						alternatives: []any{
																																							&andExpr{
																																								pos: position{line: 3799, col: 9, offset: 129206},
																																								expr: &anyMatcher{
																																									line: 3799, col: 10, offset: 129207,
																																								},
																																							},
																																							&notExpr{
																																								pos: position{line: 3799, col: 14, offset: 129211},
																																								expr: &anyMatcher{
																																									line: 3799, col: 15, offset: 129212,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 3237, col: 21, offset: 111300},
																																	run: (*parser).callonimportsAndComments361,
																																	expr: &labeledExpr{
																																		pos:   position{line: 3237, col: 21, offset: 111300},
																																		label: "pathI",
																																		expr: &zeroOrMoreExpr{
																																			pos: position{line: 3237, col: 27, offset: 111306},
																																			expr: &charClassMatcher{
																																				pos:        position{line: 3797, col: 12, offset: 129189},
																																				val:        "[^\\r\\n]",
																																				chars:      []rune{'\r', '\n'},
																																				ignoreCase: false,
																																				inverted:   true,
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																													&zeroOrMoreExpr{
																														pos: position{line: 3796, col: 12, offset: 129156},
																														expr: &charClassMatcher{
																															pos:        position{line: 3808, col: 36, offset: 129503},
																															val:        "[ \\t]",
																															chars:      []rune{' ', '\t'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&choiceExpr{
																														pos: position{line: 3796, col: 16, offset: 129160},
																														alternatives: []any{
																															&seqExpr{
																																pos: position{line: 3796, col: 16, offset: 129160},
																																exprs: []any{
																																	&zeroOrOneExpr{
																																		pos: position{line: 3796, col: 16, offset: 129160},
																																		expr: &litMatcher{
																																			pos:        position{line: 3796, col: 16, offset: 129160},
																																			val:        "\r",
																																			ignoreCase: false,
																																			want:       "\"\\r\"",
																																		},
																																	},
																																	&litMatcher{
																																		pos:        position{line: 3796, col: 22, offset: 129166},
																																		val:        "\n",
																																		ignoreCase: false,
																																		want:       "\"\\n\"",
																																	},
																																},
																															},
																															&notExpr{
																																pos: position{line: 3795, col: 12, offset: 129142},
																																expr: &anyMatcher{
																																	line: 3795, col: 13, offset: 129143,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&stateCodeExpr{
																							pos: position{line: 4289, col: 11, offset: 150234},
																							run: (*parser).callonimportsAndComments374,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 3280, col: 5, offset: 112594},
																run: (*parser).callonimportsAndComments375,
																expr: &seqExpr{
																	pos: position{line: 3280, col: 5, offset: 112594},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 3280, col: 5, offset: 112594},
																			val:        "import",
																			ignoreCase: false,
																			want:       "\"import\"",
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 3280, col: 14, offset: 112603},
																			expr: &litMatcher{
																				pos:        position{line: 3280, col: 14, offset: 112603},
																				val:        " ",
																				ignoreCase: false,
																				want:       "\" \"",
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 3280, col: 19, offset: 112608},
																			label: "specI",
																			expr: &actionExpr{
																				pos: position{line: 3300, col: 15, offset: 113262},
																				run: (*parser).callonimportsAndComments381,
																				expr: &seqExpr{
																					pos: position{line: 3300, col: 15, offset: 113262},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 3300, col: 15, offset: 113262},
																							label: "aliasI",
																							expr: &zeroOrOneExpr{
																								pos: position{line: 3300, col: 22, offset: 113269},
																								expr: &seqExpr{
																									pos: position{line: 3300, col: 23, offset: 113270},
																									exprs: []any{
																										&choiceExpr{
																											pos: position{line: 3313, col: 16, offset: 113550},
																											alternatives: []any{
																												&actionExpr{
																													pos: position{line: 3313, col: 16, offset: 113550},
																													run: (*parser).callonimportsAndComments387,
																													expr: &litMatcher{
																														pos:        position{line: 3313, col: 16, offset: 113550},
																														val:        ".",
																														ignoreCase: false,
																														want:       "\".\"",
																													},
																												},
																												&actionExpr{
																													pos: position{line: 2371, col: 12, offset: 80907},
																													run: (*parser).callonimportsAndComments389,
																													expr: &labeledExpr{
																														pos:   position{line: 2371, col: 12, offset: 80907},
																														label: "ident",
																														expr: &seqExpr{
																															pos: position{line: 2410, col: 17, offset: 81833},
																															exprs: []any{
																																&charClassMatcher{
																																	pos:        position{line: 2393, col: 20, offset: 81588},
																																	val:        "[_\\pL]",
																																	chars:      []rune{'_'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																																&zeroOrMoreExpr{
																																	pos: position{line: 2410, col: 26, offset: 81842},
																																	expr: &charClassMatcher{
																																		pos:        position{line: 2393, col: 20, offset: 81588},
																																		val:        "[_\\pL\\pNd]",
																																		chars:      []rune{'_'},
																																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																																		ignoreCase: false,
																																		inverted:   false,
																																	},
																																},
																															},
																														},
																													},
																												},
																												&actionExpr{
																													pos: position{line: 3315, col: 15, offset: 113629},
																													run: (*parser).callonimportsAndComments395,
																													expr: &seqExpr{
																														pos: position{line: 3315, col: 15, offset: 113629},
																														exprs: []any{
																															&oneOrMoreExpr{
																																pos: position{line: 3315, col: 15, offset: 113629},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3315, col: 15, offset: 113629},
																																	val:        "[^\"`\\ ]",
																																	chars:      []rune{'"', '`', '\'', ' '},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																															},
																															&labeledExpr{
																																pos:   position{line: 3315, col: 24, offset: 113638},
																																label: "endPosI",
																																expr: &actionExpr{
																																	pos: position{line: 3799, col: 8, offset: 129205},
																																	run: (*parser).callonimportsAndComments400,
																																	expr: &choiceExpr{
																																		pos: position{line: 3799, col: 9, offset: 129206},
																																		alternatives: []any{
																																			&andExpr{
																																				pos: position{line: 3799, col: 9, offset: 129206},
																																				expr: &anyMatcher{
																																					line: 3799, col: 10, offset: 129207,
																																				},
																																			},
																																			&notExpr{
																																				pos: position{line: 3799, col: 14, offset: 129211},
																																				expr: &anyMatcher{
																																					line: 3799, col: 15, offset: 129212,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&oneOrMoreExpr{
																											pos: position{line: 3300, col: 35, offset: 113282},
																											expr: &litMatcher{
																												pos:        position{line: 3300, col: 35, offset: 113282},
																												val:        " ",
																												ignoreCase: false,
																												want:       "\" \"",
																											},
																										},
																									},
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 3300, col: 42, offset: 113289},
																							label: "pathI",
																							expr: &choiceExpr{
																								pos: position{line: 3237, col: 12, offset: 111291},
																								alternatives: []any{
																									&actionExpr{
																										pos: position{line: 828, col: 14, offset: 25189},
																										run: (*parser).callonimportsAndComments410,
																										expr: &seqExpr{
																											pos: position{line: 828, col: 14, offset: 25189},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 828, col: 14, offset: 25189},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 828, col: 18, offset: 25193},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 828, col: 23, offset: 25198},
																														expr: &charClassMatcher{
																															pos:        position{line: 2747, col: 27, offset: 94906},
																															val:        "[^\\n`]",
																															chars:      []rune{'\n', '`'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 828, col: 47, offset: 25222},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 830, col: 5, offset: 25314},
																										run: (*parser).callonimportsAndComments417,
																										expr: &seqExpr{
																											pos: position{line: 830, col: 5, offset: 25314},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 830, col: 5, offset: 25314},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 830, col: 9, offset: 25318},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 830, col: 14, offset: 25323},
																														expr: &charClassMatcher{
																															pos:        position{line: 2747, col: 27, offset: 94906},
																															val:        "[^\\n`]",
																															chars:      []rune{'\n', '`'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&andExpr{
																													pos: position{line: 830, col: 38, offset: 25347},
																													expr: &seqExpr{
																														pos: position{line: 3796, col: 12, offset: 129156},
																														exprs: []any{
																															&zeroOrMoreExpr{
																																pos: position{line: 3796, col: 12, offset: 129156},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3808, col: 36, offset: 129503},
																																	val:        "[ \\t]",
																																	chars:      []rune{' ', '\t'},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																															&choiceExpr{
																																pos: position{line: 3796, col: 16, offset: 129160},
																																alternatives: []any{
																																	&seqExpr{
																																		pos: position{line: 3796, col: 16, offset: 129160},
																																		exprs: []any{
																																			&zeroOrOneExpr{
																																				pos: position{line: 3796, col: 16, offset: 129160},
																																				expr: &litMatcher{
																																					pos:        position{line: 3796, col: 16, offset: 129160},
																																					val:        "\r",
																																					ignoreCase: false,
																																					want:       "\"\\r\"",
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 3796, col: 22, offset: 129166},
																																				val:        "\n",
																																				ignoreCase: false,
																																				want:       "\"\\n\"",
																																			},
																																		},
																																	},
																																	&notExpr{
																																		pos: position{line: 3795, col: 12, offset: 129142},
																																		expr: &anyMatcher{
																																			line: 3795, col: 13, offset: 129143,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 849, col: 22, offset: 25751},
																										run: (*parser).callonimportsAndComments434,
																										expr: &seqExpr{
																											pos: position{line: 849, col: 22, offset: 25751},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 849, col: 22, offset: 25751},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 849, col: 26, offset: 25755},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 849, col: 31, offset: 25760},
																														expr: &choiceExpr{
																															pos: position{line: 849, col: 32, offset: 25761},
																															alternatives: []any{
																																&seqExpr{
																																	pos: position{line: 2486, col: 24, offset: 84569},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2486, col: 24, offset: 84569},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2487, col: 24, offset: 84636},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2487, col: 24, offset: 84636},
																																			val:        "\\x",
																																			ignoreCase: false,
																																			want:       "\"\\\\x\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2488, col: 5, offset: 84673},
																																	run: (*parser).callonimportsAndComments449,
																																	expr: &seqExpr{
																																		pos: position{line: 2488, col: 5, offset: 84673},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2488, col: 5, offset: 84673},
																																				val:        "\\x",
																																				ignoreCase: false,
																																				want:       "\"\\\\x\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2488, col: 14, offset: 84682},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2488, col: 26, offset: 84694},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2505, col: 19, offset: 85311},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2505, col: 19, offset: 85311},
																																			val:        "\\u",
																																			ignoreCase: false,
																																			want:       "\"\\\\u\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2506, col: 5, offset: 85370},
																																	run: (*parser).callonimportsAndComments462,
																																	expr: &seqExpr{
																																		pos: position{line: 2506, col: 5, offset: 85370},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2506, col: 5, offset: 85370},
																																				val:        "\\u",
																																				ignoreCase: false,
																																				want:       "\"\\\\u\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 14, offset: 85379},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 26, offset: 85391},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 38, offset: 85403},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 50, offset: 85415},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2535, col: 16, offset: 86551},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2535, col: 16, offset: 86551},
																																			val:        "\\U",
																																			ignoreCase: false,
																																			want:       "\"\\\\U\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2536, col: 5, offset: 86654},
																																	run: (*parser).callonimportsAndComments483,
																																	expr: &seqExpr{
																																		pos: position{line: 2536, col: 5, offset: 86654},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2536, col: 5, offset: 86654},
																																				val:        "\\U",
																																				ignoreCase: false,
																																				want:       "\"\\\\U\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 14, offset: 86663},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 26, offset: 86675},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 38, offset: 86687},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 50, offset: 86699},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 62, offset: 86711},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 74, offset: 86723},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 86, offset: 86735},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 98, offset: 86747},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2763, col: 36, offset: 95684},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2763, col: 36, offset: 95684},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2763, col: 41, offset: 95689},
																																			val:        "[abfnrtv\\\\\"]",
																																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 2761, col: 38, offset: 95576},
																																	val:        "[^\"\\\\\\n]",
																																	chars:      []rune{'"', '\\', '\n'},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																																&actionExpr{
																																	pos: position{line: 2650, col: 37, offset: 91334},
																																	run: (*parser).callonimportsAndComments506,
																																	expr: &seqExpr{
																																		pos: position{line: 2650, col: 37, offset: 91334},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2650, col: 37, offset: 91334},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2674, col: 5, offset: 92351},
																																	run: (*parser).callonimportsAndComments517,
																																	expr: &seqExpr{
																																		pos: position{line: 2674, col: 5, offset: 92351},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2674, col: 5, offset: 92351},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2695, col: 5, offset: 93193},
																																	run: (*parser).callonimportsAndComments524,
																																	expr: &seqExpr{
																																		pos: position{line: 2695, col: 5, offset: 93193},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2695, col: 5, offset: 93193},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2713, col: 5, offset: 93879},
																																	run: (*parser).callonimportsAndComments529,
																																	expr: &seqExpr{
																																		pos: position{line: 2713, col: 5, offset: 93879},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2713, col: 5, offset: 93879},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2713, col: 10, offset: 93884},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 3797, col: 12, offset: 129189},
																																					val:        "[^\\r\\n]",
																																					chars:      []rune{'\r', '\n'},
																																					ignoreCase: false,
																																					inverted:   true,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 849, col: 115, offset: 25844},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 851, col: 5, offset: 25936},
																										run: (*parser).callonimportsAndComments535,
																										expr: &seqExpr{
																											pos: position{line: 851, col: 5, offset: 25936},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 851, col: 5, offset: 25936},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 851, col: 9, offset: 25940},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 851, col: 14, offset: 25945},
																														expr: &choiceExpr{
																															pos: position{line: 851, col: 15, offset: 25946},
																															alternatives: []any{
																																&seqExpr{
																																	pos: position{line: 2486, col: 24, offset: 84569},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2486, col: 24, offset: 84569},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2487, col: 24, offset: 84636},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2487, col: 24, offset: 84636},
																																			val:        "\\x",
																																			ignoreCase: false,
																																			want:       "\"\\\\x\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2488, col: 5, offset: 84673},
																																	run: (*parser).callonimportsAndComments550,
																																	expr: &seqExpr{
																																		pos: position{line: 2488, col: 5, offset: 84673},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2488, col: 5, offset: 84673},
																																				val:        "\\x",
																																				ignoreCase: false,
																																				want:       "\"\\\\x\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2488, col: 14, offset: 84682},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2488, col: 26, offset: 84694},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2505, col: 19, offset: 85311},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2505, col: 19, offset: 85311},
																																			val:        "\\u",
																																			ignoreCase: false,
																																			want:       "\"\\\\u\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2506, col: 5, offset: 85370},
																																	run: (*parser).callonimportsAndComments563,
																																	expr: &seqExpr{
																																		pos: position{line: 2506, col: 5, offset: 85370},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2506, col: 5, offset: 85370},
																																				val:        "\\u",
																																				ignoreCase: false,
																																				want:       "\"\\\\u\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 14, offset: 85379},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 26, offset: 85391},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 38, offset: 85403},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 50, offset: 85415},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2535, col: 16, offset: 86551},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2535, col: 16, offset: 86551},
																																			val:        "\\U",
																																			ignoreCase: false,
																																			want:       "\"\\\\U\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2536, col: 5, offset: 86654},
																																	run: (*parser).callonimportsAndComments584,
																																	expr: &seqExpr{
																																		pos: position{line: 2536, col: 5, offset: 86654},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2536, col: 5, offset: 86654},
																																				val:        "\\U",
																																				ignoreCase: false,
																																				want:       "\"\\\\U\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 14, offset: 86663},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 26, offset: 86675},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 38, offset: 86687},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 50, offset: 86699},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 62, offset: 86711},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 74, offset: 86723},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 86, offset: 86735},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 98, offset: 86747},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2763, col: 36, offset: 95684},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2763, col: 36, offset: 95684},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2763, col: 41, offset: 95689},
																																			val:        "[abfnrtv\\\\\"]",
																																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 2761, col: 38, offset: 95576},
																																	val:        "[^\"\\\\\\n]",
																																	chars:      []rune{'"', '\\', '\n'},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																																&actionExpr{
																																	pos: position{line: 2650, col: 37, offset: 91334},
																																	run: (*parser).callonimportsAndComments607,
																																	expr: &seqExpr{
																																		pos: position{line: 2650, col: 37, offset: 91334},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2650, col: 37, offset: 91334},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2674, col: 5, offset: 92351},
																																	run: (*parser).callonimportsAndComments618,
																																	expr: &seqExpr{
																																		pos: position{line: 2674, col: 5, offset: 92351},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2674, col: 5, offset: 92351},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2695, col: 5, offset: 93193},
																																	run: (*parser).callonimportsAndComments625,
																																	expr: &seqExpr{
																																		pos: position{line: 2695, col: 5, offset: 93193},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2695, col: 5, offset: 93193},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2713, col: 5, offset: 93879},
																																	run: (*parser).callonimportsAndComments630,
																																	expr: &seqExpr{
																																		pos: position{line: 2713, col: 5, offset: 93879},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2713, col: 5, offset: 93879},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2713, col: 10, offset: 93884},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 3797, col: 12, offset: 129189},
																																					val:        "[^\\r\\n]",
																																					chars:      []rune{'\r', '\n'},
																																					ignoreCase: false,
																																					inverted:   true,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																												&labeledExpr{
																													pos:   position{line: 851, col: 98, offset: 26029},
																													label: "endPosI",
																													expr: &actionExpr{
																														pos: position{line: 3799, col: 8, offset: 129205},
																														run: (*parser).callonimportsAndComments636,
																														expr: &choiceExpr{
																															pos: position{line: 3799, col: 9, offset: 129206},
																															alternatives: []any{
																																&andExpr{
																																	pos: position{line: 3799, col: 9, offset: 129206},
																																	expr: &anyMatcher{
																																		line: 3799, col: 10, offset: 129207,
																																	},
																																},
																																&notExpr{
																																	pos: position{line: 3799, col: 14, offset: 129211},
																																	expr: &anyMatcher{
																																		line: 3799, col: 15, offset: 129212,
																																	},
																																},
																															},
																														},
																													},
																												},
																												&andExpr{
																													pos: position{line: 851, col: 110, offset: 26041},
																													expr: &seqExpr{
																														pos: position{line: 3796, col: 12, offset: 129156},
																														exprs: []any{
																															&zeroOrMoreExpr{
																																pos: position{line: 3796, col: 12, offset: 129156},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3808, col: 36, offset: 129503},
																																	val:        "[ \\t]",
																																	chars:      []rune{' ', '\t'},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																															&choiceExpr{
																																pos: position{line: 3796, col: 16, offset: 129160},
																																alternatives: []any{
																																	&seqExpr{
																																		pos: position{line: 3796, col: 16, offset: 129160},
																																		exprs: []any{
																																			&zeroOrOneExpr{
																																				pos: position{line: 3796, col: 16, offset: 129160},
																																				expr: &litMatcher{
																																					pos:        position{line: 3796, col: 16, offset: 129160},
																																					val:        "\r",
																																					ignoreCase: false,
																																					want:       "\"\\r\"",
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 3796, col: 22, offset: 129166},
																																				val:        "\n",
																																				ignoreCase: false,
																																				want:       "\"\\n\"",
																																			},
																																		},
																																	},
																																	&notExpr{
																																		pos: position{line: 3795, col: 12, offset: 129142},
																																		expr: &anyMatcher{
																																			line: 3795, col: 13, offset: 129143,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 870, col: 22, offset: 26447},
																										run: (*parser).callonimportsAndComments653,
																										expr: &seqExpr{
																											pos: position{line: 870, col: 22, offset: 26447},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 870, col: 22, offset: 26447},
																													val:        "'",
																													ignoreCase: false,
																													want:       "\"'\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 870, col: 27, offset: 26452},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 870, col: 32, offset: 26457},
																														expr: &charClassMatcher{
																															pos:        position{line: 870, col: 32, offset: 26457},
																															val:        "[^\\\\r\\n]",
																															chars:      []rune{'\'', '\r', '\n'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 870, col: 42, offset: 26467},
																													val:        "'",
																													ignoreCase: false,
																													want:       "\"'\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 870, col: 47, offset: 26472},
																													label: "endPosI",
																													expr: &actionExpr{
																														pos: position{line: 3799, col: 8, offset: 129205},
																														run: (*parser).callonimportsAndComments661,
																														expr: &choiceExpr{
																															pos: position{line: 3799, col: 9, offset: 129206},
																															alternatives: []any{
																																&andExpr{
																																	pos: position{line: 3799, col: 9, offset: 129206},
																																	expr: &anyMatcher{
																																		line: 3799, col: 10, offset: 129207,
																																	},
																																},
																																&notExpr{
																																	pos: position{line: 3799, col: 14, offset: 129211},
																																	expr: &anyMatcher{
																																		line: 3799, col: 15, offset: 129212,
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 3237, col: 21, offset: 111300},
																										run: (*parser).callonimportsAndComments667,
																										expr: &labeledExpr{
																											pos:   position{line: 3237, col: 21, offset: 111300},
																											label: "pathI",
																											expr: &zeroOrMoreExpr{
																												pos: position{line: 3237, col: 27, offset: 111306},
																												expr: &charClassMatcher{
																													pos:        position{line: 3797, col: 12, offset: 129189},
																													val:        "[^\\r\\n]",
																													chars:      []rune{'\r', '\n'},
																													ignoreCase: false,
																													inverted:   true,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&zeroOrMoreExpr{
																							pos: position{line: 3796, col: 12, offset: 129156},
																							expr: &charClassMatcher{
																								pos:        position{line: 3808, col: 36, offset: 129503},
																								val:        "[ \\t]",
																								chars:      []rune{' ', '\t'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&choiceExpr{
																							pos: position{line: 3796, col: 16, offset: 129160},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 3796, col: 16, offset: 129160},
																									exprs: []any{
																										&zeroOrOneExpr{
																											pos: position{line: 3796, col: 16, offset: 129160},
																											expr: &litMatcher{
																												pos:        position{line: 3796, col: 16, offset: 129160},
																												val:        "\r",
																												ignoreCase: false,
																												want:       "\"\\r\"",
																											},
																										},
																										&litMatcher{
																											pos:        position{line: 3796, col: 22, offset: 129166},
																											val:        "\n",
																											ignoreCase: false,
																											want:       "\"\\n\"",
																										},
																									},
																								},
																								&notExpr{
																									pos: position{line: 3795, col: 12, offset: 129142},
																									expr: &anyMatcher{
																										line: 3795, col: 13, offset: 129143,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 3285, col: 5, offset: 112753},
																run: (*parser).callonimportsAndComments680,
																expr: &seqExpr{
																	pos: position{line: 3285, col: 5, offset: 112753},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 3285, col: 5, offset: 112753},
																			val:        "import",
																			ignoreCase: false,
																			want:       "\"import\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 3285, col: 14, offset: 112762},
																			label: "posI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonimportsAndComments684,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 3796, col: 12, offset: 129156},
																			expr: &charClassMatcher{
																				pos:        position{line: 3808, col: 36, offset: 129503},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																		&choiceExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			alternatives: []any{
																				&seqExpr{
																					pos: position{line: 3796, col: 16, offset: 129160},
																					exprs: []any{
																						&zeroOrOneExpr{
																							pos: position{line: 3796, col: 16, offset: 129160},
																							expr: &litMatcher{
																								pos:        position{line: 3796, col: 16, offset: 129160},
																								val:        "\r",
																								ignoreCase: false,
																								want:       "\"\\r\"",
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 3796, col: 22, offset: 129166},
																							val:        "\n",
																							ignoreCase: false,
																							want:       "\"\\n\"",
																						},
																					},
																				},
																				&notExpr{
																					pos: position{line: 3795, col: 12, offset: 129142},
																					expr: &anyMatcher{
																						line: 3795, col: 13, offset: 129143,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "usesAndComments",
			pos:  position{line: 69, col: 1, offset: 2069},
			expr: &actionExpr{
				pos: position{line: 69, col: 20, offset: 2088},
				run: (*parser).callonusesAndComments1,
				expr: &labeledExpr{
					pos:   position{line: 69, col: 20, offset: 2088},
					label: "valsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 69, col: 26, offset: 2094},
						expr: &seqExpr{
							pos: position{line: 69, col: 27, offset: 2095},
							exprs: []any{
								&zeroOrOneExpr{
									pos: position{line: 69, col: 27, offset: 2095},
									expr: &ruleRefExpr{
										pos:  position{line: 69, col: 27, offset: 2095},
										name: "CorgiComments",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 69, col: 42, offset: 2110},
									expr: &oneOrMoreExpr{
										pos: position{line: 3810, col: 36, offset: 129590},
										expr: &seqExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 3810, col: 37, offset: 129591},
													expr: &charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3809, col: 36, offset: 129544},
													expr: &litMatcher{
														pos:        position{line: 3809, col: 36, offset: 129544},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3809, col: 42, offset: 129550},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 3333, col: 9, offset: 114224},
									run: (*parser).callonusesAndComments15,
									expr: &labeledExpr{
										pos:   position{line: 3333, col: 9, offset: 114224},
										label: "usesI",
										expr: &oneOrMoreExpr{
											pos: position{line: 3333, col: 15, offset: 114230},
											expr: &seqExpr{
												pos: position{line: 3333, col: 16, offset: 114231},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3333, col: 16, offset: 114231},
														expr: &oneOrMoreExpr{
															pos: position{line: 3810, col: 36, offset: 129590},
															expr: &seqExpr{
																pos: position{line: 3810, col: 37, offset: 129591},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3810, col: 37, offset: 129591},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 3809, col: 36, offset: 129544},
																		expr: &litMatcher{
																			pos:        position{line: 3809, col: 36, offset: 129544},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3809, col: 42, offset: 129550},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
														},
													},
													&choiceExpr{
														pos: position{line: 3347, col: 8, offset: 114512},
														alternatives: []any{
															&actionExpr{
																pos: position{line: 3347, col: 8, offset: 114512},
																run: (*parser).callonusesAndComments28,
																expr: &seqExpr{
																	pos: position{line: 3347, col: 8, offset: 114512},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 3347, col: 8, offset: 114512},
																			val:        "use",
																			ignoreCase: false,
																			want:       "\"use\"",
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 3796, col: 12, offset: 129156},
																			expr: &charClassMatcher{
																				pos:        position{line: 3808, col: 36, offset: 129503},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																		&choiceExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			alternatives: []any{
																				&seqExpr{
																					pos: position{line: 3796, col: 16, offset: 129160},
																					exprs: []any{
																						&zeroOrOneExpr{
																							pos: position{line: 3796, col: 16, offset: 129160},
																							expr: &litMatcher{
																								pos:        position{line: 3796, col: 16, offset: 129160},
																								val:        "\r",
																								ignoreCase: false,
																								want:       "\"\\r\"",
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 3796, col: 22, offset: 129166},
																							val:        "\n",
																							ignoreCase: false,
																							want:       "\"\\n\"",
																						},
																					},
																				},
																				&notExpr{
																					pos: position{line: 3795, col: 12, offset: 129142},
																					expr: &anyMatcher{
																						line: 3795, col: 13, offset: 129143,
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 3347, col: 18, offset: 114522},
																			label: "specsI",
																			expr: &actionExpr{
																				pos: position{line: 3368, col: 13, offset: 115128},
																				run: (*parser).callonusesAndComments41,
																				expr: &seqExpr{
																					pos: position{line: 3368, col: 13, offset: 115128},
																					exprs: []any{
																						&stateCodeExpr{
																							pos: position{line: 4284, col: 11, offset: 150129},
																							run: (*parser).callonusesAndComments43,
																						},
																						&labeledExpr{
																							pos:   position{line: 3368, col: 20, offset: 115135},
																							label: "usesI",
																							expr: &oneOrMoreExpr{
																								pos: position{line: 3368, col: 26, offset: 115141},
																								expr: &seqExpr{
																									pos: position{line: 3368, col: 27, offset: 115142},
																									exprs: []any{
																										&zeroOrOneExpr{
																											pos: position{line: 3368, col: 27, offset: 115142},
																											expr: &oneOrMoreExpr{
																												pos: position{line: 3810, col: 36, offset: 129590},
																												expr: &seqExpr{
																													pos: position{line: 3810, col: 37, offset: 129591},
																													exprs: []any{
																														&zeroOrMoreExpr{
																															pos: position{line: 3810, col: 37, offset: 129591},
																															expr: &charClassMatcher{
																																pos:        position{line: 3808, col: 36, offset: 129503},
																																val:        "[ \\t]",
																																chars:      []rune{' ', '\t'},
																																ignoreCase: false,
																																inverted:   false,
																															},
																														},
																														&zeroOrOneExpr{
																															pos: position{line: 3809, col: 36, offset: 129544},
																															expr: &litMatcher{
																																pos:        position{line: 3809, col: 36, offset: 129544},
																																val:        "\r",
																																ignoreCase: false,
																																want:       "\"\\r\"",
																															},
																														},
																														&litMatcher{
																															pos:        position{line: 3809, col: 42, offset: 129550},
																															val:        "\n",
																															ignoreCase: false,
																															want:       "\"\\n\"",
																														},
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 3897, col: 17, offset: 133397},
																											run: (*parser).callonusesAndComments55,
																											expr: &zeroOrMoreExpr{
																												pos: position{line: 3897, col: 17, offset: 133397},
																												expr: &charClassMatcher{
																													pos:        position{line: 3808, col: 36, offset: 129503},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&andCodeExpr{
																											pos: position{line: 3897, col: 41, offset: 133421},
																											run: (*parser).callonusesAndComments58,
																										},
																										&choiceExpr{
																											pos: position{line: 3949, col: 5, offset: 135331},
																											alternatives: []any{
																												&andCodeExpr{
																													pos: position{line: 3949, col: 5, offset: 135331},
																													run: (*parser).callonusesAndComments60,
																												},
																												&seqExpr{
																													pos: position{line: 3951, col: 9, offset: 135414},
																													exprs: []any{
																														&andCodeExpr{
																															pos: position{line: 3951, col: 9, offset: 135414},
																															run: (*parser).callonusesAndComments62,
																														},
																														&stateCodeExpr{
																															pos: position{line: 3953, col: 7, offset: 135537},
																															run: (*parser).callonusesAndComments63,
																														},
																													},
																												},
																												&seqExpr{
																													pos: position{line: 3960, col: 9, offset: 135873},
																													exprs: []any{
																														&andCodeExpr{
																															pos: position{line: 3960, col: 9, offset: 135873},
																															run: (*parser).callonusesAndComments65,
																														},
																														&andCodeExpr{
																															pos: position{line: 3962, col: 7, offset: 135981},
																															run: (*parser).callonusesAndComments66,
																														},
																														&choiceExpr{
																															pos: position{line: 4015, col: 9, offset: 138316},
																															alternatives: []any{
																																&seqExpr{
																																	pos: position{line: 4015, col: 9, offset: 138316},
																																	exprs: []any{
																																		&andCodeExpr{
																																			pos: position{line: 4015, col: 9, offset: 138316},
																																			run: (*parser).callonusesAndComments69,
																																		},
																																		&andCodeExpr{
																																			pos: position{line: 4019, col: 11, offset: 138566},
																																			run: (*parser).callonusesAndComments70,
																																		},
																																		&stateCodeExpr{
																																			pos: position{line: 4085, col: 11, offset: 141772},
																																			run: (*parser).callonusesAndComments71,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 4093, col: 13, offset: 142125},
																																	exprs: []any{
																																		&andCodeExpr{
																																			pos: position{line: 4093, col: 13, offset: 142125},
																																			run: (*parser).callonusesAndComments73,
																																		},
																																		&andCodeExpr{
																																			pos: position{line: 4097, col: 11, offset: 142380},
																																			run: (*parser).callonusesAndComments74,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 3372, col: 12, offset: 115258},
																											run: (*parser).callonusesAndComments75,
																											expr: &seqExpr{
																												pos: position{line: 3372, col: 12, offset: 115258},
																												exprs: []any{
																													&labeledExpr{
																														pos:   position{line: 3372, col: 12, offset: 115258},
																														label: "aliasI",
																														expr: &zeroOrOneExpr{
																															pos: position{line: 3372, col: 19, offset: 115265},
																															expr: &seqExpr{
																																pos: position{line: 3372, col: 20, offset: 115266},
																																exprs: []any{
																																	&choiceExpr{
																																		pos: position{line: 3385, col: 13, offset: 115535},
																																		alternatives: []any{
																																			&actionExpr{
																																				pos: position{line: 3385, col: 13, offset: 115535},
																																				run: (*parser).callonusesAndComments81,
																																				expr: &litMatcher{
																																					pos:        position{line: 3385, col: 13, offset: 115535},
																																					val:        ".",
																																					ignoreCase: false,
																																					want:       "\".\"",
																																				},
																																			},
																																			&actionExpr{
																																				pos: position{line: 759, col: 10, offset: 23002},
																																				run: (*parser).callonusesAndComments83,
																																				expr: &labeledExpr{
																																					pos:   position{line: 759, col: 10, offset: 23002},
																																					label: "identI",
																																					expr: &seqExpr{
																																						pos: position{line: 2410, col: 17, offset: 81833},
																																						exprs: []any{
																																							&charClassMatcher{
																																								pos:        position{line: 2393, col: 20, offset: 81588},
																																								val:        "[_\\pL]",
																																								chars:      []rune{'_'},
																																								classes:    []*unicode.RangeTable{rangeTable("L")},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																							&zeroOrMoreExpr{
																																								pos: position{line: 2410, col: 26, offset: 81842},
																																								expr: &charClassMatcher{
																																									pos:        position{line: 2393, col: 20, offset: 81588},
																																									val:        "[_\\pL\\pNd]",
																																									chars:      []rune{'_'},
																																									classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																																									ignoreCase: false,
																																									inverted:   false,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&actionExpr{
																																				pos: position{line: 761, col: 5, offset: 23096},
																																				run: (*parser).callonusesAndComments89,
																																				expr: &seqExpr{
																																					pos: position{line: 761, col: 5, offset: 23096},
																																					exprs: []any{
																																						&labeledExpr{
																																							pos:   position{line: 761, col: 5, offset: 23096},
																																							label: "identI",
																																							expr: &seqExpr{
																																								pos: position{line: 761, col: 13, offset: 23104},
																																								exprs: []any{
																																									&zeroOrOneExpr{
																																										pos: position{line: 761, col: 13, offset: 23104},
																																										expr: &litMatcher{
																																											pos:        position{line: 761, col: 13, offset: 23104},
																																											val:        "$",
																																											ignoreCase: false,
																																											want:       "\"$\"",
																																										},
																																									},
																																									&oneOrMoreExpr{
																																										pos: position{line: 761, col: 18, offset: 23109},
																																										expr: &choiceExpr{
																																											pos: position{line: 761, col: 19, offset: 23110},
																																											alternatives: []any{
																																												&seqExpr{
																																													pos: position{line: 761, col: 19, offset: 23110},
																																													exprs: []any{
																																														&charClassMatcher{
																																															pos:        position{line: 761, col: 19, offset: 23110},
																																															val:        "[\\pNd]",
																																															classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																															ignoreCase: false,
																																															inverted:   false,
																																														},
																																														&charClassMatcher{
																																															pos:        position{line: 761, col: 28, offset: 23119},
																																															val:        "[_-\\pL]",
																																															chars:      []rune{'_', '-'},
																																															classes:    []*unicode.RangeTable{rangeTable("L")},
																																															ignoreCase: false,
																																															inverted:   false,
																																														},
																																													},
																																												},
																																												&charClassMatcher{
																																													pos:        position{line: 761, col: 38, offset: 23129},
																																													val:        "[_-\\pL]",
																																													chars:      []rune{'_', '-'},
																																													classes:    []*unicode.RangeTable{rangeTable("L")},
																																													ignoreCase: false,
																																													inverted:   false,
																																												},
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																						&labeledExpr{
																																							pos:   position{line: 761, col: 49, offset: 23140},
																																							label: "endPosI",
																																							expr: &actionExpr{
																																								pos: position{line: 3799, col: 8, offset: 129205},
																																								run: (*parser).callonusesAndComments102,
																																								expr: &choiceExpr{
																																									pos: position{line: 3799, col: 9, offset: 129206},
																																									alternatives: []any{
																																										&andExpr{
																																											pos: position{line: 3799, col: 9, offset: 129206},
																																											expr: &anyMatcher{
																																												line: 3799, col: 10, offset: 129207,
																																											},
																																										},
																																										&notExpr{
																																											pos: position{line: 3799, col: 14, offset: 129211},
																																											expr: &anyMatcher{
																																												line: 3799, col: 15, offset: 129212,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&actionExpr{
																																				pos: position{line: 3387, col: 13, offset: 115610},
																																				run: (*parser).callonusesAndComments108,
																																				expr: &seqExpr{
																																					pos: position{line: 3387, col: 13, offset: 115610},
																																					exprs: []any{
																																						&oneOrMoreExpr{
																																							pos: position{line: 3387, col: 13, offset: 115610},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3387, col: 13, offset: 115610},
																																								val:        "[^\"`\\ ]",
																																								chars:      []rune{'"', '`', '\'', ' '},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																						},
																																						&labeledExpr{
																																							pos:   position{line: 3387, col: 22, offset: 115619},
																																							label: "endPosI",
																																							expr: &actionExpr{
																																								pos: position{line: 3799, col: 8, offset: 129205},
																																								run: (*parser).callonusesAndComments113,
																																								expr: &choiceExpr{
																																									pos: position{line: 3799, col: 9, offset: 129206},
																																									alternatives: []any{
																																										&andExpr{
																																											pos: position{line: 3799, col: 9, offset: 129206},
																																											expr: &anyMatcher{
																																												line: 3799, col: 10, offset: 129207,
																																											},
																																										},
																																										&notExpr{
																																											pos: position{line: 3799, col: 14, offset: 129211},
																																											expr: &anyMatcher{
																																												line: 3799, col: 15, offset: 129212,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																	&oneOrMoreExpr{
																																		pos: position{line: 3372, col: 29, offset: 115275},
																																		expr: &litMatcher{
																																			pos:        position{line: 3372, col: 29, offset: 115275},
																																			val:        " ",
																																			ignoreCase: false,
																																			want:       "\" \"",
																																		},
																																	},
																																},
																															},
																														},
																													},
																													&labeledExpr{
																														pos:   position{line: 3372, col: 36, offset: 115282},
																														label: "pathI",
																														expr: &choiceExpr{
																															pos: position{line: 3237, col: 12, offset: 111291},
																															alternatives: []any{
																																&actionExpr{
																																	pos: position{line: 828, col: 14, offset: 25189},
																																	run: (*parser).callonusesAndComments123,
																																	expr: &seqExpr{
																																		pos: position{line: 828, col: 14, offset: 25189},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 828, col: 14, offset: 25189},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 828, col: 18, offset: 25193},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 828, col: 23, offset: 25198},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 2747, col: 27, offset: 94906},
																																						val:        "[^\\n`]",
																																						chars:      []rune{'\n', '`'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 828, col: 47, offset: 25222},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 830, col: 5, offset: 25314},
																																	run: (*parser).callonusesAndComments130,
																																	expr: &seqExpr{
																																		pos: position{line: 830, col: 5, offset: 25314},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 830, col: 5, offset: 25314},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 830, col: 9, offset: 25318},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 830, col: 14, offset: 25323},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 2747, col: 27, offset: 94906},
																																						val:        "[^\\n`]",
																																						chars:      []rune{'\n', '`'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&andExpr{
																																				pos: position{line: 830, col: 38, offset: 25347},
																																				expr: &seqExpr{
																																					pos: position{line: 3796, col: 12, offset: 129156},
																																					exprs: []any{
																																						&zeroOrMoreExpr{
																																							pos: position{line: 3796, col: 12, offset: 129156},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3808, col: 36, offset: 129503},
																																								val:        "[ \\t]",
																																								chars:      []rune{' ', '\t'},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																						},
																																						&choiceExpr{
																																							pos: position{line: 3796, col: 16, offset: 129160},
																																							alternatives: []any{
																																								&seqExpr{
																																									pos: position{line: 3796, col: 16, offset: 129160},
																																									exprs: []any{
																																										&zeroOrOneExpr{
																																											pos: position{line: 3796, col: 16, offset: 129160},
																																											expr: &litMatcher{
																																												pos:        position{line: 3796, col: 16, offset: 129160},
																																												val:        "\r",
																																												ignoreCase: false,
																																												want:       "\"\\r\"",
																																											},
																																										},
																																										&litMatcher{
																																											pos:        position{line: 3796, col: 22, offset: 129166},
																																											val:        "\n",
																																											ignoreCase: false,
																																											want:       "\"\\n\"",
																																										},
																																									},
																																								},
																																								&notExpr{
																																									pos: position{line: 3795, col: 12, offset: 129142},
																																									expr: &anyMatcher{
																																										line: 3795, col: 13, offset: 129143,
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 849, col: 22, offset: 25751},
																																	run: (*parser).callonusesAndComments147,
																																	expr: &seqExpr{
																																		pos: position{line: 849, col: 22, offset: 25751},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 849, col: 22, offset: 25751},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 849, col: 26, offset: 25755},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 849, col: 31, offset: 25760},
																																					expr: &choiceExpr{
																																						pos: position{line: 849, col: 32, offset: 25761},
																																						alternatives: []any{
																																							&seqExpr{
																																								pos: position{line: 2486, col: 24, offset: 84569},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2486, col: 24, offset: 84569},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2487, col: 24, offset: 84636},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2487, col: 24, offset: 84636},
																																										val:        "\\x",
																																										ignoreCase: false,
																																										want:       "\"\\\\x\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2488, col: 5, offset: 84673},
																																								run: (*parser).callonusesAndComments162,
																																								expr: &seqExpr{
																																									pos: position{line: 2488, col: 5, offset: 84673},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2488, col: 5, offset: 84673},
																																											val:        "\\x",
																																											ignoreCase: false,
																																											want:       "\"\\\\x\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2488, col: 14, offset: 84682},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2488, col: 26, offset: 84694},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2505, col: 19, offset: 85311},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2505, col: 19, offset: 85311},
																																										val:        "\\u",
																																										ignoreCase: false,
																																										want:       "\"\\\\u\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2506, col: 5, offset: 85370},
																																								run: (*parser).callonusesAndComments175,
																																								expr: &seqExpr{
																																									pos: position{line: 2506, col: 5, offset: 85370},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2506, col: 5, offset: 85370},
																																											val:        "\\u",
																																											ignoreCase: false,
																																											want:       "\"\\\\u\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 14, offset: 85379},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 26, offset: 85391},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 38, offset: 85403},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 50, offset: 85415},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2535, col: 16, offset: 86551},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2535, col: 16, offset: 86551},
																																										val:        "\\U",
																																										ignoreCase: false,
																																										want:       "\"\\\\U\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2536, col: 5, offset: 86654},
																																								run: (*parser).callonusesAndComments196,
																																								expr: &seqExpr{
																																									pos: position{line: 2536, col: 5, offset: 86654},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2536, col: 5, offset: 86654},
																																											val:        "\\U",
																																											ignoreCase: false,
																																											want:       "\"\\\\U\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 14, offset: 86663},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 26, offset: 86675},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 38, offset: 86687},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 50, offset: 86699},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 62, offset: 86711},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 74, offset: 86723},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 86, offset: 86735},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 98, offset: 86747},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2763, col: 36, offset: 95684},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2763, col: 36, offset: 95684},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2763, col: 41, offset: 95689},
																																										val:        "[abfnrtv\\\\\"]",
																																										chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&charClassMatcher{
																																								pos:        position{line: 2761, col: 38, offset: 95576},
																																								val:        "[^\"\\\\\\n]",
																																								chars:      []rune{'"', '\\', '\n'},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																							&actionExpr{
																																								pos: position{line: 2650, col: 37, offset: 91334},
																																								run: (*parser).callonusesAndComments219,
																																								expr: &seqExpr{
																																									pos: position{line: 2650, col: 37, offset: 91334},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2650, col: 37, offset: 91334},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2674, col: 5, offset: 92351},
																																								run: (*parser).callonusesAndComments230,
																																								expr: &seqExpr{
																																									pos: position{line: 2674, col: 5, offset: 92351},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2674, col: 5, offset: 92351},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2695, col: 5, offset: 93193},
																																								run: (*parser).callonusesAndComments237,
																																								expr: &seqExpr{
																																									pos: position{line: 2695, col: 5, offset: 93193},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2695, col: 5, offset: 93193},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2713, col: 5, offset: 93879},
																																								run: (*parser).callonusesAndComments242,
																																								expr: &seqExpr{
																																									pos: position{line: 2713, col: 5, offset: 93879},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2713, col: 5, offset: 93879},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2713, col: 10, offset: 93884},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 3797, col: 12, offset: 129189},
																																												val:        "[^\\r\\n]",
																																												chars:      []rune{'\r', '\n'},
																																												ignoreCase: false,
																																												inverted:   true,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 849, col: 115, offset: 25844},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 851, col: 5, offset: 25936},
																																	run: (*parser).callonusesAndComments248,
																																	expr: &seqExpr{
																																		pos: position{line: 851, col: 5, offset: 25936},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 851, col: 5, offset: 25936},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 851, col: 9, offset: 25940},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 851, col: 14, offset: 25945},
																																					expr: &choiceExpr{
																																						pos: position{line: 851, col: 15, offset: 25946},
																																						alternatives: []any{
																																							&seqExpr{
																																								pos: position{line: 2486, col: 24, offset: 84569},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2486, col: 24, offset: 84569},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2403, col: 19, offset: 81758},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2487, col: 24, offset: 84636},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2487, col: 24, offset: 84636},
																																										val:        "\\x",
																																										ignoreCase: false,
																																										want:       "\"\\\\x\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2488, col: 5, offset: 84673},
																																								run: (*parser).callonusesAndComments263,
																																								expr: &seqExpr{
																																									pos: position{line: 2488, col: 5, offset: 84673},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2488, col: 5, offset: 84673},
																																											val:        "\\x",
																																											ignoreCase: false,
																																											want:       "\"\\\\x\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2488, col: 14, offset: 84682},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2488, col: 26, offset: 84694},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2505, col: 19, offset: 85311},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2505, col: 19, offset: 85311},
																																										val:        "\\u",
																																										ignoreCase: false,
																																										want:       "\"\\\\u\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2506, col: 5, offset: 85370},
																																								run: (*parser).callonusesAndComments276,
																																								expr: &seqExpr{
																																									pos: position{line: 2506, col: 5, offset: 85370},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2506, col: 5, offset: 85370},
																																											val:        "\\u",
																																											ignoreCase: false,
																																											want:       "\"\\\\u\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 14, offset: 85379},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 26, offset: 85391},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 38, offset: 85403},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2506, col: 50, offset: 85415},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2535, col: 16, offset: 86551},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2535, col: 16, offset: 86551},
																																										val:        "\\U",
																																										ignoreCase: false,
																																										want:       "\"\\\\U\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2404, col: 19, offset: 81782},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2536, col: 5, offset: 86654},
																																								run: (*parser).callonusesAndComments297,
																																								expr: &seqExpr{
																																									pos: position{line: 2536, col: 5, offset: 86654},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2536, col: 5, offset: 86654},
																																											val:        "\\U",
																																											ignoreCase: false,
																																											want:       "\"\\\\U\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 14, offset: 86663},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 26, offset: 86675},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 38, offset: 86687},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 50, offset: 86699},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 62, offset: 86711},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 74, offset: 86723},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 86, offset: 86735},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2536, col: 98, offset: 86747},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2404, col: 19, offset: 81782},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2763, col: 36, offset: 95684},
																																								exprs: []any{
																																									&litMatcher{
																																										pos:        position{line: 2763, col: 36, offset: 95684},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2763, col: 41, offset: 95689},
																																										val:        "[abfnrtv\\\\\"]",
																																										chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&charClassMatcher{
																																								pos:        position{line: 2761, col: 38, offset: 95576},
																																								val:        "[^\"\\\\\\n]",
																																								chars:      []rune{'"', '\\', '\n'},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																							&actionExpr{
																																								pos: position{line: 2650, col: 37, offset: 91334},
																																								run: (*parser).callonusesAndComments320,
																																								expr: &seqExpr{
																																									pos: position{line: 2650, col: 37, offset: 91334},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2650, col: 37, offset: 91334},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2674, col: 5, offset: 92351},
																																								run: (*parser).callonusesAndComments331,
																																								expr: &seqExpr{
																																									pos: position{line: 2674, col: 5, offset: 92351},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2674, col: 5, offset: 92351},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2695, col: 5, offset: 93193},
																																								run: (*parser).callonusesAndComments338,
																																								expr: &seqExpr{
																																									pos: position{line: 2695, col: 5, offset: 93193},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2695, col: 5, offset: 93193},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2404, col: 19, offset: 81782},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2713, col: 5, offset: 93879},
																																								run: (*parser).callonusesAndComments343,
																																								expr: &seqExpr{
																																									pos: position{line: 2713, col: 5, offset: 93879},
																																									exprs: []any{
																																										&litMatcher{
																																											pos:        position{line: 2713, col: 5, offset: 93879},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2713, col: 10, offset: 93884},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 3797, col: 12, offset: 129189},
																																												val:        "[^\\r\\n]",
																																												chars:      []rune{'\r', '\n'},
																																												ignoreCase: false,
																																												inverted:   true,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 851, col: 98, offset: 26029},
																																				label: "endPosI",
																																				expr: &actionExpr{
																																					pos: position{line: 3799, col: 8, offset: 129205},
																																					run: (*parser).callonusesAndComments349,
																																					expr: &choiceExpr{
																																						pos: position{line: 3799, col: 9, offset: 129206},
																																						alternatives: []any{
																																							&andExpr{
																																								pos: position{line: 3799, col: 9, offset: 129206},
																																								expr: &anyMatcher{
																																									line: 3799, col: 10, offset: 129207,
																																								},
																																							},
																																							&notExpr{
																																								pos: position{line: 3799, col: 14, offset: 129211},
																																								expr: &anyMatcher{
																																									line: 3799, col: 15, offset: 129212,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&andExpr{
																																				pos: position{line: 851, col: 110, offset: 26041},
																																				expr: &seqExpr{
																																					pos: position{line: 3796, col: 12, offset: 129156},
																																					exprs: []any{
																																						&zeroOrMoreExpr{
																																							pos: position{line: 3796, col: 12, offset: 129156},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3808, col: 36, offset: 129503},
																																								val:        "[ \\t]",
																																								chars:      []rune{' ', '\t'},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																						},
																																						&choiceExpr{
																																							pos: position{line: 3796, col: 16, offset: 129160},
																																							alternatives: []any{
																																								&seqExpr{
																																									pos: position{line: 3796, col: 16, offset: 129160},
																																									exprs: []any{
																																										&zeroOrOneExpr{
																																											pos: position{line: 3796, col: 16, offset: 129160},
																																											expr: &litMatcher{
																																												pos:        position{line: 3796, col: 16, offset: 129160},
																																												val:        "\r",
																																												ignoreCase: false,
																																												want:       "\"\\r\"",
																																											},
																																										},
																																										&litMatcher{
																																											pos:        position{line: 3796, col: 22, offset: 129166},
																																											val:        "\n",
																																											ignoreCase: false,
																																											want:       "\"\\n\"",
																																										},
																																									},
																																								},
																																								&notExpr{
																																									pos: position{line: 3795, col: 12, offset: 129142},
																																									expr: &anyMatcher{
																																										line: 3795, col: 13, offset: 129143,
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 870, col: 22, offset: 26447},
																																	run: (*parser).callonusesAndComments366,
																																	expr: &seqExpr{
																																		pos: position{line: 870, col: 22, offset: 26447},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 870, col: 22, offset: 26447},
																																				val:        "'",
																																				ignoreCase: false,
																																				want:       "\"'\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 870, col: 27, offset: 26452},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 870, col: 32, offset: 26457},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 870, col: 32, offset: 26457},
																																						val:        "[^\\\\r\\n]",
																																						chars:      []rune{'\'', '\r', '\n'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 870, col: 42, offset: 26467},
																																				val:        "'",
																																				ignoreCase: false,
																																				want:       "\"'\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 870, col: 47, offset: 26472},
																																				label: "endPosI",
																																				expr: &actionExpr{
																																					pos: position{line: 3799, col: 8, offset: 129205},
																																					run: (*parser).callonusesAndComments374,
																																					expr: &choiceExpr{
																																						pos: position{line: 3799, col: 9, offset: 129206},
																																						alternatives: []any{
																																							&andExpr{
																																								pos: position{line: 3799, col: 9, offset: 129206},
																																								expr: &anyMatcher{
																																									line: 3799, col: 10, offset: 129207,
																																								},
																																							},
																																							&notExpr{
																																								pos: position{line: 3799, col: 14, offset: 129211},
																																								expr: &anyMatcher{
																																									line: 3799, col: 15, offset: 129212,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 3237, col: 21, offset: 111300},
																																	run: (*parser).callonusesAndComments380,
																																	expr: &labeledExpr{
																																		pos:   position{line: 3237, col: 21, offset: 111300},
																																		label: "pathI",
																																		expr: &zeroOrMoreExpr{
																																			pos: position{line: 3237, col: 27, offset: 111306},
																																			expr: &charClassMatcher{
																																				pos:        position{line: 3797, col: 12, offset: 129189},
																																				val:        "[^\\r\\n]",
																																				chars:      []rune{'\r', '\n'},
																																				ignoreCase: false,
																																				inverted:   true,
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																													&zeroOrMoreExpr{
																														pos: position{line: 3796, col: 12, offset: 129156},
																														expr: &charClassMatcher{
																															pos:        position{line: 3808, col: 36, offset: 129503},
																															val:        "[ \\t]",
																															chars:      []rune{' ', '\t'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&choiceExpr{
																														pos: position{line: 3796, col: 16, offset: 129160},
																														alternatives: []any{
																															&seqExpr{
																																pos: position{line: 3796, col: 16, offset: 129160},
																																exprs: []any{
																																	&zeroOrOneExpr{
																																		pos: position{line: 3796, col: 16, offset: 129160},
																																		expr: &litMatcher{
																																			pos:        position{line: 3796, col: 16, offset: 129160},
																																			val:        "\r",
																																			ignoreCase: false,
																																			want:       "\"\\r\"",
																																		},
																																	},
																																	&litMatcher{
																																		pos:        position{line: 3796, col: 22, offset: 129166},
																																		val:        "\n",
																																		ignoreCase: false,
																																		want:       "\"\\n\"",
																																	},
																																},
																															},
																															&notExpr{
																																pos: position{line: 3795, col: 12, offset: 129142},
																																expr: &anyMatcher{
																																	line: 3795, col: 13, offset: 129143,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&stateCodeExpr{
																							pos: position{line: 4289, col: 11, offset: 150234},
																							run: (*parser).callonusesAndComments393,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 3352, col: 5, offset: 114641},
																run: (*parser).callonusesAndComments394,
																expr: &seqExpr{
																	pos: position{line: 3352, col: 5, offset: 114641},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 3352, col: 5, offset: 114641},
																			val:        "use",
																			ignoreCase: false,
																			want:       "\"use\"",
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 3352, col: 11, offset: 114647},
																			expr: &litMatcher{
																				pos:        position{line: 3352, col: 11, offset: 114647},
																				val:        " ",
																				ignoreCase: false,
																				want:       "\" \"",
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 3352, col: 16, offset: 114652},
																			label: "specI",
																			expr: &actionExpr{
																				pos: position{line: 3372, col: 12, offset: 115258},
																				run: (*parser).callonusesAndComments400,
																				expr: &seqExpr{
																					pos: position{line: 3372, col: 12, offset: 115258},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 3372, col: 12, offset: 115258},
																							label: "aliasI",
																							expr: &zeroOrOneExpr{
																								pos: position{line: 3372, col: 19, offset: 115265},
																								expr: &seqExpr{
																									pos: position{line: 3372, col: 20, offset: 115266},
																									exprs: []any{
																										&choiceExpr{
																											pos: position{line: 3385, col: 13, offset: 115535},
																											alternatives: []any{
																												&actionExpr{
																													pos: position{line: 3385, col: 13, offset: 115535},
																													run: (*parser).callonusesAndComments406,
																													expr: &litMatcher{
																														pos:        position{line: 3385, col: 13, offset: 115535},
																														val:        ".",
																														ignoreCase: false,
																														want:       "\".\"",
																													},
																												},
																												&actionExpr{
																													pos: position{line: 759, col: 10, offset: 23002},
																													run: (*parser).callonusesAndComments408,
																													expr: &labeledExpr{
																														pos:   position{line: 759, col: 10, offset: 23002},
																														label: "identI",
																														expr: &seqExpr{
																															pos: position{line: 2410, col: 17, offset: 81833},
																															exprs: []any{
																																&charClassMatcher{
																																	pos:        position{line: 2393, col: 20, offset: 81588},
																																	val:        "[_\\pL]",
																																	chars:      []rune{'_'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																																&zeroOrMoreExpr{
																																	pos: position{line: 2410, col: 26, offset: 81842},
																																	expr: &charClassMatcher{
																																		pos:        position{line: 2393, col: 20, offset: 81588},
																																		val:        "[_\\pL\\pNd]",
																																		chars:      []rune{'_'},
																																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																																		ignoreCase: false,
																																		inverted:   false,
																																	},
																																},
																															},
																														},
																													},
																												},
																												&actionExpr{
																													pos: position{line: 761, col: 5, offset: 23096},
																													run: (*parser).callonusesAndComments414,
																													expr: &seqExpr{
																														pos: position{line: 761, col: 5, offset: 23096},
																														exprs: []any{
																															&labeledExpr{
																																pos:   position{line: 761, col: 5, offset: 23096},
																																label: "identI",
																																expr: &seqExpr{
																																	pos: position{line: 761, col: 13, offset: 23104},
																																	exprs: []any{
																																		&zeroOrOneExpr{
																																			pos: position{line: 761, col: 13, offset: 23104},
																																			expr: &litMatcher{
																																				pos:        position{line: 761, col: 13, offset: 23104},
																																				val:        "$",
																																				ignoreCase: false,
																																				want:       "\"$\"",
																																			},
																																		},
																																		&oneOrMoreExpr{
																																			pos: position{line: 761, col: 18, offset: 23109},
																																			expr: &choiceExpr{
																																				pos: position{line: 761, col: 19, offset: 23110},
																																				alternatives: []any{
																																					&seqExpr{
																																						pos: position{line: 761, col: 19, offset: 23110},
																																						exprs: []any{
																																							&charClassMatcher{
																																								pos:        position{line: 761, col: 19, offset: 23110},
																																								val:        "[\\pNd]",
																																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																							&charClassMatcher{
																																								pos:        position{line: 761, col: 28, offset: 23119},
																																								val:        "[_-\\pL]",
																																								chars:      []rune{'_', '-'},
																																								classes:    []*unicode.RangeTable{rangeTable("L")},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																						},
																																					},
																																					&charClassMatcher{
																																						pos:        position{line: 761, col: 38, offset: 23129},
																																						val:        "[_-\\pL]",
																																						chars:      []rune{'_', '-'},
																																						classes:    []*unicode.RangeTable{rangeTable("L")},
																																						ignoreCase: false,
																																						inverted:   false,
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																															&labeledExpr{
																																pos:   position{line: 761, col: 49, offset: 23140},
																																label: "endPosI",
																																expr: &actionExpr{
																																	pos: position{line: 3799, col: 8, offset: 129205},
																																	run: (*parser).callonusesAndComments427,
																																	expr: &choiceExpr{
																																		pos: position{line: 3799, col: 9, offset: 129206},
																																		alternatives: []any{
																																			&andExpr{
																																				pos: position{line: 3799, col: 9, offset: 129206},
																																				expr: &anyMatcher{
																																					line: 3799, col: 10, offset: 129207,
																																				},
																																			},
																																			&notExpr{
																																				pos: position{line: 3799, col: 14, offset: 129211},
																																				expr: &anyMatcher{
																																					line: 3799, col: 15, offset: 129212,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																												&actionExpr{
																													pos: position{line: 3387, col: 13, offset: 115610},
																													run: (*parser).callonusesAndComments433,
																													expr: &seqExpr{
																														pos: position{line: 3387, col: 13, offset: 115610},
																														exprs: []any{
																															&oneOrMoreExpr{
																																pos: position{line: 3387, col: 13, offset: 115610},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3387, col: 13, offset: 115610},
																																	val:        "[^\"`\\ ]",
																																	chars:      []rune{'"', '`', '\'', ' '},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																															},
																															&labeledExpr{
																																pos:   position{line: 3387, col: 22, offset: 115619},
																																label: "endPosI",
																																expr: &actionExpr{
																																	pos: position{line: 3799, col: 8, offset: 129205},
																																	run: (*parser).callonusesAndComments438,
																																	expr: &choiceExpr{
																																		pos: position{line: 3799, col: 9, offset: 129206},
																																		alternatives: []any{
																																			&andExpr{
																																				pos: position{line: 3799, col: 9, offset: 129206},
																																				expr: &anyMatcher{
																																					line: 3799, col: 10, offset: 129207,
																																				},
																																			},
																																			&notExpr{
																																				pos: position{line: 3799, col: 14, offset: 129211},
																																				expr: &anyMatcher{
																																					line: 3799, col: 15, offset: 129212,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&oneOrMoreExpr{
																											pos: position{line: 3372, col: 29, offset: 115275},
																											expr: &litMatcher{
																												pos:        position{line: 3372, col: 29, offset: 115275},
																												val:        " ",
																												ignoreCase: false,
																												want:       "\" \"",
																											},
																										},
																									},
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 3372, col: 36, offset: 115282},
																							label: "pathI",
																							expr: &choiceExpr{
																								pos: position{line: 3237, col: 12, offset: 111291},
																								alternatives: []any{
																									&actionExpr{
																										pos: position{line: 828, col: 14, offset: 25189},
																										run: (*parser).callonusesAndComments448,
																										expr: &seqExpr{
																											pos: position{line: 828, col: 14, offset: 25189},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 828, col: 14, offset: 25189},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 828, col: 18, offset: 25193},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 828, col: 23, offset: 25198},
																														expr: &charClassMatcher{
																															pos:        position{line: 2747, col: 27, offset: 94906},
																															val:        "[^\\n`]",
																															chars:      []rune{'\n', '`'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 828, col: 47, offset: 25222},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 830, col: 5, offset: 25314},
																										run: (*parser).callonusesAndComments455,
																										expr: &seqExpr{
																											pos: position{line: 830, col: 5, offset: 25314},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 830, col: 5, offset: 25314},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 830, col: 9, offset: 25318},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 830, col: 14, offset: 25323},
																														expr: &charClassMatcher{
																															pos:        position{line: 2747, col: 27, offset: 94906},
																															val:        "[^\\n`]",
																															chars:      []rune{'\n', '`'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&andExpr{
																													pos: position{line: 830, col: 38, offset: 25347},
																													expr: &seqExpr{
																														pos: position{line: 3796, col: 12, offset: 129156},
																														exprs: []any{
																															&zeroOrMoreExpr{
																																pos: position{line: 3796, col: 12, offset: 129156},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3808, col: 36, offset: 129503},
																																	val:        "[ \\t]",
																																	chars:      []rune{' ', '\t'},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																															&choiceExpr{
																																pos: position{line: 3796, col: 16, offset: 129160},
																																alternatives: []any{
																																	&seqExpr{
																																		pos: position{line: 3796, col: 16, offset: 129160},
																																		exprs: []any{
																																			&zeroOrOneExpr{
																																				pos: position{line: 3796, col: 16, offset: 129160},
																																				expr: &litMatcher{
																																					pos:        position{line: 3796, col: 16, offset: 129160},
																																					val:        "\r",
																																					ignoreCase: false,
																																					want:       "\"\\r\"",
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 3796, col: 22, offset: 129166},
																																				val:        "\n",
																																				ignoreCase: false,
																																				want:       "\"\\n\"",
																																			},
																																		},
																																	},
																																	&notExpr{
																																		pos: position{line: 3795, col: 12, offset: 129142},
																																		expr: &anyMatcher{
																																			line: 3795, col: 13, offset: 129143,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 849, col: 22, offset: 25751},
																										run: (*parser).callonusesAndComments472,
																										expr: &seqExpr{
																											pos: position{line: 849, col: 22, offset: 25751},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 849, col: 22, offset: 25751},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 849, col: 26, offset: 25755},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 849, col: 31, offset: 25760},
																														expr: &choiceExpr{
																															pos: position{line: 849, col: 32, offset: 25761},
																															alternatives: []any{
																																&seqExpr{
																																	pos: position{line: 2486, col: 24, offset: 84569},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2486, col: 24, offset: 84569},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2487, col: 24, offset: 84636},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2487, col: 24, offset: 84636},
																																			val:        "\\x",
																																			ignoreCase: false,
																																			want:       "\"\\\\x\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2488, col: 5, offset: 84673},
																																	run: (*parser).callonusesAndComments487,
																																	expr: &seqExpr{
																																		pos: position{line: 2488, col: 5, offset: 84673},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2488, col: 5, offset: 84673},
																																				val:        "\\x",
																																				ignoreCase: false,
																																				want:       "\"\\\\x\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2488, col: 14, offset: 84682},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2488, col: 26, offset: 84694},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2505, col: 19, offset: 85311},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2505, col: 19, offset: 85311},
																																			val:        "\\u",
																																			ignoreCase: false,
																																			want:       "\"\\\\u\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2506, col: 5, offset: 85370},
																																	run: (*parser).callonusesAndComments500,
																																	expr: &seqExpr{
																																		pos: position{line: 2506, col: 5, offset: 85370},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2506, col: 5, offset: 85370},
																																				val:        "\\u",
																																				ignoreCase: false,
																																				want:       "\"\\\\u\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 14, offset: 85379},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 26, offset: 85391},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 38, offset: 85403},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 50, offset: 85415},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2535, col: 16, offset: 86551},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2535, col: 16, offset: 86551},
																																			val:        "\\U",
																																			ignoreCase: false,
																																			want:       "\"\\\\U\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2536, col: 5, offset: 86654},
																																	run: (*parser).callonusesAndComments521,
																																	expr: &seqExpr{
																																		pos: position{line: 2536, col: 5, offset: 86654},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2536, col: 5, offset: 86654},
																																				val:        "\\U",
																																				ignoreCase: false,
																																				want:       "\"\\\\U\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 14, offset: 86663},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 26, offset: 86675},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 38, offset: 86687},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 50, offset: 86699},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 62, offset: 86711},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 74, offset: 86723},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 86, offset: 86735},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 98, offset: 86747},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2763, col: 36, offset: 95684},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2763, col: 36, offset: 95684},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2763, col: 41, offset: 95689},
																																			val:        "[abfnrtv\\\\\"]",
																																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 2761, col: 38, offset: 95576},
																																	val:        "[^\"\\\\\\n]",
																																	chars:      []rune{'"', '\\', '\n'},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																																&actionExpr{
																																	pos: position{line: 2650, col: 37, offset: 91334},
																																	run: (*parser).callonusesAndComments544,
																																	expr: &seqExpr{
																																		pos: position{line: 2650, col: 37, offset: 91334},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2650, col: 37, offset: 91334},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2674, col: 5, offset: 92351},
																																	run: (*parser).callonusesAndComments555,
																																	expr: &seqExpr{
																																		pos: position{line: 2674, col: 5, offset: 92351},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2674, col: 5, offset: 92351},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2695, col: 5, offset: 93193},
																																	run: (*parser).callonusesAndComments562,
																																	expr: &seqExpr{
																																		pos: position{line: 2695, col: 5, offset: 93193},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2695, col: 5, offset: 93193},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2713, col: 5, offset: 93879},
																																	run: (*parser).callonusesAndComments567,
																																	expr: &seqExpr{
																																		pos: position{line: 2713, col: 5, offset: 93879},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2713, col: 5, offset: 93879},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2713, col: 10, offset: 93884},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 3797, col: 12, offset: 129189},
																																					val:        "[^\\r\\n]",
																																					chars:      []rune{'\r', '\n'},
																																					ignoreCase: false,
																																					inverted:   true,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 849, col: 115, offset: 25844},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 851, col: 5, offset: 25936},
																										run: (*parser).callonusesAndComments573,
																										expr: &seqExpr{
																											pos: position{line: 851, col: 5, offset: 25936},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 851, col: 5, offset: 25936},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 851, col: 9, offset: 25940},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 851, col: 14, offset: 25945},
																														expr: &choiceExpr{
																															pos: position{line: 851, col: 15, offset: 25946},
																															alternatives: []any{
																																&seqExpr{
																																	pos: position{line: 2486, col: 24, offset: 84569},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2486, col: 24, offset: 84569},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2403, col: 19, offset: 81758},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2487, col: 24, offset: 84636},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2487, col: 24, offset: 84636},
																																			val:        "\\x",
																																			ignoreCase: false,
																																			want:       "\"\\\\x\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2488, col: 5, offset: 84673},
																																	run: (*parser).callonusesAndComments588,
																																	expr: &seqExpr{
																																		pos: position{line: 2488, col: 5, offset: 84673},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2488, col: 5, offset: 84673},
																																				val:        "\\x",
																																				ignoreCase: false,
																																				want:       "\"\\\\x\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2488, col: 14, offset: 84682},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2488, col: 26, offset: 84694},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2505, col: 19, offset: 85311},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2505, col: 19, offset: 85311},
																																			val:        "\\u",
																																			ignoreCase: false,
																																			want:       "\"\\\\u\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2506, col: 5, offset: 85370},
																																	run: (*parser).callonusesAndComments601,
																																	expr: &seqExpr{
																																		pos: position{line: 2506, col: 5, offset: 85370},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2506, col: 5, offset: 85370},
																																				val:        "\\u",
																																				ignoreCase: false,
																																				want:       "\"\\\\u\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 14, offset: 85379},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 26, offset: 85391},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 38, offset: 85403},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2506, col: 50, offset: 85415},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2535, col: 16, offset: 86551},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2535, col: 16, offset: 86551},
																																			val:        "\\U",
																																			ignoreCase: false,
																																			want:       "\"\\\\U\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2404, col: 19, offset: 81782},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2536, col: 5, offset: 86654},
																																	run: (*parser).callonusesAndComments622,
																																	expr: &seqExpr{
																																		pos: position{line: 2536, col: 5, offset: 86654},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2536, col: 5, offset: 86654},
																																				val:        "\\U",
																																				ignoreCase: false,
																																				want:       "\"\\\\U\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 14, offset: 86663},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 26, offset: 86675},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 38, offset: 86687},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 50, offset: 86699},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 62, offset: 86711},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 74, offset: 86723},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 86, offset: 86735},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2536, col: 98, offset: 86747},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2404, col: 19, offset: 81782},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2763, col: 36, offset: 95684},
																																	exprs: []any{
																																		&litMatcher{
																																			pos:        position{line: 2763, col: 36, offset: 95684},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2763, col: 41, offset: 95689},
																																			val:        "[abfnrtv\\\\\"]",
																																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 2761, col: 38, offset: 95576},
																																	val:        "[^\"\\\\\\n]",
																																	chars:      []rune{'"', '\\', '\n'},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																																&actionExpr{
																																	pos: position{line: 2650, col: 37, offset: 91334},
																																	run: (*parser).callonusesAndComments645,
																																	expr: &seqExpr{
																																		pos: position{line: 2650, col: 37, offset: 91334},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2650, col: 37, offset: 91334},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2674, col: 5, offset: 92351},
																																	run: (*parser).callonusesAndComments656,
																																	expr: &seqExpr{
																																		pos: position{line: 2674, col: 5, offset: 92351},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2674, col: 5, offset: 92351},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2695, col: 5, offset: 93193},
																																	run: (*parser).callonusesAndComments663,
																																	expr: &seqExpr{
																																		pos: position{line: 2695, col: 5, offset: 93193},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2695, col: 5, offset: 93193},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2404, col: 19, offset: 81782},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2713, col: 5, offset: 93879},
																																	run: (*parser).callonusesAndComments668,
																																	expr: &seqExpr{
																																		pos: position{line: 2713, col: 5, offset: 93879},
																																		exprs: []any{
																																			&litMatcher{
																																				pos:        position{line: 2713, col: 5, offset: 93879},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2713, col: 10, offset: 93884},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 3797, col: 12, offset: 129189},
																																					val:        "[^\\r\\n]",
																																					chars:      []rune{'\r', '\n'},
																																					ignoreCase: false,
																																					inverted:   true,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																												&labeledExpr{
																													pos:   position{line: 851, col: 98, offset: 26029},
																													label: "endPosI",
																													expr: &actionExpr{
																														pos: position{line: 3799, col: 8, offset: 129205},
																														run: (*parser).callonusesAndComments674,
																														expr: &choiceExpr{
																															pos: position{line: 3799, col: 9, offset: 129206},
																															alternatives: []any{
																																&andExpr{
																																	pos: position{line: 3799, col: 9, offset: 129206},
																																	expr: &anyMatcher{
																																		line: 3799, col: 10, offset: 129207,
																																	},
																																},
																																&notExpr{
																																	pos: position{line: 3799, col: 14, offset: 129211},
																																	expr: &anyMatcher{
																																		line: 3799, col: 15, offset: 129212,
																																	},
																																},
																															},
																														},
																													},
																												},
																												&andExpr{
																													pos: position{line: 851, col: 110, offset: 26041},
																													expr: &seqExpr{
																														pos: position{line: 3796, col: 12, offset: 129156},
																														exprs: []any{
																															&zeroOrMoreExpr{
																																pos: position{line: 3796, col: 12, offset: 129156},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3808, col: 36, offset: 129503},
																																	val:        "[ \\t]",
																																	chars:      []rune{' ', '\t'},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																															&choiceExpr{
																																pos: position{line: 3796, col: 16, offset: 129160},
																																alternatives: []any{
																																	&seqExpr{
																																		pos: position{line: 3796, col: 16, offset: 129160},
																																		exprs: []any{
																																			&zeroOrOneExpr{
																																				pos: position{line: 3796, col: 16, offset: 129160},
																																				expr: &litMatcher{
																																					pos:        position{line: 3796, col: 16, offset: 129160},
																																					val:        "\r",
																																					ignoreCase: false,
																																					want:       "\"\\r\"",
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 3796, col: 22, offset: 129166},
																																				val:        "\n",
																																				ignoreCase: false,
																																				want:       "\"\\n\"",
																																			},
																																		},
																																	},
																																	&notExpr{
																																		pos: position{line: 3795, col: 12, offset: 129142},
																																		expr: &anyMatcher{
																																			line: 3795, col: 13, offset: 129143,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 870, col: 22, offset: 26447},
																										run: (*parser).callonusesAndComments691,
																										expr: &seqExpr{
																											pos: position{line: 870, col: 22, offset: 26447},
																											exprs: []any{
																												&litMatcher{
																													pos:        position{line: 870, col: 22, offset: 26447},
																													val:        "'",
																													ignoreCase: false,
																													want:       "\"'\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 870, col: 27, offset: 26452},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 870, col: 32, offset: 26457},
																														expr: &charClassMatcher{
																															pos:        position{line: 870, col: 32, offset: 26457},
																															val:        "[^\\\\r\\n]",
																															chars:      []rune{'\'', '\r', '\n'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 870, col: 42, offset: 26467},
																													val:        "'",
																													ignoreCase: false,
																													want:       "\"'\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 870, col: 47, offset: 26472},
																													label: "endPosI",
																													expr: &actionExpr{
																														pos: position{line: 3799, col: 8, offset: 129205},
																														run: (*parser).callonusesAndComments699,
																														expr: &choiceExpr{
																															pos: position{line: 3799, col: 9, offset: 129206},
																															alternatives: []any{
																																&andExpr{
																																	pos: position{line: 3799, col: 9, offset: 129206},
																																	expr: &anyMatcher{
																																		line: 3799, col: 10, offset: 129207,
																																	},
																																},
																																&notExpr{
																																	pos: position{line: 3799, col: 14, offset: 129211},
																																	expr: &anyMatcher{
																																		line: 3799, col: 15, offset: 129212,
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 3237, col: 21, offset: 111300},
																										run: (*parser).callonusesAndComments705,
																										expr: &labeledExpr{
																											pos:   position{line: 3237, col: 21, offset: 111300},
																											label: "pathI",
																											expr: &zeroOrMoreExpr{
																												pos: position{line: 3237, col: 27, offset: 111306},
																												expr: &charClassMatcher{
																													pos:        position{line: 3797, col: 12, offset: 129189},
																													val:        "[^\\r\\n]",
																													chars:      []rune{'\r', '\n'},
																													ignoreCase: false,
																													inverted:   true,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&zeroOrMoreExpr{
																							pos: position{line: 3796, col: 12, offset: 129156},
																							expr: &charClassMatcher{
																								pos:        position{line: 3808, col: 36, offset: 129503},
																								val:        "[ \\t]",
																								chars:      []rune{' ', '\t'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&choiceExpr{
																							pos: position{line: 3796, col: 16, offset: 129160},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 3796, col: 16, offset: 129160},
																									exprs: []any{
																										&zeroOrOneExpr{
																											pos: position{line: 3796, col: 16, offset: 129160},
																											expr: &litMatcher{
																												pos:        position{line: 3796, col: 16, offset: 129160},
																												val:        "\r",
																												ignoreCase: false,
																												want:       "\"\\r\"",
																											},
																										},
																										&litMatcher{
																											pos:        position{line: 3796, col: 22, offset: 129166},
																											val:        "\n",
																											ignoreCase: false,
																											want:       "\"\\n\"",
																										},
																									},
																								},
																								&notExpr{
																									pos: position{line: 3795, col: 12, offset: 129142},
																									expr: &anyMatcher{
																										line: 3795, col: 13, offset: 129143,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 3357, col: 5, offset: 114782},
																run: (*parser).callonusesAndComments718,
																expr: &seqExpr{
																	pos: position{line: 3357, col: 5, offset: 114782},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 3357, col: 5, offset: 114782},
																			val:        "use",
																			ignoreCase: false,
																			want:       "\"use\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 3357, col: 11, offset: 114788},
																			label: "posI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonusesAndComments722,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 3796, col: 12, offset: 129156},
																			expr: &charClassMatcher{
																				pos:        position{line: 3808, col: 36, offset: 129503},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																		&choiceExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			alternatives: []any{
																				&seqExpr{
																					pos: position{line: 3796, col: 16, offset: 129160},
																					exprs: []any{
																						&zeroOrOneExpr{
																							pos: position{line: 3796, col: 16, offset: 129160},
																							expr: &litMatcher{
																								pos:        position{line: 3796, col: 16, offset: 129160},
																								val:        "\r",
																								ignoreCase: false,
																								want:       "\"\\r\"",
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 3796, col: 22, offset: 129166},
																							val:        "\n",
																							ignoreCase: false,
																							want:       "\"\\n\"",
																						},
																					},
																				},
																				&notExpr{
																					pos: position{line: 3795, col: 12, offset: 129142},
																					expr: &anyMatcher{
																						line: 3795, col: 13, offset: 129143,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "codesAndComments",
			pos:  position{line: 83, col: 1, offset: 2458},
			expr: &actionExpr{
				pos: position{line: 83, col: 21, offset: 2478},
				run: (*parser).calloncodesAndComments1,
				expr: &labeledExpr{
					pos:   position{line: 83, col: 21, offset: 2478},
					label: "valsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 83, col: 27, offset: 2484},
						expr: &seqExpr{
							pos: position{line: 83, col: 28, offset: 2485},
							exprs: []any{
								&zeroOrOneExpr{
									pos: position{line: 83, col: 28, offset: 2485},
									expr: &ruleRefExpr{
										pos:  position{line: 83, col: 28, offset: 2485},
										name: "CorgiComments",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 83, col: 43, offset: 2500},
									expr: &oneOrMoreExpr{
										pos: position{line: 3810, col: 36, offset: 129590},
										expr: &seqExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 3810, col: 37, offset: 129591},
													expr: &charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3809, col: 36, offset: 129544},
													expr: &litMatcher{
														pos:        position{line: 3809, col: 36, offset: 129544},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3809, col: 42, offset: 129550},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 83, col: 52, offset: 2509},
									name: "Codes",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "globalCodeAndFunc",
			pos:  position{line: 97, col: 1, offset: 2855},
			expr: &actionExpr{
				pos: position{line: 97, col: 22, offset: 2876},
				run: (*parser).callonglobalCodeAndFunc1,
				expr: &seqExpr{
					pos: position{line: 97, col: 22, offset: 2876},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 97, col: 22, offset: 2876},
							label: "codesAndCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 97, col: 40, offset: 2894},
								expr: &ruleRefExpr{
									pos:  position{line: 97, col: 40, offset: 2894},
									name: "codesAndComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 97, col: 58, offset: 2912},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 97, col: 67, offset: 2921},
							label: "commentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 97, col: 77, offset: 2931},
								expr: &ruleRefExpr{
									pos:  position{line: 97, col: 77, offset: 2931},
									name: "CorgiComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 97, col: 92, offset: 2946},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 97, col: 101, offset: 2955},
							label: "funcI",
							expr: &ruleRefExpr{
								pos:  position{line: 97, col: 107, offset: 2961},
								name: "Func",
							},
						},
					},
				},
			},
		},
		{
			name: "preScope",
			pos:  position{line: 115, col: 1, offset: 3415},
			expr: &actionExpr{
				pos: position{line: 115, col: 13, offset: 3427},
				run: (*parser).callonpreScope1,
				expr: &seqExpr{
					pos: position{line: 115, col: 13, offset: 3427},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 115, col: 13, offset: 3427},
							label: "itmsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 115, col: 19, offset: 3433},
								expr: &seqExpr{
									pos: position{line: 115, col: 20, offset: 3434},
									exprs: []any{
										&choiceExpr{
											pos: position{line: 115, col: 21, offset: 3435},
											alternatives: []any{
												&ruleRefExpr{
													pos:  position{line: 115, col: 21, offset: 3435},
													name: "CorgiComment",
												},
												&ruleRefExpr{
													pos:  position{line: 115, col: 36, offset: 3450},
													name: "Code",
												},
												&ruleRefExpr{
													pos:  position{line: 115, col: 43, offset: 3457},
													name: "Mixin",
												},
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 115, col: 50, offset: 3464},
											expr: &oneOrMoreExpr{
												pos: position{line: 3810, col: 36, offset: 129590},
												expr: &seqExpr{
													pos: position{line: 3810, col: 37, offset: 129591},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 3810, col: 37, offset: 129591},
															expr: &charClassMatcher{
																pos:        position{line: 3808, col: 36, offset: 129503},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&zeroOrOneExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															expr: &litMatcher{
																pos:        position{line: 3809, col: 36, offset: 129544},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3809, col: 42, offset: 129550},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 115, col: 61, offset: 3475},
							label: "doctypeI",
							expr: &choiceExpr{
								pos: position{line: 932, col: 12, offset: 28545},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 932, col: 12, offset: 28545},
										run: (*parser).callonpreScope20,
										expr: &seqExpr{
											pos: position{line: 932, col: 12, offset: 28545},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 932, col: 12, offset: 28545},
													val:        "doctype",
													ignoreCase: false,
													want:       "\"doctype\"",
												},
												&choiceExpr{
													pos: position{line: 945, col: 18, offset: 28968},
													alternatives: []any{
														&seqExpr{
															pos: position{line: 945, col: 18, offset: 28968},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 945, col: 18, offset: 28968},
																	val:        " html",
																	ignoreCase: false,
																	want:       "\" html\"",
																},
																&zeroOrMoreExpr{
																	pos: position{line: 3796, col: 12, offset: 129156},
																	expr: &charClassMatcher{
																		pos:        position{line: 3808, col: 36, offset: 129503},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&choiceExpr{
																	pos: position{line: 3796, col: 16, offset: 129160},
																	alternatives: []any{
																		&seqExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			exprs: []any{
																				&zeroOrOneExpr{
																					pos: position{line: 3796, col: 16, offset: 129160},
																					expr: &litMatcher{
																						pos:        position{line: 3796, col: 16, offset: 129160},
																						val:        "\r",
																						ignoreCase: false,
																						want:       "\"\\r\"",
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 3796, col: 22, offset: 129166},
																					val:        "\n",
																					ignoreCase: false,
																					want:       "\"\\n\"",
																				},
																			},
																		},
																		&notExpr{
																			pos: position{line: 3795, col: 12, offset: 129142},
																			expr: &anyMatcher{
																				line: 3795, col: 13, offset: 129143,
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 946, col: 5, offset: 28986},
															run: (*parser).callonpreScope35,
															expr: &seqExpr{
																pos: position{line: 946, col: 5, offset: 28986},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 946, col: 5, offset: 28986},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																	&labeledExpr{
																		pos:   position{line: 946, col: 9, offset: 28990},
																		label: "startPosI",
																		expr: &actionExpr{
																			pos: position{line: 3799, col: 8, offset: 129205},
																			run: (*parser).callonpreScope39,
																			expr: &choiceExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				alternatives: []any{
																					&andExpr{
																						pos: position{line: 3799, col: 9, offset: 129206},
																						expr: &anyMatcher{
																							line: 3799, col: 10, offset: 129207,
																						},
																					},
																					&notExpr{
																						pos: position{line: 3799, col: 14, offset: 129211},
																						expr: &anyMatcher{
																							line: 3799, col: 15, offset: 129212,
																						},
																					},
																				},
																			},
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 946, col: 23, offset: 29004},
																		expr: &charClassMatcher{
																			pos:        position{line: 3797, col: 12, offset: 129189},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 956, col: 9, offset: 29385},
															run: (*parser).callonpreScope56,
															expr: &seqExpr{
																pos: position{line: 956, col: 9, offset: 29385},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 956, col: 9, offset: 29385},
																		expr: &litMatcher{
																			pos:        position{line: 956, col: 9, offset: 29385},
																			val:        " ",
																			ignoreCase: false,
																			want:       "\" \"",
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 956, col: 14, offset: 29390},
																		expr: &charClassMatcher{
																			pos:        position{line: 3797, col: 12, offset: 129189},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 934, col: 5, offset: 28622},
										run: (*parser).callonpreScope71,
										expr: &seqExpr{
											pos: position{line: 934, col: 5, offset: 28622},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 934, col: 5, offset: 28622},
													val:        "!doctype",
													ignoreCase: false,
													want:       "\"!doctype\"",
												},
												&choiceExpr{
													pos: position{line: 945, col: 18, offset: 28968},
													alternatives: []any{
														&seqExpr{
															pos: position{line: 945, col: 18, offset: 28968},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 945, col: 18, offset: 28968},
																	val:        " html",
																	ignoreCase: false,
																	want:       "\" html\"",
																},
																&zeroOrMoreExpr{
																	pos: position{line: 3796, col: 12, offset: 129156},
																	expr: &charClassMatcher{
																		pos:        position{line: 3808, col: 36, offset: 129503},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&choiceExpr{
																	pos: position{line: 3796, col: 16, offset: 129160},
																	alternatives: []any{
																		&seqExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			exprs: []any{
																				&zeroOrOneExpr{
																					pos: position{line: 3796, col: 16, offset: 129160},
																					expr: &litMatcher{
																						pos:        position{line: 3796, col: 16, offset: 129160},
																						val:        "\r",
																						ignoreCase: false,
																						want:       "\"\\r\"",
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 3796, col: 22, offset: 129166},
																					val:        "\n",
																					ignoreCase: false,
																					want:       "\"\\n\"",
																				},
																			},
																		},
																		&notExpr{
																			pos: position{line: 3795, col: 12, offset: 129142},
																			expr: &anyMatcher{
																				line: 3795, col: 13, offset: 129143,
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 946, col: 5, offset: 28986},
															run: (*parser).callonpreScope86,
															expr: &seqExpr{
																pos: position{line: 946, col: 5, offset: 28986},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 946, col: 5, offset: 28986},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																	&labeledExpr{
																		pos:   position{line: 946, col: 9, offset: 28990},
																		label: "startPosI",
																		expr: &actionExpr{
																			pos: position{line: 3799, col: 8, offset: 129205},
																			run: (*parser).callonpreScope90,
																			expr: &choiceExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				alternatives: []any{
																					&andExpr{
																						pos: position{line: 3799, col: 9, offset: 129206},
																						expr: &anyMatcher{
																							line: 3799, col: 10, offset: 129207,
																						},
																					},
																					&notExpr{
																						pos: position{line: 3799, col: 14, offset: 129211},
																						expr: &anyMatcher{
																							line: 3799, col: 15, offset: 129212,
																						},
																					},
																				},
																			},
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 946, col: 23, offset: 29004},
																		expr: &charClassMatcher{
																			pos:        position{line: 3797, col: 12, offset: 129189},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 956, col: 9, offset: 29385},
															run: (*parser).callonpreScope107,
															expr: &seqExpr{
																pos: position{line: 956, col: 9, offset: 29385},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 956, col: 9, offset: 29385},
																		expr: &litMatcher{
																			pos:        position{line: 956, col: 9, offset: 29385},
																			val:        " ",
																			ignoreCase: false,
																			want:       "\" \"",
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 956, col: 14, offset: 29390},
																		expr: &charClassMatcher{
																			pos:        position{line: 3797, col: 12, offset: 129189},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Scope",
			pos:  position{line: 154, col: 1, offset: 4742},
			expr: &actionExpr{
				pos: position{line: 154, col: 10, offset: 4751},
				run: (*parser).callonScope1,
				expr: &labeledExpr{
					pos:   position{line: 154, col: 10, offset: 4751},
					label: "itemsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 154, col: 17, offset: 4758},
						expr: &seqExpr{
							pos: position{line: 154, col: 18, offset: 4759},
							exprs: []any{
								&zeroOrOneExpr{
									pos: position{line: 154, col: 18, offset: 4759},
									expr: &oneOrMoreExpr{
										pos: position{line: 3810, col: 36, offset: 129590},
										expr: &seqExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 3810, col: 37, offset: 129591},
													expr: &charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3809, col: 36, offset: 129544},
													expr: &litMatcher{
														pos:        position{line: 3809, col: 36, offset: 129544},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3809, col: 42, offset: 129550},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 3897, col: 17, offset: 133397},
									run: (*parser).callonScope13,
									expr: &zeroOrMoreExpr{
										pos: position{line: 3897, col: 17, offset: 133397},
										expr: &charClassMatcher{
											pos:        position{line: 3808, col: 36, offset: 129503},
											val:        "[ \\t]",
											chars:      []rune{' ', '\t'},
											ignoreCase: false,
											inverted:   false,
										},
									},
								},
								&andCodeExpr{
									pos: position{line: 3897, col: 41, offset: 133421},
									run: (*parser).callonScope16,
								},
								&choiceExpr{
									pos: position{line: 3949, col: 5, offset: 135331},
									alternatives: []any{
										&andCodeExpr{
											pos: position{line: 3949, col: 5, offset: 135331},
											run: (*parser).callonScope18,
										},
										&seqExpr{
											pos: position{line: 3951, col: 9, offset: 135414},
											exprs: []any{
												&andCodeExpr{
													pos: position{line: 3951, col: 9, offset: 135414},
													run: (*parser).callonScope20,
												},
												&stateCodeExpr{
													pos: position{line: 3953, col: 7, offset: 135537},
													run: (*parser).callonScope21,
												},
											},
										},
										&seqExpr{
											pos: position{line: 3960, col: 9, offset: 135873},
											exprs: []any{
												&andCodeExpr{
													pos: position{line: 3960, col: 9, offset: 135873},
													run: (*parser).callonScope23,
												},
												&andCodeExpr{
													pos: position{line: 3962, col: 7, offset: 135981},
													run: (*parser).callonScope24,
												},
												&choiceExpr{
													pos: position{line: 4015, col: 9, offset: 138316},
													alternatives: []any{
														&seqExpr{
															pos: position{line: 4015, col: 9, offset: 138316},
															exprs: []any{
																&andCodeExpr{
																	pos: position{line: 4015, col: 9, offset: 138316},
																	run: (*parser).callonScope27,
																},
																&andCodeExpr{
																	pos: position{line: 4019, col: 11, offset: 138566},
																	run: (*parser).callonScope28,
																},
																&stateCodeExpr{
																	pos: position{line: 4085, col: 11, offset: 141772},
																	run: (*parser).callonScope29,
																},
															},
														},
														&seqExpr{
															pos: position{line: 4093, col: 13, offset: 142125},
															exprs: []any{
																&andCodeExpr{
																	pos: position{line: 4093, col: 13, offset: 142125},
																	run: (*parser).callonScope31,
																},
																&andCodeExpr{
																	pos: position{line: 4097, col: 11, offset: 142380},
																	run: (*parser).callonScope32,
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 154, col: 39, offset: 4780},
									name: "scopeItem",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "scopeItem",
			pos:  position{line: 168, col: 1, offset: 5086},
			expr: &choiceExpr{
				pos: position{line: 169, col: 5, offset: 5105},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 169, col: 5, offset: 5105},
						name: "Block",
					},
					&ruleRefExpr{
						pos:  position{line: 169, col: 13, offset: 5113},
						name: "Prepend",
					},
					&ruleRefExpr{
						pos:  position{line: 169, col: 23, offset: 5123},
						name: "Append",
					},
					&ruleRefExpr{
						pos:  position{line: 170, col: 5, offset: 5152},
						name: "Code",
					},
					&ruleRefExpr{
						pos:  position{line: 171, col: 5, offset: 5198},
						name: "If",
					},
					&ruleRefExpr{
						pos:  position{line: 171, col: 10, offset: 5203},
						name: "IfBlock",
					},
					&ruleRefExpr{
						pos:  position{line: 171, col: 20, offset: 5213},
						name: "Switch",
					},
					&ruleRefExpr{
						pos:  position{line: 171, col: 29, offset: 5222},
						name: "For",
					},
					&ruleRefExpr{
						pos:  position{line: 172, col: 5, offset: 5258},
						name: "CorgiComment",
					},
					&ruleRefExpr{
						pos:  position{line: 173, col: 5, offset: 5305},
						name: "HTMLComment",
					},
					&ruleRefExpr{
						pos:  position{line: 173, col: 19, offset: 5319},
						name: "And",
					},
					&ruleRefExpr{
						pos:  position{line: 174, col: 5, offset: 5384},
						name: "Filter",
					},
					&actionExpr{
						pos: position{line: 2888, col: 12, offset: 99886},
						run: (*parser).callonscopeItem14,
						expr: &seqExpr{
							pos: position{line: 2888, col: 12, offset: 99886},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2888, col: 12, offset: 99886},
									val:        "include",
									ignoreCase: false,
									want:       "\"include\"",
								},
								&labeledExpr{
									pos:   position{line: 2888, col: 22, offset: 99896},
									label: "pathI",
									expr: &choiceExpr{
										pos: position{line: 3223, col: 18, offset: 110865},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 3223, col: 18, offset: 110865},
												run: (*parser).callonscopeItem19,
												expr: &seqExpr{
													pos: position{line: 3223, col: 18, offset: 110865},
													exprs: []any{
														&oneOrMoreExpr{
															pos: position{line: 3223, col: 18, offset: 110865},
															expr: &litMatcher{
																pos:        position{line: 3223, col: 18, offset: 110865},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&labeledExpr{
															pos:   position{line: 3223, col: 23, offset: 110870},
															label: "sI",
															expr: &choiceExpr{
																pos: position{line: 822, col: 11, offset: 25102},
																alternatives: []any{
																	&actionExpr{
																		pos: position{line: 828, col: 14, offset: 25189},
																		run: (*parser).callonscopeItem25,
																		expr: &seqExpr{
																			pos: position{line: 828, col: 14, offset: 25189},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 828, col: 14, offset: 25189},
																					val:        "`",
																					ignoreCase: false,
																					want:       "\"`\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 828, col: 18, offset: 25193},
																					label: "strI",
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 828, col: 23, offset: 25198},
																						expr: &charClassMatcher{
																							pos:        position{line: 2747, col: 27, offset: 94906},
																							val:        "[^\\n`]",
																							chars:      []rune{'\n', '`'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 828, col: 47, offset: 25222},
																					val:        "`",
																					ignoreCase: false,
																					want:       "\"`\"",
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 830, col: 5, offset: 25314},
																		run: (*parser).callonscopeItem32,
																		expr: &seqExpr{
																			pos: position{line: 830, col: 5, offset: 25314},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 830, col: 5, offset: 25314},
																					val:        "`",
																					ignoreCase: false,
																					want:       "\"`\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 830, col: 9, offset: 25318},
																					label: "strI",
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 830, col: 14, offset: 25323},
																						expr: &charClassMatcher{
																							pos:        position{line: 2747, col: 27, offset: 94906},
																							val:        "[^\\n`]",
																							chars:      []rune{'\n', '`'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																					},
																				},
																				&andExpr{
																					pos: position{line: 830, col: 38, offset: 25347},
																					expr: &seqExpr{
																						pos: position{line: 3796, col: 12, offset: 129156},
																						exprs: []any{
																							&zeroOrMoreExpr{
																								pos: position{line: 3796, col: 12, offset: 129156},
																								expr: &charClassMatcher{
																									pos:        position{line: 3808, col: 36, offset: 129503},
																									val:        "[ \\t]",
																									chars:      []rune{' ', '\t'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&choiceExpr{
																								pos: position{line: 3796, col: 16, offset: 129160},
																								alternatives: []any{
																									&seqExpr{
																										pos: position{line: 3796, col: 16, offset: 129160},
																										exprs: []any{
																											&zeroOrOneExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												expr: &litMatcher{
																													pos:        position{line: 3796, col: 16, offset: 129160},
																													val:        "\r",
																													ignoreCase: false,
																													want:       "\"\\r\"",
																												},
																											},
																											&litMatcher{
																												pos:        position{line: 3796, col: 22, offset: 129166},
																												val:        "\n",
																												ignoreCase: false,
																												want:       "\"\\n\"",
																											},
																										},
																									},
																									&notExpr{
																										pos: position{line: 3795, col: 12, offset: 129142},
																										expr: &anyMatcher{
																											line: 3795, col: 13, offset: 129143,
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 849, col: 22, offset: 25751},
																		run: (*parser).callonscopeItem49,
																		expr: &seqExpr{
																			pos: position{line: 849, col: 22, offset: 25751},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 849, col: 22, offset: 25751},
																					val:        "\"",
																					ignoreCase: false,
																					want:       "\"\\\"\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 849, col: 26, offset: 25755},
																					label: "strI",
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 849, col: 31, offset: 25760},
																						expr: &choiceExpr{
																							pos: position{line: 849, col: 32, offset: 25761},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 2486, col: 24, offset: 84569},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2486, col: 24, offset: 84569},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2487, col: 24, offset: 84636},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2487, col: 24, offset: 84636},
																											val:        "\\x",
																											ignoreCase: false,
																											want:       "\"\\\\x\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2488, col: 5, offset: 84673},
																									run: (*parser).callonscopeItem64,
																									expr: &seqExpr{
																										pos: position{line: 2488, col: 5, offset: 84673},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2488, col: 5, offset: 84673},
																												val:        "\\x",
																												ignoreCase: false,
																												want:       "\"\\\\x\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2488, col: 14, offset: 84682},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2488, col: 26, offset: 84694},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2505, col: 19, offset: 85311},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2505, col: 19, offset: 85311},
																											val:        "\\u",
																											ignoreCase: false,
																											want:       "\"\\\\u\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2506, col: 5, offset: 85370},
																									run: (*parser).callonscopeItem77,
																									expr: &seqExpr{
																										pos: position{line: 2506, col: 5, offset: 85370},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2506, col: 5, offset: 85370},
																												val:        "\\u",
																												ignoreCase: false,
																												want:       "\"\\\\u\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 14, offset: 85379},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 26, offset: 85391},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 38, offset: 85403},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 50, offset: 85415},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2535, col: 16, offset: 86551},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2535, col: 16, offset: 86551},
																											val:        "\\U",
																											ignoreCase: false,
																											want:       "\"\\\\U\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2536, col: 5, offset: 86654},
																									run: (*parser).callonscopeItem98,
																									expr: &seqExpr{
																										pos: position{line: 2536, col: 5, offset: 86654},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2536, col: 5, offset: 86654},
																												val:        "\\U",
																												ignoreCase: false,
																												want:       "\"\\\\U\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 14, offset: 86663},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 26, offset: 86675},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 38, offset: 86687},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 50, offset: 86699},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 62, offset: 86711},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 74, offset: 86723},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 86, offset: 86735},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 98, offset: 86747},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2763, col: 36, offset: 95684},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2763, col: 36, offset: 95684},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2763, col: 41, offset: 95689},
																											val:        "[abfnrtv\\\\\"]",
																											chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 2761, col: 38, offset: 95576},
																									val:        "[^\"\\\\\\n]",
																									chars:      []rune{'"', '\\', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																								&actionExpr{
																									pos: position{line: 2650, col: 37, offset: 91334},
																									run: (*parser).callonscopeItem121,
																									expr: &seqExpr{
																										pos: position{line: 2650, col: 37, offset: 91334},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2650, col: 37, offset: 91334},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2674, col: 5, offset: 92351},
																									run: (*parser).callonscopeItem132,
																									expr: &seqExpr{
																										pos: position{line: 2674, col: 5, offset: 92351},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2674, col: 5, offset: 92351},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2695, col: 5, offset: 93193},
																									run: (*parser).callonscopeItem139,
																									expr: &seqExpr{
																										pos: position{line: 2695, col: 5, offset: 93193},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2695, col: 5, offset: 93193},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2713, col: 5, offset: 93879},
																									run: (*parser).callonscopeItem144,
																									expr: &seqExpr{
																										pos: position{line: 2713, col: 5, offset: 93879},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2713, col: 5, offset: 93879},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2713, col: 10, offset: 93884},
																												expr: &charClassMatcher{
																													pos:        position{line: 3797, col: 12, offset: 129189},
																													val:        "[^\\r\\n]",
																													chars:      []rune{'\r', '\n'},
																													ignoreCase: false,
																													inverted:   true,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 849, col: 115, offset: 25844},
																					val:        "\"",
																					ignoreCase: false,
																					want:       "\"\\\"\"",
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 851, col: 5, offset: 25936},
																		run: (*parser).callonscopeItem150,
																		expr: &seqExpr{
																			pos: position{line: 851, col: 5, offset: 25936},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 851, col: 5, offset: 25936},
																					val:        "\"",
																					ignoreCase: false,
																					want:       "\"\\\"\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 851, col: 9, offset: 25940},
																					label: "strI",
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 851, col: 14, offset: 25945},
																						expr: &choiceExpr{
																							pos: position{line: 851, col: 15, offset: 25946},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 2486, col: 24, offset: 84569},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2486, col: 24, offset: 84569},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2487, col: 24, offset: 84636},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2487, col: 24, offset: 84636},
																											val:        "\\x",
																											ignoreCase: false,
																											want:       "\"\\\\x\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2488, col: 5, offset: 84673},
																									run: (*parser).callonscopeItem165,
																									expr: &seqExpr{
																										pos: position{line: 2488, col: 5, offset: 84673},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2488, col: 5, offset: 84673},
																												val:        "\\x",
																												ignoreCase: false,
																												want:       "\"\\\\x\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2488, col: 14, offset: 84682},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2488, col: 26, offset: 84694},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2505, col: 19, offset: 85311},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2505, col: 19, offset: 85311},
																											val:        "\\u",
																											ignoreCase: false,
																											want:       "\"\\\\u\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2506, col: 5, offset: 85370},
																									run: (*parser).callonscopeItem178,
																									expr: &seqExpr{
																										pos: position{line: 2506, col: 5, offset: 85370},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2506, col: 5, offset: 85370},
																												val:        "\\u",
																												ignoreCase: false,
																												want:       "\"\\\\u\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 14, offset: 85379},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 26, offset: 85391},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 38, offset: 85403},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 50, offset: 85415},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2535, col: 16, offset: 86551},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2535, col: 16, offset: 86551},
																											val:        "\\U",
																											ignoreCase: false,
																											want:       "\"\\\\U\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2536, col: 5, offset: 86654},
																									run: (*parser).callonscopeItem199,
																									expr: &seqExpr{
																										pos: position{line: 2536, col: 5, offset: 86654},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2536, col: 5, offset: 86654},
																												val:        "\\U",
																												ignoreCase: false,
																												want:       "\"\\\\U\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 14, offset: 86663},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 26, offset: 86675},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 38, offset: 86687},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 50, offset: 86699},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 62, offset: 86711},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 74, offset: 86723},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 86, offset: 86735},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 98, offset: 86747},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2763, col: 36, offset: 95684},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2763, col: 36, offset: 95684},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2763, col: 41, offset: 95689},
																											val:        "[abfnrtv\\\\\"]",
																											chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 2761, col: 38, offset: 95576},
																									val:        "[^\"\\\\\\n]",
																									chars:      []rune{'"', '\\', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																								&actionExpr{
																									pos: position{line: 2650, col: 37, offset: 91334},
																									run: (*parser).callonscopeItem222,
																									expr: &seqExpr{
																										pos: position{line: 2650, col: 37, offset: 91334},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2650, col: 37, offset: 91334},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2674, col: 5, offset: 92351},
																									run: (*parser).callonscopeItem233,
																									expr: &seqExpr{
																										pos: position{line: 2674, col: 5, offset: 92351},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2674, col: 5, offset: 92351},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2695, col: 5, offset: 93193},
																									run: (*parser).callonscopeItem240,
																									expr: &seqExpr{
																										pos: position{line: 2695, col: 5, offset: 93193},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2695, col: 5, offset: 93193},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2713, col: 5, offset: 93879},
																									run: (*parser).callonscopeItem245,
																									expr: &seqExpr{
																										pos: position{line: 2713, col: 5, offset: 93879},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2713, col: 5, offset: 93879},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2713, col: 10, offset: 93884},
																												expr: &charClassMatcher{
																													pos:        position{line: 3797, col: 12, offset: 129189},
																													val:        "[^\\r\\n]",
																													chars:      []rune{'\r', '\n'},
																													ignoreCase: false,
																													inverted:   true,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 851, col: 98, offset: 26029},
																					label: "endPosI",
																					expr: &actionExpr{
																						pos: position{line: 3799, col: 8, offset: 129205},
																						run: (*parser).callonscopeItem251,
																						expr: &choiceExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							alternatives: []any{
																								&andExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									expr: &anyMatcher{
																										line: 3799, col: 10, offset: 129207,
																									},
																								},
																								&notExpr{
																									pos: position{line: 3799, col: 14, offset: 129211},
																									expr: &anyMatcher{
																										line: 3799, col: 15, offset: 129212,
																									},
																								},
																							},
																						},
																					},
																				},
																				&andExpr{
																					pos: position{line: 851, col: 110, offset: 26041},
																					expr: &seqExpr{
																						pos: position{line: 3796, col: 12, offset: 129156},
																						exprs: []any{
																							&zeroOrMoreExpr{
																								pos: position{line: 3796, col: 12, offset: 129156},
																								expr: &charClassMatcher{
																									pos:        position{line: 3808, col: 36, offset: 129503},
																									val:        "[ \\t]",
																									chars:      []rune{' ', '\t'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&choiceExpr{
																								pos: position{line: 3796, col: 16, offset: 129160},
																								alternatives: []any{
																									&seqExpr{
																										pos: position{line: 3796, col: 16, offset: 129160},
																										exprs: []any{
																											&zeroOrOneExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												expr: &litMatcher{
																													pos:        position{line: 3796, col: 16, offset: 129160},
																													val:        "\r",
																													ignoreCase: false,
																													want:       "\"\\r\"",
																												},
																											},
																											&litMatcher{
																												pos:        position{line: 3796, col: 22, offset: 129166},
																												val:        "\n",
																												ignoreCase: false,
																												want:       "\"\\n\"",
																											},
																										},
																									},
																									&notExpr{
																										pos: position{line: 3795, col: 12, offset: 129142},
																										expr: &anyMatcher{
																											line: 3795, col: 13, offset: 129143,
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 870, col: 22, offset: 26447},
																		run: (*parser).callonscopeItem268,
																		expr: &seqExpr{
																			pos: position{line: 870, col: 22, offset: 26447},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 870, col: 22, offset: 26447},
																					val:        "'",
																					ignoreCase: false,
																					want:       "\"'\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 870, col: 27, offset: 26452},
																					label: "strI",
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 870, col: 32, offset: 26457},
																						expr: &charClassMatcher{
																							pos:        position{line: 870, col: 32, offset: 26457},
																							val:        "[^\\\\r\\n]",
																							chars:      []rune{'\'', '\r', '\n'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 870, col: 42, offset: 26467},
																					val:        "'",
																					ignoreCase: false,
																					want:       "\"'\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 870, col: 47, offset: 26472},
																					label: "endPosI",
																					expr: &actionExpr{
																						pos: position{line: 3799, col: 8, offset: 129205},
																						run: (*parser).callonscopeItem276,
																						expr: &choiceExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							alternatives: []any{
																								&andExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									expr: &anyMatcher{
																										line: 3799, col: 10, offset: 129207,
																									},
																								},
																								&notExpr{
																									pos: position{line: 3799, col: 14, offset: 129211},
																									expr: &anyMatcher{
																										line: 3799, col: 15, offset: 129212,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 3225, col: 5, offset: 110905},
												run: (*parser).callonscopeItem282,
												expr: &seqExpr{
													pos: position{line: 3225, col: 5, offset: 110905},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 3225, col: 5, offset: 110905},
															expr: &litMatcher{
																pos:        position{line: 3225, col: 5, offset: 110905},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&labeledExpr{
															pos:   position{line: 3225, col: 10, offset: 110910},
															label: "pathI",
															expr: &zeroOrMoreExpr{
																pos: position{line: 3225, col: 16, offset: 110916},
																expr: &charClassMatcher{
																	pos:        position{line: 3797, col: 12, offset: 129189},
																	val:        "[^\\r\\n]",
																	chars:      []rune{'\r', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 176, col: 5, offset: 5481},
						name: "Mixin",
					},
					&ruleRefExpr{
						pos:  position{line: 176, col: 13, offset: 5489},
						name: "Return",
					},
					&ruleRefExpr{
						pos:  position{line: 176, col: 22, offset: 5498},
						name: "MixinCall",
					},
					&ruleRefExpr{
						pos:  position{line: 177, col: 5, offset: 5530},
						name: "ArrowBlock",
					},
					&actionExpr{
						pos: position{line: 184, col: 17, offset: 5678},
						run: (*parser).callonscopeItem293,
						expr: &labeledExpr{
							pos:   position{line: 184, col: 17, offset: 5678},
							label: "doctypeI",
							expr: &choiceExpr{
								pos: position{line: 932, col: 12, offset: 28545},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 932, col: 12, offset: 28545},
										run: (*parser).callonscopeItem296,
										expr: &seqExpr{
											pos: position{line: 932, col: 12, offset: 28545},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 932, col: 12, offset: 28545},
													val:        "doctype",
													ignoreCase: false,
													want:       "\"doctype\"",
												},
												&choiceExpr{
													pos: position{line: 945, col: 18, offset: 28968},
													alternatives: []any{
														&seqExpr{
															pos: position{line: 945, col: 18, offset: 28968},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 945, col: 18, offset: 28968},
																	val:        " html",
																	ignoreCase: false,
																	want:       "\" html\"",
																},
																&zeroOrMoreExpr{
																	pos: position{line: 3796, col: 12, offset: 129156},
																	expr: &charClassMatcher{
																		pos:        position{line: 3808, col: 36, offset: 129503},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&choiceExpr{
																	pos: position{line: 3796, col: 16, offset: 129160},
																	alternatives: []any{
																		&seqExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			exprs: []any{
																				&zeroOrOneExpr{
																					pos: position{line: 3796, col: 16, offset: 129160},
																					expr: &litMatcher{
																						pos:        position{line: 3796, col: 16, offset: 129160},
																						val:        "\r",
																						ignoreCase: false,
																						want:       "\"\\r\"",
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 3796, col: 22, offset: 129166},
																					val:        "\n",
																					ignoreCase: false,
																					want:       "\"\\n\"",
																				},
																			},
																		},
																		&notExpr{
																			pos: position{line: 3795, col: 12, offset: 129142},
																			expr: &anyMatcher{
																				line: 3795, col: 13, offset: 129143,
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 946, col: 5, offset: 28986},
															run: (*parser).callonscopeItem311,
															expr: &seqExpr{
																pos: position{line: 946, col: 5, offset: 28986},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 946, col: 5, offset: 28986},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																	&labeledExpr{
																		pos:   position{line: 946, col: 9, offset: 28990},
																		label: "startPosI",
																		expr: &actionExpr{
																			pos: position{line: 3799, col: 8, offset: 129205},
																			run: (*parser).callonscopeItem315,
																			expr: &choiceExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				alternatives: []any{
																					&andExpr{
																						pos: position{line: 3799, col: 9, offset: 129206},
																						expr: &anyMatcher{
																							line: 3799, col: 10, offset: 129207,
																						},
																					},
																					&notExpr{
																						pos: position{line: 3799, col: 14, offset: 129211},
																						expr: &anyMatcher{
																							line: 3799, col: 15, offset: 129212,
																						},
																					},
																				},
																			},
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 946, col: 23, offset: 29004},
																		expr: &charClassMatcher{
																			pos:        position{line: 3797, col: 12, offset: 129189},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 956, col: 9, offset: 29385},
															run: (*parser).callonscopeItem332,
															expr: &seqExpr{
																pos: position{line: 956, col: 9, offset: 29385},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 956, col: 9, offset: 29385},
																		expr: &litMatcher{
																			pos:        position{line: 956, col: 9, offset: 29385},
																			val:        " ",
																			ignoreCase: false,
																			want:       "\" \"",
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 956, col: 14, offset: 29390},
																		expr: &charClassMatcher{
																			pos:        position{line: 3797, col: 12, offset: 129189},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 934, col: 5, offset: 28622},
										run: (*parser).callonscopeItem347,
										expr: &seqExpr{
											pos: position{line: 934, col: 5, offset: 28622},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 934, col: 5, offset: 28622},
													val:        "!doctype",
													ignoreCase: false,
													want:       "\"!doctype\"",
												},
												&choiceExpr{
													pos: position{line: 945, col: 18, offset: 28968},
													alternatives: []any{
														&seqExpr{
															pos: position{line: 945, col: 18, offset: 28968},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 945, col: 18, offset: 28968},
																	val:        " html",
																	ignoreCase: false,
																	want:       "\" html\"",
																},
																&zeroOrMoreExpr{
																	pos: position{line: 3796, col: 12, offset: 129156},
																	expr: &charClassMatcher{
																		pos:        position{line: 3808, col: 36, offset: 129503},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&choiceExpr{
																	pos: position{line: 3796, col: 16, offset: 129160},
																	alternatives: []any{
																		&seqExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			exprs: []any{
																				&zeroOrOneExpr{
																					pos: position{line: 3796, col: 16, offset: 129160},
																					expr: &litMatcher{
																						pos:        position{line: 3796, col: 16, offset: 129160},
																						val:        "\r",
																						ignoreCase: false,
																						want:       "\"\\r\"",
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 3796, col: 22, offset: 129166},
																					val:        "\n",
																					ignoreCase: false,
																					want:       "\"\\n\"",
																				},
																			},
																		},
																		&notExpr{
																			pos: position{line: 3795, col: 12, offset: 129142},
																			expr: &anyMatcher{
																				line: 3795, col: 13, offset: 129143,
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 946, col: 5, offset: 28986},
															run: (*parser).callonscopeItem362,
															expr: &seqExpr{
																pos: position{line: 946, col: 5, offset: 28986},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 946, col: 5, offset: 28986},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																	&labeledExpr{
																		pos:   position{line: 946, col: 9, offset: 28990},
																		label: "startPosI",
																		expr: &actionExpr{
																			pos: position{line: 3799, col: 8, offset: 129205},
																			run: (*parser).callonscopeItem366,
																			expr: &choiceExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				alternatives: []any{
																					&andExpr{
																						pos: position{line: 3799, col: 9, offset: 129206},
																						expr: &anyMatcher{
																							line: 3799, col: 10, offset: 129207,
																						},
																					},
																					&notExpr{
																						pos: position{line: 3799, col: 14, offset: 129211},
																						expr: &anyMatcher{
																							line: 3799, col: 15, offset: 129212,
																						},
																					},
																				},
																			},
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 946, col: 23, offset: 29004},
																		expr: &charClassMatcher{
																			pos:        position{line: 3797, col: 12, offset: 129189},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 956, col: 9, offset: 29385},
															run: (*parser).callonscopeItem383,
															expr: &seqExpr{
																pos: position{line: 956, col: 9, offset: 29385},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 956, col: 9, offset: 29385},
																		expr: &litMatcher{
																			pos:        position{line: 956, col: 9, offset: 29385},
																			val:        " ",
																			ignoreCase: false,
																			want:       "\" \"",
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 956, col: 14, offset: 29390},
																		expr: &charClassMatcher{
																			pos:        position{line: 3797, col: 12, offset: 129189},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 180, col: 5, offset: 5596},
						name: "DivShorthand",
					},
					&ruleRefExpr{
						pos:  position{line: 180, col: 20, offset: 5611},
						name: "Element",
					},
					&ruleRefExpr{
						pos:  position{line: 181, col: 5, offset: 5651},
						name: "BadItem",
					},
				},
			},
		},
		{
			name: "Body",
			pos:  position{line: 206, col: 1, offset: 6506},
			expr: &actionExpr{
				pos: position{line: 206, col: 9, offset: 6514},
				run: (*parser).callonBody1,
				expr: &seqExpr{
					pos: position{line: 206, col: 9, offset: 6514},
					exprs: []any{
						&stateCodeExpr{
							pos: position{line: 4284, col: 11, offset: 150129},
							run: (*parser).callonBody3,
						},
						&labeledExpr{
							pos:   position{line: 206, col: 16, offset: 6521},
							label: "scopeI",
							expr: &ruleRefExpr{
								pos:  position{line: 206, col: 23, offset: 6528},
								name: "Scope",
							},
						},
						&stateCodeExpr{
							pos: position{line: 4289, col: 11, offset: 150234},
							run: (*parser).callonBody6,
						},
					},
				},
			},
		},
		{
			name: "Beaitb",
			pos:  position{line: 210, col: 1, offset: 6569},
			expr: &choiceExpr{
				pos: position{line: 210, col: 11, offset: 6579},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 210, col: 11, offset: 6579},
						run: (*parser).callonBeaitb2,
						expr: &labeledExpr{
							pos:   position{line: 210, col: 11, offset: 6579},
							label: "scopeItemI",
							expr: &choiceExpr{
								pos: position{line: 210, col: 23, offset: 6591},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 210, col: 23, offset: 6591},
										name: "BlockExpansion",
									},
									&ruleRefExpr{
										pos:  position{line: 210, col: 40, offset: 6608},
										name: "InlineText",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 212, col: 5, offset: 6686},
						run: (*parser).callonBeaitb7,
						expr: &seqExpr{
							pos: position{line: 212, col: 5, offset: 6686},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 212, col: 9, offset: 6690},
									label: "bodyI",
									expr: &ruleRefExpr{
										pos:  position{line: 212, col: 15, offset: 6696},
										name: "Body",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 214, col: 5, offset: 6729},
						run: (*parser).callonBeaitb20,
						expr: &seqExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 216, col: 5, offset: 6771},
						run: (*parser).callonBeaitb31,
						expr: &seqExpr{
							pos: position{line: 216, col: 5, offset: 6771},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 216, col: 5, offset: 6771},
									label: "lineI",
									expr: &oneOrMoreExpr{
										pos: position{line: 216, col: 11, offset: 6777},
										expr: &charClassMatcher{
											pos:        position{line: 3797, col: 12, offset: 129189},
											val:        "[^\\r\\n]",
											chars:      []rune{'\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 216, col: 24, offset: 6790},
									label: "bodyI",
									expr: &zeroOrOneExpr{
										pos: position{line: 216, col: 30, offset: 6796},
										expr: &ruleRefExpr{
											pos:  position{line: 216, col: 30, offset: 6796},
											name: "Body",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Beait",
			pos:  position{line: 231, col: 1, offset: 7216},
			expr: &choiceExpr{
				pos: position{line: 231, col: 10, offset: 7225},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 231, col: 10, offset: 7225},
						run: (*parser).callonBeait2,
						expr: &labeledExpr{
							pos:   position{line: 231, col: 10, offset: 7225},
							label: "scopeItemI",
							expr: &choiceExpr{
								pos: position{line: 231, col: 22, offset: 7237},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 231, col: 22, offset: 7237},
										name: "BlockExpansion",
									},
									&ruleRefExpr{
										pos:  position{line: 231, col: 39, offset: 7254},
										name: "InlineText",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 233, col: 5, offset: 7328},
						run: (*parser).callonBeait7,
						expr: &seqExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 235, col: 5, offset: 7370},
						run: (*parser).callonBeait18,
						expr: &seqExpr{
							pos: position{line: 235, col: 5, offset: 7370},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 235, col: 5, offset: 7370},
									label: "lineI",
									expr: &oneOrMoreExpr{
										pos: position{line: 235, col: 11, offset: 7376},
										expr: &charClassMatcher{
											pos:        position{line: 3797, col: 12, offset: 129189},
											val:        "[^\\r\\n]",
											chars:      []rune{'\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BadItem",
			pos:  position{line: 248, col: 1, offset: 7747},
			expr: &actionExpr{
				pos: position{line: 248, col: 12, offset: 7758},
				run: (*parser).callonBadItem1,
				expr: &seqExpr{
					pos: position{line: 248, col: 12, offset: 7758},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 248, col: 12, offset: 7758},
							label: "lineI",
							expr: &oneOrMoreExpr{
								pos: position{line: 248, col: 18, offset: 7764},
								expr: &charClassMatcher{
									pos:        position{line: 3797, col: 12, offset: 129189},
									val:        "[^\\r\\n]",
									chars:      []rune{'\r', '\n'},
									ignoreCase: false,
									inverted:   true,
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							expr: &charClassMatcher{
								pos:        position{line: 3808, col: 36, offset: 129503},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3796, col: 16, offset: 129160},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											expr: &litMatcher{
												pos:        position{line: 3796, col: 16, offset: 129160},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3796, col: 22, offset: 129166},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3795, col: 12, offset: 129142},
									expr: &anyMatcher{
										line: 3795, col: 13, offset: 129143,
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 248, col: 31, offset: 7777},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 248, col: 37, offset: 7783},
								expr: &ruleRefExpr{
									pos:  position{line: 248, col: 37, offset: 7783},
									name: "Body",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Block",
			pos:  position{line: 283, col: 1, offset: 9176},
			expr: &actionExpr{
				pos: position{line: 283, col: 10, offset: 9185},
				run: (*parser).callonBlock1,
				expr: &seqExpr{
					pos: position{line: 283, col: 10, offset: 9185},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 283, col: 10, offset: 9185},
							label: "blockI",
							expr: &actionExpr{
								pos: position{line: 304, col: 19, offset: 9777},
								run: (*parser).callonBlock4,
								expr: &seqExpr{
									pos: position{line: 304, col: 19, offset: 9777},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 304, col: 19, offset: 9777},
											val:        "block",
											ignoreCase: false,
											want:       "\"block\"",
										},
										&labeledExpr{
											pos:   position{line: 304, col: 27, offset: 9785},
											label: "nameI",
											expr: &choiceExpr{
												pos: position{line: 329, col: 14, offset: 10358},
												alternatives: []any{
													&actionExpr{
														pos: position{line: 329, col: 14, offset: 10358},
														run: (*parser).callonBlock9,
														expr: &seqExpr{
															pos: position{line: 329, col: 14, offset: 10358},
															exprs: []any{
																&oneOrMoreExpr{
																	pos: position{line: 329, col: 14, offset: 10358},
																	expr: &litMatcher{
																		pos:        position{line: 329, col: 14, offset: 10358},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&labeledExpr{
																	pos:   position{line: 329, col: 19, offset: 10363},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 773, col: 14, offset: 23557},
																		alternatives: []any{
																			&actionExpr{
																				pos: position{line: 773, col: 14, offset: 23557},
																				run: (*parser).callonBlock15,
																				expr: &labeledExpr{
																					pos:   position{line: 773, col: 14, offset: 23557},
																					label: "identI",
																					expr: &choiceExpr{
																						pos: position{line: 759, col: 10, offset: 23002},
																						alternatives: []any{
																							&actionExpr{
																								pos: position{line: 759, col: 10, offset: 23002},
																								run: (*parser).callonBlock18,
																								expr: &labeledExpr{
																									pos:   position{line: 759, col: 10, offset: 23002},
																									label: "identI",
																									expr: &seqExpr{
																										pos: position{line: 2410, col: 17, offset: 81833},
																										exprs: []any{
																											&charClassMatcher{
																												pos:        position{line: 2393, col: 20, offset: 81588},
																												val:        "[_\\pL]",
																												chars:      []rune{'_'},
																												classes:    []*unicode.RangeTable{rangeTable("L")},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&zeroOrMoreExpr{
																												pos: position{line: 2410, col: 26, offset: 81842},
																												expr: &charClassMatcher{
																													pos:        position{line: 2393, col: 20, offset: 81588},
																													val:        "[_\\pL\\pNd]",
																													chars:      []rune{'_'},
																													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 761, col: 5, offset: 23096},
																								run: (*parser).callonBlock24,
																								expr: &seqExpr{
																									pos: position{line: 761, col: 5, offset: 23096},
																									exprs: []any{
																										&labeledExpr{
																											pos:   position{line: 761, col: 5, offset: 23096},
																											label: "identI",
																											expr: &seqExpr{
																												pos: position{line: 761, col: 13, offset: 23104},
																												exprs: []any{
																													&zeroOrOneExpr{
																														pos: position{line: 761, col: 13, offset: 23104},
																														expr: &litMatcher{
																															pos:        position{line: 761, col: 13, offset: 23104},
																															val:        "$",
																															ignoreCase: false,
																															want:       "\"$\"",
																														},
																													},
																													&oneOrMoreExpr{
																														pos: position{line: 761, col: 18, offset: 23109},
																														expr: &choiceExpr{
																															pos: position{line: 761, col: 19, offset: 23110},
																															alternatives: []any{
																																&seqExpr{
																																	pos: position{line: 761, col: 19, offset: 23110},
																																	exprs: []any{
																																		&charClassMatcher{
																																			pos:        position{line: 761, col: 19, offset: 23110},
																																			val:        "[\\pNd]",
																																			classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 761, col: 28, offset: 23119},
																																			val:        "[_-\\pL]",
																																			chars:      []rune{'_', '-'},
																																			classes:    []*unicode.RangeTable{rangeTable("L")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 761, col: 38, offset: 23129},
																																	val:        "[_-\\pL]",
																																	chars:      []rune{'_', '-'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&labeledExpr{
																											pos:   position{line: 761, col: 49, offset: 23140},
																											label: "endPosI",
																											expr: &actionExpr{
																												pos: position{line: 3799, col: 8, offset: 129205},
																												run: (*parser).callonBlock37,
																												expr: &choiceExpr{
																													pos: position{line: 3799, col: 9, offset: 129206},
																													alternatives: []any{
																														&andExpr{
																															pos: position{line: 3799, col: 9, offset: 129206},
																															expr: &anyMatcher{
																																line: 3799, col: 10, offset: 129207,
																															},
																														},
																														&notExpr{
																															pos: position{line: 3799, col: 14, offset: 129211},
																															expr: &anyMatcher{
																																line: 3799, col: 15, offset: 129212,
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 775, col: 5, offset: 23599},
																				run: (*parser).callonBlock43,
																				expr: &seqExpr{
																					pos: position{line: 775, col: 5, offset: 23599},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 775, col: 5, offset: 23599},
																							label: "posI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonBlock46,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																						&andExpr{
																							pos: position{line: 775, col: 14, offset: 23608},
																							expr: &choiceExpr{
																								pos: position{line: 775, col: 16, offset: 23610},
																								alternatives: []any{
																									&seqExpr{
																										pos: position{line: 3796, col: 12, offset: 129156},
																										exprs: []any{
																											&zeroOrMoreExpr{
																												pos: position{line: 3796, col: 12, offset: 129156},
																												expr: &charClassMatcher{
																													pos:        position{line: 3808, col: 36, offset: 129503},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&choiceExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												alternatives: []any{
																													&seqExpr{
																														pos: position{line: 3796, col: 16, offset: 129160},
																														exprs: []any{
																															&zeroOrOneExpr{
																																pos: position{line: 3796, col: 16, offset: 129160},
																																expr: &litMatcher{
																																	pos:        position{line: 3796, col: 16, offset: 129160},
																																	val:        "\r",
																																	ignoreCase: false,
																																	want:       "\"\\r\"",
																																},
																															},
																															&litMatcher{
																																pos:        position{line: 3796, col: 22, offset: 129166},
																																val:        "\n",
																																ignoreCase: false,
																																want:       "\"\\n\"",
																															},
																														},
																													},
																													&notExpr{
																														pos: position{line: 3795, col: 12, offset: 129142},
																														expr: &anyMatcher{
																															line: 3795, col: 13, offset: 129143,
																														},
																													},
																												},
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 775, col: 22, offset: 23616},
																										val:        "[:!=()]",
																										chars:      []rune{':', '!', '=', '(', ')'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 786, col: 5, offset: 23948},
																				run: (*parser).callonBlock65,
																				expr: &seqExpr{
																					pos: position{line: 786, col: 5, offset: 23948},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 786, col: 5, offset: 23948},
																							label: "identI",
																							expr: &oneOrMoreExpr{
																								pos: position{line: 786, col: 12, offset: 23955},
																								expr: &charClassMatcher{
																									pos:        position{line: 786, col: 12, offset: 23955},
																									val:        "[^ \\t\\r\\n:!=()]",
																									chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 786, col: 29, offset: 23972},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonBlock71,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 331, col: 5, offset: 10409},
														run: (*parser).callonBlock77,
														expr: &andExpr{
															pos: position{line: 331, col: 5, offset: 10409},
															expr: &seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 283, col: 32, offset: 9207},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 283, col: 38, offset: 9213},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineBlock",
			pos:  position{line: 288, col: 1, offset: 9315},
			expr: &actionExpr{
				pos: position{line: 288, col: 16, offset: 9330},
				run: (*parser).callonInlineBlock1,
				expr: &seqExpr{
					pos: position{line: 288, col: 16, offset: 9330},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 288, col: 16, offset: 9330},
							label: "blockI",
							expr: &actionExpr{
								pos: position{line: 304, col: 19, offset: 9777},
								run: (*parser).callonInlineBlock4,
								expr: &seqExpr{
									pos: position{line: 304, col: 19, offset: 9777},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 304, col: 19, offset: 9777},
											val:        "block",
											ignoreCase: false,
											want:       "\"block\"",
										},
										&labeledExpr{
											pos:   position{line: 304, col: 27, offset: 9785},
											label: "nameI",
											expr: &choiceExpr{
												pos: position{line: 329, col: 14, offset: 10358},
												alternatives: []any{
													&actionExpr{
														pos: position{line: 329, col: 14, offset: 10358},
														run: (*parser).callonInlineBlock9,
														expr: &seqExpr{
															pos: position{line: 329, col: 14, offset: 10358},
															exprs: []any{
																&oneOrMoreExpr{
																	pos: position{line: 329, col: 14, offset: 10358},
																	expr: &litMatcher{
																		pos:        position{line: 329, col: 14, offset: 10358},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&labeledExpr{
																	pos:   position{line: 329, col: 19, offset: 10363},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 773, col: 14, offset: 23557},
																		alternatives: []any{
																			&actionExpr{
																				pos: position{line: 773, col: 14, offset: 23557},
																				run: (*parser).callonInlineBlock15,
																				expr: &labeledExpr{
																					pos:   position{line: 773, col: 14, offset: 23557},
																					label: "identI",
																					expr: &choiceExpr{
																						pos: position{line: 759, col: 10, offset: 23002},
																						alternatives: []any{
																							&actionExpr{
																								pos: position{line: 759, col: 10, offset: 23002},
																								run: (*parser).callonInlineBlock18,
																								expr: &labeledExpr{
																									pos:   position{line: 759, col: 10, offset: 23002},
																									label: "identI",
																									expr: &seqExpr{
																										pos: position{line: 2410, col: 17, offset: 81833},
																										exprs: []any{
																											&charClassMatcher{
																												pos:        position{line: 2393, col: 20, offset: 81588},
																												val:        "[_\\pL]",
																												chars:      []rune{'_'},
																												classes:    []*unicode.RangeTable{rangeTable("L")},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&zeroOrMoreExpr{
																												pos: position{line: 2410, col: 26, offset: 81842},
																												expr: &charClassMatcher{
																													pos:        position{line: 2393, col: 20, offset: 81588},
																													val:        "[_\\pL\\pNd]",
																													chars:      []rune{'_'},
																													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 761, col: 5, offset: 23096},
																								run: (*parser).callonInlineBlock24,
																								expr: &seqExpr{
																									pos: position{line: 761, col: 5, offset: 23096},
																									exprs: []any{
																										&labeledExpr{
																											pos:   position{line: 761, col: 5, offset: 23096},
																											label: "identI",
																											expr: &seqExpr{
																												pos: position{line: 761, col: 13, offset: 23104},
																												exprs: []any{
																													&zeroOrOneExpr{
																														pos: position{line: 761, col: 13, offset: 23104},
																														expr: &litMatcher{
																															pos:        position{line: 761, col: 13, offset: 23104},
																															val:        "$",
																															ignoreCase: false,
																															want:       "\"$\"",
																														},
																													},
																													&oneOrMoreExpr{
																														pos: position{line: 761, col: 18, offset: 23109},
																														expr: &choiceExpr{
																															pos: position{line: 761, col: 19, offset: 23110},
																															alternatives: []any{
																																&seqExpr{
																																	pos: position{line: 761, col: 19, offset: 23110},
																																	exprs: []any{
																																		&charClassMatcher{
																																			pos:        position{line: 761, col: 19, offset: 23110},
																																			val:        "[\\pNd]",
																																			classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 761, col: 28, offset: 23119},
																																			val:        "[_-\\pL]",
																																			chars:      []rune{'_', '-'},
																																			classes:    []*unicode.RangeTable{rangeTable("L")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 761, col: 38, offset: 23129},
																																	val:        "[_-\\pL]",
																																	chars:      []rune{'_', '-'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&labeledExpr{
																											pos:   position{line: 761, col: 49, offset: 23140},
																											label: "endPosI",
																											expr: &actionExpr{
																												pos: position{line: 3799, col: 8, offset: 129205},
																												run: (*parser).callonInlineBlock37,
																												expr: &choiceExpr{
																													pos: position{line: 3799, col: 9, offset: 129206},
																													alternatives: []any{
																														&andExpr{
																															pos: position{line: 3799, col: 9, offset: 129206},
																															expr: &anyMatcher{
																																line: 3799, col: 10, offset: 129207,
																															},
																														},
																														&notExpr{
																															pos: position{line: 3799, col: 14, offset: 129211},
																															expr: &anyMatcher{
																																line: 3799, col: 15, offset: 129212,
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 775, col: 5, offset: 23599},
																				run: (*parser).callonInlineBlock43,
																				expr: &seqExpr{
																					pos: position{line: 775, col: 5, offset: 23599},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 775, col: 5, offset: 23599},
																							label: "posI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonInlineBlock46,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																						&andExpr{
																							pos: position{line: 775, col: 14, offset: 23608},
																							expr: &choiceExpr{
																								pos: position{line: 775, col: 16, offset: 23610},
																								alternatives: []any{
																									&seqExpr{
																										pos: position{line: 3796, col: 12, offset: 129156},
																										exprs: []any{
																											&zeroOrMoreExpr{
																												pos: position{line: 3796, col: 12, offset: 129156},
																												expr: &charClassMatcher{
																													pos:        position{line: 3808, col: 36, offset: 129503},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&choiceExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												alternatives: []any{
																													&seqExpr{
																														pos: position{line: 3796, col: 16, offset: 129160},
																														exprs: []any{
																															&zeroOrOneExpr{
																																pos: position{line: 3796, col: 16, offset: 129160},
																																expr: &litMatcher{
																																	pos:        position{line: 3796, col: 16, offset: 129160},
																																	val:        "\r",
																																	ignoreCase: false,
																																	want:       "\"\\r\"",
																																},
																															},
																															&litMatcher{
																																pos:        position{line: 3796, col: 22, offset: 129166},
																																val:        "\n",
																																ignoreCase: false,
																																want:       "\"\\n\"",
																															},
																														},
																													},
																													&notExpr{
																														pos: position{line: 3795, col: 12, offset: 129142},
																														expr: &anyMatcher{
																															line: 3795, col: 13, offset: 129143,
																														},
																													},
																												},
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 775, col: 22, offset: 23616},
																										val:        "[:!=()]",
																										chars:      []rune{':', '!', '=', '(', ')'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 786, col: 5, offset: 23948},
																				run: (*parser).callonInlineBlock65,
																				expr: &seqExpr{
																					pos: position{line: 786, col: 5, offset: 23948},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 786, col: 5, offset: 23948},
																							label: "identI",
																							expr: &oneOrMoreExpr{
																								pos: position{line: 786, col: 12, offset: 23955},
																								expr: &charClassMatcher{
																									pos:        position{line: 786, col: 12, offset: 23955},
																									val:        "[^ \\t\\r\\n:!=()]",
																									chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 786, col: 29, offset: 23972},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonInlineBlock71,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 331, col: 5, offset: 10409},
														run: (*parser).callonInlineBlock77,
														expr: &andExpr{
															pos: position{line: 331, col: 5, offset: 10409},
															expr: &seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 288, col: 38, offset: 9352},
							label: "scopeI",
							expr: &ruleRefExpr{
								pos:  position{line: 288, col: 45, offset: 9359},
								name: "Beait",
							},
						},
					},
				},
			},
		},
		{
			name: "Prepend",
			pos:  position{line: 293, col: 1, offset: 9474},
			expr: &actionExpr{
				pos: position{line: 293, col: 12, offset: 9485},
				run: (*parser).callonPrepend1,
				expr: &seqExpr{
					pos: position{line: 293, col: 12, offset: 9485},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 293, col: 12, offset: 9485},
							label: "blockI",
							expr: &actionExpr{
								pos: position{line: 312, col: 21, offset: 9971},
								run: (*parser).callonPrepend4,
								expr: &seqExpr{
									pos: position{line: 312, col: 21, offset: 9971},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 312, col: 21, offset: 9971},
											val:        "prepend",
											ignoreCase: false,
											want:       "\"prepend\"",
										},
										&labeledExpr{
											pos:   position{line: 312, col: 31, offset: 9981},
											label: "nameI",
											expr: &choiceExpr{
												pos: position{line: 329, col: 14, offset: 10358},
												alternatives: []any{
													&actionExpr{
														pos: position{line: 329, col: 14, offset: 10358},
														run: (*parser).callonPrepend9,
														expr: &seqExpr{
															pos: position{line: 329, col: 14, offset: 10358},
															exprs: []any{
																&oneOrMoreExpr{
																	pos: position{line: 329, col: 14, offset: 10358},
																	expr: &litMatcher{
																		pos:        position{line: 329, col: 14, offset: 10358},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&labeledExpr{
																	pos:   position{line: 329, col: 19, offset: 10363},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 773, col: 14, offset: 23557},
																		alternatives: []any{
																			&actionExpr{
																				pos: position{line: 773, col: 14, offset: 23557},
																				run: (*parser).callonPrepend15,
																				expr: &labeledExpr{
																					pos:   position{line: 773, col: 14, offset: 23557},
																					label: "identI",
																					expr: &choiceExpr{
																						pos: position{line: 759, col: 10, offset: 23002},
																						alternatives: []any{
																							&actionExpr{
																								pos: position{line: 759, col: 10, offset: 23002},
																								run: (*parser).callonPrepend18,
																								expr: &labeledExpr{
																									pos:   position{line: 759, col: 10, offset: 23002},
																									label: "identI",
																									expr: &seqExpr{
																										pos: position{line: 2410, col: 17, offset: 81833},
																										exprs: []any{
																											&charClassMatcher{
																												pos:        position{line: 2393, col: 20, offset: 81588},
																												val:        "[_\\pL]",
																												chars:      []rune{'_'},
																												classes:    []*unicode.RangeTable{rangeTable("L")},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&zeroOrMoreExpr{
																												pos: position{line: 2410, col: 26, offset: 81842},
																												expr: &charClassMatcher{
																													pos:        position{line: 2393, col: 20, offset: 81588},
																													val:        "[_\\pL\\pNd]",
																													chars:      []rune{'_'},
																													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 761, col: 5, offset: 23096},
																								run: (*parser).callonPrepend24,
																								expr: &seqExpr{
																									pos: position{line: 761, col: 5, offset: 23096},
																									exprs: []any{
																										&labeledExpr{
																											pos:   position{line: 761, col: 5, offset: 23096},
																											label: "identI",
																											expr: &seqExpr{
																												pos: position{line: 761, col: 13, offset: 23104},
																												exprs: []any{
																													&zeroOrOneExpr{
																														pos: position{line: 761, col: 13, offset: 23104},
																														expr: &litMatcher{
																															pos:        position{line: 761, col: 13, offset: 23104},
																															val:        "$",
																															ignoreCase: false,
																															want:       "\"$\"",
																														},
																													},
																													&oneOrMoreExpr{
																														pos: position{line: 761, col: 18, offset: 23109},
																														expr: &choiceExpr{
																															pos: position{line: 761, col: 19, offset: 23110},
																															alternatives: []any{
																																&seqExpr{
																																	pos: position{line: 761, col: 19, offset: 23110},
																																	exprs: []any{
																																		&charClassMatcher{
																																			pos:        position{line: 761, col: 19, offset: 23110},
																																			val:        "[\\pNd]",
																																			classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 761, col: 28, offset: 23119},
																																			val:        "[_-\\pL]",
																																			chars:      []rune{'_', '-'},
																																			classes:    []*unicode.RangeTable{rangeTable("L")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 761, col: 38, offset: 23129},
																																	val:        "[_-\\pL]",
																																	chars:      []rune{'_', '-'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&labeledExpr{
																											pos:   position{line: 761, col: 49, offset: 23140},
																											label: "endPosI",
																											expr: &actionExpr{
																												pos: position{line: 3799, col: 8, offset: 129205},
																												run: (*parser).callonPrepend37,
																												expr: &choiceExpr{
																													pos: position{line: 3799, col: 9, offset: 129206},
																													alternatives: []any{
																														&andExpr{
																															pos: position{line: 3799, col: 9, offset: 129206},
																															expr: &anyMatcher{
																																line: 3799, col: 10, offset: 129207,
																															},
																														},
																														&notExpr{
																															pos: position{line: 3799, col: 14, offset: 129211},
																															expr: &anyMatcher{
																																line: 3799, col: 15, offset: 129212,
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 775, col: 5, offset: 23599},
																				run: (*parser).callonPrepend43,
																				expr: &seqExpr{
																					pos: position{line: 775, col: 5, offset: 23599},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 775, col: 5, offset: 23599},
																							label: "posI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonPrepend46,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																						&andExpr{
																							pos: position{line: 775, col: 14, offset: 23608},
																							expr: &choiceExpr{
																								pos: position{line: 775, col: 16, offset: 23610},
																								alternatives: []any{
																									&seqExpr{
																										pos: position{line: 3796, col: 12, offset: 129156},
																										exprs: []any{
																											&zeroOrMoreExpr{
																												pos: position{line: 3796, col: 12, offset: 129156},
																												expr: &charClassMatcher{
																													pos:        position{line: 3808, col: 36, offset: 129503},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&choiceExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												alternatives: []any{
																													&seqExpr{
																														pos: position{line: 3796, col: 16, offset: 129160},
																														exprs: []any{
																															&zeroOrOneExpr{
																																pos: position{line: 3796, col: 16, offset: 129160},
																																expr: &litMatcher{
																																	pos:        position{line: 3796, col: 16, offset: 129160},
																																	val:        "\r",
																																	ignoreCase: false,
																																	want:       "\"\\r\"",
																																},
																															},
																															&litMatcher{
																																pos:        position{line: 3796, col: 22, offset: 129166},
																																val:        "\n",
																																ignoreCase: false,
																																want:       "\"\\n\"",
																															},
																														},
																													},
																													&notExpr{
																														pos: position{line: 3795, col: 12, offset: 129142},
																														expr: &anyMatcher{
																															line: 3795, col: 13, offset: 129143,
																														},
																													},
																												},
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 775, col: 22, offset: 23616},
																										val:        "[:!=()]",
																										chars:      []rune{':', '!', '=', '(', ')'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 786, col: 5, offset: 23948},
																				run: (*parser).callonPrepend65,
																				expr: &seqExpr{
																					pos: position{line: 786, col: 5, offset: 23948},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 786, col: 5, offset: 23948},
																							label: "identI",
																							expr: &oneOrMoreExpr{
																								pos: position{line: 786, col: 12, offset: 23955},
																								expr: &charClassMatcher{
																									pos:        position{line: 786, col: 12, offset: 23955},
																									val:        "[^ \\t\\r\\n:!=()]",
																									chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 786, col: 29, offset: 23972},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonPrepend71,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 331, col: 5, offset: 10409},
														run: (*parser).callonPrepend77,
														expr: &andExpr{
															pos: position{line: 331, col: 5, offset: 10409},
															expr: &seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 293, col: 36, offset: 9509},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 293, col: 42, offset: 9515},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "Append",
			pos:  position{line: 298, col: 1, offset: 9617},
			expr: &actionExpr{
				pos: position{line: 298, col: 11, offset: 9627},
				run: (*parser).callonAppend1,
				expr: &seqExpr{
					pos: position{line: 298, col: 11, offset: 9627},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 298, col: 11, offset: 9627},
							label: "blockI",
							expr: &actionExpr{
								pos: position{line: 320, col: 20, offset: 10168},
								run: (*parser).callonAppend4,
								expr: &seqExpr{
									pos: position{line: 320, col: 20, offset: 10168},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 320, col: 20, offset: 10168},
											val:        "append",
											ignoreCase: false,
											want:       "\"append\"",
										},
										&labeledExpr{
											pos:   position{line: 320, col: 29, offset: 10177},
											label: "nameI",
											expr: &choiceExpr{
												pos: position{line: 329, col: 14, offset: 10358},
												alternatives: []any{
													&actionExpr{
														pos: position{line: 329, col: 14, offset: 10358},
														run: (*parser).callonAppend9,
														expr: &seqExpr{
															pos: position{line: 329, col: 14, offset: 10358},
															exprs: []any{
																&oneOrMoreExpr{
																	pos: position{line: 329, col: 14, offset: 10358},
																	expr: &litMatcher{
																		pos:        position{line: 329, col: 14, offset: 10358},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&labeledExpr{
																	pos:   position{line: 329, col: 19, offset: 10363},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 773, col: 14, offset: 23557},
																		alternatives: []any{
																			&actionExpr{
																				pos: position{line: 773, col: 14, offset: 23557},
																				run: (*parser).callonAppend15,
																				expr: &labeledExpr{
																					pos:   position{line: 773, col: 14, offset: 23557},
																					label: "identI",
																					expr: &choiceExpr{
																						pos: position{line: 759, col: 10, offset: 23002},
																						alternatives: []any{
																							&actionExpr{
																								pos: position{line: 759, col: 10, offset: 23002},
																								run: (*parser).callonAppend18,
																								expr: &labeledExpr{
																									pos:   position{line: 759, col: 10, offset: 23002},
																									label: "identI",
																									expr: &seqExpr{
																										pos: position{line: 2410, col: 17, offset: 81833},
																										exprs: []any{
																											&charClassMatcher{
																												pos:        position{line: 2393, col: 20, offset: 81588},
																												val:        "[_\\pL]",
																												chars:      []rune{'_'},
																												classes:    []*unicode.RangeTable{rangeTable("L")},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&zeroOrMoreExpr{
																												pos: position{line: 2410, col: 26, offset: 81842},
																												expr: &charClassMatcher{
																													pos:        position{line: 2393, col: 20, offset: 81588},
																													val:        "[_\\pL\\pNd]",
																													chars:      []rune{'_'},
																													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 761, col: 5, offset: 23096},
																								run: (*parser).callonAppend24,
																								expr: &seqExpr{
																									pos: position{line: 761, col: 5, offset: 23096},
																									exprs: []any{
																										&labeledExpr{
																											pos:   position{line: 761, col: 5, offset: 23096},
																											label: "identI",
																											expr: &seqExpr{
																												pos: position{line: 761, col: 13, offset: 23104},
																												exprs: []any{
																													&zeroOrOneExpr{
																														pos: position{line: 761, col: 13, offset: 23104},
																														expr: &litMatcher{
																															pos:        position{line: 761, col: 13, offset: 23104},
																															val:        "$",
																															ignoreCase: false,
																															want:       "\"$\"",
																														},
																													},
																													&oneOrMoreExpr{
																														pos: position{line: 761, col: 18, offset: 23109},
																														expr: &choiceExpr{
																															pos: position{line: 761, col: 19, offset: 23110},
																															alternatives: []any{
																																&seqExpr{
																																	pos: position{line: 761, col: 19, offset: 23110},
																																	exprs: []any{
																																		&charClassMatcher{
																																			pos:        position{line: 761, col: 19, offset: 23110},
																																			val:        "[\\pNd]",
																																			classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 761, col: 28, offset: 23119},
																																			val:        "[_-\\pL]",
																																			chars:      []rune{'_', '-'},
																																			classes:    []*unicode.RangeTable{rangeTable("L")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 761, col: 38, offset: 23129},
																																	val:        "[_-\\pL]",
																																	chars:      []rune{'_', '-'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&labeledExpr{
																											pos:   position{line: 761, col: 49, offset: 23140},
																											label: "endPosI",
																											expr: &actionExpr{
																												pos: position{line: 3799, col: 8, offset: 129205},
																												run: (*parser).callonAppend37,
																												expr: &choiceExpr{
																													pos: position{line: 3799, col: 9, offset: 129206},
																													alternatives: []any{
																														&andExpr{
																															pos: position{line: 3799, col: 9, offset: 129206},
																															expr: &anyMatcher{
																																line: 3799, col: 10, offset: 129207,
																															},
																														},
																														&notExpr{
																															pos: position{line: 3799, col: 14, offset: 129211},
																															expr: &anyMatcher{
																																line: 3799, col: 15, offset: 129212,
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 775, col: 5, offset: 23599},
																				run: (*parser).callonAppend43,
																				expr: &seqExpr{
																					pos: position{line: 775, col: 5, offset: 23599},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 775, col: 5, offset: 23599},
																							label: "posI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonAppend46,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																						&andExpr{
																							pos: position{line: 775, col: 14, offset: 23608},
																							expr: &choiceExpr{
																								pos: position{line: 775, col: 16, offset: 23610},
																								alternatives: []any{
																									&seqExpr{
																										pos: position{line: 3796, col: 12, offset: 129156},
																										exprs: []any{
																											&zeroOrMoreExpr{
																												pos: position{line: 3796, col: 12, offset: 129156},
																												expr: &charClassMatcher{
																													pos:        position{line: 3808, col: 36, offset: 129503},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&choiceExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												alternatives: []any{
																													&seqExpr{
																														pos: position{line: 3796, col: 16, offset: 129160},
																														exprs: []any{
																															&zeroOrOneExpr{
																																pos: position{line: 3796, col: 16, offset: 129160},
																																expr: &litMatcher{
																																	pos:        position{line: 3796, col: 16, offset: 129160},
																																	val:        "\r",
																																	ignoreCase: false,
																																	want:       "\"\\r\"",
																																},
																															},
																															&litMatcher{
																																pos:        position{line: 3796, col: 22, offset: 129166},
																																val:        "\n",
																																ignoreCase: false,
																																want:       "\"\\n\"",
																															},
																														},
																													},
																													&notExpr{
																														pos: position{line: 3795, col: 12, offset: 129142},
																														expr: &anyMatcher{
																															line: 3795, col: 13, offset: 129143,
																														},
																													},
																												},
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 775, col: 22, offset: 23616},
																										val:        "[:!=()]",
																										chars:      []rune{':', '!', '=', '(', ')'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 786, col: 5, offset: 23948},
																				run: (*parser).callonAppend65,
																				expr: &seqExpr{
																					pos: position{line: 786, col: 5, offset: 23948},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 786, col: 5, offset: 23948},
																							label: "identI",
																							expr: &oneOrMoreExpr{
																								pos: position{line: 786, col: 12, offset: 23955},
																								expr: &charClassMatcher{
																									pos:        position{line: 786, col: 12, offset: 23955},
																									val:        "[^ \\t\\r\\n:!=()]",
																									chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 786, col: 29, offset: 23972},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonAppend71,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 331, col: 5, offset: 10409},
														run: (*parser).callonAppend77,
														expr: &andExpr{
															pos: position{line: 331, col: 5, offset: 10409},
															expr: &seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 298, col: 34, offset: 9650},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 298, col: 40, offset: 9656},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "BlockExpansion",
			pos:  position{line: 346, col: 1, offset: 10856},
			expr: &actionExpr{
				pos: position{line: 346, col: 19, offset: 10874},
				run: (*parser).callonBlockExpansion1,
				expr: &seqExpr{
					pos: position{line: 346, col: 19, offset: 10874},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 346, col: 19, offset: 10874},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&labeledExpr{
							pos:   position{line: 346, col: 23, offset: 10878},
							label: "sI",
							expr: &ruleRefExpr{
								pos:  position{line: 346, col: 26, offset: 10881},
								name: "blockExpansionItem",
							},
						},
					},
				},
			},
		},
		{
			name: "blockExpansionItem",
			pos:  position{line: 353, col: 1, offset: 11009},
			expr: &choiceExpr{
				pos: position{line: 353, col: 23, offset: 11031},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 353, col: 23, offset: 11031},
						name: "InlineArrowBlock",
					},
					&ruleRefExpr{
						pos:  position{line: 353, col: 42, offset: 11050},
						name: "spacedBlockExpansionItem",
					},
					&actionExpr{
						pos: position{line: 399, col: 22, offset: 12405},
						run: (*parser).callonblockExpansionItem4,
						expr: &seqExpr{
							pos: position{line: 399, col: 22, offset: 12405},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 399, col: 22, offset: 12405},
									label: "lineI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 399, col: 28, offset: 12411},
										expr: &charClassMatcher{
											pos:        position{line: 3797, col: 12, offset: 129189},
											val:        "[^\\r\\n]",
											chars:      []rune{'\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "spacedBlockExpansionItem",
			pos:  position{line: 355, col: 1, offset: 11096},
			expr: &choiceExpr{
				pos: position{line: 355, col: 29, offset: 11124},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 355, col: 29, offset: 11124},
						run: (*parser).callonspacedBlockExpansionItem2,
						expr: &seqExpr{
							pos: position{line: 355, col: 29, offset: 11124},
							exprs: []any{
								&oneOrMoreExpr{
									pos: position{line: 355, col: 29, offset: 11124},
									expr: &litMatcher{
										pos:        position{line: 355, col: 29, offset: 11124},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 355, col: 34, offset: 11129},
									label: "sI",
									expr: &ruleRefExpr{
										pos:  position{line: 355, col: 37, offset: 11132},
										name: "_spacedBlockExpansionItem",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 357, col: 5, offset: 11183},
						run: (*parser).callonspacedBlockExpansionItem8,
						expr: &seqExpr{
							pos: position{line: 357, col: 5, offset: 11183},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 357, col: 5, offset: 11183},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonspacedBlockExpansionItem11,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 357, col: 14, offset: 11192},
									label: "sI",
									expr: &ruleRefExpr{
										pos:  position{line: 357, col: 17, offset: 11195},
										name: "_spacedBlockExpansionItem",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "_spacedBlockExpansionItem",
			pos:  position{line: 395, col: 1, offset: 12158},
			expr: &choiceExpr{
				pos: position{line: 395, col: 30, offset: 12187},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 395, col: 30, offset: 12187},
						name: "InlineBlock",
					},
					&ruleRefExpr{
						pos:  position{line: 395, col: 45, offset: 12202},
						name: "InlineAnd",
					},
					&ruleRefExpr{
						pos:  position{line: 395, col: 57, offset: 12214},
						name: "InlineMixinCall",
					},
					&ruleRefExpr{
						pos:  position{line: 395, col: 75, offset: 12232},
						name: "Return",
					},
					&ruleRefExpr{
						pos:  position{line: 396, col: 30, offset: 12270},
						name: "InlineIf",
					},
					&ruleRefExpr{
						pos:  position{line: 396, col: 41, offset: 12281},
						name: "InlineIfBlock",
					},
					&ruleRefExpr{
						pos:  position{line: 396, col: 57, offset: 12297},
						name: "InlineFor",
					},
					&actionExpr{
						pos: position{line: 2888, col: 12, offset: 99886},
						run: (*parser).callon_spacedBlockExpansionItem9,
						expr: &seqExpr{
							pos: position{line: 2888, col: 12, offset: 99886},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2888, col: 12, offset: 99886},
									val:        "include",
									ignoreCase: false,
									want:       "\"include\"",
								},
								&labeledExpr{
									pos:   position{line: 2888, col: 22, offset: 99896},
									label: "pathI",
									expr: &choiceExpr{
										pos: position{line: 3223, col: 18, offset: 110865},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 3223, col: 18, offset: 110865},
												run: (*parser).callon_spacedBlockExpansionItem14,
												expr: &seqExpr{
													pos: position{line: 3223, col: 18, offset: 110865},
													exprs: []any{
														&oneOrMoreExpr{
															pos: position{line: 3223, col: 18, offset: 110865},
															expr: &litMatcher{
																pos:        position{line: 3223, col: 18, offset: 110865},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&labeledExpr{
															pos:   position{line: 3223, col: 23, offset: 110870},
															label: "sI",
															expr: &choiceExpr{
																pos: position{line: 822, col: 11, offset: 25102},
																alternatives: []any{
																	&actionExpr{
																		pos: position{line: 828, col: 14, offset: 25189},
																		run: (*parser).callon_spacedBlockExpansionItem20,
																		expr: &seqExpr{
																			pos: position{line: 828, col: 14, offset: 25189},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 828, col: 14, offset: 25189},
																					val:        "`",
																					ignoreCase: false,
																					want:       "\"`\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 828, col: 18, offset: 25193},
																					label: "strI",
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 828, col: 23, offset: 25198},
																						expr: &charClassMatcher{
																							pos:        position{line: 2747, col: 27, offset: 94906},
																							val:        "[^\\n`]",
																							chars:      []rune{'\n', '`'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 828, col: 47, offset: 25222},
																					val:        "`",
																					ignoreCase: false,
																					want:       "\"`\"",
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 830, col: 5, offset: 25314},
																		run: (*parser).callon_spacedBlockExpansionItem27,
																		expr: &seqExpr{
																			pos: position{line: 830, col: 5, offset: 25314},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 830, col: 5, offset: 25314},
																					val:        "`",
																					ignoreCase: false,
																					want:       "\"`\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 830, col: 9, offset: 25318},
																					label: "strI",
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 830, col: 14, offset: 25323},
																						expr: &charClassMatcher{
																							pos:        position{line: 2747, col: 27, offset: 94906},
																							val:        "[^\\n`]",
																							chars:      []rune{'\n', '`'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																					},
																				},
																				&andExpr{
																					pos: position{line: 830, col: 38, offset: 25347},
																					expr: &seqExpr{
																						pos: position{line: 3796, col: 12, offset: 129156},
																						exprs: []any{
																							&zeroOrMoreExpr{
																								pos: position{line: 3796, col: 12, offset: 129156},
																								expr: &charClassMatcher{
																									pos:        position{line: 3808, col: 36, offset: 129503},
																									val:        "[ \\t]",
																									chars:      []rune{' ', '\t'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&choiceExpr{
																								pos: position{line: 3796, col: 16, offset: 129160},
																								alternatives: []any{
																									&seqExpr{
																										pos: position{line: 3796, col: 16, offset: 129160},
																										exprs: []any{
																											&zeroOrOneExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												expr: &litMatcher{
																													pos:        position{line: 3796, col: 16, offset: 129160},
																													val:        "\r",
																													ignoreCase: false,
																													want:       "\"\\r\"",
																												},
																											},
																											&litMatcher{
																												pos:        position{line: 3796, col: 22, offset: 129166},
																												val:        "\n",
																												ignoreCase: false,
																												want:       "\"\\n\"",
																											},
																										},
																									},
																									&notExpr{
																										pos: position{line: 3795, col: 12, offset: 129142},
																										expr: &anyMatcher{
																											line: 3795, col: 13, offset: 129143,
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 849, col: 22, offset: 25751},
																		run: (*parser).callon_spacedBlockExpansionItem44,
																		expr: &seqExpr{
																			pos: position{line: 849, col: 22, offset: 25751},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 849, col: 22, offset: 25751},
																					val:        "\"",
																					ignoreCase: false,
																					want:       "\"\\\"\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 849, col: 26, offset: 25755},
																					label: "strI",
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 849, col: 31, offset: 25760},
																						expr: &choiceExpr{
																							pos: position{line: 849, col: 32, offset: 25761},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 2486, col: 24, offset: 84569},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2486, col: 24, offset: 84569},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2487, col: 24, offset: 84636},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2487, col: 24, offset: 84636},
																											val:        "\\x",
																											ignoreCase: false,
																											want:       "\"\\\\x\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2488, col: 5, offset: 84673},
																									run: (*parser).callon_spacedBlockExpansionItem59,
																									expr: &seqExpr{
																										pos: position{line: 2488, col: 5, offset: 84673},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2488, col: 5, offset: 84673},
																												val:        "\\x",
																												ignoreCase: false,
																												want:       "\"\\\\x\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2488, col: 14, offset: 84682},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2488, col: 26, offset: 84694},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2505, col: 19, offset: 85311},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2505, col: 19, offset: 85311},
																											val:        "\\u",
																											ignoreCase: false,
																											want:       "\"\\\\u\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2506, col: 5, offset: 85370},
																									run: (*parser).callon_spacedBlockExpansionItem72,
																									expr: &seqExpr{
																										pos: position{line: 2506, col: 5, offset: 85370},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2506, col: 5, offset: 85370},
																												val:        "\\u",
																												ignoreCase: false,
																												want:       "\"\\\\u\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 14, offset: 85379},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 26, offset: 85391},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 38, offset: 85403},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 50, offset: 85415},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2535, col: 16, offset: 86551},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2535, col: 16, offset: 86551},
																											val:        "\\U",
																											ignoreCase: false,
																											want:       "\"\\\\U\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2536, col: 5, offset: 86654},
																									run: (*parser).callon_spacedBlockExpansionItem93,
																									expr: &seqExpr{
																										pos: position{line: 2536, col: 5, offset: 86654},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2536, col: 5, offset: 86654},
																												val:        "\\U",
																												ignoreCase: false,
																												want:       "\"\\\\U\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 14, offset: 86663},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 26, offset: 86675},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 38, offset: 86687},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 50, offset: 86699},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 62, offset: 86711},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 74, offset: 86723},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 86, offset: 86735},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 98, offset: 86747},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2763, col: 36, offset: 95684},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2763, col: 36, offset: 95684},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2763, col: 41, offset: 95689},
																											val:        "[abfnrtv\\\\\"]",
																											chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 2761, col: 38, offset: 95576},
																									val:        "[^\"\\\\\\n]",
																									chars:      []rune{'"', '\\', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																								&actionExpr{
																									pos: position{line: 2650, col: 37, offset: 91334},
																									run: (*parser).callon_spacedBlockExpansionItem116,
																									expr: &seqExpr{
																										pos: position{line: 2650, col: 37, offset: 91334},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2650, col: 37, offset: 91334},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2674, col: 5, offset: 92351},
																									run: (*parser).callon_spacedBlockExpansionItem127,
																									expr: &seqExpr{
																										pos: position{line: 2674, col: 5, offset: 92351},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2674, col: 5, offset: 92351},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2695, col: 5, offset: 93193},
																									run: (*parser).callon_spacedBlockExpansionItem134,
																									expr: &seqExpr{
																										pos: position{line: 2695, col: 5, offset: 93193},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2695, col: 5, offset: 93193},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2713, col: 5, offset: 93879},
																									run: (*parser).callon_spacedBlockExpansionItem139,
																									expr: &seqExpr{
																										pos: position{line: 2713, col: 5, offset: 93879},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2713, col: 5, offset: 93879},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2713, col: 10, offset: 93884},
																												expr: &charClassMatcher{
																													pos:        position{line: 3797, col: 12, offset: 129189},
																													val:        "[^\\r\\n]",
																													chars:      []rune{'\r', '\n'},
																													ignoreCase: false,
																													inverted:   true,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 849, col: 115, offset: 25844},
																					val:        "\"",
																					ignoreCase: false,
																					want:       "\"\\\"\"",
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 851, col: 5, offset: 25936},
																		run: (*parser).callon_spacedBlockExpansionItem145,
																		expr: &seqExpr{
																			pos: position{line: 851, col: 5, offset: 25936},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 851, col: 5, offset: 25936},
																					val:        "\"",
																					ignoreCase: false,
																					want:       "\"\\\"\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 851, col: 9, offset: 25940},
																					label: "strI",
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 851, col: 14, offset: 25945},
																						expr: &choiceExpr{
																							pos: position{line: 851, col: 15, offset: 25946},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 2486, col: 24, offset: 84569},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2486, col: 24, offset: 84569},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2403, col: 19, offset: 81758},
																											val:        "[0-7]",
																											ranges:     []rune{'0', '7'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2487, col: 24, offset: 84636},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2487, col: 24, offset: 84636},
																											val:        "\\x",
																											ignoreCase: false,
																											want:       "\"\\\\x\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2488, col: 5, offset: 84673},
																									run: (*parser).callon_spacedBlockExpansionItem160,
																									expr: &seqExpr{
																										pos: position{line: 2488, col: 5, offset: 84673},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2488, col: 5, offset: 84673},
																												val:        "\\x",
																												ignoreCase: false,
																												want:       "\"\\\\x\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2488, col: 14, offset: 84682},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2488, col: 26, offset: 84694},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2505, col: 19, offset: 85311},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2505, col: 19, offset: 85311},
																											val:        "\\u",
																											ignoreCase: false,
																											want:       "\"\\\\u\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2506, col: 5, offset: 85370},
																									run: (*parser).callon_spacedBlockExpansionItem173,
																									expr: &seqExpr{
																										pos: position{line: 2506, col: 5, offset: 85370},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2506, col: 5, offset: 85370},
																												val:        "\\u",
																												ignoreCase: false,
																												want:       "\"\\\\u\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 14, offset: 85379},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 26, offset: 85391},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 38, offset: 85403},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2506, col: 50, offset: 85415},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2535, col: 16, offset: 86551},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2535, col: 16, offset: 86551},
																											val:        "\\U",
																											ignoreCase: false,
																											want:       "\"\\\\U\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2536, col: 5, offset: 86654},
																									run: (*parser).callon_spacedBlockExpansionItem194,
																									expr: &seqExpr{
																										pos: position{line: 2536, col: 5, offset: 86654},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2536, col: 5, offset: 86654},
																												val:        "\\U",
																												ignoreCase: false,
																												want:       "\"\\\\U\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 14, offset: 86663},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 26, offset: 86675},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 38, offset: 86687},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 50, offset: 86699},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 62, offset: 86711},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 74, offset: 86723},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 86, offset: 86735},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2536, col: 98, offset: 86747},
																												expr: &charClassMatcher{
																													pos:        position{line: 2404, col: 19, offset: 81782},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																								&seqExpr{
																									pos: position{line: 2763, col: 36, offset: 95684},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2763, col: 36, offset: 95684},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2763, col: 41, offset: 95689},
																											val:        "[abfnrtv\\\\\"]",
																											chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 2761, col: 38, offset: 95576},
																									val:        "[^\"\\\\\\n]",
																									chars:      []rune{'"', '\\', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																								&actionExpr{
																									pos: position{line: 2650, col: 37, offset: 91334},
																									run: (*parser).callon_spacedBlockExpansionItem217,
																									expr: &seqExpr{
																										pos: position{line: 2650, col: 37, offset: 91334},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2650, col: 37, offset: 91334},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2674, col: 5, offset: 92351},
																									run: (*parser).callon_spacedBlockExpansionItem228,
																									expr: &seqExpr{
																										pos: position{line: 2674, col: 5, offset: 92351},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2674, col: 5, offset: 92351},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2695, col: 5, offset: 93193},
																									run: (*parser).callon_spacedBlockExpansionItem235,
																									expr: &seqExpr{
																										pos: position{line: 2695, col: 5, offset: 93193},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2695, col: 5, offset: 93193},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																								&actionExpr{
																									pos: position{line: 2713, col: 5, offset: 93879},
																									run: (*parser).callon_spacedBlockExpansionItem240,
																									expr: &seqExpr{
																										pos: position{line: 2713, col: 5, offset: 93879},
																										exprs: []any{
																											&litMatcher{
																												pos:        position{line: 2713, col: 5, offset: 93879},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&zeroOrOneExpr{
																												pos: position{line: 2713, col: 10, offset: 93884},
																												expr: &charClassMatcher{
																													pos:        position{line: 3797, col: 12, offset: 129189},
																													val:        "[^\\r\\n]",
																													chars:      []rune{'\r', '\n'},
																													ignoreCase: false,
																													inverted:   true,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 851, col: 98, offset: 26029},
																					label: "endPosI",
																					expr: &actionExpr{
																						pos: position{line: 3799, col: 8, offset: 129205},
																						run: (*parser).callon_spacedBlockExpansionItem246,
																						expr: &choiceExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							alternatives: []any{
																								&andExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									expr: &anyMatcher{
																										line: 3799, col: 10, offset: 129207,
																									},
																								},
																								&notExpr{
																									pos: position{line: 3799, col: 14, offset: 129211},
																									expr: &anyMatcher{
																										line: 3799, col: 15, offset: 129212,
																									},
																								},
																							},
																						},
																					},
																				},
																				&andExpr{
																					pos: position{line: 851, col: 110, offset: 26041},
																					expr: &seqExpr{
																						pos: position{line: 3796, col: 12, offset: 129156},
																						exprs: []any{
																							&zeroOrMoreExpr{
																								pos: position{line: 3796, col: 12, offset: 129156},
																								expr: &charClassMatcher{
																									pos:        position{line: 3808, col: 36, offset: 129503},
																									val:        "[ \\t]",
																									chars:      []rune{' ', '\t'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&choiceExpr{
																								pos: position{line: 3796, col: 16, offset: 129160},
																								alternatives: []any{
																									&seqExpr{
																										pos: position{line: 3796, col: 16, offset: 129160},
																										exprs: []any{
																											&zeroOrOneExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												expr: &litMatcher{
																													pos:        position{line: 3796, col: 16, offset: 129160},
																													val:        "\r",
																													ignoreCase: false,
																													want:       "\"\\r\"",
																												},
																											},
																											&litMatcher{
																												pos:        position{line: 3796, col: 22, offset: 129166},
																												val:        "\n",
																												ignoreCase: false,
																												want:       "\"\\n\"",
																											},
																										},
																									},
																									&notExpr{
																										pos: position{line: 3795, col: 12, offset: 129142},
																										expr: &anyMatcher{
																											line: 3795, col: 13, offset: 129143,
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 870, col: 22, offset: 26447},
																		run: (*parser).callon_spacedBlockExpansionItem263,
																		expr: &seqExpr{
																			pos: position{line: 870, col: 22, offset: 26447},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 870, col: 22, offset: 26447},
																					val:        "'",
																					ignoreCase: false,
																					want:       "\"'\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 870, col: 27, offset: 26452},
																					label: "strI",
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 870, col: 32, offset: 26457},
																						expr: &charClassMatcher{
																							pos:        position{line: 870, col: 32, offset: 26457},
																							val:        "[^\\\\r\\n]",
																							chars:      []rune{'\'', '\r', '\n'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 870, col: 42, offset: 26467},
																					val:        "'",
																					ignoreCase: false,
																					want:       "\"'\"",
																				},
																				&labeledExpr{
																					pos:   position{line: 870, col: 47, offset: 26472},
																					label: "endPosI",
																					expr: &actionExpr{
																						pos: position{line: 3799, col: 8, offset: 129205},
																						run: (*parser).callon_spacedBlockExpansionItem271,
																						expr: &choiceExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							alternatives: []any{
																								&andExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									expr: &anyMatcher{
																										line: 3799, col: 10, offset: 129207,
																									},
																								},
																								&notExpr{
																									pos: position{line: 3799, col: 14, offset: 129211},
																									expr: &anyMatcher{
																										line: 3799, col: 15, offset: 129212,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 3225, col: 5, offset: 110905},
												run: (*parser).callon_spacedBlockExpansionItem277,
												expr: &seqExpr{
													pos: position{line: 3225, col: 5, offset: 110905},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 3225, col: 5, offset: 110905},
															expr: &litMatcher{
																pos:        position{line: 3225, col: 5, offset: 110905},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&labeledExpr{
															pos:   position{line: 3225, col: 10, offset: 110910},
															label: "pathI",
															expr: &zeroOrMoreExpr{
																pos: position{line: 3225, col: 16, offset: 110916},
																expr: &charClassMatcher{
																	pos:        position{line: 3797, col: 12, offset: 129189},
																	val:        "[^\\r\\n]",
																	chars:      []rune{'\r', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 397, col: 30, offset: 12348},
						name: "InlineElement",
					},
					&ruleRefExpr{
						pos:  position{line: 397, col: 46, offset: 12364},
						name: "InlineDivShorthand",
					},
				},
			},
		},
		{
			name: "Codes",
			pos:  position{line: 429, col: 1, offset: 13303},
			expr: &actionExpr{
				pos: position{line: 429, col: 10, offset: 13312},
				run: (*parser).callonCodes1,
				expr: &labeledExpr{
					pos:   position{line: 429, col: 10, offset: 13312},
					label: "codesI",
					expr: &oneOrMoreExpr{
						pos: position{line: 429, col: 17, offset: 13319},
						expr: &seqExpr{
							pos: position{line: 429, col: 18, offset: 13320},
							exprs: []any{
								&zeroOrOneExpr{
									pos: position{line: 429, col: 18, offset: 13320},
									expr: &oneOrMoreExpr{
										pos: position{line: 3810, col: 36, offset: 129590},
										expr: &seqExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 3810, col: 37, offset: 129591},
													expr: &charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3809, col: 36, offset: 129544},
													expr: &litMatcher{
														pos:        position{line: 3809, col: 36, offset: 129544},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3809, col: 42, offset: 129550},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 429, col: 27, offset: 13329},
									name: "Code",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Code",
			pos:  position{line: 433, col: 1, offset: 13400},
			expr: &choiceExpr{
				pos: position{line: 433, col: 9, offset: 13408},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 433, col: 9, offset: 13408},
						run: (*parser).callonCode2,
						expr: &seqExpr{
							pos: position{line: 433, col: 9, offset: 13408},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 433, col: 9, offset: 13408},
									val:        "- ",
									ignoreCase: false,
									want:       "\"- \"",
								},
								&labeledExpr{
									pos:   position{line: 433, col: 14, offset: 13413},
									label: "firstLineI",
									expr: &actionExpr{
										pos: position{line: 459, col: 13, offset: 14243},
										run: (*parser).callonCode6,
										expr: &seqExpr{
											pos: position{line: 459, col: 13, offset: 14243},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 459, col: 13, offset: 14243},
													label: "code",
													expr: &oneOrMoreExpr{
														pos: position{line: 459, col: 18, offset: 14248},
														expr: &charClassMatcher{
															pos:        position{line: 3797, col: 12, offset: 129189},
															val:        "[^\\r\\n]",
															chars:      []rune{'\r', '\n'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&zeroOrMoreExpr{
													pos: position{line: 3796, col: 12, offset: 129156},
													expr: &charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&choiceExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													alternatives: []any{
														&seqExpr{
															pos: position{line: 3796, col: 16, offset: 129160},
															exprs: []any{
																&zeroOrOneExpr{
																	pos: position{line: 3796, col: 16, offset: 129160},
																	expr: &litMatcher{
																		pos:        position{line: 3796, col: 16, offset: 129160},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3796, col: 22, offset: 129166},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
														&notExpr{
															pos: position{line: 3795, col: 12, offset: 129142},
															expr: &anyMatcher{
																line: 3795, col: 13, offset: 129143,
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 433, col: 34, offset: 13433},
									label: "additionalLinesI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 433, col: 51, offset: 13450},
										expr: &seqExpr{
											pos: position{line: 433, col: 52, offset: 13451},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 433, col: 52, offset: 13451},
													expr: &oneOrMoreExpr{
														pos: position{line: 3810, col: 36, offset: 129590},
														expr: &seqExpr{
															pos: position{line: 3810, col: 37, offset: 129591},
															exprs: []any{
																&zeroOrMoreExpr{
																	pos: position{line: 3810, col: 37, offset: 129591},
																	expr: &charClassMatcher{
																		pos:        position{line: 3808, col: 36, offset: 129503},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 3809, col: 36, offset: 129544},
																	expr: &litMatcher{
																		pos:        position{line: 3809, col: 36, offset: 129544},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3809, col: 42, offset: 129550},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
												&ruleRefExpr{
													pos:  position{line: 433, col: 61, offset: 13460},
													name: "INDENTATION2",
												},
												&actionExpr{
													pos: position{line: 459, col: 13, offset: 14243},
													run: (*parser).callonCode32,
													expr: &seqExpr{
														pos: position{line: 459, col: 13, offset: 14243},
														exprs: []any{
															&labeledExpr{
																pos:   position{line: 459, col: 13, offset: 14243},
																label: "code",
																expr: &oneOrMoreExpr{
																	pos: position{line: 459, col: 18, offset: 14248},
																	expr: &charClassMatcher{
																		pos:        position{line: 3797, col: 12, offset: 129189},
																		val:        "[^\\r\\n]",
																		chars:      []rune{'\r', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																},
															},
															&zeroOrMoreExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																expr: &charClassMatcher{
																	pos:        position{line: 3808, col: 36, offset: 129503},
																	val:        "[ \\t]",
																	chars:      []rune{' ', '\t'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&choiceExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																alternatives: []any{
																	&seqExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		exprs: []any{
																			&zeroOrOneExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				expr: &litMatcher{
																					pos:        position{line: 3796, col: 16, offset: 129160},
																					val:        "\r",
																					ignoreCase: false,
																					want:       "\"\\r\"",
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 3796, col: 22, offset: 129166},
																				val:        "\n",
																				ignoreCase: false,
																				want:       "\"\\n\"",
																			},
																		},
																	},
																	&notExpr{
																		pos: position{line: 3795, col: 12, offset: 129142},
																		expr: &anyMatcher{
																			line: 3795, col: 13, offset: 129143,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 446, col: 5, offset: 13837},
						run: (*parser).callonCode46,
						expr: &seqExpr{
							pos: position{line: 446, col: 5, offset: 13837},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 446, col: 5, offset: 13837},
									val:        "-",
									ignoreCase: false,
									want:       "\"-\"",
								},
								&labeledExpr{
									pos:   position{line: 446, col: 9, offset: 13841},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonCode50,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "condition",
			pos:  position{line: 463, col: 1, offset: 14334},
			expr: &choiceExpr{
				pos: position{line: 463, col: 14, offset: 14347},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 463, col: 14, offset: 14347},
						run: (*parser).calloncondition2,
						expr: &seqExpr{
							pos: position{line: 463, col: 14, offset: 14347},
							exprs: []any{
								&oneOrMoreExpr{
									pos: position{line: 463, col: 14, offset: 14347},
									expr: &litMatcher{
										pos:        position{line: 463, col: 14, offset: 14347},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 463, col: 19, offset: 14352},
									label: "condI",
									expr: &ruleRefExpr{
										pos:  position{line: 463, col: 25, offset: 14358},
										name: "IfExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 465, col: 5, offset: 14399},
						run: (*parser).calloncondition8,
						expr: &seqExpr{
							pos: position{line: 465, col: 5, offset: 14399},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 465, col: 5, offset: 14399},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).calloncondition11,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&andExpr{
									pos: position{line: 465, col: 14, offset: 14408},
									expr: &seqExpr{
										pos: position{line: 3796, col: 12, offset: 129156},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 3796, col: 12, offset: 129156},
												expr: &charClassMatcher{
													pos:        position{line: 3808, col: 36, offset: 129503},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&choiceExpr{
												pos: position{line: 3796, col: 16, offset: 129160},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														exprs: []any{
															&zeroOrOneExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																expr: &litMatcher{
																	pos:        position{line: 3796, col: 16, offset: 129160},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3796, col: 22, offset: 129166},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
													&notExpr{
														pos: position{line: 3795, col: 12, offset: 129142},
														expr: &anyMatcher{
															line: 3795, col: 13, offset: 129143,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 474, col: 5, offset: 14691},
						run: (*parser).calloncondition28,
						expr: &labeledExpr{
							pos:   position{line: 474, col: 5, offset: 14691},
							label: "posI",
							expr: &actionExpr{
								pos: position{line: 3799, col: 8, offset: 129205},
								run: (*parser).calloncondition30,
								expr: &choiceExpr{
									pos: position{line: 3799, col: 9, offset: 129206},
									alternatives: []any{
										&andExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											expr: &anyMatcher{
												line: 3799, col: 10, offset: 129207,
											},
										},
										&notExpr{
											pos: position{line: 3799, col: 14, offset: 129211},
											expr: &anyMatcher{
												line: 3799, col: 15, offset: 129212,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "then",
			pos:  position{line: 505, col: 1, offset: 15584},
			expr: &choiceExpr{
				pos: position{line: 505, col: 9, offset: 15592},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 505, col: 9, offset: 15592},
						run: (*parser).callonthen2,
						expr: &seqExpr{
							pos: position{line: 505, col: 9, offset: 15592},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 505, col: 13, offset: 15596},
									label: "scopeI",
									expr: &ruleRefExpr{
										pos:  position{line: 505, col: 20, offset: 15603},
										name: "Body",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 507, col: 5, offset: 15637},
						run: (*parser).callonthen15,
						expr: &labeledExpr{
							pos:   position{line: 507, col: 5, offset: 15637},
							label: "beI",
							expr: &ruleRefExpr{
								pos:  position{line: 507, col: 9, offset: 15641},
								name: "BlockExpansion",
							},
						},
					},
					&actionExpr{
						pos: position{line: 509, col: 5, offset: 15716},
						run: (*parser).callonthen18,
						expr: &seqExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 517, col: 5, offset: 15968},
						exprs: []any{
							&actionExpr{
								pos: position{line: 518, col: 6, offset: 15975},
								run: (*parser).callonthen30,
								expr: &oneOrMoreExpr{
									pos: position{line: 518, col: 6, offset: 15975},
									expr: &charClassMatcher{
										pos:        position{line: 518, col: 6, offset: 15975},
										val:        "[^:\\r\\n]",
										chars:      []rune{':', '\r', '\n'},
										ignoreCase: false,
										inverted:   true,
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 518, col: 40, offset: 16009},
								run: (*parser).callonthen33,
							},
							&ruleRefExpr{
								pos:  position{line: 527, col: 3, offset: 16284},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "If",
			pos:  position{line: 536, col: 1, offset: 16485},
			expr: &actionExpr{
				pos: position{line: 536, col: 7, offset: 16491},
				run: (*parser).callonIf1,
				expr: &seqExpr{
					pos: position{line: 536, col: 7, offset: 16491},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 536, col: 7, offset: 16491},
							val:        "if",
							ignoreCase: false,
							want:       "\"if\"",
						},
						&notExpr{
							pos: position{line: 536, col: 12, offset: 16496},
							expr: &litMatcher{
								pos:        position{line: 536, col: 13, offset: 16497},
								val:        " block",
								ignoreCase: false,
								want:       "\" block\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 536, col: 22, offset: 16506},
							label: "condI",
							expr: &ruleRefExpr{
								pos:  position{line: 536, col: 28, offset: 16512},
								name: "condition",
							},
						},
						&labeledExpr{
							pos:   position{line: 536, col: 38, offset: 16522},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 536, col: 44, offset: 16528},
								name: "then",
							},
						},
						&labeledExpr{
							pos:   position{line: 536, col: 49, offset: 16533},
							label: "elseIfsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 536, col: 58, offset: 16542},
								expr: &ruleRefExpr{
									pos:  position{line: 536, col: 58, offset: 16542},
									name: "ElseIf",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 536, col: 66, offset: 16550},
							label: "elseI",
							expr: &zeroOrOneExpr{
								pos: position{line: 536, col: 72, offset: 16556},
								expr: &ruleRefExpr{
									pos:  position{line: 536, col: 72, offset: 16556},
									name: "Else",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineIf",
			pos:  position{line: 546, col: 1, offset: 16796},
			expr: &actionExpr{
				pos: position{line: 546, col: 13, offset: 16808},
				run: (*parser).callonInlineIf1,
				expr: &seqExpr{
					pos: position{line: 546, col: 13, offset: 16808},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 546, col: 13, offset: 16808},
							val:        "if",
							ignoreCase: false,
							want:       "\"if\"",
						},
						&notExpr{
							pos: position{line: 546, col: 18, offset: 16813},
							expr: &litMatcher{
								pos:        position{line: 546, col: 19, offset: 16814},
								val:        " block",
								ignoreCase: false,
								want:       "\" block\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 546, col: 28, offset: 16823},
							label: "condI",
							expr: &ruleRefExpr{
								pos:  position{line: 546, col: 34, offset: 16829},
								name: "condition",
							},
						},
						&labeledExpr{
							pos:   position{line: 546, col: 44, offset: 16839},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 546, col: 50, offset: 16845},
								name: "BlockExpansion",
							},
						},
					},
				},
			},
		},
		{
			name: "ElseIf",
			pos:  position{line: 554, col: 1, offset: 17021},
			expr: &actionExpr{
				pos: position{line: 554, col: 11, offset: 17031},
				run: (*parser).callonElseIf1,
				expr: &seqExpr{
					pos: position{line: 554, col: 11, offset: 17031},
					exprs: []any{
						&zeroOrOneExpr{
							pos: position{line: 554, col: 11, offset: 17031},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&actionExpr{
							pos: position{line: 3897, col: 17, offset: 133397},
							run: (*parser).callonElseIf11,
							expr: &zeroOrMoreExpr{
								pos: position{line: 3897, col: 17, offset: 133397},
								expr: &charClassMatcher{
									pos:        position{line: 3808, col: 36, offset: 129503},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 3897, col: 41, offset: 133421},
							run: (*parser).callonElseIf14,
						},
						&choiceExpr{
							pos: position{line: 3949, col: 5, offset: 135331},
							alternatives: []any{
								&andCodeExpr{
									pos: position{line: 3949, col: 5, offset: 135331},
									run: (*parser).callonElseIf16,
								},
								&seqExpr{
									pos: position{line: 3951, col: 9, offset: 135414},
									exprs: []any{
										&andCodeExpr{
											pos: position{line: 3951, col: 9, offset: 135414},
											run: (*parser).callonElseIf18,
										},
										&stateCodeExpr{
											pos: position{line: 3953, col: 7, offset: 135537},
											run: (*parser).callonElseIf19,
										},
									},
								},
								&seqExpr{
									pos: position{line: 3960, col: 9, offset: 135873},
									exprs: []any{
										&andCodeExpr{
											pos: position{line: 3960, col: 9, offset: 135873},
											run: (*parser).callonElseIf21,
										},
										&andCodeExpr{
											pos: position{line: 3962, col: 7, offset: 135981},
											run: (*parser).callonElseIf22,
										},
										&choiceExpr{
											pos: position{line: 4015, col: 9, offset: 138316},
											alternatives: []any{
												&seqExpr{
													pos: position{line: 4015, col: 9, offset: 138316},
													exprs: []any{
														&andCodeExpr{
															pos: position{line: 4015, col: 9, offset: 138316},
															run: (*parser).callonElseIf25,
														},
														&andCodeExpr{
															pos: position{line: 4019, col: 11, offset: 138566},
															run: (*parser).callonElseIf26,
														},
														&stateCodeExpr{
															pos: position{line: 4085, col: 11, offset: 141772},
															run: (*parser).callonElseIf27,
														},
													},
												},
												&seqExpr{
													pos: position{line: 4093, col: 13, offset: 142125},
													exprs: []any{
														&andCodeExpr{
															pos: position{line: 4093, col: 13, offset: 142125},
															run: (*parser).callonElseIf29,
														},
														&andCodeExpr{
															pos: position{line: 4097, col: 11, offset: 142380},
															run: (*parser).callonElseIf30,
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 554, col: 32, offset: 17052},
							label: "posI",
							expr: &actionExpr{
								pos: position{line: 3799, col: 8, offset: 129205},
								run: (*parser).callonElseIf32,
								expr: &choiceExpr{
									pos: position{line: 3799, col: 9, offset: 129206},
									alternatives: []any{
										&andExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											expr: &anyMatcher{
												line: 3799, col: 10, offset: 129207,
											},
										},
										&notExpr{
											pos: position{line: 3799, col: 14, offset: 129211},
											expr: &anyMatcher{
												line: 3799, col: 15, offset: 129212,
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 554, col: 41, offset: 17061},
							val:        "else if",
							ignoreCase: false,
							want:       "\"else if\"",
						},
						&labeledExpr{
							pos:   position{line: 554, col: 51, offset: 17071},
							label: "condI",
							expr: &ruleRefExpr{
								pos:  position{line: 554, col: 57, offset: 17077},
								name: "condition",
							},
						},
						&labeledExpr{
							pos:   position{line: 554, col: 67, offset: 17087},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 554, col: 73, offset: 17093},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "Else",
			pos:  position{line: 562, col: 1, offset: 17256},
			expr: &actionExpr{
				pos: position{line: 562, col: 9, offset: 17264},
				run: (*parser).callonElse1,
				expr: &seqExpr{
					pos: position{line: 562, col: 9, offset: 17264},
					exprs: []any{
						&zeroOrOneExpr{
							pos: position{line: 562, col: 9, offset: 17264},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&actionExpr{
							pos: position{line: 3897, col: 17, offset: 133397},
							run: (*parser).callonElse11,
							expr: &zeroOrMoreExpr{
								pos: position{line: 3897, col: 17, offset: 133397},
								expr: &charClassMatcher{
									pos:        position{line: 3808, col: 36, offset: 129503},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 3897, col: 41, offset: 133421},
							run: (*parser).callonElse14,
						},
						&choiceExpr{
							pos: position{line: 3949, col: 5, offset: 135331},
							alternatives: []any{
								&andCodeExpr{
									pos: position{line: 3949, col: 5, offset: 135331},
									run: (*parser).callonElse16,
								},
								&seqExpr{
									pos: position{line: 3951, col: 9, offset: 135414},
									exprs: []any{
										&andCodeExpr{
											pos: position{line: 3951, col: 9, offset: 135414},
											run: (*parser).callonElse18,
										},
										&stateCodeExpr{
											pos: position{line: 3953, col: 7, offset: 135537},
											run: (*parser).callonElse19,
										},
									},
								},
								&seqExpr{
									pos: position{line: 3960, col: 9, offset: 135873},
									exprs: []any{
										&andCodeExpr{
											pos: position{line: 3960, col: 9, offset: 135873},
											run: (*parser).callonElse21,
										},
										&andCodeExpr{
											pos: position{line: 3962, col: 7, offset: 135981},
											run: (*parser).callonElse22,
										},
										&choiceExpr{
											pos: position{line: 4015, col: 9, offset: 138316},
											alternatives: []any{
												&seqExpr{
													pos: position{line: 4015, col: 9, offset: 138316},
													exprs: []any{
														&andCodeExpr{
															pos: position{line: 4015, col: 9, offset: 138316},
															run: (*parser).callonElse25,
														},
														&andCodeExpr{
															pos: position{line: 4019, col: 11, offset: 138566},
															run: (*parser).callonElse26,
														},
														&stateCodeExpr{
															pos: position{line: 4085, col: 11, offset: 141772},
															run: (*parser).callonElse27,
														},
													},
												},
												&seqExpr{
													pos: position{line: 4093, col: 13, offset: 142125},
													exprs: []any{
														&andCodeExpr{
															pos: position{line: 4093, col: 13, offset: 142125},
															run: (*parser).callonElse29,
														},
														&andCodeExpr{
															pos: position{line: 4097, col: 11, offset: 142380},
															run: (*parser).callonElse30,
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 562, col: 30, offset: 17285},
							val:        "else",
							ignoreCase: false,
							want:       "\"else\"",
						},
						&labeledExpr{
							pos:   position{line: 562, col: 37, offset: 17292},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 562, col: 43, offset: 17298},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "IfBlock",
			pos:  position{line: 573, col: 1, offset: 17420},
			expr: &actionExpr{
				pos: position{line: 573, col: 12, offset: 17431},
				run: (*parser).callonIfBlock1,
				expr: &seqExpr{
					pos: position{line: 573, col: 12, offset: 17431},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 573, col: 12, offset: 17431},
							val:        "if block",
							ignoreCase: false,
							want:       "\"if block\"",
						},
						&labeledExpr{
							pos:   position{line: 573, col: 23, offset: 17442},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 329, col: 14, offset: 10358},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 329, col: 14, offset: 10358},
										run: (*parser).callonIfBlock6,
										expr: &seqExpr{
											pos: position{line: 329, col: 14, offset: 10358},
											exprs: []any{
												&oneOrMoreExpr{
													pos: position{line: 329, col: 14, offset: 10358},
													expr: &litMatcher{
														pos:        position{line: 329, col: 14, offset: 10358},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&labeledExpr{
													pos:   position{line: 329, col: 19, offset: 10363},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 773, col: 14, offset: 23557},
														alternatives: []any{
															&actionExpr{
																pos: position{line: 773, col: 14, offset: 23557},
																run: (*parser).callonIfBlock12,
																expr: &labeledExpr{
																	pos:   position{line: 773, col: 14, offset: 23557},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 759, col: 10, offset: 23002},
																		alternatives: []any{
																			&actionExpr{
																				pos: position{line: 759, col: 10, offset: 23002},
																				run: (*parser).callonIfBlock15,
																				expr: &labeledExpr{
																					pos:   position{line: 759, col: 10, offset: 23002},
																					label: "identI",
																					expr: &seqExpr{
																						pos: position{line: 2410, col: 17, offset: 81833},
																						exprs: []any{
																							&charClassMatcher{
																								pos:        position{line: 2393, col: 20, offset: 81588},
																								val:        "[_\\pL]",
																								chars:      []rune{'_'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&zeroOrMoreExpr{
																								pos: position{line: 2410, col: 26, offset: 81842},
																								expr: &charClassMatcher{
																									pos:        position{line: 2393, col: 20, offset: 81588},
																									val:        "[_\\pL\\pNd]",
																									chars:      []rune{'_'},
																									classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 761, col: 5, offset: 23096},
																				run: (*parser).callonIfBlock21,
																				expr: &seqExpr{
																					pos: position{line: 761, col: 5, offset: 23096},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 761, col: 5, offset: 23096},
																							label: "identI",
																							expr: &seqExpr{
																								pos: position{line: 761, col: 13, offset: 23104},
																								exprs: []any{
																									&zeroOrOneExpr{
																										pos: position{line: 761, col: 13, offset: 23104},
																										expr: &litMatcher{
																											pos:        position{line: 761, col: 13, offset: 23104},
																											val:        "$",
																											ignoreCase: false,
																											want:       "\"$\"",
																										},
																									},
																									&oneOrMoreExpr{
																										pos: position{line: 761, col: 18, offset: 23109},
																										expr: &choiceExpr{
																											pos: position{line: 761, col: 19, offset: 23110},
																											alternatives: []any{
																												&seqExpr{
																													pos: position{line: 761, col: 19, offset: 23110},
																													exprs: []any{
																														&charClassMatcher{
																															pos:        position{line: 761, col: 19, offset: 23110},
																															val:        "[\\pNd]",
																															classes:    []*unicode.RangeTable{rangeTable("Nd")},
																															ignoreCase: false,
																															inverted:   false,
																														},
																														&charClassMatcher{
																															pos:        position{line: 761, col: 28, offset: 23119},
																															val:        "[_-\\pL]",
																															chars:      []rune{'_', '-'},
																															classes:    []*unicode.RangeTable{rangeTable("L")},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																												},
																												&charClassMatcher{
																													pos:        position{line: 761, col: 38, offset: 23129},
																													val:        "[_-\\pL]",
																													chars:      []rune{'_', '-'},
																													classes:    []*unicode.RangeTable{rangeTable("L")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 761, col: 49, offset: 23140},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonIfBlock34,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 775, col: 5, offset: 23599},
																run: (*parser).callonIfBlock40,
																expr: &seqExpr{
																	pos: position{line: 775, col: 5, offset: 23599},
																	exprs: []any{
																		&labeledExpr{
																			pos:   position{line: 775, col: 5, offset: 23599},
																			label: "posI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonIfBlock43,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																		&andExpr{
																			pos: position{line: 775, col: 14, offset: 23608},
																			expr: &choiceExpr{
																				pos: position{line: 775, col: 16, offset: 23610},
																				alternatives: []any{
																					&seqExpr{
																						pos: position{line: 3796, col: 12, offset: 129156},
																						exprs: []any{
																							&zeroOrMoreExpr{
																								pos: position{line: 3796, col: 12, offset: 129156},
																								expr: &charClassMatcher{
																									pos:        position{line: 3808, col: 36, offset: 129503},
																									val:        "[ \\t]",
																									chars:      []rune{' ', '\t'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&choiceExpr{
																								pos: position{line: 3796, col: 16, offset: 129160},
																								alternatives: []any{
																									&seqExpr{
																										pos: position{line: 3796, col: 16, offset: 129160},
																										exprs: []any{
																											&zeroOrOneExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												expr: &litMatcher{
																													pos:        position{line: 3796, col: 16, offset: 129160},
																													val:        "\r",
																													ignoreCase: false,
																													want:       "\"\\r\"",
																												},
																											},
																											&litMatcher{
																												pos:        position{line: 3796, col: 22, offset: 129166},
																												val:        "\n",
																												ignoreCase: false,
																												want:       "\"\\n\"",
																											},
																										},
																									},
																									&notExpr{
																										pos: position{line: 3795, col: 12, offset: 129142},
																										expr: &anyMatcher{
																											line: 3795, col: 13, offset: 129143,
																										},
																									},
																								},
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 775, col: 22, offset: 23616},
																						val:        "[:!=()]",
																						chars:      []rune{':', '!', '=', '(', ')'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 786, col: 5, offset: 23948},
																run: (*parser).callonIfBlock62,
																expr: &seqExpr{
																	pos: position{line: 786, col: 5, offset: 23948},
																	exprs: []any{
																		&labeledExpr{
																			pos:   position{line: 786, col: 5, offset: 23948},
																			label: "identI",
																			expr: &oneOrMoreExpr{
																				pos: position{line: 786, col: 12, offset: 23955},
																				expr: &charClassMatcher{
																					pos:        position{line: 786, col: 12, offset: 23955},
																					val:        "[^ \\t\\r\\n:!=()]",
																					chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 786, col: 29, offset: 23972},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonIfBlock68,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 331, col: 5, offset: 10409},
										run: (*parser).callonIfBlock74,
										expr: &andExpr{
											pos: position{line: 331, col: 5, offset: 10409},
											expr: &seqExpr{
												pos: position{line: 3796, col: 12, offset: 129156},
												exprs: []any{
													&zeroOrMoreExpr{
														pos: position{line: 3796, col: 12, offset: 129156},
														expr: &charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		expr: &litMatcher{
																			pos:        position{line: 3796, col: 16, offset: 129160},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3796, col: 22, offset: 129166},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3795, col: 12, offset: 129142},
																expr: &anyMatcher{
																	line: 3795, col: 13, offset: 129143,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 573, col: 39, offset: 17458},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 573, col: 45, offset: 17464},
								name: "then",
							},
						},
						&labeledExpr{
							pos:   position{line: 573, col: 50, offset: 17469},
							label: "elseIfsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 573, col: 59, offset: 17478},
								expr: &ruleRefExpr{
									pos:  position{line: 573, col: 59, offset: 17478},
									name: "ElseIfBlock",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 573, col: 72, offset: 17491},
							label: "elseI",
							expr: &zeroOrOneExpr{
								pos: position{line: 573, col: 78, offset: 17497},
								expr: &ruleRefExpr{
									pos:  position{line: 573, col: 78, offset: 17497},
									name: "Else",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineIfBlock",
			pos:  position{line: 583, col: 1, offset: 17737},
			expr: &actionExpr{
				pos: position{line: 583, col: 18, offset: 17754},
				run: (*parser).callonInlineIfBlock1,
				expr: &seqExpr{
					pos: position{line: 583, col: 18, offset: 17754},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 583, col: 18, offset: 17754},
							val:        "if block",
							ignoreCase: false,
							want:       "\"if block\"",
						},
						&labeledExpr{
							pos:   position{line: 583, col: 29, offset: 17765},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 329, col: 14, offset: 10358},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 329, col: 14, offset: 10358},
										run: (*parser).callonInlineIfBlock6,
										expr: &seqExpr{
											pos: position{line: 329, col: 14, offset: 10358},
											exprs: []any{
												&oneOrMoreExpr{
													pos: position{line: 329, col: 14, offset: 10358},
													expr: &litMatcher{
														pos:        position{line: 329, col: 14, offset: 10358},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&labeledExpr{
													pos:   position{line: 329, col: 19, offset: 10363},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 773, col: 14, offset: 23557},
														alternatives: []any{
															&actionExpr{
																pos: position{line: 773, col: 14, offset: 23557},
																run: (*parser).callonInlineIfBlock12,
																expr: &labeledExpr{
																	pos:   position{line: 773, col: 14, offset: 23557},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 759, col: 10, offset: 23002},
																		alternatives: []any{
																			&actionExpr{
																				pos: position{line: 759, col: 10, offset: 23002},
																				run: (*parser).callonInlineIfBlock15,
																				expr: &labeledExpr{
																					pos:   position{line: 759, col: 10, offset: 23002},
																					label: "identI",
																					expr: &seqExpr{
																						pos: position{line: 2410, col: 17, offset: 81833},
																						exprs: []any{
																							&charClassMatcher{
																								pos:        position{line: 2393, col: 20, offset: 81588},
																								val:        "[_\\pL]",
																								chars:      []rune{'_'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&zeroOrMoreExpr{
																								pos: position{line: 2410, col: 26, offset: 81842},
																								expr: &charClassMatcher{
																									pos:        position{line: 2393, col: 20, offset: 81588},
																									val:        "[_\\pL\\pNd]",
																									chars:      []rune{'_'},
																									classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 761, col: 5, offset: 23096},
																				run: (*parser).callonInlineIfBlock21,
																				expr: &seqExpr{
																					pos: position{line: 761, col: 5, offset: 23096},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 761, col: 5, offset: 23096},
																							label: "identI",
																							expr: &seqExpr{
																								pos: position{line: 761, col: 13, offset: 23104},
																								exprs: []any{
																									&zeroOrOneExpr{
																										pos: position{line: 761, col: 13, offset: 23104},
																										expr: &litMatcher{
																											pos:        position{line: 761, col: 13, offset: 23104},
																											val:        "$",
																											ignoreCase: false,
																											want:       "\"$\"",
																										},
																									},
																									&oneOrMoreExpr{
																										pos: position{line: 761, col: 18, offset: 23109},
																										expr: &choiceExpr{
																											pos: position{line: 761, col: 19, offset: 23110},
																											alternatives: []any{
																												&seqExpr{
																													pos: position{line: 761, col: 19, offset: 23110},
																													exprs: []any{
																														&charClassMatcher{
																															pos:        position{line: 761, col: 19, offset: 23110},
																															val:        "[\\pNd]",
																															classes:    []*unicode.RangeTable{rangeTable("Nd")},
																															ignoreCase: false,
																															inverted:   false,
																														},
																														&charClassMatcher{
																															pos:        position{line: 761, col: 28, offset: 23119},
																															val:        "[_-\\pL]",
																															chars:      []rune{'_', '-'},
																															classes:    []*unicode.RangeTable{rangeTable("L")},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																												},
																												&charClassMatcher{
																													pos:        position{line: 761, col: 38, offset: 23129},
																													val:        "[_-\\pL]",
																													chars:      []rune{'_', '-'},
																													classes:    []*unicode.RangeTable{rangeTable("L")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 761, col: 49, offset: 23140},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonInlineIfBlock34,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 775, col: 5, offset: 23599},
																run: (*parser).callonInlineIfBlock40,
																expr: &seqExpr{
																	pos: position{line: 775, col: 5, offset: 23599},
																	exprs: []any{
																		&labeledExpr{
																			pos:   position{line: 775, col: 5, offset: 23599},
																			label: "posI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonInlineIfBlock43,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																		&andExpr{
																			pos: position{line: 775, col: 14, offset: 23608},
																			expr: &choiceExpr{
																				pos: position{line: 775, col: 16, offset: 23610},
																				alternatives: []any{
																					&seqExpr{
																						pos: position{line: 3796, col: 12, offset: 129156},
																						exprs: []any{
																							&zeroOrMoreExpr{
																								pos: position{line: 3796, col: 12, offset: 129156},
																								expr: &charClassMatcher{
																									pos:        position{line: 3808, col: 36, offset: 129503},
																									val:        "[ \\t]",
																									chars:      []rune{' ', '\t'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&choiceExpr{
																								pos: position{line: 3796, col: 16, offset: 129160},
																								alternatives: []any{
																									&seqExpr{
																										pos: position{line: 3796, col: 16, offset: 129160},
																										exprs: []any{
																											&zeroOrOneExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												expr: &litMatcher{
																													pos:        position{line: 3796, col: 16, offset: 129160},
																													val:        "\r",
																													ignoreCase: false,
																													want:       "\"\\r\"",
																												},
																											},
																											&litMatcher{
																												pos:        position{line: 3796, col: 22, offset: 129166},
																												val:        "\n",
																												ignoreCase: false,
																												want:       "\"\\n\"",
																											},
																										},
																									},
																									&notExpr{
																										pos: position{line: 3795, col: 12, offset: 129142},
																										expr: &anyMatcher{
																											line: 3795, col: 13, offset: 129143,
																										},
																									},
																								},
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 775, col: 22, offset: 23616},
																						val:        "[:!=()]",
																						chars:      []rune{':', '!', '=', '(', ')'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 786, col: 5, offset: 23948},
																run: (*parser).callonInlineIfBlock62,
																expr: &seqExpr{
																	pos: position{line: 786, col: 5, offset: 23948},
																	exprs: []any{
																		&labeledExpr{
																			pos:   position{line: 786, col: 5, offset: 23948},
																			label: "identI",
																			expr: &oneOrMoreExpr{
																				pos: position{line: 786, col: 12, offset: 23955},
																				expr: &charClassMatcher{
																					pos:        position{line: 786, col: 12, offset: 23955},
																					val:        "[^ \\t\\r\\n:!=()]",
																					chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 786, col: 29, offset: 23972},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonInlineIfBlock68,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 331, col: 5, offset: 10409},
										run: (*parser).callonInlineIfBlock74,
										expr: &andExpr{
											pos: position{line: 331, col: 5, offset: 10409},
											expr: &seqExpr{
												pos: position{line: 3796, col: 12, offset: 129156},
												exprs: []any{
													&zeroOrMoreExpr{
														pos: position{line: 3796, col: 12, offset: 129156},
														expr: &charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		expr: &litMatcher{
																			pos:        position{line: 3796, col: 16, offset: 129160},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3796, col: 22, offset: 129166},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3795, col: 12, offset: 129142},
																expr: &anyMatcher{
																	line: 3795, col: 13, offset: 129143,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 583, col: 45, offset: 17781},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 583, col: 51, offset: 17787},
								name: "BlockExpansion",
							},
						},
					},
				},
			},
		},
		{
			name: "ElseIfBlock",
			pos:  position{line: 591, col: 1, offset: 17958},
			expr: &actionExpr{
				pos: position{line: 591, col: 16, offset: 17973},
				run: (*parser).callonElseIfBlock1,
				expr: &seqExpr{
					pos: position{line: 591, col: 16, offset: 17973},
					exprs: []any{
						&zeroOrOneExpr{
							pos: position{line: 591, col: 16, offset: 17973},
							expr: &oneOrMoreExpr{
								pos: position{line: 3810, col: 36, offset: 129590},
								expr: &seqExpr{
									pos: position{line: 3810, col: 37, offset: 129591},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&actionExpr{
							pos: position{line: 3897, col: 17, offset: 133397},
							run: (*parser).callonElseIfBlock11,
							expr: &zeroOrMoreExpr{
								pos: position{line: 3897, col: 17, offset: 133397},
								expr: &charClassMatcher{
									pos:        position{line: 3808, col: 36, offset: 129503},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 3897, col: 41, offset: 133421},
							run: (*parser).callonElseIfBlock14,
						},
						&choiceExpr{
							pos: position{line: 3949, col: 5, offset: 135331},
							alternatives: []any{
								&andCodeExpr{
									pos: position{line: 3949, col: 5, offset: 135331},
									run: (*parser).callonElseIfBlock16,
								},
								&seqExpr{
									pos: position{line: 3951, col: 9, offset: 135414},
									exprs: []any{
										&andCodeExpr{
											pos: position{line: 3951, col: 9, offset: 135414},
											run: (*parser).callonElseIfBlock18,
										},
										&stateCodeExpr{
											pos: position{line: 3953, col: 7, offset: 135537},
											run: (*parser).callonElseIfBlock19,
										},
									},
								},
								&seqExpr{
									pos: position{line: 3960, col: 9, offset: 135873},
									exprs: []any{
										&andCodeExpr{
											pos: position{line: 3960, col: 9, offset: 135873},
											run: (*parser).callonElseIfBlock21,
										},
										&andCodeExpr{
											pos: position{line: 3962, col: 7, offset: 135981},
											run: (*parser).callonElseIfBlock22,
										},
										&choiceExpr{
											pos: position{line: 4015, col: 9, offset: 138316},
											alternatives: []any{
												&seqExpr{
													pos: position{line: 4015, col: 9, offset: 138316},
													exprs: []any{
														&andCodeExpr{
															pos: position{line: 4015, col: 9, offset: 138316},
															run: (*parser).callonElseIfBlock25,
														},
														&andCodeExpr{
															pos: position{line: 4019, col: 11, offset: 138566},
															run: (*parser).callonElseIfBlock26,
														},
														&stateCodeExpr{
															pos: position{line: 4085, col: 11, offset: 141772},
															run: (*parser).callonElseIfBlock27,
														},
													},
												},
												&seqExpr{
													pos: position{line: 4093, col: 13, offset: 142125},
													exprs: []any{
														&andCodeExpr{
															pos: position{line: 4093, col: 13, offset: 142125},
															run: (*parser).callonElseIfBlock29,
														},
														&andCodeExpr{
															pos: position{line: 4097, col: 11, offset: 142380},
															run: (*parser).callonElseIfBlock30,
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 591, col: 37, offset: 17994},
							label: "posI",
							expr: &actionExpr{
								pos: position{line: 3799, col: 8, offset: 129205},
								run: (*parser).callonElseIfBlock32,
								expr: &choiceExpr{
									pos: position{line: 3799, col: 9, offset: 129206},
									alternatives: []any{
										&andExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											expr: &anyMatcher{
												line: 3799, col: 10, offset: 129207,
											},
										},
										&notExpr{
											pos: position{line: 3799, col: 14, offset: 129211},
											expr: &anyMatcher{
												line: 3799, col: 15, offset: 129212,
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 591, col: 46, offset: 18003},
							val:        "else if block",
							ignoreCase: false,
							want:       "\"else if block\"",
						},
						&labeledExpr{
							pos:   position{line: 591, col: 62, offset: 18019},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 329, col: 14, offset: 10358},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 329, col: 14, offset: 10358},
										run: (*parser).callonElseIfBlock41,
										expr: &seqExpr{
											pos: position{line: 329, col: 14, offset: 10358},
											exprs: []any{
												&oneOrMoreExpr{
													pos: position{line: 329, col: 14, offset: 10358},
													expr: &litMatcher{
														pos:        position{line: 329, col: 14, offset: 10358},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&labeledExpr{
													pos:   position{line: 329, col: 19, offset: 10363},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 773, col: 14, offset: 23557},
														alternatives: []any{
															&actionExpr{
																pos: position{line: 773, col: 14, offset: 23557},
																run: (*parser).callonElseIfBlock47,
																expr: &labeledExpr{
																	pos:   position{line: 773, col: 14, offset: 23557},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 759, col: 10, offset: 23002},
																		alternatives: []any{
																			&actionExpr{
																				pos: position{line: 759, col: 10, offset: 23002},
																				run: (*parser).callonElseIfBlock50,
																				expr: &labeledExpr{
																					pos:   position{line: 759, col: 10, offset: 23002},
																					label: "identI",
																					expr: &seqExpr{
																						pos: position{line: 2410, col: 17, offset: 81833},
																						exprs: []any{
																							&charClassMatcher{
																								pos:        position{line: 2393, col: 20, offset: 81588},
																								val:        "[_\\pL]",
																								chars:      []rune{'_'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&zeroOrMoreExpr{
																								pos: position{line: 2410, col: 26, offset: 81842},
																								expr: &charClassMatcher{
																									pos:        position{line: 2393, col: 20, offset: 81588},
																									val:        "[_\\pL\\pNd]",
																									chars:      []rune{'_'},
																									classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 761, col: 5, offset: 23096},
																				run: (*parser).callonElseIfBlock56,
																				expr: &seqExpr{
																					pos: position{line: 761, col: 5, offset: 23096},
																					exprs: []any{
																						&labeledExpr{
																							pos:   position{line: 761, col: 5, offset: 23096},
																							label: "identI",
																							expr: &seqExpr{
																								pos: position{line: 761, col: 13, offset: 23104},
																								exprs: []any{
																									&zeroOrOneExpr{
																										pos: position{line: 761, col: 13, offset: 23104},
																										expr: &litMatcher{
																											pos:        position{line: 761, col: 13, offset: 23104},
																											val:        "$",
																											ignoreCase: false,
																											want:       "\"$\"",
																										},
																									},
																									&oneOrMoreExpr{
																										pos: position{line: 761, col: 18, offset: 23109},
																										expr: &choiceExpr{
																											pos: position{line: 761, col: 19, offset: 23110},
																											alternatives: []any{
																												&seqExpr{
																													pos: position{line: 761, col: 19, offset: 23110},
																													exprs: []any{
																														&charClassMatcher{
																															pos:        position{line: 761, col: 19, offset: 23110},
																															val:        "[\\pNd]",
																															classes:    []*unicode.RangeTable{rangeTable("Nd")},
																															ignoreCase: false,
																															inverted:   false,
																														},
																														&charClassMatcher{
																															pos:        position{line: 761, col: 28, offset: 23119},
																															val:        "[_-\\pL]",
																															chars:      []rune{'_', '-'},
																															classes:    []*unicode.RangeTable{rangeTable("L")},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																												},
																												&charClassMatcher{
																													pos:        position{line: 761, col: 38, offset: 23129},
																													val:        "[_-\\pL]",
																													chars:      []rune{'_', '-'},
																													classes:    []*unicode.RangeTable{rangeTable("L")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 761, col: 49, offset: 23140},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3799, col: 8, offset: 129205},
																								run: (*parser).callonElseIfBlock69,
																								expr: &choiceExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									alternatives: []any{
																										&andExpr{
																											pos: position{line: 3799, col: 9, offset: 129206},
																											expr: &anyMatcher{
																												line: 3799, col: 10, offset: 129207,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3799, col: 14, offset: 129211},
																											expr: &anyMatcher{
																												line: 3799, col: 15, offset: 129212,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 775, col: 5, offset: 23599},
																run: (*parser).callonElseIfBlock75,
																expr: &seqExpr{
																	pos: position{line: 775, col: 5, offset: 23599},
																	exprs: []any{
																		&labeledExpr{
																			pos:   position{line: 775, col: 5, offset: 23599},
																			label: "posI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonElseIfBlock78,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																		&andExpr{
																			pos: position{line: 775, col: 14, offset: 23608},
																			expr: &choiceExpr{
																				pos: position{line: 775, col: 16, offset: 23610},
																				alternatives: []any{
																					&seqExpr{
																						pos: position{line: 3796, col: 12, offset: 129156},
																						exprs: []any{
																							&zeroOrMoreExpr{
																								pos: position{line: 3796, col: 12, offset: 129156},
																								expr: &charClassMatcher{
																									pos:        position{line: 3808, col: 36, offset: 129503},
																									val:        "[ \\t]",
																									chars:      []rune{' ', '\t'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&choiceExpr{
																								pos: position{line: 3796, col: 16, offset: 129160},
																								alternatives: []any{
																									&seqExpr{
																										pos: position{line: 3796, col: 16, offset: 129160},
																										exprs: []any{
																											&zeroOrOneExpr{
																												pos: position{line: 3796, col: 16, offset: 129160},
																												expr: &litMatcher{
																													pos:        position{line: 3796, col: 16, offset: 129160},
																													val:        "\r",
																													ignoreCase: false,
																													want:       "\"\\r\"",
																												},
																											},
																											&litMatcher{
																												pos:        position{line: 3796, col: 22, offset: 129166},
																												val:        "\n",
																												ignoreCase: false,
																												want:       "\"\\n\"",
																											},
																										},
																									},
																									&notExpr{
																										pos: position{line: 3795, col: 12, offset: 129142},
																										expr: &anyMatcher{
																											line: 3795, col: 13, offset: 129143,
																										},
																									},
																								},
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 775, col: 22, offset: 23616},
																						val:        "[:!=()]",
																						chars:      []rune{':', '!', '=', '(', ')'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 786, col: 5, offset: 23948},
																run: (*parser).callonElseIfBlock97,
																expr: &seqExpr{
																	pos: position{line: 786, col: 5, offset: 23948},
																	exprs: []any{
																		&labeledExpr{
																			pos:   position{line: 786, col: 5, offset: 23948},
																			label: "identI",
																			expr: &oneOrMoreExpr{
																				pos: position{line: 786, col: 12, offset: 23955},
																				expr: &charClassMatcher{
																					pos:        position{line: 786, col: 12, offset: 23955},
																					val:        "[^ \\t\\r\\n:!=()]",
																					chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 786, col: 29, offset: 23972},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonElseIfBlock103,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 331, col: 5, offset: 10409},
										run: (*parser).callonElseIfBlock109,
										expr: &andExpr{
											pos: position{line: 331, col: 5, offset: 10409},
											expr: &seqExpr{
												pos: position{line: 3796, col: 12, offset: 129156},
												exprs: []any{
													&zeroOrMoreExpr{
														pos: position{line: 3796, col: 12, offset: 129156},
														expr: &charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		expr: &litMatcher{
																			pos:        position{line: 3796, col: 16, offset: 129160},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3796, col: 22, offset: 129166},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3795, col: 12, offset: 129142},
																expr: &anyMatcher{
																	line: 3795, col: 13, offset: 129143,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 591, col: 78, offset: 18035},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 591, col: 84, offset: 18041},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "Switch",
			pos:  position{line: 610, col: 1, offset: 18530},
			expr: &actionExpr{
				pos: position{line: 610, col: 11, offset: 18540},
				run: (*parser).callonSwitch1,
				expr: &seqExpr{
					pos: position{line: 610, col: 11, offset: 18540},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 610, col: 11, offset: 18540},
							val:        "switch",
							ignoreCase: false,
							want:       "\"switch\"",
						},
						&labeledExpr{
							pos:   position{line: 610, col: 20, offset: 18549},
							label: "comparatorI",
							expr: &ruleRefExpr{
								pos:  position{line: 610, col: 32, offset: 18561},
								name: "switchComparator",
							},
						},
						&labeledExpr{
							pos:   position{line: 610, col: 49, offset: 18578},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 610, col: 55, offset: 18584},
								name: "switchBody",
							},
						},
					},
				},
			},
		},
		{
			name: "switchComparator",
			pos:  position{line: 635, col: 1, offset: 19201},
			expr: &choiceExpr{
				pos: position{line: 635, col: 21, offset: 19221},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 635, col: 21, offset: 19221},
						run: (*parser).callonswitchComparator2,
						expr: &seqExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 637, col: 5, offset: 19271},
						run: (*parser).callonswitchComparator13,
						expr: &seqExpr{
							pos: position{line: 637, col: 5, offset: 19271},
							exprs: []any{
								&oneOrMoreExpr{
									pos: position{line: 637, col: 5, offset: 19271},
									expr: &litMatcher{
										pos:        position{line: 637, col: 5, offset: 19271},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 637, col: 10, offset: 19276},
									label: "compI",
									expr: &ruleRefExpr{
										pos:  position{line: 637, col: 16, offset: 19282},
										name: "IfExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 640, col: 5, offset: 19363},
						run: (*parser).callonswitchComparator28,
						expr: &seqExpr{
							pos: position{line: 640, col: 5, offset: 19363},
							exprs: []any{
								&oneOrMoreExpr{
									pos: position{line: 640, col: 5, offset: 19363},
									expr: &litMatcher{
										pos:        position{line: 640, col: 5, offset: 19363},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 640, col: 10, offset: 19368},
									label: "compI",
									expr: &ruleRefExpr{
										pos:  position{line: 640, col: 16, offset: 19374},
										name: "IfExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 640, col: 29, offset: 19387},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonswitchComparator35,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&oneOrMoreExpr{
									pos: position{line: 640, col: 43, offset: 19401},
									expr: &charClassMatcher{
										pos:        position{line: 3797, col: 12, offset: 129189},
										val:        "[^\\r\\n]",
										chars:      []rune{'\r', '\n'},
										ignoreCase: false,
										inverted:   true,
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "switchBody",
			pos:  position{line: 651, col: 1, offset: 19724},
			expr: &actionExpr{
				pos: position{line: 651, col: 15, offset: 19738},
				run: (*parser).callonswitchBody1,
				expr: &seqExpr{
					pos: position{line: 651, col: 15, offset: 19738},
					exprs: []any{
						&stateCodeExpr{
							pos: position{line: 4284, col: 11, offset: 150129},
							run: (*parser).callonswitchBody3,
						},
						&labeledExpr{
							pos:   position{line: 651, col: 22, offset: 19745},
							label: "itms",
							expr: &zeroOrMoreExpr{
								pos: position{line: 651, col: 27, offset: 19750},
								expr: &seqExpr{
									pos: position{line: 651, col: 28, offset: 19751},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 651, col: 28, offset: 19751},
											expr: &oneOrMoreExpr{
												pos: position{line: 3810, col: 36, offset: 129590},
												expr: &seqExpr{
													pos: position{line: 3810, col: 37, offset: 129591},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 3810, col: 37, offset: 129591},
															expr: &charClassMatcher{
																pos:        position{line: 3808, col: 36, offset: 129503},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&zeroOrOneExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															expr: &litMatcher{
																pos:        position{line: 3809, col: 36, offset: 129544},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3809, col: 42, offset: 129550},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
										&actionExpr{
											pos: position{line: 3897, col: 17, offset: 133397},
											run: (*parser).callonswitchBody15,
											expr: &zeroOrMoreExpr{
												pos: position{line: 3897, col: 17, offset: 133397},
												expr: &charClassMatcher{
													pos:        position{line: 3808, col: 36, offset: 129503},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
										&andCodeExpr{
											pos: position{line: 3897, col: 41, offset: 133421},
											run: (*parser).callonswitchBody18,
										},
										&choiceExpr{
											pos: position{line: 3949, col: 5, offset: 135331},
											alternatives: []any{
												&andCodeExpr{
													pos: position{line: 3949, col: 5, offset: 135331},
													run: (*parser).callonswitchBody20,
												},
												&seqExpr{
													pos: position{line: 3951, col: 9, offset: 135414},
													exprs: []any{
														&andCodeExpr{
															pos: position{line: 3951, col: 9, offset: 135414},
															run: (*parser).callonswitchBody22,
														},
														&stateCodeExpr{
															pos: position{line: 3953, col: 7, offset: 135537},
															run: (*parser).callonswitchBody23,
														},
													},
												},
												&seqExpr{
													pos: position{line: 3960, col: 9, offset: 135873},
													exprs: []any{
														&andCodeExpr{
															pos: position{line: 3960, col: 9, offset: 135873},
															run: (*parser).callonswitchBody25,
														},
														&andCodeExpr{
															pos: position{line: 3962, col: 7, offset: 135981},
															run: (*parser).callonswitchBody26,
														},
														&choiceExpr{
															pos: position{line: 4015, col: 9, offset: 138316},
															alternatives: []any{
																&seqExpr{
																	pos: position{line: 4015, col: 9, offset: 138316},
																	exprs: []any{
																		&andCodeExpr{
																			pos: position{line: 4015, col: 9, offset: 138316},
																			run: (*parser).callonswitchBody29,
																		},
																		&andCodeExpr{
																			pos: position{line: 4019, col: 11, offset: 138566},
																			run: (*parser).callonswitchBody30,
																		},
																		&stateCodeExpr{
																			pos: position{line: 4085, col: 11, offset: 141772},
																			run: (*parser).callonswitchBody31,
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 4093, col: 13, offset: 142125},
																	exprs: []any{
																		&andCodeExpr{
																			pos: position{line: 4093, col: 13, offset: 142125},
																			run: (*parser).callonswitchBody33,
																		},
																		&andCodeExpr{
																			pos: position{line: 4097, col: 11, offset: 142380},
																			run: (*parser).callonswitchBody34,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 651, col: 49, offset: 19772},
											name: "switchBodyItem",
										},
									},
								},
							},
						},
						&stateCodeExpr{
							pos: position{line: 4289, col: 11, offset: 150234},
							run: (*parser).callonswitchBody36,
						},
					},
				},
			},
		},
		{
			name: "switchBodyItem",
			pos:  position{line: 689, col: 1, offset: 21037},
			expr: &choiceExpr{
				pos: position{line: 689, col: 19, offset: 21055},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 689, col: 19, offset: 21055},
						run: (*parser).callonswitchBodyItem2,
						expr: &labeledExpr{
							pos:   position{line: 689, col: 19, offset: 21055},
							label: "caseI",
							expr: &choiceExpr{
								pos: position{line: 689, col: 26, offset: 21062},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 689, col: 26, offset: 21062},
										name: "Case",
									},
									&ruleRefExpr{
										pos:  position{line: 689, col: 33, offset: 21069},
										name: "Default",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 691, col: 5, offset: 21119},
						run: (*parser).callonswitchBodyItem7,
						expr: &labeledExpr{
							pos:   position{line: 691, col: 5, offset: 21119},
							label: "caseI",
							expr: &ruleRefExpr{
								pos:  position{line: 691, col: 11, offset: 21125},
								name: "BadCase",
							},
						},
					},
				},
			},
		},
		{
			name: "Case",
			pos:  position{line: 695, col: 1, offset: 21174},
			expr: &actionExpr{
				pos: position{line: 695, col: 9, offset: 21182},
				run: (*parser).callonCase1,
				expr: &seqExpr{
					pos: position{line: 695, col: 9, offset: 21182},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 695, col: 9, offset: 21182},
							val:        "case",
							ignoreCase: false,
							want:       "\"case\"",
						},
						&labeledExpr{
							pos:   position{line: 695, col: 16, offset: 21189},
							label: "condI",
							expr: &ruleRefExpr{
								pos:  position{line: 695, col: 22, offset: 21195},
								name: "condition",
							},
						},
						&labeledExpr{
							pos:   position{line: 695, col: 32, offset: 21205},
							label: "thenI",
							expr: &zeroOrOneExpr{
								pos: position{line: 695, col: 38, offset: 21211},
								expr: &ruleRefExpr{
									pos:  position{line: 695, col: 38, offset: 21211},
									name: "switchThen",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Default",
			pos:  position{line: 703, col: 1, offset: 21388},
			expr: &actionExpr{
				pos: position{line: 703, col: 12, offset: 21399},
				run: (*parser).callonDefault1,
				expr: &seqExpr{
					pos: position{line: 703, col: 12, offset: 21399},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 703, col: 12, offset: 21399},
							val:        "default",
							ignoreCase: false,
							want:       "\"default\"",
						},
						&labeledExpr{
							pos:   position{line: 703, col: 22, offset: 21409},
							label: "thenI",
							expr: &zeroOrOneExpr{
								pos: position{line: 703, col: 28, offset: 21415},
								expr: &ruleRefExpr{
									pos:  position{line: 703, col: 28, offset: 21415},
									name: "switchThen",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "switchThen",
			pos:  position{line: 710, col: 1, offset: 21538},
			expr: &choiceExpr{
				pos: position{line: 710, col: 15, offset: 21552},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 710, col: 15, offset: 21552},
						run: (*parser).callonswitchThen2,
						expr: &seqExpr{
							pos: position{line: 710, col: 15, offset: 21552},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 710, col: 19, offset: 21556},
									label: "scopeI",
									expr: &ruleRefExpr{
										pos:  position{line: 710, col: 26, offset: 21563},
										name: "Body",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 712, col: 5, offset: 21597},
						run: (*parser).callonswitchThen15,
						expr: &labeledExpr{
							pos:   position{line: 712, col: 5, offset: 21597},
							label: "beI",
							expr: &ruleRefExpr{
								pos:  position{line: 712, col: 9, offset: 21601},
								name: "BlockExpansion",
							},
						},
					},
				},
			},
		},
		{
			name: "BadCase",
			pos:  position{line: 716, col: 1, offset: 21675},
			expr: &actionExpr{
				pos: position{line: 716, col: 12, offset: 21686},
				run: (*parser).callonBadCase1,
				expr: &seqExpr{
					pos: position{line: 716, col: 12, offset: 21686},
					exprs: []any{
						&oneOrMoreExpr{
							pos: position{line: 716, col: 12, offset: 21686},
							expr: &charClassMatcher{
								pos:        position{line: 3797, col: 12, offset: 129189},
								val:        "[^\\r\\n]",
								chars:      []rune{'\r', '\n'},
								ignoreCase: false,
								inverted:   true,
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							expr: &charClassMatcher{
								pos:        position{line: 3808, col: 36, offset: 129503},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3796, col: 16, offset: 129160},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											expr: &litMatcher{
												pos:        position{line: 3796, col: 16, offset: 129160},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3796, col: 22, offset: 129166},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3795, col: 12, offset: 129142},
									expr: &anyMatcher{
										line: 3795, col: 13, offset: 129143,
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 716, col: 25, offset: 21699},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 716, col: 31, offset: 21705},
								expr: &ruleRefExpr{
									pos:  position{line: 716, col: 31, offset: 21705},
									name: "Body",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "For",
			pos:  position{line: 739, col: 1, offset: 22392},
			expr: &actionExpr{
				pos: position{line: 739, col: 8, offset: 22399},
				run: (*parser).callonFor1,
				expr: &seqExpr{
					pos: position{line: 739, col: 8, offset: 22399},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 739, col: 8, offset: 22399},
							val:        "for",
							ignoreCase: false,
							want:       "\"for\"",
						},
						&labeledExpr{
							pos:   position{line: 739, col: 14, offset: 22405},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 739, col: 20, offset: 22411},
								name: "ForExpression",
							},
						},
						&labeledExpr{
							pos:   position{line: 739, col: 34, offset: 22425},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 739, col: 40, offset: 22431},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineFor",
			pos:  position{line: 747, col: 1, offset: 22579},
			expr: &actionExpr{
				pos: position{line: 747, col: 14, offset: 22592},
				run: (*parser).callonInlineFor1,
				expr: &seqExpr{
					pos: position{line: 747, col: 14, offset: 22592},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 747, col: 14, offset: 22592},
							val:        "for",
							ignoreCase: false,
							want:       "\"for\"",
						},
						&labeledExpr{
							pos:   position{line: 747, col: 20, offset: 22598},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 747, col: 26, offset: 22604},
								name: "SingleLineForExpression",
							},
						},
						&labeledExpr{
							pos:   position{line: 747, col: 50, offset: 22628},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 747, col: 56, offset: 22634},
								name: "BlockExpansion",
							},
						},
					},
				},
			},
		},
		{
			name: "CorgiComments",
			pos:  position{line: 903, col: 1, offset: 27563},
			expr: &actionExpr{
				pos: position{line: 903, col: 18, offset: 27580},
				run: (*parser).callonCorgiComments1,
				expr: &labeledExpr{
					pos:   position{line: 903, col: 18, offset: 27580},
					label: "commentsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 903, col: 28, offset: 27590},
						expr: &seqExpr{
							pos: position{line: 903, col: 29, offset: 27591},
							exprs: []any{
								&zeroOrOneExpr{
									pos: position{line: 903, col: 29, offset: 27591},
									expr: &oneOrMoreExpr{
										pos: position{line: 3810, col: 36, offset: 129590},
										expr: &seqExpr{
											pos: position{line: 3810, col: 37, offset: 129591},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 3810, col: 37, offset: 129591},
													expr: &charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3809, col: 36, offset: 129544},
													expr: &litMatcher{
														pos:        position{line: 3809, col: 36, offset: 129544},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3809, col: 42, offset: 129550},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 903, col: 38, offset: 27600},
									name: "CorgiComment",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "CorgiComment",
			pos:  position{line: 907, col: 1, offset: 27691},
			expr: &actionExpr{
				pos: position{line: 907, col: 17, offset: 27707},
				run: (*parser).callonCorgiComment1,
				expr: &seqExpr{
					pos: position{line: 907, col: 17, offset: 27707},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 907, col: 17, offset: 27707},
							val:        "//",
							ignoreCase: false,
							want:       "\"//\"",
						},
						&notExpr{
							pos: position{line: 907, col: 22, offset: 27712},
							expr: &litMatcher{
								pos:        position{line: 907, col: 23, offset: 27713},
								val:        "-",
								ignoreCase: false,
								want:       "\"-\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 907, col: 27, offset: 27717},
							label: "linesI",
							expr: &ruleRefExpr{
								pos:  position{line: 907, col: 34, offset: 27724},
								name: "corgiCommentLines",
							},
						},
					},
				},
			},
		},
		{
			name: "corgiCommentLines",
			pos:  position{line: 914, col: 1, offset: 27863},
			expr: &choiceExpr{
				pos: position{line: 914, col: 22, offset: 27884},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 914, col: 22, offset: 27884},
						run: (*parser).calloncorgiCommentLines2,
						expr: &seqExpr{
							pos: position{line: 914, col: 22, offset: 27884},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 914, col: 22, offset: 27884},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 914, col: 29, offset: 27891},
									label: "linesI",
									expr: &ruleRefExpr{
										pos:  position{line: 914, col: 36, offset: 27898},
										name: "corgiCommentBlock",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 916, col: 5, offset: 27945},
						run: (*parser).calloncorgiCommentLines17,
						expr: &labeledExpr{
							pos:   position{line: 916, col: 5, offset: 27945},
							label: "lineI",
							expr: &actionExpr{
								pos: position{line: 924, col: 21, offset: 28242},
								run: (*parser).calloncorgiCommentLines19,
								expr: &seqExpr{
									pos: position{line: 924, col: 21, offset: 28242},
									exprs: []any{
										&labeledExpr{
											pos:   position{line: 924, col: 21, offset: 28242},
											label: "commentI",
											expr: &zeroOrMoreExpr{
												pos: position{line: 924, col: 30, offset: 28251},
												expr: &charClassMatcher{
													pos:        position{line: 3797, col: 12, offset: 129189},
													val:        "[^\\r\\n]",
													chars:      []rune{'\r', '\n'},
													ignoreCase: false,
													inverted:   true,
												},
											},
										},
										&zeroOrMoreExpr{
											pos: position{line: 3796, col: 12, offset: 129156},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&choiceExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											alternatives: []any{
												&seqExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													exprs: []any{
														&zeroOrOneExpr{
															pos: position{line: 3796, col: 16, offset: 129160},
															expr: &litMatcher{
																pos:        position{line: 3796, col: 16, offset: 129160},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3796, col: 22, offset: 129166},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
												&notExpr{
													pos: position{line: 3795, col: 12, offset: 129142},
													expr: &anyMatcher{
														line: 3795, col: 13, offset: 129143,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "corgiCommentBlock",
			pos:  position{line: 920, col: 1, offset: 28044},
			expr: &actionExpr{
				pos: position{line: 920, col: 22, offset: 28065},
				run: (*parser).calloncorgiCommentBlock1,
				expr: &seqExpr{
					pos: position{line: 920, col: 22, offset: 28065},
					exprs: []any{
						&stateCodeExpr{
							pos: position{line: 4284, col: 11, offset: 150129},
							run: (*parser).calloncorgiCommentBlock3,
						},
						&labeledExpr{
							pos:   position{line: 920, col: 29, offset: 28072},
							label: "linesI",
							expr: &oneOrMoreExpr{
								pos: position{line: 920, col: 36, offset: 28079},
								expr: &seqExpr{
									pos: position{line: 920, col: 37, offset: 28080},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 920, col: 37, offset: 28080},
											expr: &oneOrMoreExpr{
												pos: position{line: 3810, col: 36, offset: 129590},
												expr: &seqExpr{
													pos: position{line: 3810, col: 37, offset: 129591},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 3810, col: 37, offset: 129591},
															expr: &charClassMatcher{
																pos:        position{line: 3808, col: 36, offset: 129503},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&zeroOrOneExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															expr: &litMatcher{
																pos:        position{line: 3809, col: 36, offset: 129544},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3809, col: 42, offset: 129550},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 920, col: 46, offset: 28089},
											name: "INDENTATION_IGNORE_ADDITIONAL",
										},
										&actionExpr{
											pos: position{line: 924, col: 21, offset: 28242},
											run: (*parser).calloncorgiCommentBlock16,
											expr: &seqExpr{
												pos: position{line: 924, col: 21, offset: 28242},
												exprs: []any{
													&labeledExpr{
														pos:   position{line: 924, col: 21, offset: 28242},
														label: "commentI",
														expr: &zeroOrMoreExpr{
															pos: position{line: 924, col: 30, offset: 28251},
															expr: &charClassMatcher{
																pos:        position{line: 3797, col: 12, offset: 129189},
																val:        "[^\\r\\n]",
																chars:      []rune{'\r', '\n'},
																ignoreCase: false,
																inverted:   true,
															},
														},
													},
													&zeroOrMoreExpr{
														pos: position{line: 3796, col: 12, offset: 129156},
														expr: &charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		expr: &litMatcher{
																			pos:        position{line: 3796, col: 16, offset: 129160},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3796, col: 22, offset: 129166},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3795, col: 12, offset: 129142},
																expr: &anyMatcher{
																	line: 3795, col: 13, offset: 129143,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&stateCodeExpr{
							pos: position{line: 4289, col: 11, offset: 150234},
							run: (*parser).calloncorgiCommentBlock30,
						},
					},
				},
			},
		},
		{
			name: "HTMLComment",
			pos:  position{line: 973, col: 1, offset: 29924},
			expr: &actionExpr{
				pos: position{line: 973, col: 16, offset: 29939},
				run: (*parser).callonHTMLComment1,
				expr: &seqExpr{
					pos: position{line: 973, col: 16, offset: 29939},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 973, col: 16, offset: 29939},
							val:        "//-",
							ignoreCase: false,
							want:       "\"//-\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 973, col: 22, offset: 29945},
							expr: &litMatcher{
								pos:        position{line: 973, col: 22, offset: 29945},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 973, col: 27, offset: 29950},
							label: "linesI",
							expr: &choiceExpr{
								pos: position{line: 974, col: 5, offset: 29963},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 974, col: 5, offset: 29963},
										run: (*parser).callonHTMLComment8,
										expr: &seqExpr{
											pos: position{line: 974, col: 5, offset: 29963},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 3796, col: 12, offset: 129156},
													expr: &charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&choiceExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													alternatives: []any{
														&seqExpr{
															pos: position{line: 3796, col: 16, offset: 129160},
															exprs: []any{
																&zeroOrOneExpr{
																	pos: position{line: 3796, col: 16, offset: 129160},
																	expr: &litMatcher{
																		pos:        position{line: 3796, col: 16, offset: 129160},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3796, col: 22, offset: 129166},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
														&notExpr{
															pos: position{line: 3795, col: 12, offset: 129142},
															expr: &anyMatcher{
																line: 3795, col: 13, offset: 129143,
															},
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 974, col: 9, offset: 29967},
													label: "linesI",
													expr: &ruleRefExpr{
														pos:  position{line: 974, col: 16, offset: 29974},
														name: "htmlCommentBlock",
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 976, col: 9, offset: 30028},
										run: (*parser).callonHTMLComment21,
										expr: &labeledExpr{
											pos:   position{line: 976, col: 9, offset: 30028},
											label: "lineI",
											expr: &actionExpr{
												pos: position{line: 990, col: 20, offset: 30446},
												run: (*parser).callonHTMLComment23,
												expr: &seqExpr{
													pos: position{line: 990, col: 20, offset: 30446},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 990, col: 20, offset: 30446},
															label: "commentI",
															expr: &zeroOrMoreExpr{
																pos: position{line: 990, col: 29, offset: 30455},
																expr: &charClassMatcher{
																	pos:        position{line: 3797, col: 12, offset: 129189},
																	val:        "[^\\r\\n]",
																	chars:      []rune{'\r', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 3796, col: 12, offset: 129156},
															expr: &charClassMatcher{
																pos:        position{line: 3808, col: 36, offset: 129503},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&choiceExpr{
															pos: position{line: 3796, col: 16, offset: 129160},
															alternatives: []any{
																&seqExpr{
																	pos: position{line: 3796, col: 16, offset: 129160},
																	exprs: []any{
																		&zeroOrOneExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			expr: &litMatcher{
																				pos:        position{line: 3796, col: 16, offset: 129160},
																				val:        "\r",
																				ignoreCase: false,
																				want:       "\"\\r\"",
																			},
																		},
																		&litMatcher{
																			pos:        position{line: 3796, col: 22, offset: 129166},
																			val:        "\n",
																			ignoreCase: false,
																			want:       "\"\\n\"",
																		},
																	},
																},
																&notExpr{
																	pos: position{line: 3795, col: 12, offset: 129142},
																	expr: &anyMatcher{
																		line: 3795, col: 13, offset: 129143,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "htmlCommentBlock",
			pos:  position{line: 986, col: 1, offset: 30252},
			expr: &actionExpr{
				pos: position{line: 986, col: 21, offset: 30272},
				run: (*parser).callonhtmlCommentBlock1,
				expr: &seqExpr{
					pos: position{line: 986, col: 21, offset: 30272},
					exprs: []any{
						&stateCodeExpr{
							pos: position{line: 4284, col: 11, offset: 150129},
							run: (*parser).callonhtmlCommentBlock3,
						},
						&labeledExpr{
							pos:   position{line: 986, col: 28, offset: 30279},
							label: "linesI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 986, col: 35, offset: 30286},
								expr: &seqExpr{
									pos: position{line: 986, col: 36, offset: 30287},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 986, col: 36, offset: 30287},
											expr: &oneOrMoreExpr{
												pos: position{line: 3810, col: 36, offset: 129590},
												expr: &seqExpr{
													pos: position{line: 3810, col: 37, offset: 129591},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 3810, col: 37, offset: 129591},
															expr: &charClassMatcher{
																pos:        position{line: 3808, col: 36, offset: 129503},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&zeroOrOneExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															expr: &litMatcher{
																pos:        position{line: 3809, col: 36, offset: 129544},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3809, col: 42, offset: 129550},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 986, col: 45, offset: 30296},
											name: "INDENTATION_IGNORE_ADDITIONAL",
										},
										&actionExpr{
											pos: position{line: 990, col: 20, offset: 30446},
											run: (*parser).callonhtmlCommentBlock16,
											expr: &seqExpr{
												pos: position{line: 990, col: 20, offset: 30446},
												exprs: []any{
													&labeledExpr{
														pos:   position{line: 990, col: 20, offset: 30446},
														label: "commentI",
														expr: &zeroOrMoreExpr{
															pos: position{line: 990, col: 29, offset: 30455},
															expr: &charClassMatcher{
																pos:        position{line: 3797, col: 12, offset: 129189},
																val:        "[^\\r\\n]",
																chars:      []rune{'\r', '\n'},
																ignoreCase: false,
																inverted:   true,
															},
														},
													},
													&zeroOrMoreExpr{
														pos: position{line: 3796, col: 12, offset: 129156},
														expr: &charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		expr: &litMatcher{
																			pos:        position{line: 3796, col: 16, offset: 129160},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3796, col: 22, offset: 129166},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3795, col: 12, offset: 129142},
																expr: &anyMatcher{
																	line: 3795, col: 13, offset: 129143,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&stateCodeExpr{
							pos: position{line: 4289, col: 11, offset: 150234},
							run: (*parser).callonhtmlCommentBlock30,
						},
					},
				},
			},
		},
		{
			name: "Element",
			pos:  position{line: 998, col: 1, offset: 30737},
			expr: &actionExpr{
				pos: position{line: 998, col: 12, offset: 30748},
				run: (*parser).callonElement1,
				expr: &seqExpr{
					pos: position{line: 998, col: 12, offset: 30748},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 998, col: 12, offset: 30748},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2879, col: 16, offset: 99517},
								expr: &charClassMatcher{
									pos:        position{line: 2865, col: 27, offset: 98856},
									val:        "[0-9A-Za-z]",
									ranges:     []rune{'0', '9', 'A', 'Z', 'a', 'z'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 998, col: 30, offset: 30766},
							label: "attrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 998, col: 37, offset: 30773},
								expr: &ruleRefExpr{
									pos:  position{line: 998, col: 37, offset: 30773},
									name: "AttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 998, col: 58, offset: 30794},
							label: "voidI",
							expr: &zeroOrOneExpr{
								pos: position{line: 998, col: 64, offset: 30800},
								expr: &litMatcher{
									pos:        position{line: 998, col: 64, offset: 30800},
									val:        "/",
									ignoreCase: false,
									want:       "\"/\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 998, col: 69, offset: 30805},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 998, col: 75, offset: 30811},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineElement",
			pos:  position{line: 1008, col: 1, offset: 31042},
			expr: &actionExpr{
				pos: position{line: 1008, col: 18, offset: 31059},
				run: (*parser).callonInlineElement1,
				expr: &seqExpr{
					pos: position{line: 1008, col: 18, offset: 31059},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1008, col: 18, offset: 31059},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2879, col: 16, offset: 99517},
								expr: &charClassMatcher{
									pos:        position{line: 2865, col: 27, offset: 98856},
									val:        "[0-9A-Za-z]",
									ranges:     []rune{'0', '9', 'A', 'Z', 'a', 'z'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1008, col: 36, offset: 31077},
							label: "attrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1008, col: 43, offset: 31084},
								expr: &ruleRefExpr{
									pos:  position{line: 1008, col: 43, offset: 31084},
									name: "SingleLineAttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1008, col: 74, offset: 31115},
							label: "voidI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1008, col: 80, offset: 31121},
								expr: &litMatcher{
									pos:        position{line: 1008, col: 80, offset: 31121},
									val:        "/",
									ignoreCase: false,
									want:       "\"/\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1008, col: 85, offset: 31126},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 1008, col: 91, offset: 31132},
								name: "Beait",
							},
						},
					},
				},
			},
		},
		{
			name: "DivShorthand",
			pos:  position{line: 1022, col: 1, offset: 31549},
			expr: &actionExpr{
				pos: position{line: 1022, col: 17, offset: 31565},
				run: (*parser).callonDivShorthand1,
				expr: &seqExpr{
					pos: position{line: 1022, col: 17, offset: 31565},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1022, col: 17, offset: 31565},
							label: "firstAttrI",
							expr: &choiceExpr{
								pos: position{line: 1022, col: 29, offset: 31577},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 1155, col: 19, offset: 36693},
										run: (*parser).callonDivShorthand5,
										expr: &seqExpr{
											pos: position{line: 1155, col: 19, offset: 36693},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 1155, col: 19, offset: 36693},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
												&labeledExpr{
													pos:   position{line: 1155, col: 23, offset: 36697},
													label: "nameI",
													expr: &oneOrMoreExpr{
														pos: position{line: 1155, col: 29, offset: 36703},
														expr: &charClassMatcher{
															pos:        position{line: 1155, col: 29, offset: 36703},
															val:        "[^ \\t\\r\\n.#()[]{}:]",
															chars:      []rune{' ', '\t', '\r', '\n', '.', '#', '(', ')', '[', ']', '{', '}', ':'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1160, col: 5, offset: 36829},
										run: (*parser).callonDivShorthand11,
										expr: &seqExpr{
											pos: position{line: 1160, col: 5, offset: 36829},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 1160, col: 5, offset: 36829},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
												&labeledExpr{
													pos:   position{line: 1160, col: 9, offset: 36833},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonDivShorthand15,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1136, col: 16, offset: 36245},
										run: (*parser).callonDivShorthand21,
										expr: &seqExpr{
											pos: position{line: 1136, col: 16, offset: 36245},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 1136, col: 16, offset: 36245},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
												&labeledExpr{
													pos:   position{line: 1136, col: 20, offset: 36249},
													label: "idI",
													expr: &oneOrMoreExpr{
														pos: position{line: 1136, col: 24, offset: 36253},
														expr: &charClassMatcher{
															pos:        position{line: 1136, col: 24, offset: 36253},
															val:        "[^ \\t\\r\\n.#()[]{}:]",
															chars:      []rune{' ', '\t', '\r', '\n', '.', '#', '(', ')', '[', ']', '{', '}', ':'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1141, col: 5, offset: 36372},
										run: (*parser).callonDivShorthand27,
										expr: &seqExpr{
											pos: position{line: 1141, col: 5, offset: 36372},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 1141, col: 5, offset: 36372},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
												&labeledExpr{
													pos:   position{line: 1141, col: 9, offset: 36376},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonDivShorthand31,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1022, col: 59, offset: 31607},
							label: "moreAttrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1022, col: 70, offset: 31618},
								expr: &ruleRefExpr{
									pos:  position{line: 1022, col: 70, offset: 31618},
									name: "AttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1022, col: 91, offset: 31639},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 1022, col: 97, offset: 31645},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineDivShorthand",
			pos:  position{line: 1030, col: 1, offset: 31906},
			expr: &actionExpr{
				pos: position{line: 1030, col: 23, offset: 31928},
				run: (*parser).callonInlineDivShorthand1,
				expr: &seqExpr{
					pos: position{line: 1030, col: 23, offset: 31928},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1030, col: 23, offset: 31928},
							label: "firstAttrI",
							expr: &choiceExpr{
								pos: position{line: 1030, col: 35, offset: 31940},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 1155, col: 19, offset: 36693},
										run: (*parser).callonInlineDivShorthand5,
										expr: &seqExpr{
											pos: position{line: 1155, col: 19, offset: 36693},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 1155, col: 19, offset: 36693},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
												&labeledExpr{
													pos:   position{line: 1155, col: 23, offset: 36697},
													label: "nameI",
													expr: &oneOrMoreExpr{
														pos: position{line: 1155, col: 29, offset: 36703},
														expr: &charClassMatcher{
															pos:        position{line: 1155, col: 29, offset: 36703},
															val:        "[^ \\t\\r\\n.#()[]{}:]",
															chars:      []rune{' ', '\t', '\r', '\n', '.', '#', '(', ')', '[', ']', '{', '}', ':'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1160, col: 5, offset: 36829},
										run: (*parser).callonInlineDivShorthand11,
										expr: &seqExpr{
											pos: position{line: 1160, col: 5, offset: 36829},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 1160, col: 5, offset: 36829},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
												&labeledExpr{
													pos:   position{line: 1160, col: 9, offset: 36833},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonInlineDivShorthand15,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1136, col: 16, offset: 36245},
										run: (*parser).callonInlineDivShorthand21,
										expr: &seqExpr{
											pos: position{line: 1136, col: 16, offset: 36245},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 1136, col: 16, offset: 36245},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
												&labeledExpr{
													pos:   position{line: 1136, col: 20, offset: 36249},
													label: "idI",
													expr: &oneOrMoreExpr{
														pos: position{line: 1136, col: 24, offset: 36253},
														expr: &charClassMatcher{
															pos:        position{line: 1136, col: 24, offset: 36253},
															val:        "[^ \\t\\r\\n.#()[]{}:]",
															chars:      []rune{' ', '\t', '\r', '\n', '.', '#', '(', ')', '[', ']', '{', '}', ':'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1141, col: 5, offset: 36372},
										run: (*parser).callonInlineDivShorthand27,
										expr: &seqExpr{
											pos: position{line: 1141, col: 5, offset: 36372},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 1141, col: 5, offset: 36372},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
												&labeledExpr{
													pos:   position{line: 1141, col: 9, offset: 36376},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonInlineDivShorthand31,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1030, col: 65, offset: 31970},
							label: "moreAttrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1030, col: 76, offset: 31981},
								expr: &ruleRefExpr{
									pos:  position{line: 1030, col: 76, offset: 31981},
									name: "SingleLineAttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1030, col: 107, offset: 32012},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 1030, col: 113, offset: 32018},
								name: "Beait",
							},
						},
					},
				},
			},
		},
		{
			name: "And",
			pos:  position{line: 1042, col: 1, offset: 32456},
			expr: &choiceExpr{
				pos: position{line: 1042, col: 8, offset: 32463},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1042, col: 8, offset: 32463},
						run: (*parser).callonAnd2,
						expr: &seqExpr{
							pos: position{line: 1042, col: 8, offset: 32463},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1042, col: 8, offset: 32463},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 1042, col: 12, offset: 32467},
									label: "collsI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1042, col: 19, offset: 32474},
										expr: &ruleRefExpr{
											pos:  position{line: 1042, col: 19, offset: 32474},
											name: "AttributeCollection",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1047, col: 5, offset: 32629},
						run: (*parser).callonAnd17,
						expr: &seqExpr{
							pos: position{line: 1047, col: 5, offset: 32629},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1047, col: 5, offset: 32629},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 1047, col: 9, offset: 32633},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonAnd21,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1062, col: 5, offset: 33229},
						run: (*parser).callonAnd36,
						expr: &seqExpr{
							pos: position{line: 1062, col: 5, offset: 33229},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1062, col: 5, offset: 33229},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 1062, col: 9, offset: 33233},
									label: "collsI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1062, col: 16, offset: 33240},
										expr: &ruleRefExpr{
											pos:  position{line: 1062, col: 16, offset: 33240},
											name: "AttributeCollection",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1062, col: 37, offset: 33261},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonAnd43,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&oneOrMoreExpr{
									pos: position{line: 1062, col: 46, offset: 33270},
									expr: &charClassMatcher{
										pos:        position{line: 3797, col: 12, offset: 129189},
										val:        "[^\\r\\n]",
										chars:      []rune{'\r', '\n'},
										ignoreCase: false,
										inverted:   true,
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineAnd",
			pos:  position{line: 1084, col: 1, offset: 34140},
			expr: &choiceExpr{
				pos: position{line: 1084, col: 14, offset: 34153},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1084, col: 14, offset: 34153},
						run: (*parser).callonInlineAnd2,
						expr: &seqExpr{
							pos: position{line: 1084, col: 14, offset: 34153},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1084, col: 14, offset: 34153},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 1084, col: 18, offset: 34157},
									label: "collsI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1084, col: 25, offset: 34164},
										expr: &ruleRefExpr{
											pos:  position{line: 1084, col: 25, offset: 34164},
											name: "SingleLineAttributeCollection",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1089, col: 5, offset: 34329},
						run: (*parser).callonInlineAnd17,
						expr: &seqExpr{
							pos: position{line: 1089, col: 5, offset: 34329},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1089, col: 5, offset: 34329},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 1089, col: 9, offset: 34333},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonInlineAnd21,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1104, col: 5, offset: 34929},
						run: (*parser).callonInlineAnd36,
						expr: &seqExpr{
							pos: position{line: 1104, col: 5, offset: 34929},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1104, col: 5, offset: 34929},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 1104, col: 9, offset: 34933},
									label: "collsI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1104, col: 16, offset: 34940},
										expr: &ruleRefExpr{
											pos:  position{line: 1104, col: 16, offset: 34940},
											name: "SingleLineAttributeCollection",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1104, col: 47, offset: 34971},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonInlineAnd43,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&oneOrMoreExpr{
									pos: position{line: 1104, col: 56, offset: 34980},
									expr: &charClassMatcher{
										pos:        position{line: 3797, col: 12, offset: 129189},
										val:        "[^\\r\\n]",
										chars:      []rune{'\r', '\n'},
										ignoreCase: false,
										inverted:   true,
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeCollection",
			pos:  position{line: 1130, col: 1, offset: 36044},
			expr: &choiceExpr{
				pos: position{line: 1130, col: 34, offset: 36077},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1136, col: 16, offset: 36245},
						run: (*parser).callonAttributeCollection2,
						expr: &seqExpr{
							pos: position{line: 1136, col: 16, offset: 36245},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1136, col: 16, offset: 36245},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1136, col: 20, offset: 36249},
									label: "idI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1136, col: 24, offset: 36253},
										expr: &charClassMatcher{
											pos:        position{line: 1136, col: 24, offset: 36253},
											val:        "[^ \\t\\r\\n.#()[]{}:]",
											chars:      []rune{' ', '\t', '\r', '\n', '.', '#', '(', ')', '[', ']', '{', '}', ':'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1141, col: 5, offset: 36372},
						run: (*parser).callonAttributeCollection8,
						expr: &seqExpr{
							pos: position{line: 1141, col: 5, offset: 36372},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1141, col: 5, offset: 36372},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1141, col: 9, offset: 36376},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonAttributeCollection12,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1155, col: 19, offset: 36693},
						run: (*parser).callonAttributeCollection18,
						expr: &seqExpr{
							pos: position{line: 1155, col: 19, offset: 36693},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1155, col: 19, offset: 36693},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&labeledExpr{
									pos:   position{line: 1155, col: 23, offset: 36697},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1155, col: 29, offset: 36703},
										expr: &charClassMatcher{
											pos:        position{line: 1155, col: 29, offset: 36703},
											val:        "[^ \\t\\r\\n.#()[]{}:]",
											chars:      []rune{' ', '\t', '\r', '\n', '.', '#', '(', ')', '[', ']', '{', '}', ':'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1160, col: 5, offset: 36829},
						run: (*parser).callonAttributeCollection24,
						expr: &seqExpr{
							pos: position{line: 1160, col: 5, offset: 36829},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1160, col: 5, offset: 36829},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&labeledExpr{
									pos:   position{line: 1160, col: 9, offset: 36833},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonAttributeCollection28,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1130, col: 65, offset: 36108},
						name: "AttributeList",
					},
				},
			},
		},
		{
			name: "SingleLineAttributeCollection",
			pos:  position{line: 1131, col: 1, offset: 36122},
			expr: &choiceExpr{
				pos: position{line: 1131, col: 34, offset: 36155},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1136, col: 16, offset: 36245},
						run: (*parser).callonSingleLineAttributeCollection2,
						expr: &seqExpr{
							pos: position{line: 1136, col: 16, offset: 36245},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1136, col: 16, offset: 36245},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1136, col: 20, offset: 36249},
									label: "idI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1136, col: 24, offset: 36253},
										expr: &charClassMatcher{
											pos:        position{line: 1136, col: 24, offset: 36253},
											val:        "[^ \\t\\r\\n.#()[]{}:]",
											chars:      []rune{' ', '\t', '\r', '\n', '.', '#', '(', ')', '[', ']', '{', '}', ':'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1141, col: 5, offset: 36372},
						run: (*parser).callonSingleLineAttributeCollection8,
						expr: &seqExpr{
							pos: position{line: 1141, col: 5, offset: 36372},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1141, col: 5, offset: 36372},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1141, col: 9, offset: 36376},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonSingleLineAttributeCollection12,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1155, col: 19, offset: 36693},
						run: (*parser).callonSingleLineAttributeCollection18,
						expr: &seqExpr{
							pos: position{line: 1155, col: 19, offset: 36693},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1155, col: 19, offset: 36693},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&labeledExpr{
									pos:   position{line: 1155, col: 23, offset: 36697},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1155, col: 29, offset: 36703},
										expr: &charClassMatcher{
											pos:        position{line: 1155, col: 29, offset: 36703},
											val:        "[^ \\t\\r\\n.#()[]{}:]",
											chars:      []rune{' ', '\t', '\r', '\n', '.', '#', '(', ')', '[', ']', '{', '}', ':'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1160, col: 5, offset: 36829},
						run: (*parser).callonSingleLineAttributeCollection24,
						expr: &seqExpr{
							pos: position{line: 1160, col: 5, offset: 36829},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1160, col: 5, offset: 36829},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&labeledExpr{
									pos:   position{line: 1160, col: 9, offset: 36833},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonSingleLineAttributeCollection28,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1131, col: 65, offset: 36186},
						name: "SingleLineAttributeList",
					},
				},
			},
		},
		{
			name: "AttributeList",
			pos:  position{line: 1174, col: 1, offset: 37152},
			expr: &choiceExpr{
				pos: position{line: 1174, col: 18, offset: 37169},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1174, col: 18, offset: 37169},
						run: (*parser).callonAttributeList2,
						expr: &seqExpr{
							pos: position{line: 1174, col: 18, offset: 37169},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1174, col: 18, offset: 37169},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1174, col: 22, offset: 37173},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1174, col: 26, offset: 37177},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1174, col: 38, offset: 37189},
										expr: &ruleRefExpr{
											pos:  position{line: 1174, col: 38, offset: 37189},
											name: "attributes",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1174, col: 50, offset: 37201},
									expr: &litMatcher{
										pos:        position{line: 1174, col: 50, offset: 37201},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1174, col: 55, offset: 37206},
									expr: &seqExpr{
										pos: position{line: 1174, col: 56, offset: 37207},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 1174, col: 56, offset: 37207},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1174, col: 60, offset: 37211},
												expr: &choiceExpr{
													pos: position{line: 3812, col: 20, offset: 129621},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															exprs: []any{
																&zeroOrOneExpr{
																	pos: position{line: 3809, col: 36, offset: 129544},
																	expr: &litMatcher{
																		pos:        position{line: 3809, col: 36, offset: 129544},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3809, col: 42, offset: 129550},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1174, col: 66, offset: 37217},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonAttributeList28,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1180, col: 5, offset: 37423},
						run: (*parser).callonAttributeList30,
						expr: &seqExpr{
							pos: position{line: 1180, col: 5, offset: 37423},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1180, col: 5, offset: 37423},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1180, col: 9, offset: 37427},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1180, col: 13, offset: 37431},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1180, col: 25, offset: 37443},
										expr: &ruleRefExpr{
											pos:  position{line: 1180, col: 25, offset: 37443},
											name: "attributes",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1180, col: 37, offset: 37455},
									expr: &seqExpr{
										pos: position{line: 1180, col: 38, offset: 37456},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 1180, col: 38, offset: 37456},
												expr: &litMatcher{
													pos:        position{line: 1180, col: 38, offset: 37456},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 1180, col: 43, offset: 37461},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1180, col: 49, offset: 37467},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonAttributeList49,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "attributes",
			pos:  position{line: 1199, col: 1, offset: 38042},
			expr: &actionExpr{
				pos: position{line: 1199, col: 15, offset: 38056},
				run: (*parser).callonattributes1,
				expr: &seqExpr{
					pos: position{line: 1199, col: 15, offset: 38056},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1199, col: 15, offset: 38056},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 1199, col: 22, offset: 38063},
								name: "Attribute",
							},
						},
						&labeledExpr{
							pos:   position{line: 1199, col: 32, offset: 38073},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1199, col: 38, offset: 38079},
								expr: &seqExpr{
									pos: position{line: 1199, col: 39, offset: 38080},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 1199, col: 39, offset: 38080},
											expr: &litMatcher{
												pos:        position{line: 1199, col: 39, offset: 38080},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 1199, col: 44, offset: 38085},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 1199, col: 48, offset: 38089},
											expr: &choiceExpr{
												pos: position{line: 3812, col: 20, offset: 129621},
												alternatives: []any{
													&charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														exprs: []any{
															&zeroOrOneExpr{
																pos: position{line: 3809, col: 36, offset: 129544},
																expr: &litMatcher{
																	pos:        position{line: 3809, col: 36, offset: 129544},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3809, col: 42, offset: 129550},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1199, col: 52, offset: 38093},
											name: "Attribute",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineAttributeList",
			pos:  position{line: 1210, col: 1, offset: 38363},
			expr: &choiceExpr{
				pos: position{line: 1210, col: 28, offset: 38390},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1210, col: 28, offset: 38390},
						run: (*parser).callonSingleLineAttributeList2,
						expr: &seqExpr{
							pos: position{line: 1210, col: 28, offset: 38390},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1210, col: 28, offset: 38390},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1210, col: 32, offset: 38394},
									expr: &litMatcher{
										pos:        position{line: 1210, col: 32, offset: 38394},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1210, col: 37, offset: 38399},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1210, col: 49, offset: 38411},
										expr: &ruleRefExpr{
											pos:  position{line: 1210, col: 49, offset: 38411},
											name: "singleLineAttributes",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1210, col: 71, offset: 38433},
									expr: &litMatcher{
										pos:        position{line: 1210, col: 71, offset: 38433},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1210, col: 76, offset: 38438},
									expr: &seqExpr{
										pos: position{line: 1210, col: 77, offset: 38439},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 1210, col: 77, offset: 38439},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1210, col: 81, offset: 38443},
												expr: &litMatcher{
													pos:        position{line: 1210, col: 81, offset: 38443},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1210, col: 88, offset: 38450},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonSingleLineAttributeList18,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1216, col: 5, offset: 38656},
						run: (*parser).callonSingleLineAttributeList20,
						expr: &seqExpr{
							pos: position{line: 1216, col: 5, offset: 38656},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1216, col: 5, offset: 38656},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1216, col: 9, offset: 38660},
									expr: &litMatcher{
										pos:        position{line: 1216, col: 9, offset: 38660},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1216, col: 14, offset: 38665},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1216, col: 26, offset: 38677},
										expr: &ruleRefExpr{
											pos:  position{line: 1216, col: 26, offset: 38677},
											name: "singleLineAttributes",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1216, col: 48, offset: 38699},
									expr: &seqExpr{
										pos: position{line: 1216, col: 49, offset: 38700},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 1216, col: 49, offset: 38700},
												expr: &litMatcher{
													pos:        position{line: 1216, col: 49, offset: 38700},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 1216, col: 54, offset: 38705},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1216, col: 60, offset: 38711},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonSingleLineAttributeList34,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineAttributes",
			pos:  position{line: 1235, col: 1, offset: 39286},
			expr: &actionExpr{
				pos: position{line: 1235, col: 25, offset: 39310},
				run: (*parser).callonsingleLineAttributes1,
				expr: &seqExpr{
					pos: position{line: 1235, col: 25, offset: 39310},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1235, col: 25, offset: 39310},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 1235, col: 32, offset: 39317},
								name: "Attribute",
							},
						},
						&labeledExpr{
							pos:   position{line: 1235, col: 42, offset: 39327},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1235, col: 48, offset: 39333},
								expr: &seqExpr{
									pos: position{line: 1235, col: 49, offset: 39334},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 1235, col: 49, offset: 39334},
											expr: &litMatcher{
												pos:        position{line: 1235, col: 49, offset: 39334},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 1235, col: 54, offset: 39339},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 1235, col: 58, offset: 39343},
											expr: &litMatcher{
												pos:        position{line: 1235, col: 58, offset: 39343},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1235, col: 63, offset: 39348},
											name: "SingleLineAttribute",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Attribute",
			pos:  position{line: 1250, col: 1, offset: 39812},
			expr: &choiceExpr{
				pos: position{line: 1250, col: 24, offset: 39835},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 1250, col: 24, offset: 39835},
						name: "MixinCallAttribute",
					},
					&actionExpr{
						pos: position{line: 1314, col: 19, offset: 41940},
						run: (*parser).callonAttribute3,
						expr: &seqExpr{
							pos: position{line: 1314, col: 19, offset: 41940},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1314, col: 19, offset: 41940},
									val:        "&&",
									ignoreCase: false,
									want:       "\"&&\"",
								},
								&andExpr{
									pos: position{line: 1314, col: 24, offset: 41945},
									expr: &choiceExpr{
										pos: position{line: 1314, col: 26, offset: 41947},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 1314, col: 31, offset: 41952},
												val:        "[,)]",
												chars:      []rune{',', ')'},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1250, col: 62, offset: 39873},
						name: "SimpleAttribute",
					},
				},
			},
		},
		{
			name: "SingleLineAttribute",
			pos:  position{line: 1251, col: 1, offset: 39889},
			expr: &choiceExpr{
				pos: position{line: 1251, col: 24, offset: 39912},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 1251, col: 24, offset: 39912},
						name: "SingleLineMixinCallAttribute",
					},
					&actionExpr{
						pos: position{line: 1314, col: 19, offset: 41940},
						run: (*parser).callonSingleLineAttribute3,
						expr: &seqExpr{
							pos: position{line: 1314, col: 19, offset: 41940},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1314, col: 19, offset: 41940},
									val:        "&&",
									ignoreCase: false,
									want:       "\"&&\"",
								},
								&andExpr{
									pos: position{line: 1314, col: 24, offset: 41945},
									expr: &choiceExpr{
										pos: position{line: 1314, col: 26, offset: 41947},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 1314, col: 31, offset: 41952},
												val:        "[,)]",
												chars:      []rune{',', ')'},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1251, col: 72, offset: 39960},
						name: "SingleLineSimpleAttribute",
					},
				},
			},
		},
		{
			name: "SimpleAttribute",
			pos:  position{line: 1258, col: 1, offset: 40061},
			expr: &choiceExpr{
				pos: position{line: 1258, col: 30, offset: 40090},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 1258, col: 30, offset: 40090},
						name: "simpleValueAttribute",
					},
					&actionExpr{
						pos: position{line: 1303, col: 27, offset: 41760},
						run: (*parser).callonSimpleAttribute3,
						expr: &seqExpr{
							pos: position{line: 1303, col: 27, offset: 41760},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 1303, col: 27, offset: 41760},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1253, col: 18, offset: 40004},
										expr: &seqExpr{
											pos: position{line: 1253, col: 19, offset: 40005},
											exprs: []any{
												&notExpr{
													pos: position{line: 1253, col: 19, offset: 40005},
													expr: &charClassMatcher{
														pos:        position{line: 1253, col: 20, offset: 40006},
														val:        "[(),]",
														chars:      []rune{'(', ')', ','},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2886, col: 26, offset: 99797},
													expr: &charClassMatcher{
														pos:        position{line: 2862, col: 27, offset: 98705},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2886, col: 101, offset: 99872,
												},
											},
										},
									},
								},
								&notExpr{
									pos: position{line: 1303, col: 47, offset: 41780},
									expr: &seqExpr{
										pos: position{line: 1303, col: 49, offset: 41782},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 1303, col: 49, offset: 41782},
												expr: &litMatcher{
													pos:        position{line: 1303, col: 49, offset: 41782},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&charClassMatcher{
												pos:        position{line: 1303, col: 54, offset: 41787},
												val:        "[!=]",
												chars:      []rune{'!', '='},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineSimpleAttribute",
			pos:  position{line: 1259, col: 1, offset: 40136},
			expr: &choiceExpr{
				pos: position{line: 1259, col: 30, offset: 40165},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 1259, col: 30, offset: 40165},
						name: "singleLineSimpleValueAttribute",
					},
					&actionExpr{
						pos: position{line: 1303, col: 27, offset: 41760},
						run: (*parser).callonSingleLineSimpleAttribute3,
						expr: &seqExpr{
							pos: position{line: 1303, col: 27, offset: 41760},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 1303, col: 27, offset: 41760},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1253, col: 18, offset: 40004},
										expr: &seqExpr{
											pos: position{line: 1253, col: 19, offset: 40005},
											exprs: []any{
												&notExpr{
													pos: position{line: 1253, col: 19, offset: 40005},
													expr: &charClassMatcher{
														pos:        position{line: 1253, col: 20, offset: 40006},
														val:        "[(),]",
														chars:      []rune{'(', ')', ','},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2886, col: 26, offset: 99797},
													expr: &charClassMatcher{
														pos:        position{line: 2862, col: 27, offset: 98705},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2886, col: 101, offset: 99872,
												},
											},
										},
									},
								},
								&notExpr{
									pos: position{line: 1303, col: 47, offset: 41780},
									expr: &seqExpr{
										pos: position{line: 1303, col: 49, offset: 41782},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 1303, col: 49, offset: 41782},
												expr: &litMatcher{
													pos:        position{line: 1303, col: 49, offset: 41782},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&charClassMatcher{
												pos:        position{line: 1303, col: 54, offset: 41787},
												val:        "[!=]",
												chars:      []rune{'!', '='},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "simpleValueAttribute",
			pos:  position{line: 1261, col: 1, offset: 40222},
			expr: &choiceExpr{
				pos: position{line: 1261, col: 25, offset: 40246},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1261, col: 25, offset: 40246},
						run: (*parser).callonsimpleValueAttribute2,
						expr: &seqExpr{
							pos: position{line: 1261, col: 25, offset: 40246},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 1261, col: 25, offset: 40246},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1253, col: 18, offset: 40004},
										expr: &seqExpr{
											pos: position{line: 1253, col: 19, offset: 40005},
											exprs: []any{
												&notExpr{
													pos: position{line: 1253, col: 19, offset: 40005},
													expr: &charClassMatcher{
														pos:        position{line: 1253, col: 20, offset: 40006},
														val:        "[(),]",
														chars:      []rune{'(', ')', ','},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2886, col: 26, offset: 99797},
													expr: &charClassMatcher{
														pos:        position{line: 2862, col: 27, offset: 98705},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2886, col: 101, offset: 99872,
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1261, col: 45, offset: 40266},
									expr: &litMatcher{
										pos:        position{line: 1261, col: 45, offset: 40266},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1261, col: 50, offset: 40271},
									label: "assignPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonsimpleValueAttribute15,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1261, col: 65, offset: 40286},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1261, col: 69, offset: 40290},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1261, col: 73, offset: 40294},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonsimpleValueAttribute30,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1261, col: 82, offset: 40303},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1261, col: 88, offset: 40309},
										name: "Expression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1268, col: 5, offset: 40526},
						run: (*parser).callonsimpleValueAttribute38,
						expr: &seqExpr{
							pos: position{line: 1268, col: 5, offset: 40526},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 1268, col: 5, offset: 40526},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1253, col: 18, offset: 40004},
										expr: &seqExpr{
											pos: position{line: 1253, col: 19, offset: 40005},
											exprs: []any{
												&notExpr{
													pos: position{line: 1253, col: 19, offset: 40005},
													expr: &charClassMatcher{
														pos:        position{line: 1253, col: 20, offset: 40006},
														val:        "[(),]",
														chars:      []rune{'(', ')', ','},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2886, col: 26, offset: 99797},
													expr: &charClassMatcher{
														pos:        position{line: 2862, col: 27, offset: 98705},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2886, col: 101, offset: 99872,
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1268, col: 25, offset: 40546},
									expr: &litMatcher{
										pos:        position{line: 1268, col: 25, offset: 40546},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1268, col: 30, offset: 40551},
									label: "assignPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonsimpleValueAttribute51,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1268, col: 45, offset: 40566},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&labeledExpr{
									pos:   position{line: 1268, col: 49, offset: 40570},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonsimpleValueAttribute59,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineSimpleValueAttribute",
			pos:  position{line: 1282, col: 1, offset: 40967},
			expr: &choiceExpr{
				pos: position{line: 1282, col: 35, offset: 41001},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1282, col: 35, offset: 41001},
						run: (*parser).callonsingleLineSimpleValueAttribute2,
						expr: &seqExpr{
							pos: position{line: 1282, col: 35, offset: 41001},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 1282, col: 35, offset: 41001},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1253, col: 18, offset: 40004},
										expr: &seqExpr{
											pos: position{line: 1253, col: 19, offset: 40005},
											exprs: []any{
												&notExpr{
													pos: position{line: 1253, col: 19, offset: 40005},
													expr: &charClassMatcher{
														pos:        position{line: 1253, col: 20, offset: 40006},
														val:        "[(),]",
														chars:      []rune{'(', ')', ','},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2886, col: 26, offset: 99797},
													expr: &charClassMatcher{
														pos:        position{line: 2862, col: 27, offset: 98705},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2886, col: 101, offset: 99872,
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1282, col: 55, offset: 41021},
									expr: &litMatcher{
										pos:        position{line: 1282, col: 55, offset: 41021},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1282, col: 60, offset: 41026},
									label: "assignPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonsingleLineSimpleValueAttribute15,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1282, col: 75, offset: 41041},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1282, col: 79, offset: 41045},
									expr: &litMatcher{
										pos:        position{line: 1282, col: 79, offset: 41045},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1282, col: 84, offset: 41050},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1282, col: 90, offset: 41056},
										name: "Expression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1289, col: 5, offset: 41277},
						run: (*parser).callonsingleLineSimpleValueAttribute26,
						expr: &seqExpr{
							pos: position{line: 1289, col: 5, offset: 41277},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 1289, col: 5, offset: 41277},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1253, col: 18, offset: 40004},
										expr: &seqExpr{
											pos: position{line: 1253, col: 19, offset: 40005},
											exprs: []any{
												&notExpr{
													pos: position{line: 1253, col: 19, offset: 40005},
													expr: &charClassMatcher{
														pos:        position{line: 1253, col: 20, offset: 40006},
														val:        "[(),]",
														chars:      []rune{'(', ')', ','},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2886, col: 26, offset: 99797},
													expr: &charClassMatcher{
														pos:        position{line: 2862, col: 27, offset: 98705},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2886, col: 101, offset: 99872,
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1289, col: 25, offset: 41297},
									expr: &litMatcher{
										pos:        position{line: 1289, col: 25, offset: 41297},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1289, col: 30, offset: 41302},
									label: "assignPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonsingleLineSimpleValueAttribute39,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1289, col: 45, offset: 41317},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&labeledExpr{
									pos:   position{line: 1289, col: 49, offset: 41321},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonsingleLineSimpleValueAttribute47,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "MixinCallAttribute",
			pos:  position{line: 1322, col: 1, offset: 42051},
			expr: &actionExpr{
				pos: position{line: 1322, col: 23, offset: 42073},
				run: (*parser).callonMixinCallAttribute1,
				expr: &seqExpr{
					pos: position{line: 1322, col: 23, offset: 42073},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1322, col: 23, offset: 42073},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 1253, col: 18, offset: 40004},
								expr: &seqExpr{
									pos: position{line: 1253, col: 19, offset: 40005},
									exprs: []any{
										&notExpr{
											pos: position{line: 1253, col: 19, offset: 40005},
											expr: &charClassMatcher{
												pos:        position{line: 1253, col: 20, offset: 40006},
												val:        "[(),]",
												chars:      []rune{'(', ')', ','},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&notExpr{
											pos: position{line: 2886, col: 26, offset: 99797},
											expr: &charClassMatcher{
												pos:        position{line: 2862, col: 27, offset: 98705},
												val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
												chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
												ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&anyMatcher{
											line: 2886, col: 101, offset: 99872,
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1322, col: 43, offset: 42093},
							expr: &litMatcher{
								pos:        position{line: 1322, col: 43, offset: 42093},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1322, col: 48, offset: 42098},
							label: "assignPosI",
							expr: &actionExpr{
								pos: position{line: 3799, col: 8, offset: 129205},
								run: (*parser).callonMixinCallAttribute14,
								expr: &choiceExpr{
									pos: position{line: 3799, col: 9, offset: 129206},
									alternatives: []any{
										&andExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											expr: &anyMatcher{
												line: 3799, col: 10, offset: 129207,
											},
										},
										&notExpr{
											pos: position{line: 3799, col: 14, offset: 129211},
											expr: &anyMatcher{
												line: 3799, col: 15, offset: 129212,
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1322, col: 63, offset: 42113},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1322, col: 67, offset: 42117},
							expr: &choiceExpr{
								pos: position{line: 3812, col: 20, offset: 129621},
								alternatives: []any{
									&charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
									&seqExpr{
										pos: position{line: 3809, col: 36, offset: 129544},
										exprs: []any{
											&zeroOrOneExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												expr: &litMatcher{
													pos:        position{line: 3809, col: 36, offset: 129544},
													val:        "\r",
													ignoreCase: false,
													want:       "\"\\r\"",
												},
											},
											&litMatcher{
												pos:        position{line: 3809, col: 42, offset: 129550},
												val:        "\n",
												ignoreCase: false,
												want:       "\"\\n\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1322, col: 71, offset: 42121},
							label: "callI",
							expr: &ruleRefExpr{
								pos:  position{line: 1322, col: 77, offset: 42127},
								name: "mixinCallAttributeCall",
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineMixinCallAttribute",
			pos:  position{line: 1332, col: 1, offset: 42409},
			expr: &actionExpr{
				pos: position{line: 1332, col: 33, offset: 42441},
				run: (*parser).callonSingleLineMixinCallAttribute1,
				expr: &seqExpr{
					pos: position{line: 1332, col: 33, offset: 42441},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1332, col: 33, offset: 42441},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 1253, col: 18, offset: 40004},
								expr: &seqExpr{
									pos: position{line: 1253, col: 19, offset: 40005},
									exprs: []any{
										&notExpr{
											pos: position{line: 1253, col: 19, offset: 40005},
											expr: &charClassMatcher{
												pos:        position{line: 1253, col: 20, offset: 40006},
												val:        "[(),]",
												chars:      []rune{'(', ')', ','},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&notExpr{
											pos: position{line: 2886, col: 26, offset: 99797},
											expr: &charClassMatcher{
												pos:        position{line: 2862, col: 27, offset: 98705},
												val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
												chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
												ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&anyMatcher{
											line: 2886, col: 101, offset: 99872,
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1332, col: 53, offset: 42461},
							expr: &litMatcher{
								pos:        position{line: 1332, col: 53, offset: 42461},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1332, col: 58, offset: 42466},
							label: "assignPosI",
							expr: &actionExpr{
								pos: position{line: 3799, col: 8, offset: 129205},
								run: (*parser).callonSingleLineMixinCallAttribute14,
								expr: &choiceExpr{
									pos: position{line: 3799, col: 9, offset: 129206},
									alternatives: []any{
										&andExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											expr: &anyMatcher{
												line: 3799, col: 10, offset: 129207,
											},
										},
										&notExpr{
											pos: position{line: 3799, col: 14, offset: 129211},
											expr: &anyMatcher{
												line: 3799, col: 15, offset: 129212,
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1332, col: 73, offset: 42481},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1332, col: 77, offset: 42485},
							expr: &litMatcher{
								pos:        position{line: 1332, col: 77, offset: 42485},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1332, col: 82, offset: 42490},
							label: "callI",
							expr: &ruleRefExpr{
								pos:  position{line: 1332, col: 88, offset: 42496},
								name: "singleLineMixinCallAttributeCall",
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallAttributeCall",
			pos:  position{line: 1343, col: 1, offset: 42789},
			expr: &actionExpr{
				pos: position{line: 1343, col: 27, offset: 42815},
				run: (*parser).callonmixinCallAttributeCall1,
				expr: &seqExpr{
					pos: position{line: 1343, col: 27, offset: 42815},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1343, col: 27, offset: 42815},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 1343, col: 31, offset: 42819},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1343, col: 42, offset: 42830},
								expr: &seqExpr{
									pos: position{line: 1343, col: 43, offset: 42831},
									exprs: []any{
										&choiceExpr{
											pos: position{line: 759, col: 10, offset: 23002},
											alternatives: []any{
												&actionExpr{
													pos: position{line: 759, col: 10, offset: 23002},
													run: (*parser).callonmixinCallAttributeCall8,
													expr: &labeledExpr{
														pos:   position{line: 759, col: 10, offset: 23002},
														label: "identI",
														expr: &seqExpr{
															pos: position{line: 2410, col: 17, offset: 81833},
															exprs: []any{
																&charClassMatcher{
																	pos:        position{line: 2393, col: 20, offset: 81588},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2410, col: 26, offset: 81842},
																	expr: &charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 761, col: 5, offset: 23096},
													run: (*parser).callonmixinCallAttributeCall14,
													expr: &seqExpr{
														pos: position{line: 761, col: 5, offset: 23096},
														exprs: []any{
															&labeledExpr{
																pos:   position{line: 761, col: 5, offset: 23096},
																label: "identI",
																expr: &seqExpr{
																	pos: position{line: 761, col: 13, offset: 23104},
																	exprs: []any{
																		&zeroOrOneExpr{
																			pos: position{line: 761, col: 13, offset: 23104},
																			expr: &litMatcher{
																				pos:        position{line: 761, col: 13, offset: 23104},
																				val:        "$",
																				ignoreCase: false,
																				want:       "\"$\"",
																			},
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 761, col: 18, offset: 23109},
																			expr: &choiceExpr{
																				pos: position{line: 761, col: 19, offset: 23110},
																				alternatives: []any{
																					&seqExpr{
																						pos: position{line: 761, col: 19, offset: 23110},
																						exprs: []any{
																							&charClassMatcher{
																								pos:        position{line: 761, col: 19, offset: 23110},
																								val:        "[\\pNd]",
																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 761, col: 28, offset: 23119},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 761, col: 38, offset: 23129},
																						val:        "[_-\\pL]",
																						chars:      []rune{'_', '-'},
																						classes:    []*unicode.RangeTable{rangeTable("L")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&labeledExpr{
																pos:   position{line: 761, col: 49, offset: 23140},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3799, col: 8, offset: 129205},
																	run: (*parser).callonmixinCallAttributeCall27,
																	expr: &choiceExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		alternatives: []any{
																			&andExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				expr: &anyMatcher{
																					line: 3799, col: 10, offset: 129207,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3799, col: 14, offset: 129211},
																				expr: &anyMatcher{
																					line: 3799, col: 15, offset: 129212,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 1343, col: 49, offset: 42837},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1343, col: 55, offset: 42843},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 773, col: 14, offset: 23557},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 773, col: 14, offset: 23557},
										run: (*parser).callonmixinCallAttributeCall36,
										expr: &labeledExpr{
											pos:   position{line: 773, col: 14, offset: 23557},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 759, col: 10, offset: 23002},
												alternatives: []any{
													&actionExpr{
														pos: position{line: 759, col: 10, offset: 23002},
														run: (*parser).callonmixinCallAttributeCall39,
														expr: &labeledExpr{
															pos:   position{line: 759, col: 10, offset: 23002},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2410, col: 17, offset: 81833},
																exprs: []any{
																	&charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2410, col: 26, offset: 81842},
																		expr: &charClassMatcher{
																			pos:        position{line: 2393, col: 20, offset: 81588},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 761, col: 5, offset: 23096},
														run: (*parser).callonmixinCallAttributeCall45,
														expr: &seqExpr{
															pos: position{line: 761, col: 5, offset: 23096},
															exprs: []any{
																&labeledExpr{
																	pos:   position{line: 761, col: 5, offset: 23096},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 761, col: 13, offset: 23104},
																		exprs: []any{
																			&zeroOrOneExpr{
																				pos: position{line: 761, col: 13, offset: 23104},
																				expr: &litMatcher{
																					pos:        position{line: 761, col: 13, offset: 23104},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 761, col: 18, offset: 23109},
																				expr: &choiceExpr{
																					pos: position{line: 761, col: 19, offset: 23110},
																					alternatives: []any{
																						&seqExpr{
																							pos: position{line: 761, col: 19, offset: 23110},
																							exprs: []any{
																								&charClassMatcher{
																									pos:        position{line: 761, col: 19, offset: 23110},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 761, col: 28, offset: 23119},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 761, col: 38, offset: 23129},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 761, col: 49, offset: 23140},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonmixinCallAttributeCall58,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 775, col: 5, offset: 23599},
										run: (*parser).callonmixinCallAttributeCall64,
										expr: &seqExpr{
											pos: position{line: 775, col: 5, offset: 23599},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 775, col: 5, offset: 23599},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonmixinCallAttributeCall67,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
												&andExpr{
													pos: position{line: 775, col: 14, offset: 23608},
													expr: &choiceExpr{
														pos: position{line: 775, col: 16, offset: 23610},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 775, col: 22, offset: 23616},
																val:        "[:!=()]",
																chars:      []rune{':', '!', '=', '(', ')'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 786, col: 5, offset: 23948},
										run: (*parser).callonmixinCallAttributeCall86,
										expr: &seqExpr{
											pos: position{line: 786, col: 5, offset: 23948},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 786, col: 5, offset: 23948},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 786, col: 12, offset: 23955},
														expr: &charClassMatcher{
															pos:        position{line: 786, col: 12, offset: 23955},
															val:        "[^ \\t\\r\\n:!=()]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 786, col: 29, offset: 23972},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonmixinCallAttributeCall92,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1343, col: 71, offset: 42859},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1343, col: 77, offset: 42865},
								expr: &ruleRefExpr{
									pos:  position{line: 1343, col: 77, offset: 42865},
									name: "mixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1343, col: 91, offset: 42879},
							label: "valueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1343, col: 98, offset: 42886},
								expr: &ruleRefExpr{
									pos:  position{line: 1343, col: 98, offset: 42886},
									name: "mixinCallAttributeValue",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinCallAttributeCall",
			pos:  position{line: 1363, col: 1, offset: 43453},
			expr: &actionExpr{
				pos: position{line: 1363, col: 37, offset: 43489},
				run: (*parser).callonsingleLineMixinCallAttributeCall1,
				expr: &seqExpr{
					pos: position{line: 1363, col: 37, offset: 43489},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1363, col: 37, offset: 43489},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 1363, col: 41, offset: 43493},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1363, col: 52, offset: 43504},
								expr: &seqExpr{
									pos: position{line: 1363, col: 53, offset: 43505},
									exprs: []any{
										&choiceExpr{
											pos: position{line: 759, col: 10, offset: 23002},
											alternatives: []any{
												&actionExpr{
													pos: position{line: 759, col: 10, offset: 23002},
													run: (*parser).callonsingleLineMixinCallAttributeCall8,
													expr: &labeledExpr{
														pos:   position{line: 759, col: 10, offset: 23002},
														label: "identI",
														expr: &seqExpr{
															pos: position{line: 2410, col: 17, offset: 81833},
															exprs: []any{
																&charClassMatcher{
																	pos:        position{line: 2393, col: 20, offset: 81588},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2410, col: 26, offset: 81842},
																	expr: &charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 761, col: 5, offset: 23096},
													run: (*parser).callonsingleLineMixinCallAttributeCall14,
													expr: &seqExpr{
														pos: position{line: 761, col: 5, offset: 23096},
														exprs: []any{
															&labeledExpr{
																pos:   position{line: 761, col: 5, offset: 23096},
																label: "identI",
																expr: &seqExpr{
																	pos: position{line: 761, col: 13, offset: 23104},
																	exprs: []any{
																		&zeroOrOneExpr{
																			pos: position{line: 761, col: 13, offset: 23104},
																			expr: &litMatcher{
																				pos:        position{line: 761, col: 13, offset: 23104},
																				val:        "$",
																				ignoreCase: false,
																				want:       "\"$\"",
																			},
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 761, col: 18, offset: 23109},
																			expr: &choiceExpr{
																				pos: position{line: 761, col: 19, offset: 23110},
																				alternatives: []any{
																					&seqExpr{
																						pos: position{line: 761, col: 19, offset: 23110},
																						exprs: []any{
																							&charClassMatcher{
																								pos:        position{line: 761, col: 19, offset: 23110},
																								val:        "[\\pNd]",
																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 761, col: 28, offset: 23119},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 761, col: 38, offset: 23129},
																						val:        "[_-\\pL]",
																						chars:      []rune{'_', '-'},
																						classes:    []*unicode.RangeTable{rangeTable("L")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&labeledExpr{
																pos:   position{line: 761, col: 49, offset: 23140},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3799, col: 8, offset: 129205},
																	run: (*parser).callonsingleLineMixinCallAttributeCall27,
																	expr: &choiceExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		alternatives: []any{
																			&andExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				expr: &anyMatcher{
																					line: 3799, col: 10, offset: 129207,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3799, col: 14, offset: 129211},
																				expr: &anyMatcher{
																					line: 3799, col: 15, offset: 129212,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 1363, col: 59, offset: 43511},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1363, col: 65, offset: 43517},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 773, col: 14, offset: 23557},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 773, col: 14, offset: 23557},
										run: (*parser).callonsingleLineMixinCallAttributeCall36,
										expr: &labeledExpr{
											pos:   position{line: 773, col: 14, offset: 23557},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 759, col: 10, offset: 23002},
												alternatives: []any{
													&actionExpr{
														pos: position{line: 759, col: 10, offset: 23002},
														run: (*parser).callonsingleLineMixinCallAttributeCall39,
														expr: &labeledExpr{
															pos:   position{line: 759, col: 10, offset: 23002},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2410, col: 17, offset: 81833},
																exprs: []any{
																	&charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2410, col: 26, offset: 81842},
																		expr: &charClassMatcher{
																			pos:        position{line: 2393, col: 20, offset: 81588},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 761, col: 5, offset: 23096},
														run: (*parser).callonsingleLineMixinCallAttributeCall45,
														expr: &seqExpr{
															pos: position{line: 761, col: 5, offset: 23096},
															exprs: []any{
																&labeledExpr{
																	pos:   position{line: 761, col: 5, offset: 23096},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 761, col: 13, offset: 23104},
																		exprs: []any{
																			&zeroOrOneExpr{
																				pos: position{line: 761, col: 13, offset: 23104},
																				expr: &litMatcher{
																					pos:        position{line: 761, col: 13, offset: 23104},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 761, col: 18, offset: 23109},
																				expr: &choiceExpr{
																					pos: position{line: 761, col: 19, offset: 23110},
																					alternatives: []any{
																						&seqExpr{
																							pos: position{line: 761, col: 19, offset: 23110},
																							exprs: []any{
																								&charClassMatcher{
																									pos:        position{line: 761, col: 19, offset: 23110},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 761, col: 28, offset: 23119},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 761, col: 38, offset: 23129},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 761, col: 49, offset: 23140},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonsingleLineMixinCallAttributeCall58,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 775, col: 5, offset: 23599},
										run: (*parser).callonsingleLineMixinCallAttributeCall64,
										expr: &seqExpr{
											pos: position{line: 775, col: 5, offset: 23599},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 775, col: 5, offset: 23599},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonsingleLineMixinCallAttributeCall67,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
												&andExpr{
													pos: position{line: 775, col: 14, offset: 23608},
													expr: &choiceExpr{
														pos: position{line: 775, col: 16, offset: 23610},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 775, col: 22, offset: 23616},
																val:        "[:!=()]",
																chars:      []rune{':', '!', '=', '(', ')'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 786, col: 5, offset: 23948},
										run: (*parser).callonsingleLineMixinCallAttributeCall86,
										expr: &seqExpr{
											pos: position{line: 786, col: 5, offset: 23948},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 786, col: 5, offset: 23948},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 786, col: 12, offset: 23955},
														expr: &charClassMatcher{
															pos:        position{line: 786, col: 12, offset: 23955},
															val:        "[^ \\t\\r\\n:!=()]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 786, col: 29, offset: 23972},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonsingleLineMixinCallAttributeCall92,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1363, col: 81, offset: 43533},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1363, col: 87, offset: 43539},
								expr: &ruleRefExpr{
									pos:  position{line: 1363, col: 87, offset: 43539},
									name: "singleLineMixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1363, col: 111, offset: 43563},
							label: "valueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1363, col: 118, offset: 43570},
								expr: &ruleRefExpr{
									pos:  position{line: 1363, col: 118, offset: 43570},
									name: "mixinCallAttributeValue",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallAttributeValue",
			pos:  position{line: 1384, col: 1, offset: 44138},
			expr: &choiceExpr{
				pos: position{line: 1384, col: 28, offset: 44165},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3721, col: 27, offset: 126477},
						run: (*parser).callonmixinCallAttributeValue2,
						expr: &seqExpr{
							pos: position{line: 3721, col: 27, offset: 126477},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3721, col: 27, offset: 126477},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3824, col: 14, offset: 129997},
										run: (*parser).callonmixinCallAttributeValue5,
										expr: &litMatcher{
											pos:        position{line: 3824, col: 14, offset: 129997},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3721, col: 50, offset: 126500},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3721, col: 56, offset: 126506},
										expr: &charClassMatcher{
											pos:        position{line: 3721, col: 56, offset: 126506},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3721, col: 67, offset: 126517},
									label: "rBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3825, col: 14, offset: 130037},
										run: (*parser).callonmixinCallAttributeValue11,
										expr: &litMatcher{
											pos:        position{line: 3825, col: 14, offset: 130037},
											val:        "]",
											ignoreCase: false,
											want:       "\"]\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3727, col: 5, offset: 126728},
						run: (*parser).callonmixinCallAttributeValue13,
						expr: &seqExpr{
							pos: position{line: 3727, col: 5, offset: 126728},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3727, col: 5, offset: 126728},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3824, col: 14, offset: 129997},
										run: (*parser).callonmixinCallAttributeValue16,
										expr: &litMatcher{
											pos:        position{line: 3824, col: 14, offset: 129997},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3727, col: 28, offset: 126751},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3727, col: 34, offset: 126757},
										expr: &charClassMatcher{
											pos:        position{line: 3727, col: 34, offset: 126757},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1384, col: 53, offset: 44190},
						name: "expressionInterpolationValue",
					},
				},
			},
		},
		{
			name: "Expression",
			pos:  position{line: 1397, col: 1, offset: 44475},
			expr: &choiceExpr{
				pos: position{line: 1397, col: 15, offset: 44489},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1397, col: 15, offset: 44489},
						run: (*parser).callonExpression2,
						expr: &labeledExpr{
							pos:   position{line: 1397, col: 15, offset: 44489},
							label: "cExprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1397, col: 22, offset: 44496},
								name: "ChainExpression",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1399, col: 5, offset: 44617},
						name: "GoExpression",
					},
				},
			},
		},
		{
			name: "SingleLineExpression",
			pos:  position{line: 1401, col: 1, offset: 44631},
			expr: &choiceExpr{
				pos: position{line: 1401, col: 25, offset: 44655},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1401, col: 25, offset: 44655},
						run: (*parser).callonSingleLineExpression2,
						expr: &labeledExpr{
							pos:   position{line: 1401, col: 25, offset: 44655},
							label: "cExprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1401, col: 32, offset: 44662},
								name: "SingleLineChainExpression",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1403, col: 5, offset: 44793},
						name: "SingleLineGoExpression",
					},
				},
			},
		},
		{
			name: "GoExpression",
			pos:  position{line: 1413, col: 1, offset: 45201},
			expr: &actionExpr{
				pos: position{line: 1413, col: 17, offset: 45217},
				run: (*parser).callonGoExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1413, col: 17, offset: 45217},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1413, col: 24, offset: 45224},
						expr: &choiceExpr{
							pos: position{line: 1414, col: 6, offset: 45231},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 1414, col: 6, offset: 45231},
									name: "goParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 1414, col: 20, offset: 45245},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1414, col: 39, offset: 45264},
									name: "TernaryExpression",
								},
								&actionExpr{
									pos: position{line: 1477, col: 15, offset: 47305},
									run: (*parser).callonGoExpression8,
									expr: &seqExpr{
										pos: position{line: 1477, col: 15, offset: 47305},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1477, col: 15, offset: 47305},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonGoExpression11,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&choiceExpr{
												pos: position{line: 2457, col: 14, offset: 83160},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 2457, col: 14, offset: 83160},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2457, col: 14, offset: 83160},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&choiceExpr{
																pos: position{line: 2457, col: 20, offset: 83166},
																alternatives: []any{
																	&seqExpr{
																		pos: position{line: 2505, col: 19, offset: 85311},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2505, col: 19, offset: 85311},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2506, col: 5, offset: 85370},
																		run: (*parser).callonGoExpression27,
																		expr: &seqExpr{
																			pos: position{line: 2506, col: 5, offset: 85370},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2506, col: 5, offset: 85370},
																					val:        "\\u",
																					ignoreCase: false,
																					want:       "\"\\\\u\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 14, offset: 85379},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 26, offset: 85391},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 38, offset: 85403},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 50, offset: 85415},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2535, col: 16, offset: 86551},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2535, col: 16, offset: 86551},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2536, col: 5, offset: 86654},
																		run: (*parser).callonGoExpression48,
																		expr: &seqExpr{
																			pos: position{line: 2536, col: 5, offset: 86654},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2536, col: 5, offset: 86654},
																					val:        "\\U",
																					ignoreCase: false,
																					want:       "\"\\\\U\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 14, offset: 86663},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 26, offset: 86675},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 38, offset: 86687},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 50, offset: 86699},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 62, offset: 86711},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 74, offset: 86723},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 86, offset: 86735},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 98, offset: 86747},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2570, col: 24, offset: 88132},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2570, col: 24, offset: 88132},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2570, col: 29, offset: 88137},
																				val:        "[abfnrtv\\\\\\]",
																				chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 2484, col: 75, offset: 84423},
																		val:        "[^\\\\\\\\n]",
																		chars:      []rune{'\'', '\\', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																	&seqExpr{
																		pos: position{line: 2486, col: 24, offset: 84569},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2486, col: 24, offset: 84569},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2487, col: 24, offset: 84636},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2487, col: 24, offset: 84636},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2488, col: 5, offset: 84673},
																		run: (*parser).callonGoExpression80,
																		expr: &seqExpr{
																			pos: position{line: 2488, col: 5, offset: 84673},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2488, col: 5, offset: 84673},
																					val:        "\\x",
																					ignoreCase: false,
																					want:       "\"\\\\x\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 14, offset: 84682},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 26, offset: 84694},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2571, col: 24, offset: 88215},
																		run: (*parser).callonGoExpression87,
																		expr: &seqExpr{
																			pos: position{line: 2571, col: 24, offset: 88215},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2571, col: 24, offset: 88215},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2595, col: 5, offset: 89231},
																		run: (*parser).callonGoExpression98,
																		expr: &seqExpr{
																			pos: position{line: 2595, col: 5, offset: 89231},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2595, col: 5, offset: 89231},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2616, col: 5, offset: 90072},
																		run: (*parser).callonGoExpression105,
																		expr: &seqExpr{
																			pos: position{line: 2616, col: 5, offset: 90072},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2616, col: 5, offset: 90072},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2634, col: 5, offset: 90757},
																		run: (*parser).callonGoExpression110,
																		expr: &seqExpr{
																			pos: position{line: 2634, col: 5, offset: 90757},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2634, col: 5, offset: 90757},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2634, col: 10, offset: 90762},
																					expr: &charClassMatcher{
																						pos:        position{line: 3797, col: 12, offset: 129189},
																						val:        "[^\\r\\n]",
																						chars:      []rune{'\r', '\n'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2457, col: 76, offset: 83222},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
														},
													},
													&actionExpr{
														pos: position{line: 2458, col: 5, offset: 83233},
														run: (*parser).callonGoExpression116,
														expr: &seqExpr{
															pos: position{line: 2458, col: 5, offset: 83233},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2458, col: 5, offset: 83233},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 10, offset: 83238},
																	label: "valsI",
																	expr: &zeroOrMoreExpr{
																		pos: position{line: 2458, col: 16, offset: 83244},
																		expr: &choiceExpr{
																			pos: position{line: 2458, col: 17, offset: 83245},
																			alternatives: []any{
																				&seqExpr{
																					pos: position{line: 2505, col: 19, offset: 85311},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2505, col: 19, offset: 85311},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2506, col: 5, offset: 85370},
																					run: (*parser).callonGoExpression128,
																					expr: &seqExpr{
																						pos: position{line: 2506, col: 5, offset: 85370},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2506, col: 5, offset: 85370},
																								val:        "\\u",
																								ignoreCase: false,
																								want:       "\"\\\\u\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 14, offset: 85379},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 26, offset: 85391},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 38, offset: 85403},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 50, offset: 85415},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2535, col: 16, offset: 86551},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2535, col: 16, offset: 86551},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2536, col: 5, offset: 86654},
																					run: (*parser).callonGoExpression149,
																					expr: &seqExpr{
																						pos: position{line: 2536, col: 5, offset: 86654},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2536, col: 5, offset: 86654},
																								val:        "\\U",
																								ignoreCase: false,
																								want:       "\"\\\\U\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 14, offset: 86663},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 26, offset: 86675},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 38, offset: 86687},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 50, offset: 86699},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 62, offset: 86711},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 74, offset: 86723},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 86, offset: 86735},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 98, offset: 86747},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2570, col: 24, offset: 88132},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2570, col: 24, offset: 88132},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2570, col: 29, offset: 88137},
																							val:        "[abfnrtv\\\\\\]",
																							chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2484, col: 75, offset: 84423},
																					val:        "[^\\\\\\\\n]",
																					chars:      []rune{'\'', '\\', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																				&seqExpr{
																					pos: position{line: 2486, col: 24, offset: 84569},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2486, col: 24, offset: 84569},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2487, col: 24, offset: 84636},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2487, col: 24, offset: 84636},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2488, col: 5, offset: 84673},
																					run: (*parser).callonGoExpression181,
																					expr: &seqExpr{
																						pos: position{line: 2488, col: 5, offset: 84673},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2488, col: 5, offset: 84673},
																								val:        "\\x",
																								ignoreCase: false,
																								want:       "\"\\\\x\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 14, offset: 84682},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 26, offset: 84694},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2571, col: 24, offset: 88215},
																					run: (*parser).callonGoExpression188,
																					expr: &seqExpr{
																						pos: position{line: 2571, col: 24, offset: 88215},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2571, col: 24, offset: 88215},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2595, col: 5, offset: 89231},
																					run: (*parser).callonGoExpression199,
																					expr: &seqExpr{
																						pos: position{line: 2595, col: 5, offset: 89231},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2595, col: 5, offset: 89231},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2616, col: 5, offset: 90072},
																					run: (*parser).callonGoExpression206,
																					expr: &seqExpr{
																						pos: position{line: 2616, col: 5, offset: 90072},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2616, col: 5, offset: 90072},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2634, col: 5, offset: 90757},
																					run: (*parser).callonGoExpression211,
																					expr: &seqExpr{
																						pos: position{line: 2634, col: 5, offset: 90757},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2634, col: 5, offset: 90757},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2634, col: 10, offset: 90762},
																								expr: &charClassMatcher{
																									pos:        position{line: 3797, col: 12, offset: 129189},
																									val:        "[^\\r\\n]",
																									chars:      []rune{'\r', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&litMatcher{
																	pos:        position{line: 2458, col: 74, offset: 83302},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 79, offset: 83307},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonGoExpression218,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 1415, col: 6, offset: 45302},
									run: (*parser).callonGoExpression224,
									expr: &seqExpr{
										pos: position{line: 1415, col: 6, offset: 45302},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1415, col: 6, offset: 45302},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonGoExpression227,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&notExpr{
												pos: position{line: 1415, col: 15, offset: 45311},
												expr: &choiceExpr{
													pos: position{line: 1405, col: 25, offset: 44841},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 1405, col: 25, offset: 44841},
															val:        "[)}],]",
															chars:      []rune{')', '}', ']', ','},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 1405, col: 40, offset: 44856},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 1405, col: 40, offset: 44856},
																	val:        ":",
																	ignoreCase: false,
																	want:       "\":\"",
																},
																&notExpr{
																	pos: position{line: 1405, col: 44, offset: 44860},
																	expr: &litMatcher{
																		pos:        position{line: 1405, col: 45, offset: 44861},
																		val:        "=",
																		ignoreCase: false,
																		want:       "\"=\"",
																	},
																},
															},
														},
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 3797, col: 12, offset: 129189},
												val:        "[^\\r\\n]",
												chars:      []rune{'\r', '\n'},
												ignoreCase: false,
												inverted:   true,
											},
											&zeroOrMoreExpr{
												pos: position{line: 1415, col: 45, offset: 45341},
												expr: &seqExpr{
													pos: position{line: 1415, col: 46, offset: 45342},
													exprs: []any{
														&notExpr{
															pos: position{line: 1415, col: 46, offset: 45342},
															expr: &choiceExpr{
																pos: position{line: 1405, col: 25, offset: 44841},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 1405, col: 25, offset: 44841},
																		val:        "[)}],]",
																		chars:      []rune{')', '}', ']', ','},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 1405, col: 40, offset: 44856},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 1405, col: 40, offset: 44856},
																				val:        ":",
																				ignoreCase: false,
																				want:       "\":\"",
																			},
																			&notExpr{
																				pos: position{line: 1405, col: 44, offset: 44860},
																				expr: &litMatcher{
																					pos:        position{line: 1405, col: 45, offset: 44861},
																					val:        "=",
																					ignoreCase: false,
																					want:       "\"=\"",
																				},
																			},
																		},
																	},
																},
															},
														},
														&notExpr{
															pos: position{line: 1415, col: 68, offset: 45364},
															expr: &seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
														&charClassMatcher{
															pos:        position{line: 1415, col: 73, offset: 45369},
															val:        "[^\\\"`?([{]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goParenExpr",
			pos:  position{line: 1422, col: 1, offset: 45534},
			expr: &choiceExpr{
				pos: position{line: 1422, col: 16, offset: 45549},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1422, col: 16, offset: 45549},
						run: (*parser).callongoParenExpr2,
						expr: &labeledExpr{
							pos:   position{line: 1422, col: 16, offset: 45549},
							label: "exprI",
							expr: &choiceExpr{
								pos: position{line: 1422, col: 23, offset: 45556},
								alternatives: []any{
									&seqExpr{
										pos: position{line: 1422, col: 23, offset: 45556},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 1422, col: 23, offset: 45556},
												val:        "(",
												ignoreCase: false,
												want:       "\"(\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1422, col: 27, offset: 45560},
												expr: &ruleRefExpr{
													pos:  position{line: 1422, col: 27, offset: 45560},
													name: "goSubExpression",
												},
											},
											&actionExpr{
												pos: position{line: 3799, col: 8, offset: 129205},
												run: (*parser).callongoParenExpr9,
												expr: &choiceExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													alternatives: []any{
														&andExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															expr: &anyMatcher{
																line: 3799, col: 10, offset: 129207,
															},
														},
														&notExpr{
															pos: position{line: 3799, col: 14, offset: 129211},
															expr: &anyMatcher{
																line: 3799, col: 15, offset: 129212,
															},
														},
													},
												},
											},
											&litMatcher{
												pos:        position{line: 1422, col: 48, offset: 45581},
												val:        ")",
												ignoreCase: false,
												want:       "\")\"",
											},
										},
									},
									&seqExpr{
										pos: position{line: 1422, col: 54, offset: 45587},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 1422, col: 54, offset: 45587},
												val:        "[",
												ignoreCase: false,
												want:       "\"[\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1422, col: 58, offset: 45591},
												expr: &ruleRefExpr{
													pos:  position{line: 1422, col: 58, offset: 45591},
													name: "goSubExpression",
												},
											},
											&actionExpr{
												pos: position{line: 3799, col: 8, offset: 129205},
												run: (*parser).callongoParenExpr20,
												expr: &choiceExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													alternatives: []any{
														&andExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															expr: &anyMatcher{
																line: 3799, col: 10, offset: 129207,
															},
														},
														&notExpr{
															pos: position{line: 3799, col: 14, offset: 129211},
															expr: &anyMatcher{
																line: 3799, col: 15, offset: 129212,
															},
														},
													},
												},
											},
											&litMatcher{
												pos:        position{line: 1422, col: 79, offset: 45612},
												val:        "]",
												ignoreCase: false,
												want:       "\"]\"",
											},
										},
									},
									&seqExpr{
										pos: position{line: 1422, col: 85, offset: 45618},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 1422, col: 85, offset: 45618},
												val:        "{",
												ignoreCase: false,
												want:       "\"{\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1422, col: 89, offset: 45622},
												expr: &ruleRefExpr{
													pos:  position{line: 1422, col: 89, offset: 45622},
													name: "goSubExpression",
												},
											},
											&actionExpr{
												pos: position{line: 3799, col: 8, offset: 129205},
												run: (*parser).callongoParenExpr31,
												expr: &choiceExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													alternatives: []any{
														&andExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															expr: &anyMatcher{
																line: 3799, col: 10, offset: 129207,
															},
														},
														&notExpr{
															pos: position{line: 3799, col: 14, offset: 129211},
															expr: &anyMatcher{
																line: 3799, col: 15, offset: 129212,
															},
														},
													},
												},
											},
											&litMatcher{
												pos:        position{line: 1422, col: 110, offset: 45643},
												val:        "}",
												ignoreCase: false,
												want:       "\"}\"",
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1445, col: 5, offset: 46326},
						run: (*parser).callongoParenExpr38,
						expr: &seqExpr{
							pos: position{line: 1445, col: 5, offset: 46326},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 1445, col: 5, offset: 46326},
									label: "parenI",
									expr: &charClassMatcher{
										pos:        position{line: 1445, col: 12, offset: 46333},
										val:        "[([{]",
										chars:      []rune{'(', '[', '{'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&labeledExpr{
									pos:   position{line: 1445, col: 18, offset: 46339},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callongoParenExpr43,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1445, col: 32, offset: 46353},
									label: "exprI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1445, col: 38, offset: 46359},
										expr: &ruleRefExpr{
											pos:  position{line: 1445, col: 38, offset: 46359},
											name: "goSubExpression",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goSubExpression",
			pos:  position{line: 1481, col: 1, offset: 47423},
			expr: &actionExpr{
				pos: position{line: 1481, col: 20, offset: 47442},
				run: (*parser).callongoSubExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1481, col: 20, offset: 47442},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1481, col: 27, offset: 47449},
						expr: &choiceExpr{
							pos: position{line: 1482, col: 5, offset: 47455},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 1482, col: 5, offset: 47455},
									name: "goParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 1482, col: 19, offset: 47469},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1482, col: 38, offset: 47488},
									name: "TernaryExpression",
								},
								&actionExpr{
									pos: position{line: 1477, col: 15, offset: 47305},
									run: (*parser).callongoSubExpression8,
									expr: &seqExpr{
										pos: position{line: 1477, col: 15, offset: 47305},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1477, col: 15, offset: 47305},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callongoSubExpression11,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&choiceExpr{
												pos: position{line: 2457, col: 14, offset: 83160},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 2457, col: 14, offset: 83160},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2457, col: 14, offset: 83160},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&choiceExpr{
																pos: position{line: 2457, col: 20, offset: 83166},
																alternatives: []any{
																	&seqExpr{
																		pos: position{line: 2505, col: 19, offset: 85311},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2505, col: 19, offset: 85311},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2506, col: 5, offset: 85370},
																		run: (*parser).callongoSubExpression27,
																		expr: &seqExpr{
																			pos: position{line: 2506, col: 5, offset: 85370},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2506, col: 5, offset: 85370},
																					val:        "\\u",
																					ignoreCase: false,
																					want:       "\"\\\\u\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 14, offset: 85379},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 26, offset: 85391},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 38, offset: 85403},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 50, offset: 85415},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2535, col: 16, offset: 86551},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2535, col: 16, offset: 86551},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2536, col: 5, offset: 86654},
																		run: (*parser).callongoSubExpression48,
																		expr: &seqExpr{
																			pos: position{line: 2536, col: 5, offset: 86654},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2536, col: 5, offset: 86654},
																					val:        "\\U",
																					ignoreCase: false,
																					want:       "\"\\\\U\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 14, offset: 86663},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 26, offset: 86675},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 38, offset: 86687},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 50, offset: 86699},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 62, offset: 86711},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 74, offset: 86723},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 86, offset: 86735},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 98, offset: 86747},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2570, col: 24, offset: 88132},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2570, col: 24, offset: 88132},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2570, col: 29, offset: 88137},
																				val:        "[abfnrtv\\\\\\]",
																				chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 2484, col: 75, offset: 84423},
																		val:        "[^\\\\\\\\n]",
																		chars:      []rune{'\'', '\\', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																	&seqExpr{
																		pos: position{line: 2486, col: 24, offset: 84569},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2486, col: 24, offset: 84569},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2487, col: 24, offset: 84636},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2487, col: 24, offset: 84636},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2488, col: 5, offset: 84673},
																		run: (*parser).callongoSubExpression80,
																		expr: &seqExpr{
																			pos: position{line: 2488, col: 5, offset: 84673},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2488, col: 5, offset: 84673},
																					val:        "\\x",
																					ignoreCase: false,
																					want:       "\"\\\\x\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 14, offset: 84682},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 26, offset: 84694},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2571, col: 24, offset: 88215},
																		run: (*parser).callongoSubExpression87,
																		expr: &seqExpr{
																			pos: position{line: 2571, col: 24, offset: 88215},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2571, col: 24, offset: 88215},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2595, col: 5, offset: 89231},
																		run: (*parser).callongoSubExpression98,
																		expr: &seqExpr{
																			pos: position{line: 2595, col: 5, offset: 89231},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2595, col: 5, offset: 89231},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2616, col: 5, offset: 90072},
																		run: (*parser).callongoSubExpression105,
																		expr: &seqExpr{
																			pos: position{line: 2616, col: 5, offset: 90072},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2616, col: 5, offset: 90072},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2634, col: 5, offset: 90757},
																		run: (*parser).callongoSubExpression110,
																		expr: &seqExpr{
																			pos: position{line: 2634, col: 5, offset: 90757},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2634, col: 5, offset: 90757},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2634, col: 10, offset: 90762},
																					expr: &charClassMatcher{
																						pos:        position{line: 3797, col: 12, offset: 129189},
																						val:        "[^\\r\\n]",
																						chars:      []rune{'\r', '\n'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2457, col: 76, offset: 83222},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
														},
													},
													&actionExpr{
														pos: position{line: 2458, col: 5, offset: 83233},
														run: (*parser).callongoSubExpression116,
														expr: &seqExpr{
															pos: position{line: 2458, col: 5, offset: 83233},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2458, col: 5, offset: 83233},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 10, offset: 83238},
																	label: "valsI",
																	expr: &zeroOrMoreExpr{
																		pos: position{line: 2458, col: 16, offset: 83244},
																		expr: &choiceExpr{
																			pos: position{line: 2458, col: 17, offset: 83245},
																			alternatives: []any{
																				&seqExpr{
																					pos: position{line: 2505, col: 19, offset: 85311},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2505, col: 19, offset: 85311},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2506, col: 5, offset: 85370},
																					run: (*parser).callongoSubExpression128,
																					expr: &seqExpr{
																						pos: position{line: 2506, col: 5, offset: 85370},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2506, col: 5, offset: 85370},
																								val:        "\\u",
																								ignoreCase: false,
																								want:       "\"\\\\u\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 14, offset: 85379},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 26, offset: 85391},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 38, offset: 85403},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 50, offset: 85415},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2535, col: 16, offset: 86551},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2535, col: 16, offset: 86551},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2536, col: 5, offset: 86654},
																					run: (*parser).callongoSubExpression149,
																					expr: &seqExpr{
																						pos: position{line: 2536, col: 5, offset: 86654},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2536, col: 5, offset: 86654},
																								val:        "\\U",
																								ignoreCase: false,
																								want:       "\"\\\\U\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 14, offset: 86663},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 26, offset: 86675},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 38, offset: 86687},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 50, offset: 86699},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 62, offset: 86711},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 74, offset: 86723},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 86, offset: 86735},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 98, offset: 86747},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2570, col: 24, offset: 88132},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2570, col: 24, offset: 88132},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2570, col: 29, offset: 88137},
																							val:        "[abfnrtv\\\\\\]",
																							chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2484, col: 75, offset: 84423},
																					val:        "[^\\\\\\\\n]",
																					chars:      []rune{'\'', '\\', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																				&seqExpr{
																					pos: position{line: 2486, col: 24, offset: 84569},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2486, col: 24, offset: 84569},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2487, col: 24, offset: 84636},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2487, col: 24, offset: 84636},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2488, col: 5, offset: 84673},
																					run: (*parser).callongoSubExpression181,
																					expr: &seqExpr{
																						pos: position{line: 2488, col: 5, offset: 84673},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2488, col: 5, offset: 84673},
																								val:        "\\x",
																								ignoreCase: false,
																								want:       "\"\\\\x\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 14, offset: 84682},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 26, offset: 84694},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2571, col: 24, offset: 88215},
																					run: (*parser).callongoSubExpression188,
																					expr: &seqExpr{
																						pos: position{line: 2571, col: 24, offset: 88215},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2571, col: 24, offset: 88215},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2595, col: 5, offset: 89231},
																					run: (*parser).callongoSubExpression199,
																					expr: &seqExpr{
																						pos: position{line: 2595, col: 5, offset: 89231},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2595, col: 5, offset: 89231},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2616, col: 5, offset: 90072},
																					run: (*parser).callongoSubExpression206,
																					expr: &seqExpr{
																						pos: position{line: 2616, col: 5, offset: 90072},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2616, col: 5, offset: 90072},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2634, col: 5, offset: 90757},
																					run: (*parser).callongoSubExpression211,
																					expr: &seqExpr{
																						pos: position{line: 2634, col: 5, offset: 90757},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2634, col: 5, offset: 90757},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2634, col: 10, offset: 90762},
																								expr: &charClassMatcher{
																									pos:        position{line: 3797, col: 12, offset: 129189},
																									val:        "[^\\r\\n]",
																									chars:      []rune{'\r', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&litMatcher{
																	pos:        position{line: 2458, col: 74, offset: 83302},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 79, offset: 83307},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callongoSubExpression218,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 1483, col: 5, offset: 47525},
									run: (*parser).callongoSubExpression224,
									expr: &seqExpr{
										pos: position{line: 1483, col: 5, offset: 47525},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1483, col: 5, offset: 47525},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callongoSubExpression227,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 1483, col: 14, offset: 47534},
												val:        "[^)}]]",
												chars:      []rune{')', '}', ']'},
												ignoreCase: false,
												inverted:   true,
											},
											&zeroOrMoreExpr{
												pos: position{line: 1483, col: 22, offset: 47542},
												expr: &charClassMatcher{
													pos:        position{line: 1483, col: 22, offset: 47542},
													val:        "[^\\\"`?([{}])]",
													chars:      []rune{'\'', '"', '`', '?', '(', '[', '{', '}', ']', ')'},
													ignoreCase: false,
													inverted:   true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "multiLineGoExpression",
			pos:  position{line: 1490, col: 1, offset: 47710},
			expr: &actionExpr{
				pos: position{line: 1490, col: 26, offset: 47735},
				run: (*parser).callonmultiLineGoExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1490, col: 26, offset: 47735},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1490, col: 33, offset: 47742},
						expr: &choiceExpr{
							pos: position{line: 1491, col: 5, offset: 47748},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 1491, col: 5, offset: 47748},
									name: "goParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 1491, col: 19, offset: 47762},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1491, col: 38, offset: 47781},
									name: "TernaryExpression",
								},
								&actionExpr{
									pos: position{line: 1477, col: 15, offset: 47305},
									run: (*parser).callonmultiLineGoExpression8,
									expr: &seqExpr{
										pos: position{line: 1477, col: 15, offset: 47305},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1477, col: 15, offset: 47305},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonmultiLineGoExpression11,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&choiceExpr{
												pos: position{line: 2457, col: 14, offset: 83160},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 2457, col: 14, offset: 83160},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2457, col: 14, offset: 83160},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&choiceExpr{
																pos: position{line: 2457, col: 20, offset: 83166},
																alternatives: []any{
																	&seqExpr{
																		pos: position{line: 2505, col: 19, offset: 85311},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2505, col: 19, offset: 85311},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2506, col: 5, offset: 85370},
																		run: (*parser).callonmultiLineGoExpression27,
																		expr: &seqExpr{
																			pos: position{line: 2506, col: 5, offset: 85370},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2506, col: 5, offset: 85370},
																					val:        "\\u",
																					ignoreCase: false,
																					want:       "\"\\\\u\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 14, offset: 85379},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 26, offset: 85391},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 38, offset: 85403},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 50, offset: 85415},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2535, col: 16, offset: 86551},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2535, col: 16, offset: 86551},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2536, col: 5, offset: 86654},
																		run: (*parser).callonmultiLineGoExpression48,
																		expr: &seqExpr{
																			pos: position{line: 2536, col: 5, offset: 86654},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2536, col: 5, offset: 86654},
																					val:        "\\U",
																					ignoreCase: false,
																					want:       "\"\\\\U\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 14, offset: 86663},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 26, offset: 86675},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 38, offset: 86687},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 50, offset: 86699},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 62, offset: 86711},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 74, offset: 86723},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 86, offset: 86735},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 98, offset: 86747},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2570, col: 24, offset: 88132},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2570, col: 24, offset: 88132},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2570, col: 29, offset: 88137},
																				val:        "[abfnrtv\\\\\\]",
																				chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 2484, col: 75, offset: 84423},
																		val:        "[^\\\\\\\\n]",
																		chars:      []rune{'\'', '\\', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																	&seqExpr{
																		pos: position{line: 2486, col: 24, offset: 84569},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2486, col: 24, offset: 84569},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2487, col: 24, offset: 84636},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2487, col: 24, offset: 84636},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2488, col: 5, offset: 84673},
																		run: (*parser).callonmultiLineGoExpression80,
																		expr: &seqExpr{
																			pos: position{line: 2488, col: 5, offset: 84673},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2488, col: 5, offset: 84673},
																					val:        "\\x",
																					ignoreCase: false,
																					want:       "\"\\\\x\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 14, offset: 84682},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 26, offset: 84694},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2571, col: 24, offset: 88215},
																		run: (*parser).callonmultiLineGoExpression87,
																		expr: &seqExpr{
																			pos: position{line: 2571, col: 24, offset: 88215},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2571, col: 24, offset: 88215},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2595, col: 5, offset: 89231},
																		run: (*parser).callonmultiLineGoExpression98,
																		expr: &seqExpr{
																			pos: position{line: 2595, col: 5, offset: 89231},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2595, col: 5, offset: 89231},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2616, col: 5, offset: 90072},
																		run: (*parser).callonmultiLineGoExpression105,
																		expr: &seqExpr{
																			pos: position{line: 2616, col: 5, offset: 90072},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2616, col: 5, offset: 90072},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2634, col: 5, offset: 90757},
																		run: (*parser).callonmultiLineGoExpression110,
																		expr: &seqExpr{
																			pos: position{line: 2634, col: 5, offset: 90757},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2634, col: 5, offset: 90757},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2634, col: 10, offset: 90762},
																					expr: &charClassMatcher{
																						pos:        position{line: 3797, col: 12, offset: 129189},
																						val:        "[^\\r\\n]",
																						chars:      []rune{'\r', '\n'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2457, col: 76, offset: 83222},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
														},
													},
													&actionExpr{
														pos: position{line: 2458, col: 5, offset: 83233},
														run: (*parser).callonmultiLineGoExpression116,
														expr: &seqExpr{
															pos: position{line: 2458, col: 5, offset: 83233},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2458, col: 5, offset: 83233},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 10, offset: 83238},
																	label: "valsI",
																	expr: &zeroOrMoreExpr{
																		pos: position{line: 2458, col: 16, offset: 83244},
																		expr: &choiceExpr{
																			pos: position{line: 2458, col: 17, offset: 83245},
																			alternatives: []any{
																				&seqExpr{
																					pos: position{line: 2505, col: 19, offset: 85311},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2505, col: 19, offset: 85311},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2506, col: 5, offset: 85370},
																					run: (*parser).callonmultiLineGoExpression128,
																					expr: &seqExpr{
																						pos: position{line: 2506, col: 5, offset: 85370},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2506, col: 5, offset: 85370},
																								val:        "\\u",
																								ignoreCase: false,
																								want:       "\"\\\\u\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 14, offset: 85379},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 26, offset: 85391},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 38, offset: 85403},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 50, offset: 85415},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2535, col: 16, offset: 86551},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2535, col: 16, offset: 86551},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2536, col: 5, offset: 86654},
																					run: (*parser).callonmultiLineGoExpression149,
																					expr: &seqExpr{
																						pos: position{line: 2536, col: 5, offset: 86654},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2536, col: 5, offset: 86654},
																								val:        "\\U",
																								ignoreCase: false,
																								want:       "\"\\\\U\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 14, offset: 86663},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 26, offset: 86675},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 38, offset: 86687},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 50, offset: 86699},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 62, offset: 86711},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 74, offset: 86723},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 86, offset: 86735},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 98, offset: 86747},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2570, col: 24, offset: 88132},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2570, col: 24, offset: 88132},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2570, col: 29, offset: 88137},
																							val:        "[abfnrtv\\\\\\]",
																							chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2484, col: 75, offset: 84423},
																					val:        "[^\\\\\\\\n]",
																					chars:      []rune{'\'', '\\', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																				&seqExpr{
																					pos: position{line: 2486, col: 24, offset: 84569},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2486, col: 24, offset: 84569},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2487, col: 24, offset: 84636},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2487, col: 24, offset: 84636},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2488, col: 5, offset: 84673},
																					run: (*parser).callonmultiLineGoExpression181,
																					expr: &seqExpr{
																						pos: position{line: 2488, col: 5, offset: 84673},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2488, col: 5, offset: 84673},
																								val:        "\\x",
																								ignoreCase: false,
																								want:       "\"\\\\x\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 14, offset: 84682},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 26, offset: 84694},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2571, col: 24, offset: 88215},
																					run: (*parser).callonmultiLineGoExpression188,
																					expr: &seqExpr{
																						pos: position{line: 2571, col: 24, offset: 88215},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2571, col: 24, offset: 88215},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2595, col: 5, offset: 89231},
																					run: (*parser).callonmultiLineGoExpression199,
																					expr: &seqExpr{
																						pos: position{line: 2595, col: 5, offset: 89231},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2595, col: 5, offset: 89231},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2616, col: 5, offset: 90072},
																					run: (*parser).callonmultiLineGoExpression206,
																					expr: &seqExpr{
																						pos: position{line: 2616, col: 5, offset: 90072},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2616, col: 5, offset: 90072},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2634, col: 5, offset: 90757},
																					run: (*parser).callonmultiLineGoExpression211,
																					expr: &seqExpr{
																						pos: position{line: 2634, col: 5, offset: 90757},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2634, col: 5, offset: 90757},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2634, col: 10, offset: 90762},
																								expr: &charClassMatcher{
																									pos:        position{line: 3797, col: 12, offset: 129189},
																									val:        "[^\\r\\n]",
																									chars:      []rune{'\r', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&litMatcher{
																	pos:        position{line: 2458, col: 74, offset: 83302},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 79, offset: 83307},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonmultiLineGoExpression218,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 1492, col: 5, offset: 47818},
									run: (*parser).callonmultiLineGoExpression224,
									expr: &seqExpr{
										pos: position{line: 1492, col: 5, offset: 47818},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1492, col: 5, offset: 47818},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonmultiLineGoExpression227,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&notExpr{
												pos: position{line: 1492, col: 14, offset: 47827},
												expr: &choiceExpr{
													pos: position{line: 1405, col: 25, offset: 44841},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 1405, col: 25, offset: 44841},
															val:        "[)}],]",
															chars:      []rune{')', '}', ']', ','},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 1405, col: 40, offset: 44856},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 1405, col: 40, offset: 44856},
																	val:        ":",
																	ignoreCase: false,
																	want:       "\":\"",
																},
																&notExpr{
																	pos: position{line: 1405, col: 44, offset: 44860},
																	expr: &litMatcher{
																		pos:        position{line: 1405, col: 45, offset: 44861},
																		val:        "=",
																		ignoreCase: false,
																		want:       "\"=\"",
																	},
																},
															},
														},
													},
												},
											},
											&anyMatcher{
												line: 1492, col: 36, offset: 47849,
											},
											&zeroOrMoreExpr{
												pos: position{line: 1492, col: 38, offset: 47851},
												expr: &seqExpr{
													pos: position{line: 1492, col: 39, offset: 47852},
													exprs: []any{
														&notExpr{
															pos: position{line: 1492, col: 39, offset: 47852},
															expr: &choiceExpr{
																pos: position{line: 1405, col: 25, offset: 44841},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 1405, col: 25, offset: 44841},
																		val:        "[)}],]",
																		chars:      []rune{')', '}', ']', ','},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 1405, col: 40, offset: 44856},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 1405, col: 40, offset: 44856},
																				val:        ":",
																				ignoreCase: false,
																				want:       "\":\"",
																			},
																			&notExpr{
																				pos: position{line: 1405, col: 44, offset: 44860},
																				expr: &litMatcher{
																					pos:        position{line: 1405, col: 45, offset: 44861},
																					val:        "=",
																					ignoreCase: false,
																					want:       "\"=\"",
																				},
																			},
																		},
																	},
																},
															},
														},
														&charClassMatcher{
															pos:        position{line: 1492, col: 61, offset: 47874},
															val:        "[^\\\"`?([{]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineGoExpression",
			pos:  position{line: 1499, col: 1, offset: 48039},
			expr: &actionExpr{
				pos: position{line: 1499, col: 27, offset: 48065},
				run: (*parser).callonSingleLineGoExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1499, col: 27, offset: 48065},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1499, col: 34, offset: 48072},
						expr: &choiceExpr{
							pos: position{line: 1500, col: 5, offset: 48078},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 1500, col: 5, offset: 48078},
									name: "singleLineGoParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 1500, col: 29, offset: 48102},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1500, col: 48, offset: 48121},
									name: "SingleLineTernaryExpression",
								},
								&actionExpr{
									pos: position{line: 1477, col: 15, offset: 47305},
									run: (*parser).callonSingleLineGoExpression8,
									expr: &seqExpr{
										pos: position{line: 1477, col: 15, offset: 47305},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1477, col: 15, offset: 47305},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonSingleLineGoExpression11,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&choiceExpr{
												pos: position{line: 2457, col: 14, offset: 83160},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 2457, col: 14, offset: 83160},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2457, col: 14, offset: 83160},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&choiceExpr{
																pos: position{line: 2457, col: 20, offset: 83166},
																alternatives: []any{
																	&seqExpr{
																		pos: position{line: 2505, col: 19, offset: 85311},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2505, col: 19, offset: 85311},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2506, col: 5, offset: 85370},
																		run: (*parser).callonSingleLineGoExpression27,
																		expr: &seqExpr{
																			pos: position{line: 2506, col: 5, offset: 85370},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2506, col: 5, offset: 85370},
																					val:        "\\u",
																					ignoreCase: false,
																					want:       "\"\\\\u\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 14, offset: 85379},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 26, offset: 85391},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 38, offset: 85403},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 50, offset: 85415},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2535, col: 16, offset: 86551},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2535, col: 16, offset: 86551},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2536, col: 5, offset: 86654},
																		run: (*parser).callonSingleLineGoExpression48,
																		expr: &seqExpr{
																			pos: position{line: 2536, col: 5, offset: 86654},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2536, col: 5, offset: 86654},
																					val:        "\\U",
																					ignoreCase: false,
																					want:       "\"\\\\U\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 14, offset: 86663},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 26, offset: 86675},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 38, offset: 86687},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 50, offset: 86699},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 62, offset: 86711},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 74, offset: 86723},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 86, offset: 86735},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 98, offset: 86747},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2570, col: 24, offset: 88132},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2570, col: 24, offset: 88132},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2570, col: 29, offset: 88137},
																				val:        "[abfnrtv\\\\\\]",
																				chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 2484, col: 75, offset: 84423},
																		val:        "[^\\\\\\\\n]",
																		chars:      []rune{'\'', '\\', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																	&seqExpr{
																		pos: position{line: 2486, col: 24, offset: 84569},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2486, col: 24, offset: 84569},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2487, col: 24, offset: 84636},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2487, col: 24, offset: 84636},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2488, col: 5, offset: 84673},
																		run: (*parser).callonSingleLineGoExpression80,
																		expr: &seqExpr{
																			pos: position{line: 2488, col: 5, offset: 84673},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2488, col: 5, offset: 84673},
																					val:        "\\x",
																					ignoreCase: false,
																					want:       "\"\\\\x\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 14, offset: 84682},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 26, offset: 84694},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2571, col: 24, offset: 88215},
																		run: (*parser).callonSingleLineGoExpression87,
																		expr: &seqExpr{
																			pos: position{line: 2571, col: 24, offset: 88215},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2571, col: 24, offset: 88215},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2595, col: 5, offset: 89231},
																		run: (*parser).callonSingleLineGoExpression98,
																		expr: &seqExpr{
																			pos: position{line: 2595, col: 5, offset: 89231},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2595, col: 5, offset: 89231},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2616, col: 5, offset: 90072},
																		run: (*parser).callonSingleLineGoExpression105,
																		expr: &seqExpr{
																			pos: position{line: 2616, col: 5, offset: 90072},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2616, col: 5, offset: 90072},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2634, col: 5, offset: 90757},
																		run: (*parser).callonSingleLineGoExpression110,
																		expr: &seqExpr{
																			pos: position{line: 2634, col: 5, offset: 90757},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2634, col: 5, offset: 90757},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2634, col: 10, offset: 90762},
																					expr: &charClassMatcher{
																						pos:        position{line: 3797, col: 12, offset: 129189},
																						val:        "[^\\r\\n]",
																						chars:      []rune{'\r', '\n'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2457, col: 76, offset: 83222},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
														},
													},
													&actionExpr{
														pos: position{line: 2458, col: 5, offset: 83233},
														run: (*parser).callonSingleLineGoExpression116,
														expr: &seqExpr{
															pos: position{line: 2458, col: 5, offset: 83233},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2458, col: 5, offset: 83233},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 10, offset: 83238},
																	label: "valsI",
																	expr: &zeroOrMoreExpr{
																		pos: position{line: 2458, col: 16, offset: 83244},
																		expr: &choiceExpr{
																			pos: position{line: 2458, col: 17, offset: 83245},
																			alternatives: []any{
																				&seqExpr{
																					pos: position{line: 2505, col: 19, offset: 85311},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2505, col: 19, offset: 85311},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2506, col: 5, offset: 85370},
																					run: (*parser).callonSingleLineGoExpression128,
																					expr: &seqExpr{
																						pos: position{line: 2506, col: 5, offset: 85370},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2506, col: 5, offset: 85370},
																								val:        "\\u",
																								ignoreCase: false,
																								want:       "\"\\\\u\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 14, offset: 85379},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 26, offset: 85391},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 38, offset: 85403},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 50, offset: 85415},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2535, col: 16, offset: 86551},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2535, col: 16, offset: 86551},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2536, col: 5, offset: 86654},
																					run: (*parser).callonSingleLineGoExpression149,
																					expr: &seqExpr{
																						pos: position{line: 2536, col: 5, offset: 86654},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2536, col: 5, offset: 86654},
																								val:        "\\U",
																								ignoreCase: false,
																								want:       "\"\\\\U\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 14, offset: 86663},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 26, offset: 86675},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 38, offset: 86687},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 50, offset: 86699},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 62, offset: 86711},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 74, offset: 86723},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 86, offset: 86735},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 98, offset: 86747},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2570, col: 24, offset: 88132},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2570, col: 24, offset: 88132},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2570, col: 29, offset: 88137},
																							val:        "[abfnrtv\\\\\\]",
																							chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2484, col: 75, offset: 84423},
																					val:        "[^\\\\\\\\n]",
																					chars:      []rune{'\'', '\\', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																				&seqExpr{
																					pos: position{line: 2486, col: 24, offset: 84569},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2486, col: 24, offset: 84569},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2487, col: 24, offset: 84636},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2487, col: 24, offset: 84636},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2488, col: 5, offset: 84673},
																					run: (*parser).callonSingleLineGoExpression181,
																					expr: &seqExpr{
																						pos: position{line: 2488, col: 5, offset: 84673},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2488, col: 5, offset: 84673},
																								val:        "\\x",
																								ignoreCase: false,
																								want:       "\"\\\\x\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 14, offset: 84682},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 26, offset: 84694},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2571, col: 24, offset: 88215},
																					run: (*parser).callonSingleLineGoExpression188,
																					expr: &seqExpr{
																						pos: position{line: 2571, col: 24, offset: 88215},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2571, col: 24, offset: 88215},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2595, col: 5, offset: 89231},
																					run: (*parser).callonSingleLineGoExpression199,
																					expr: &seqExpr{
																						pos: position{line: 2595, col: 5, offset: 89231},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2595, col: 5, offset: 89231},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2616, col: 5, offset: 90072},
																					run: (*parser).callonSingleLineGoExpression206,
																					expr: &seqExpr{
																						pos: position{line: 2616, col: 5, offset: 90072},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2616, col: 5, offset: 90072},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2634, col: 5, offset: 90757},
																					run: (*parser).callonSingleLineGoExpression211,
																					expr: &seqExpr{
																						pos: position{line: 2634, col: 5, offset: 90757},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2634, col: 5, offset: 90757},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2634, col: 10, offset: 90762},
																								expr: &charClassMatcher{
																									pos:        position{line: 3797, col: 12, offset: 129189},
																									val:        "[^\\r\\n]",
																									chars:      []rune{'\r', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&litMatcher{
																	pos:        position{line: 2458, col: 74, offset: 83302},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 79, offset: 83307},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonSingleLineGoExpression218,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 1501, col: 5, offset: 48168},
									run: (*parser).callonSingleLineGoExpression224,
									expr: &seqExpr{
										pos: position{line: 1501, col: 5, offset: 48168},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1501, col: 5, offset: 48168},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonSingleLineGoExpression227,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&notExpr{
												pos: position{line: 1501, col: 14, offset: 48177},
												expr: &choiceExpr{
													pos: position{line: 1405, col: 25, offset: 44841},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 1405, col: 25, offset: 44841},
															val:        "[)}],]",
															chars:      []rune{')', '}', ']', ','},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 1405, col: 40, offset: 44856},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 1405, col: 40, offset: 44856},
																	val:        ":",
																	ignoreCase: false,
																	want:       "\":\"",
																},
																&notExpr{
																	pos: position{line: 1405, col: 44, offset: 44860},
																	expr: &litMatcher{
																		pos:        position{line: 1405, col: 45, offset: 44861},
																		val:        "=",
																		ignoreCase: false,
																		want:       "\"=\"",
																	},
																},
															},
														},
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 3797, col: 12, offset: 129189},
												val:        "[^\\r\\n]",
												chars:      []rune{'\r', '\n'},
												ignoreCase: false,
												inverted:   true,
											},
											&zeroOrMoreExpr{
												pos: position{line: 1501, col: 44, offset: 48207},
												expr: &seqExpr{
													pos: position{line: 1501, col: 45, offset: 48208},
													exprs: []any{
														&notExpr{
															pos: position{line: 1501, col: 45, offset: 48208},
															expr: &choiceExpr{
																pos: position{line: 1405, col: 25, offset: 44841},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 1405, col: 25, offset: 44841},
																		val:        "[)}],]",
																		chars:      []rune{')', '}', ']', ','},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 1405, col: 40, offset: 44856},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 1405, col: 40, offset: 44856},
																				val:        ":",
																				ignoreCase: false,
																				want:       "\":\"",
																			},
																			&notExpr{
																				pos: position{line: 1405, col: 44, offset: 44860},
																				expr: &litMatcher{
																					pos:        position{line: 1405, col: 45, offset: 44861},
																					val:        "=",
																					ignoreCase: false,
																					want:       "\"=\"",
																				},
																			},
																		},
																	},
																},
															},
														},
														&notExpr{
															pos: position{line: 1501, col: 67, offset: 48230},
															expr: &seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
														&charClassMatcher{
															pos:        position{line: 1501, col: 72, offset: 48235},
															val:        "[^\\\"`?([{]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineGoParenExpr",
			pos:  position{line: 1508, col: 1, offset: 48400},
			expr: &choiceExpr{
				pos: position{line: 1508, col: 26, offset: 48425},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1508, col: 26, offset: 48425},
						run: (*parser).callonsingleLineGoParenExpr2,
						expr: &labeledExpr{
							pos:   position{line: 1508, col: 26, offset: 48425},
							label: "exprI",
							expr: &choiceExpr{
								pos: position{line: 1508, col: 33, offset: 48432},
								alternatives: []any{
									&seqExpr{
										pos: position{line: 1508, col: 33, offset: 48432},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 1508, col: 33, offset: 48432},
												val:        "(",
												ignoreCase: false,
												want:       "\"(\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1508, col: 37, offset: 48436},
												expr: &ruleRefExpr{
													pos:  position{line: 1508, col: 37, offset: 48436},
													name: "singleLineGoSubExpression",
												},
											},
											&actionExpr{
												pos: position{line: 3799, col: 8, offset: 129205},
												run: (*parser).callonsingleLineGoParenExpr9,
												expr: &choiceExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													alternatives: []any{
														&andExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															expr: &anyMatcher{
																line: 3799, col: 10, offset: 129207,
															},
														},
														&notExpr{
															pos: position{line: 3799, col: 14, offset: 129211},
															expr: &anyMatcher{
																line: 3799, col: 15, offset: 129212,
															},
														},
													},
												},
											},
											&litMatcher{
												pos:        position{line: 1508, col: 68, offset: 48467},
												val:        ")",
												ignoreCase: false,
												want:       "\")\"",
											},
										},
									},
									&seqExpr{
										pos: position{line: 1508, col: 74, offset: 48473},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 1508, col: 74, offset: 48473},
												val:        "[",
												ignoreCase: false,
												want:       "\"[\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1508, col: 78, offset: 48477},
												expr: &ruleRefExpr{
													pos:  position{line: 1508, col: 78, offset: 48477},
													name: "singleLineGoSubExpression",
												},
											},
											&actionExpr{
												pos: position{line: 3799, col: 8, offset: 129205},
												run: (*parser).callonsingleLineGoParenExpr20,
												expr: &choiceExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													alternatives: []any{
														&andExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															expr: &anyMatcher{
																line: 3799, col: 10, offset: 129207,
															},
														},
														&notExpr{
															pos: position{line: 3799, col: 14, offset: 129211},
															expr: &anyMatcher{
																line: 3799, col: 15, offset: 129212,
															},
														},
													},
												},
											},
											&litMatcher{
												pos:        position{line: 1508, col: 109, offset: 48508},
												val:        "]",
												ignoreCase: false,
												want:       "\"]\"",
											},
										},
									},
									&seqExpr{
										pos: position{line: 1508, col: 115, offset: 48514},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 1508, col: 115, offset: 48514},
												val:        "{",
												ignoreCase: false,
												want:       "\"{\"",
											},
											&zeroOrOneExpr{
												pos: position{line: 1508, col: 119, offset: 48518},
												expr: &ruleRefExpr{
													pos:  position{line: 1508, col: 119, offset: 48518},
													name: "singleLineGoSubExpression",
												},
											},
											&actionExpr{
												pos: position{line: 3799, col: 8, offset: 129205},
												run: (*parser).callonsingleLineGoParenExpr31,
												expr: &choiceExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													alternatives: []any{
														&andExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															expr: &anyMatcher{
																line: 3799, col: 10, offset: 129207,
															},
														},
														&notExpr{
															pos: position{line: 3799, col: 14, offset: 129211},
															expr: &anyMatcher{
																line: 3799, col: 15, offset: 129212,
															},
														},
													},
												},
											},
											&litMatcher{
												pos:        position{line: 1508, col: 150, offset: 48549},
												val:        "}",
												ignoreCase: false,
												want:       "\"}\"",
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1531, col: 5, offset: 49198},
						run: (*parser).callonsingleLineGoParenExpr38,
						expr: &seqExpr{
							pos: position{line: 1531, col: 5, offset: 49198},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 1531, col: 5, offset: 49198},
									label: "parenI",
									expr: &charClassMatcher{
										pos:        position{line: 1531, col: 12, offset: 49205},
										val:        "[([{]",
										chars:      []rune{'(', '[', '{'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&labeledExpr{
									pos:   position{line: 1531, col: 18, offset: 49211},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonsingleLineGoParenExpr43,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1531, col: 32, offset: 49225},
									label: "exprI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1531, col: 38, offset: 49231},
										expr: &ruleRefExpr{
											pos:  position{line: 1531, col: 38, offset: 49231},
											name: "singleLineGoSubExpression",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineGoSubExpression",
			pos:  position{line: 1562, col: 1, offset: 50127},
			expr: &actionExpr{
				pos: position{line: 1562, col: 30, offset: 50156},
				run: (*parser).callonsingleLineGoSubExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1562, col: 30, offset: 50156},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1562, col: 37, offset: 50163},
						expr: &choiceExpr{
							pos: position{line: 1563, col: 5, offset: 50169},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 1563, col: 5, offset: 50169},
									name: "singleLineGoParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 1563, col: 29, offset: 50193},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1563, col: 48, offset: 50212},
									name: "SingleLineTernaryExpression",
								},
								&actionExpr{
									pos: position{line: 1477, col: 15, offset: 47305},
									run: (*parser).callonsingleLineGoSubExpression8,
									expr: &seqExpr{
										pos: position{line: 1477, col: 15, offset: 47305},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1477, col: 15, offset: 47305},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonsingleLineGoSubExpression11,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&choiceExpr{
												pos: position{line: 2457, col: 14, offset: 83160},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 2457, col: 14, offset: 83160},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2457, col: 14, offset: 83160},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&choiceExpr{
																pos: position{line: 2457, col: 20, offset: 83166},
																alternatives: []any{
																	&seqExpr{
																		pos: position{line: 2505, col: 19, offset: 85311},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2505, col: 19, offset: 85311},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2506, col: 5, offset: 85370},
																		run: (*parser).callonsingleLineGoSubExpression27,
																		expr: &seqExpr{
																			pos: position{line: 2506, col: 5, offset: 85370},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2506, col: 5, offset: 85370},
																					val:        "\\u",
																					ignoreCase: false,
																					want:       "\"\\\\u\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 14, offset: 85379},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 26, offset: 85391},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 38, offset: 85403},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 50, offset: 85415},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2535, col: 16, offset: 86551},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2535, col: 16, offset: 86551},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2536, col: 5, offset: 86654},
																		run: (*parser).callonsingleLineGoSubExpression48,
																		expr: &seqExpr{
																			pos: position{line: 2536, col: 5, offset: 86654},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2536, col: 5, offset: 86654},
																					val:        "\\U",
																					ignoreCase: false,
																					want:       "\"\\\\U\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 14, offset: 86663},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 26, offset: 86675},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 38, offset: 86687},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 50, offset: 86699},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 62, offset: 86711},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 74, offset: 86723},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 86, offset: 86735},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 98, offset: 86747},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2570, col: 24, offset: 88132},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2570, col: 24, offset: 88132},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2570, col: 29, offset: 88137},
																				val:        "[abfnrtv\\\\\\]",
																				chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 2484, col: 75, offset: 84423},
																		val:        "[^\\\\\\\\n]",
																		chars:      []rune{'\'', '\\', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																	&seqExpr{
																		pos: position{line: 2486, col: 24, offset: 84569},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2486, col: 24, offset: 84569},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2487, col: 24, offset: 84636},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2487, col: 24, offset: 84636},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2488, col: 5, offset: 84673},
																		run: (*parser).callonsingleLineGoSubExpression80,
																		expr: &seqExpr{
																			pos: position{line: 2488, col: 5, offset: 84673},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2488, col: 5, offset: 84673},
																					val:        "\\x",
																					ignoreCase: false,
																					want:       "\"\\\\x\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 14, offset: 84682},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 26, offset: 84694},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2571, col: 24, offset: 88215},
																		run: (*parser).callonsingleLineGoSubExpression87,
																		expr: &seqExpr{
																			pos: position{line: 2571, col: 24, offset: 88215},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2571, col: 24, offset: 88215},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2595, col: 5, offset: 89231},
																		run: (*parser).callonsingleLineGoSubExpression98,
																		expr: &seqExpr{
																			pos: position{line: 2595, col: 5, offset: 89231},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2595, col: 5, offset: 89231},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2616, col: 5, offset: 90072},
																		run: (*parser).callonsingleLineGoSubExpression105,
																		expr: &seqExpr{
																			pos: position{line: 2616, col: 5, offset: 90072},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2616, col: 5, offset: 90072},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2634, col: 5, offset: 90757},
																		run: (*parser).callonsingleLineGoSubExpression110,
																		expr: &seqExpr{
																			pos: position{line: 2634, col: 5, offset: 90757},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2634, col: 5, offset: 90757},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2634, col: 10, offset: 90762},
																					expr: &charClassMatcher{
																						pos:        position{line: 3797, col: 12, offset: 129189},
																						val:        "[^\\r\\n]",
																						chars:      []rune{'\r', '\n'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2457, col: 76, offset: 83222},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
														},
													},
													&actionExpr{
														pos: position{line: 2458, col: 5, offset: 83233},
														run: (*parser).callonsingleLineGoSubExpression116,
														expr: &seqExpr{
															pos: position{line: 2458, col: 5, offset: 83233},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2458, col: 5, offset: 83233},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 10, offset: 83238},
																	label: "valsI",
																	expr: &zeroOrMoreExpr{
																		pos: position{line: 2458, col: 16, offset: 83244},
																		expr: &choiceExpr{
																			pos: position{line: 2458, col: 17, offset: 83245},
																			alternatives: []any{
																				&seqExpr{
																					pos: position{line: 2505, col: 19, offset: 85311},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2505, col: 19, offset: 85311},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2506, col: 5, offset: 85370},
																					run: (*parser).callonsingleLineGoSubExpression128,
																					expr: &seqExpr{
																						pos: position{line: 2506, col: 5, offset: 85370},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2506, col: 5, offset: 85370},
																								val:        "\\u",
																								ignoreCase: false,
																								want:       "\"\\\\u\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 14, offset: 85379},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 26, offset: 85391},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 38, offset: 85403},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 50, offset: 85415},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2535, col: 16, offset: 86551},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2535, col: 16, offset: 86551},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2536, col: 5, offset: 86654},
																					run: (*parser).callonsingleLineGoSubExpression149,
																					expr: &seqExpr{
																						pos: position{line: 2536, col: 5, offset: 86654},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2536, col: 5, offset: 86654},
																								val:        "\\U",
																								ignoreCase: false,
																								want:       "\"\\\\U\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 14, offset: 86663},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 26, offset: 86675},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 38, offset: 86687},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 50, offset: 86699},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 62, offset: 86711},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 74, offset: 86723},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 86, offset: 86735},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 98, offset: 86747},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2570, col: 24, offset: 88132},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2570, col: 24, offset: 88132},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2570, col: 29, offset: 88137},
																							val:        "[abfnrtv\\\\\\]",
																							chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2484, col: 75, offset: 84423},
																					val:        "[^\\\\\\\\n]",
																					chars:      []rune{'\'', '\\', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																				&seqExpr{
																					pos: position{line: 2486, col: 24, offset: 84569},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2486, col: 24, offset: 84569},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2487, col: 24, offset: 84636},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2487, col: 24, offset: 84636},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2488, col: 5, offset: 84673},
																					run: (*parser).callonsingleLineGoSubExpression181,
																					expr: &seqExpr{
																						pos: position{line: 2488, col: 5, offset: 84673},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2488, col: 5, offset: 84673},
																								val:        "\\x",
																								ignoreCase: false,
																								want:       "\"\\\\x\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 14, offset: 84682},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 26, offset: 84694},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2571, col: 24, offset: 88215},
																					run: (*parser).callonsingleLineGoSubExpression188,
																					expr: &seqExpr{
																						pos: position{line: 2571, col: 24, offset: 88215},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2571, col: 24, offset: 88215},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2595, col: 5, offset: 89231},
																					run: (*parser).callonsingleLineGoSubExpression199,
																					expr: &seqExpr{
																						pos: position{line: 2595, col: 5, offset: 89231},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2595, col: 5, offset: 89231},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2616, col: 5, offset: 90072},
																					run: (*parser).callonsingleLineGoSubExpression206,
																					expr: &seqExpr{
																						pos: position{line: 2616, col: 5, offset: 90072},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2616, col: 5, offset: 90072},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2634, col: 5, offset: 90757},
																					run: (*parser).callonsingleLineGoSubExpression211,
																					expr: &seqExpr{
																						pos: position{line: 2634, col: 5, offset: 90757},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2634, col: 5, offset: 90757},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2634, col: 10, offset: 90762},
																								expr: &charClassMatcher{
																									pos:        position{line: 3797, col: 12, offset: 129189},
																									val:        "[^\\r\\n]",
																									chars:      []rune{'\r', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&litMatcher{
																	pos:        position{line: 2458, col: 74, offset: 83302},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 79, offset: 83307},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonsingleLineGoSubExpression218,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 1564, col: 5, offset: 50259},
									run: (*parser).callonsingleLineGoSubExpression224,
									expr: &seqExpr{
										pos: position{line: 1564, col: 5, offset: 50259},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1564, col: 5, offset: 50259},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonsingleLineGoSubExpression227,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&notExpr{
												pos: position{line: 1564, col: 14, offset: 50268},
												expr: &seqExpr{
													pos: position{line: 3796, col: 12, offset: 129156},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 3796, col: 12, offset: 129156},
															expr: &charClassMatcher{
																pos:        position{line: 3808, col: 36, offset: 129503},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&choiceExpr{
															pos: position{line: 3796, col: 16, offset: 129160},
															alternatives: []any{
																&seqExpr{
																	pos: position{line: 3796, col: 16, offset: 129160},
																	exprs: []any{
																		&zeroOrOneExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			expr: &litMatcher{
																				pos:        position{line: 3796, col: 16, offset: 129160},
																				val:        "\r",
																				ignoreCase: false,
																				want:       "\"\\r\"",
																			},
																		},
																		&litMatcher{
																			pos:        position{line: 3796, col: 22, offset: 129166},
																			val:        "\n",
																			ignoreCase: false,
																			want:       "\"\\n\"",
																		},
																	},
																},
																&notExpr{
																	pos: position{line: 3795, col: 12, offset: 129142},
																	expr: &anyMatcher{
																		line: 3795, col: 13, offset: 129143,
																	},
																},
															},
														},
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 1564, col: 19, offset: 50273},
												val:        "[^)}]]",
												chars:      []rune{')', '}', ']'},
												ignoreCase: false,
												inverted:   true,
											},
											&zeroOrMoreExpr{
												pos: position{line: 1564, col: 27, offset: 50281},
												expr: &seqExpr{
													pos: position{line: 1564, col: 28, offset: 50282},
													exprs: []any{
														&notExpr{
															pos: position{line: 1564, col: 28, offset: 50282},
															expr: &seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
														&charClassMatcher{
															pos:        position{line: 1564, col: 33, offset: 50287},
															val:        "[^\\\"`?([{}])]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{', '}', ']', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "IfExpression",
			pos:  position{line: 1577, col: 1, offset: 50689},
			expr: &choiceExpr{
				pos: position{line: 1577, col: 17, offset: 50705},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1577, col: 17, offset: 50705},
						run: (*parser).callonIfExpression2,
						expr: &labeledExpr{
							pos:   position{line: 1577, col: 17, offset: 50705},
							label: "cExprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1577, col: 24, offset: 50712},
								name: "ChainExpression",
							},
						},
					},
					&actionExpr{
						pos: position{line: 1594, col: 5, offset: 51317},
						run: (*parser).callonIfExpression5,
						expr: &labeledExpr{
							pos:   position{line: 1594, col: 5, offset: 51317},
							label: "exprsI",
							expr: &oneOrMoreExpr{
								pos: position{line: 1594, col: 12, offset: 51324},
								expr: &choiceExpr{
									pos: position{line: 1595, col: 5, offset: 51330},
									alternatives: []any{
										&ruleRefExpr{
											pos:  position{line: 1595, col: 5, offset: 51330},
											name: "goParenExpr",
										},
										&ruleRefExpr{
											pos:  position{line: 1595, col: 19, offset: 51344},
											name: "StringExpression",
										},
										&ruleRefExpr{
											pos:  position{line: 1595, col: 38, offset: 51363},
											name: "TernaryExpression",
										},
										&actionExpr{
											pos: position{line: 1477, col: 15, offset: 47305},
											run: (*parser).callonIfExpression12,
											expr: &seqExpr{
												pos: position{line: 1477, col: 15, offset: 47305},
												exprs: []any{
													&labeledExpr{
														pos:   position{line: 1477, col: 15, offset: 47305},
														label: "posI",
														expr: &actionExpr{
															pos: position{line: 3799, col: 8, offset: 129205},
															run: (*parser).callonIfExpression15,
															expr: &choiceExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																alternatives: []any{
																	&andExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		expr: &anyMatcher{
																			line: 3799, col: 10, offset: 129207,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3799, col: 14, offset: 129211},
																		expr: &anyMatcher{
																			line: 3799, col: 15, offset: 129212,
																		},
																	},
																},
															},
														},
													},
													&choiceExpr{
														pos: position{line: 2457, col: 14, offset: 83160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 2457, col: 14, offset: 83160},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 2457, col: 14, offset: 83160},
																		val:        "'",
																		ignoreCase: false,
																		want:       "\"'\"",
																	},
																	&choiceExpr{
																		pos: position{line: 2457, col: 20, offset: 83166},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 2505, col: 19, offset: 85311},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 2505, col: 19, offset: 85311},
																						val:        "\\u",
																						ignoreCase: false,
																						want:       "\"\\\\u\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2506, col: 5, offset: 85370},
																				run: (*parser).callonIfExpression31,
																				expr: &seqExpr{
																					pos: position{line: 2506, col: 5, offset: 85370},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2506, col: 5, offset: 85370},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2506, col: 14, offset: 85379},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2506, col: 26, offset: 85391},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2506, col: 38, offset: 85403},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2506, col: 50, offset: 85415},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2535, col: 16, offset: 86551},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 2535, col: 16, offset: 86551},
																						val:        "\\U",
																						ignoreCase: false,
																						want:       "\"\\\\U\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2536, col: 5, offset: 86654},
																				run: (*parser).callonIfExpression52,
																				expr: &seqExpr{
																					pos: position{line: 2536, col: 5, offset: 86654},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2536, col: 5, offset: 86654},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 14, offset: 86663},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 26, offset: 86675},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 38, offset: 86687},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 50, offset: 86699},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 62, offset: 86711},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 74, offset: 86723},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 86, offset: 86735},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 98, offset: 86747},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2570, col: 24, offset: 88132},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 2570, col: 24, offset: 88132},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2570, col: 29, offset: 88137},
																						val:        "[abfnrtv\\\\\\]",
																						chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&charClassMatcher{
																				pos:        position{line: 2484, col: 75, offset: 84423},
																				val:        "[^\\\\\\\\n]",
																				chars:      []rune{'\'', '\\', '\n'},
																				ignoreCase: false,
																				inverted:   true,
																			},
																			&seqExpr{
																				pos: position{line: 2486, col: 24, offset: 84569},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 2486, col: 24, offset: 84569},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2403, col: 19, offset: 81758},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2403, col: 19, offset: 81758},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2403, col: 19, offset: 81758},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2487, col: 24, offset: 84636},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 2487, col: 24, offset: 84636},
																						val:        "\\x",
																						ignoreCase: false,
																						want:       "\"\\\\x\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2488, col: 5, offset: 84673},
																				run: (*parser).callonIfExpression84,
																				expr: &seqExpr{
																					pos: position{line: 2488, col: 5, offset: 84673},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2488, col: 5, offset: 84673},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2488, col: 14, offset: 84682},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2488, col: 26, offset: 84694},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2571, col: 24, offset: 88215},
																				run: (*parser).callonIfExpression91,
																				expr: &seqExpr{
																					pos: position{line: 2571, col: 24, offset: 88215},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2571, col: 24, offset: 88215},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2595, col: 5, offset: 89231},
																				run: (*parser).callonIfExpression102,
																				expr: &seqExpr{
																					pos: position{line: 2595, col: 5, offset: 89231},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2595, col: 5, offset: 89231},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2616, col: 5, offset: 90072},
																				run: (*parser).callonIfExpression109,
																				expr: &seqExpr{
																					pos: position{line: 2616, col: 5, offset: 90072},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2616, col: 5, offset: 90072},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2634, col: 5, offset: 90757},
																				run: (*parser).callonIfExpression114,
																				expr: &seqExpr{
																					pos: position{line: 2634, col: 5, offset: 90757},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2634, col: 5, offset: 90757},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2634, col: 10, offset: 90762},
																							expr: &charClassMatcher{
																								pos:        position{line: 3797, col: 12, offset: 129189},
																								val:        "[^\\r\\n]",
																								chars:      []rune{'\r', '\n'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 2457, col: 76, offset: 83222},
																		val:        "'",
																		ignoreCase: false,
																		want:       "\"'\"",
																	},
																},
															},
															&actionExpr{
																pos: position{line: 2458, col: 5, offset: 83233},
																run: (*parser).callonIfExpression120,
																expr: &seqExpr{
																	pos: position{line: 2458, col: 5, offset: 83233},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 2458, col: 5, offset: 83233},
																			val:        "'",
																			ignoreCase: false,
																			want:       "\"'\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 2458, col: 10, offset: 83238},
																			label: "valsI",
																			expr: &zeroOrMoreExpr{
																				pos: position{line: 2458, col: 16, offset: 83244},
																				expr: &choiceExpr{
																					pos: position{line: 2458, col: 17, offset: 83245},
																					alternatives: []any{
																						&seqExpr{
																							pos: position{line: 2505, col: 19, offset: 85311},
																							exprs: []any{
																								&litMatcher{
																									pos:        position{line: 2505, col: 19, offset: 85311},
																									val:        "\\u",
																									ignoreCase: false,
																									want:       "\"\\\\u\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2506, col: 5, offset: 85370},
																							run: (*parser).callonIfExpression132,
																							expr: &seqExpr{
																								pos: position{line: 2506, col: 5, offset: 85370},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2506, col: 5, offset: 85370},
																										val:        "\\u",
																										ignoreCase: false,
																										want:       "\"\\\\u\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2506, col: 14, offset: 85379},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2506, col: 26, offset: 85391},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2506, col: 38, offset: 85403},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2506, col: 50, offset: 85415},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2535, col: 16, offset: 86551},
																							exprs: []any{
																								&litMatcher{
																									pos:        position{line: 2535, col: 16, offset: 86551},
																									val:        "\\U",
																									ignoreCase: false,
																									want:       "\"\\\\U\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2536, col: 5, offset: 86654},
																							run: (*parser).callonIfExpression153,
																							expr: &seqExpr{
																								pos: position{line: 2536, col: 5, offset: 86654},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2536, col: 5, offset: 86654},
																										val:        "\\U",
																										ignoreCase: false,
																										want:       "\"\\\\U\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 14, offset: 86663},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 26, offset: 86675},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 38, offset: 86687},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 50, offset: 86699},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 62, offset: 86711},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 74, offset: 86723},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 86, offset: 86735},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 98, offset: 86747},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2570, col: 24, offset: 88132},
																							exprs: []any{
																								&litMatcher{
																									pos:        position{line: 2570, col: 24, offset: 88132},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2570, col: 29, offset: 88137},
																									val:        "[abfnrtv\\\\\\]",
																									chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 2484, col: 75, offset: 84423},
																							val:        "[^\\\\\\\\n]",
																							chars:      []rune{'\'', '\\', '\n'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																						&seqExpr{
																							pos: position{line: 2486, col: 24, offset: 84569},
																							exprs: []any{
																								&litMatcher{
																									pos:        position{line: 2486, col: 24, offset: 84569},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2403, col: 19, offset: 81758},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2403, col: 19, offset: 81758},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2403, col: 19, offset: 81758},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2487, col: 24, offset: 84636},
																							exprs: []any{
																								&litMatcher{
																									pos:        position{line: 2487, col: 24, offset: 84636},
																									val:        "\\x",
																									ignoreCase: false,
																									want:       "\"\\\\x\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2488, col: 5, offset: 84673},
																							run: (*parser).callonIfExpression185,
																							expr: &seqExpr{
																								pos: position{line: 2488, col: 5, offset: 84673},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2488, col: 5, offset: 84673},
																										val:        "\\x",
																										ignoreCase: false,
																										want:       "\"\\\\x\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2488, col: 14, offset: 84682},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2488, col: 26, offset: 84694},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2571, col: 24, offset: 88215},
																							run: (*parser).callonIfExpression192,
																							expr: &seqExpr{
																								pos: position{line: 2571, col: 24, offset: 88215},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2571, col: 24, offset: 88215},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2595, col: 5, offset: 89231},
																							run: (*parser).callonIfExpression203,
																							expr: &seqExpr{
																								pos: position{line: 2595, col: 5, offset: 89231},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2595, col: 5, offset: 89231},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2616, col: 5, offset: 90072},
																							run: (*parser).callonIfExpression210,
																							expr: &seqExpr{
																								pos: position{line: 2616, col: 5, offset: 90072},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2616, col: 5, offset: 90072},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2634, col: 5, offset: 90757},
																							run: (*parser).callonIfExpression215,
																							expr: &seqExpr{
																								pos: position{line: 2634, col: 5, offset: 90757},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2634, col: 5, offset: 90757},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2634, col: 10, offset: 90762},
																										expr: &charClassMatcher{
																											pos:        position{line: 3797, col: 12, offset: 129189},
																											val:        "[^\\r\\n]",
																											chars:      []rune{'\r', '\n'},
																											ignoreCase: false,
																											inverted:   true,
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&litMatcher{
																			pos:        position{line: 2458, col: 74, offset: 83302},
																			val:        "'",
																			ignoreCase: false,
																			want:       "\"'\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 2458, col: 79, offset: 83307},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonIfExpression222,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&actionExpr{
											pos: position{line: 1596, col: 5, offset: 51400},
											run: (*parser).callonIfExpression228,
											expr: &seqExpr{
												pos: position{line: 1596, col: 5, offset: 51400},
												exprs: []any{
													&labeledExpr{
														pos:   position{line: 1596, col: 5, offset: 51400},
														label: "posI",
														expr: &actionExpr{
															pos: position{line: 3799, col: 8, offset: 129205},
															run: (*parser).callonIfExpression231,
															expr: &choiceExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																alternatives: []any{
																	&andExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		expr: &anyMatcher{
																			line: 3799, col: 10, offset: 129207,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3799, col: 14, offset: 129211},
																		expr: &anyMatcher{
																			line: 3799, col: 15, offset: 129212,
																		},
																	},
																},
															},
														},
													},
													&notExpr{
														pos: position{line: 1596, col: 14, offset: 51409},
														expr: &choiceExpr{
															pos: position{line: 1575, col: 27, offset: 50670},
															alternatives: []any{
																&charClassMatcher{
																	pos:        position{line: 1575, col: 27, offset: 50670},
																	val:        "[)}]]",
																	chars:      []rune{')', '}', ']'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&seqExpr{
																	pos: position{line: 1575, col: 36, offset: 50679},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 1575, col: 36, offset: 50679},
																			val:        ":",
																			ignoreCase: false,
																			want:       "\":\"",
																		},
																		&notExpr{
																			pos: position{line: 1575, col: 40, offset: 50683},
																			expr: &litMatcher{
																				pos:        position{line: 1575, col: 41, offset: 50684},
																				val:        "=",
																				ignoreCase: false,
																				want:       "\"=\"",
																			},
																		},
																	},
																},
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 3797, col: 12, offset: 129189},
														val:        "[^\\r\\n]",
														chars:      []rune{'\r', '\n'},
														ignoreCase: false,
														inverted:   true,
													},
													&zeroOrMoreExpr{
														pos: position{line: 1596, col: 46, offset: 51441},
														expr: &seqExpr{
															pos: position{line: 1596, col: 47, offset: 51442},
															exprs: []any{
																&notExpr{
																	pos: position{line: 1596, col: 47, offset: 51442},
																	expr: &choiceExpr{
																		pos: position{line: 1575, col: 27, offset: 50670},
																		alternatives: []any{
																			&charClassMatcher{
																				pos:        position{line: 1575, col: 27, offset: 50670},
																				val:        "[)}]]",
																				chars:      []rune{')', '}', ']'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&seqExpr{
																				pos: position{line: 1575, col: 36, offset: 50679},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 1575, col: 36, offset: 50679},
																						val:        ":",
																						ignoreCase: false,
																						want:       "\":\"",
																					},
																					&notExpr{
																						pos: position{line: 1575, col: 40, offset: 50683},
																						expr: &litMatcher{
																							pos:        position{line: 1575, col: 41, offset: 50684},
																							val:        "=",
																							ignoreCase: false,
																							want:       "\"=\"",
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&notExpr{
																	pos: position{line: 1596, col: 71, offset: 51466},
																	expr: &seqExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		exprs: []any{
																			&zeroOrMoreExpr{
																				pos: position{line: 3796, col: 12, offset: 129156},
																				expr: &charClassMatcher{
																					pos:        position{line: 3808, col: 36, offset: 129503},
																					val:        "[ \\t]",
																					chars:      []rune{' ', '\t'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&choiceExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				alternatives: []any{
																					&seqExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						exprs: []any{
																							&zeroOrOneExpr{
																								pos: position{line: 3796, col: 16, offset: 129160},
																								expr: &litMatcher{
																									pos:        position{line: 3796, col: 16, offset: 129160},
																									val:        "\r",
																									ignoreCase: false,
																									want:       "\"\\r\"",
																								},
																							},
																							&litMatcher{
																								pos:        position{line: 3796, col: 22, offset: 129166},
																								val:        "\n",
																								ignoreCase: false,
																								want:       "\"\\n\"",
																							},
																						},
																					},
																					&notExpr{
																						pos: position{line: 3795, col: 12, offset: 129142},
																						expr: &anyMatcher{
																							line: 3795, col: 13, offset: 129143,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&charClassMatcher{
																	pos:        position{line: 1596, col: 76, offset: 51471},
																	val:        "[^\\\"`?([{]",
																	chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineIfExpression",
			pos:  position{line: 1603, col: 1, offset: 51636},
			expr: &choiceExpr{
				pos: position{line: 1603, col: 27, offset: 51662},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1603, col: 27, offset: 51662},
						run: (*parser).callonSingleLineIfExpression2,
						expr: &labeledExpr{
							pos:   position{line: 1603, col: 27, offset: 51662},
							label: "cExprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1603, col: 34, offset: 51669},
								name: "SingleLineChainExpression",
							},
						},
					},
					&actionExpr{
						pos: position{line: 1620, col: 5, offset: 52284},
						run: (*parser).callonSingleLineIfExpression5,
						expr: &labeledExpr{
							pos:   position{line: 1620, col: 5, offset: 52284},
							label: "exprsI",
							expr: &oneOrMoreExpr{
								pos: position{line: 1620, col: 12, offset: 52291},
								expr: &choiceExpr{
									pos: position{line: 1621, col: 5, offset: 52297},
									alternatives: []any{
										&ruleRefExpr{
											pos:  position{line: 1621, col: 5, offset: 52297},
											name: "singleLineGoParenExpr",
										},
										&ruleRefExpr{
											pos:  position{line: 1621, col: 29, offset: 52321},
											name: "StringExpression",
										},
										&ruleRefExpr{
											pos:  position{line: 1621, col: 48, offset: 52340},
											name: "SingleLineTernaryExpression",
										},
										&actionExpr{
											pos: position{line: 1477, col: 15, offset: 47305},
											run: (*parser).callonSingleLineIfExpression12,
											expr: &seqExpr{
												pos: position{line: 1477, col: 15, offset: 47305},
												exprs: []any{
													&labeledExpr{
														pos:   position{line: 1477, col: 15, offset: 47305},
														label: "posI",
														expr: &actionExpr{
															pos: position{line: 3799, col: 8, offset: 129205},
															run: (*parser).callonSingleLineIfExpression15,
															expr: &choiceExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																alternatives: []any{
																	&andExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		expr: &anyMatcher{
																			line: 3799, col: 10, offset: 129207,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3799, col: 14, offset: 129211},
																		expr: &anyMatcher{
																			line: 3799, col: 15, offset: 129212,
																		},
																	},
																},
															},
														},
													},
													&choiceExpr{
														pos: position{line: 2457, col: 14, offset: 83160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 2457, col: 14, offset: 83160},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 2457, col: 14, offset: 83160},
																		val:        "'",
																		ignoreCase: false,
																		want:       "\"'\"",
																	},
																	&choiceExpr{
																		pos: position{line: 2457, col: 20, offset: 83166},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 2505, col: 19, offset: 85311},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 2505, col: 19, offset: 85311},
																						val:        "\\u",
																						ignoreCase: false,
																						want:       "\"\\\\u\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2506, col: 5, offset: 85370},
																				run: (*parser).callonSingleLineIfExpression31,
																				expr: &seqExpr{
																					pos: position{line: 2506, col: 5, offset: 85370},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2506, col: 5, offset: 85370},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2506, col: 14, offset: 85379},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2506, col: 26, offset: 85391},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2506, col: 38, offset: 85403},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2506, col: 50, offset: 85415},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2535, col: 16, offset: 86551},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 2535, col: 16, offset: 86551},
																						val:        "\\U",
																						ignoreCase: false,
																						want:       "\"\\\\U\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2536, col: 5, offset: 86654},
																				run: (*parser).callonSingleLineIfExpression52,
																				expr: &seqExpr{
																					pos: position{line: 2536, col: 5, offset: 86654},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2536, col: 5, offset: 86654},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 14, offset: 86663},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 26, offset: 86675},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 38, offset: 86687},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 50, offset: 86699},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 62, offset: 86711},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 74, offset: 86723},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 86, offset: 86735},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2536, col: 98, offset: 86747},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2570, col: 24, offset: 88132},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 2570, col: 24, offset: 88132},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2570, col: 29, offset: 88137},
																						val:        "[abfnrtv\\\\\\]",
																						chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&charClassMatcher{
																				pos:        position{line: 2484, col: 75, offset: 84423},
																				val:        "[^\\\\\\\\n]",
																				chars:      []rune{'\'', '\\', '\n'},
																				ignoreCase: false,
																				inverted:   true,
																			},
																			&seqExpr{
																				pos: position{line: 2486, col: 24, offset: 84569},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 2486, col: 24, offset: 84569},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2403, col: 19, offset: 81758},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2403, col: 19, offset: 81758},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2403, col: 19, offset: 81758},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2487, col: 24, offset: 84636},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 2487, col: 24, offset: 84636},
																						val:        "\\x",
																						ignoreCase: false,
																						want:       "\"\\\\x\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2488, col: 5, offset: 84673},
																				run: (*parser).callonSingleLineIfExpression84,
																				expr: &seqExpr{
																					pos: position{line: 2488, col: 5, offset: 84673},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2488, col: 5, offset: 84673},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2488, col: 14, offset: 84682},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2488, col: 26, offset: 84694},
																							expr: &charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2571, col: 24, offset: 88215},
																				run: (*parser).callonSingleLineIfExpression91,
																				expr: &seqExpr{
																					pos: position{line: 2571, col: 24, offset: 88215},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2571, col: 24, offset: 88215},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2595, col: 5, offset: 89231},
																				run: (*parser).callonSingleLineIfExpression102,
																				expr: &seqExpr{
																					pos: position{line: 2595, col: 5, offset: 89231},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2595, col: 5, offset: 89231},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2616, col: 5, offset: 90072},
																				run: (*parser).callonSingleLineIfExpression109,
																				expr: &seqExpr{
																					pos: position{line: 2616, col: 5, offset: 90072},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2616, col: 5, offset: 90072},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2634, col: 5, offset: 90757},
																				run: (*parser).callonSingleLineIfExpression114,
																				expr: &seqExpr{
																					pos: position{line: 2634, col: 5, offset: 90757},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2634, col: 5, offset: 90757},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2634, col: 10, offset: 90762},
																							expr: &charClassMatcher{
																								pos:        position{line: 3797, col: 12, offset: 129189},
																								val:        "[^\\r\\n]",
																								chars:      []rune{'\r', '\n'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 2457, col: 76, offset: 83222},
																		val:        "'",
																		ignoreCase: false,
																		want:       "\"'\"",
																	},
																},
															},
															&actionExpr{
																pos: position{line: 2458, col: 5, offset: 83233},
																run: (*parser).callonSingleLineIfExpression120,
																expr: &seqExpr{
																	pos: position{line: 2458, col: 5, offset: 83233},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 2458, col: 5, offset: 83233},
																			val:        "'",
																			ignoreCase: false,
																			want:       "\"'\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 2458, col: 10, offset: 83238},
																			label: "valsI",
																			expr: &zeroOrMoreExpr{
																				pos: position{line: 2458, col: 16, offset: 83244},
																				expr: &choiceExpr{
																					pos: position{line: 2458, col: 17, offset: 83245},
																					alternatives: []any{
																						&seqExpr{
																							pos: position{line: 2505, col: 19, offset: 85311},
																							exprs: []any{
																								&litMatcher{
																									pos:        position{line: 2505, col: 19, offset: 85311},
																									val:        "\\u",
																									ignoreCase: false,
																									want:       "\"\\\\u\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2506, col: 5, offset: 85370},
																							run: (*parser).callonSingleLineIfExpression132,
																							expr: &seqExpr{
																								pos: position{line: 2506, col: 5, offset: 85370},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2506, col: 5, offset: 85370},
																										val:        "\\u",
																										ignoreCase: false,
																										want:       "\"\\\\u\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2506, col: 14, offset: 85379},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2506, col: 26, offset: 85391},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2506, col: 38, offset: 85403},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2506, col: 50, offset: 85415},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2535, col: 16, offset: 86551},
																							exprs: []any{
																								&litMatcher{
																									pos:        position{line: 2535, col: 16, offset: 86551},
																									val:        "\\U",
																									ignoreCase: false,
																									want:       "\"\\\\U\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2536, col: 5, offset: 86654},
																							run: (*parser).callonSingleLineIfExpression153,
																							expr: &seqExpr{
																								pos: position{line: 2536, col: 5, offset: 86654},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2536, col: 5, offset: 86654},
																										val:        "\\U",
																										ignoreCase: false,
																										want:       "\"\\\\U\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 14, offset: 86663},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 26, offset: 86675},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 38, offset: 86687},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 50, offset: 86699},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 62, offset: 86711},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 74, offset: 86723},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 86, offset: 86735},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2536, col: 98, offset: 86747},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2570, col: 24, offset: 88132},
																							exprs: []any{
																								&litMatcher{
																									pos:        position{line: 2570, col: 24, offset: 88132},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2570, col: 29, offset: 88137},
																									val:        "[abfnrtv\\\\\\]",
																									chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 2484, col: 75, offset: 84423},
																							val:        "[^\\\\\\\\n]",
																							chars:      []rune{'\'', '\\', '\n'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																						&seqExpr{
																							pos: position{line: 2486, col: 24, offset: 84569},
																							exprs: []any{
																								&litMatcher{
																									pos:        position{line: 2486, col: 24, offset: 84569},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2403, col: 19, offset: 81758},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2403, col: 19, offset: 81758},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2403, col: 19, offset: 81758},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2487, col: 24, offset: 84636},
																							exprs: []any{
																								&litMatcher{
																									pos:        position{line: 2487, col: 24, offset: 84636},
																									val:        "\\x",
																									ignoreCase: false,
																									want:       "\"\\\\x\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2488, col: 5, offset: 84673},
																							run: (*parser).callonSingleLineIfExpression185,
																							expr: &seqExpr{
																								pos: position{line: 2488, col: 5, offset: 84673},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2488, col: 5, offset: 84673},
																										val:        "\\x",
																										ignoreCase: false,
																										want:       "\"\\\\x\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2488, col: 14, offset: 84682},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2488, col: 26, offset: 84694},
																										expr: &charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2571, col: 24, offset: 88215},
																							run: (*parser).callonSingleLineIfExpression192,
																							expr: &seqExpr{
																								pos: position{line: 2571, col: 24, offset: 88215},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2571, col: 24, offset: 88215},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2595, col: 5, offset: 89231},
																							run: (*parser).callonSingleLineIfExpression203,
																							expr: &seqExpr{
																								pos: position{line: 2595, col: 5, offset: 89231},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2595, col: 5, offset: 89231},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2616, col: 5, offset: 90072},
																							run: (*parser).callonSingleLineIfExpression210,
																							expr: &seqExpr{
																								pos: position{line: 2616, col: 5, offset: 90072},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2616, col: 5, offset: 90072},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2634, col: 5, offset: 90757},
																							run: (*parser).callonSingleLineIfExpression215,
																							expr: &seqExpr{
																								pos: position{line: 2634, col: 5, offset: 90757},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2634, col: 5, offset: 90757},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2634, col: 10, offset: 90762},
																										expr: &charClassMatcher{
																											pos:        position{line: 3797, col: 12, offset: 129189},
																											val:        "[^\\r\\n]",
																											chars:      []rune{'\r', '\n'},
																											ignoreCase: false,
																											inverted:   true,
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&litMatcher{
																			pos:        position{line: 2458, col: 74, offset: 83302},
																			val:        "'",
																			ignoreCase: false,
																			want:       "\"'\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 2458, col: 79, offset: 83307},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonSingleLineIfExpression222,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&actionExpr{
											pos: position{line: 1622, col: 5, offset: 52387},
											run: (*parser).callonSingleLineIfExpression228,
											expr: &seqExpr{
												pos: position{line: 1622, col: 5, offset: 52387},
												exprs: []any{
													&labeledExpr{
														pos:   position{line: 1622, col: 5, offset: 52387},
														label: "posI",
														expr: &actionExpr{
															pos: position{line: 3799, col: 8, offset: 129205},
															run: (*parser).callonSingleLineIfExpression231,
															expr: &choiceExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																alternatives: []any{
																	&andExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		expr: &anyMatcher{
																			line: 3799, col: 10, offset: 129207,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3799, col: 14, offset: 129211},
																		expr: &anyMatcher{
																			line: 3799, col: 15, offset: 129212,
																		},
																	},
																},
															},
														},
													},
													&notExpr{
														pos: position{line: 1622, col: 14, offset: 52396},
														expr: &choiceExpr{
															pos: position{line: 1575, col: 27, offset: 50670},
															alternatives: []any{
																&charClassMatcher{
																	pos:        position{line: 1575, col: 27, offset: 50670},
																	val:        "[)}]]",
																	chars:      []rune{')', '}', ']'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&seqExpr{
																	pos: position{line: 1575, col: 36, offset: 50679},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 1575, col: 36, offset: 50679},
																			val:        ":",
																			ignoreCase: false,
																			want:       "\":\"",
																		},
																		&notExpr{
																			pos: position{line: 1575, col: 40, offset: 50683},
																			expr: &litMatcher{
																				pos:        position{line: 1575, col: 41, offset: 50684},
																				val:        "=",
																				ignoreCase: false,
																				want:       "\"=\"",
																			},
																		},
																	},
																},
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 3797, col: 12, offset: 129189},
														val:        "[^\\r\\n]",
														chars:      []rune{'\r', '\n'},
														ignoreCase: false,
														inverted:   true,
													},
													&zeroOrMoreExpr{
														pos: position{line: 1622, col: 46, offset: 52428},
														expr: &seqExpr{
															pos: position{line: 1622, col: 47, offset: 52429},
															exprs: []any{
																&notExpr{
																	pos: position{line: 1622, col: 47, offset: 52429},
																	expr: &choiceExpr{
																		pos: position{line: 1575, col: 27, offset: 50670},
																		alternatives: []any{
																			&charClassMatcher{
																				pos:        position{line: 1575, col: 27, offset: 50670},
																				val:        "[)}]]",
																				chars:      []rune{')', '}', ']'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&seqExpr{
																				pos: position{line: 1575, col: 36, offset: 50679},
																				exprs: []any{
																					&litMatcher{
																						pos:        position{line: 1575, col: 36, offset: 50679},
																						val:        ":",
																						ignoreCase: false,
																						want:       "\":\"",
																					},
																					&notExpr{
																						pos: position{line: 1575, col: 40, offset: 50683},
																						expr: &litMatcher{
																							pos:        position{line: 1575, col: 41, offset: 50684},
																							val:        "=",
																							ignoreCase: false,
																							want:       "\"=\"",
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&notExpr{
																	pos: position{line: 1622, col: 71, offset: 52453},
																	expr: &seqExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		exprs: []any{
																			&zeroOrMoreExpr{
																				pos: position{line: 3796, col: 12, offset: 129156},
																				expr: &charClassMatcher{
																					pos:        position{line: 3808, col: 36, offset: 129503},
																					val:        "[ \\t]",
																					chars:      []rune{' ', '\t'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&choiceExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				alternatives: []any{
																					&seqExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						exprs: []any{
																							&zeroOrOneExpr{
																								pos: position{line: 3796, col: 16, offset: 129160},
																								expr: &litMatcher{
																									pos:        position{line: 3796, col: 16, offset: 129160},
																									val:        "\r",
																									ignoreCase: false,
																									want:       "\"\\r\"",
																								},
																							},
																							&litMatcher{
																								pos:        position{line: 3796, col: 22, offset: 129166},
																								val:        "\n",
																								ignoreCase: false,
																								want:       "\"\\n\"",
																							},
																						},
																					},
																					&notExpr{
																						pos: position{line: 3795, col: 12, offset: 129142},
																						expr: &anyMatcher{
																							line: 3795, col: 13, offset: 129143,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&charClassMatcher{
																	pos:        position{line: 1622, col: 76, offset: 52458},
																	val:        "[^\\\"`?([{]",
																	chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ForExpression",
			pos:  position{line: 1633, col: 1, offset: 52812},
			expr: &choiceExpr{
				pos: position{line: 1633, col: 18, offset: 52829},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1633, col: 18, offset: 52829},
						run: (*parser).callonForExpression2,
						expr: &seqExpr{
							pos: position{line: 1633, col: 18, offset: 52829},
							exprs: []any{
								&oneOrMoreExpr{
									pos: position{line: 1633, col: 18, offset: 52829},
									expr: &litMatcher{
										pos:        position{line: 1633, col: 18, offset: 52829},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1633, col: 23, offset: 52834},
									label: "rExprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1633, col: 30, offset: 52841},
										name: "RangeExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1635, col: 5, offset: 52963},
						run: (*parser).callonForExpression8,
						expr: &seqExpr{
							pos: position{line: 1635, col: 5, offset: 52963},
							exprs: []any{
								&oneOrMoreExpr{
									pos: position{line: 1635, col: 5, offset: 52963},
									expr: &litMatcher{
										pos:        position{line: 1635, col: 5, offset: 52963},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1635, col: 10, offset: 52968},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1635, col: 16, offset: 52974},
										name: "IfExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1637, col: 5, offset: 53038},
						run: (*parser).callonForExpression14,
						expr: &andExpr{
							pos: position{line: 1637, col: 5, offset: 53038},
							expr: &seqExpr{
								pos: position{line: 1637, col: 7, offset: 53040},
								exprs: []any{
									&zeroOrMoreExpr{
										pos: position{line: 1637, col: 7, offset: 53040},
										expr: &litMatcher{
											pos:        position{line: 1637, col: 7, offset: 53040},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&choiceExpr{
										pos: position{line: 1637, col: 13, offset: 53046},
										alternatives: []any{
											&seqExpr{
												pos: position{line: 3796, col: 12, offset: 129156},
												exprs: []any{
													&zeroOrMoreExpr{
														pos: position{line: 3796, col: 12, offset: 129156},
														expr: &charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		expr: &litMatcher{
																			pos:        position{line: 3796, col: 16, offset: 129160},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3796, col: 22, offset: 129166},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3795, col: 12, offset: 129142},
																expr: &anyMatcher{
																	line: 3795, col: 13, offset: 129143,
																},
															},
														},
													},
												},
											},
											&litMatcher{
												pos:        position{line: 1637, col: 19, offset: 53052},
												val:        ":",
												ignoreCase: false,
												want:       "\":\"",
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineForExpression",
			pos:  position{line: 1641, col: 1, offset: 53103},
			expr: &choiceExpr{
				pos: position{line: 1641, col: 28, offset: 53130},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1641, col: 28, offset: 53130},
						run: (*parser).callonSingleLineForExpression2,
						expr: &seqExpr{
							pos: position{line: 1641, col: 28, offset: 53130},
							exprs: []any{
								&oneOrMoreExpr{
									pos: position{line: 1641, col: 28, offset: 53130},
									expr: &litMatcher{
										pos:        position{line: 1641, col: 28, offset: 53130},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1641, col: 33, offset: 53135},
									label: "rExprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1641, col: 40, offset: 53142},
										name: "SingleLineRangeExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1643, col: 5, offset: 53274},
						run: (*parser).callonSingleLineForExpression8,
						expr: &seqExpr{
							pos: position{line: 1643, col: 5, offset: 53274},
							exprs: []any{
								&oneOrMoreExpr{
									pos: position{line: 1643, col: 5, offset: 53274},
									expr: &litMatcher{
										pos:        position{line: 1643, col: 5, offset: 53274},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1643, col: 10, offset: 53279},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1643, col: 16, offset: 53285},
										name: "SingleLineIfExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1645, col: 5, offset: 53359},
						run: (*parser).callonSingleLineForExpression14,
						expr: &andExpr{
							pos: position{line: 1645, col: 5, offset: 53359},
							expr: &seqExpr{
								pos: position{line: 1645, col: 7, offset: 53361},
								exprs: []any{
									&zeroOrMoreExpr{
										pos: position{line: 1645, col: 7, offset: 53361},
										expr: &litMatcher{
											pos:        position{line: 1645, col: 7, offset: 53361},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&choiceExpr{
										pos: position{line: 1645, col: 13, offset: 53367},
										alternatives: []any{
											&seqExpr{
												pos: position{line: 3796, col: 12, offset: 129156},
												exprs: []any{
													&zeroOrMoreExpr{
														pos: position{line: 3796, col: 12, offset: 129156},
														expr: &charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		expr: &litMatcher{
																			pos:        position{line: 3796, col: 16, offset: 129160},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3796, col: 22, offset: 129166},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3795, col: 12, offset: 129142},
																expr: &anyMatcher{
																	line: 3795, col: 13, offset: 129143,
																},
															},
														},
													},
												},
											},
											&litMatcher{
												pos:        position{line: 1645, col: 19, offset: 53373},
												val:        ":",
												ignoreCase: false,
												want:       "\":\"",
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "RangeExpression",
			pos:  position{line: 1649, col: 1, offset: 53424},
			expr: &actionExpr{
				pos: position{line: 1649, col: 20, offset: 53443},
				run: (*parser).callonRangeExpression1,
				expr: &seqExpr{
					pos: position{line: 1649, col: 20, offset: 53443},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1649, col: 20, offset: 53443},
							label: "varsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1649, col: 26, offset: 53449},
								expr: &actionExpr{
									pos: position{line: 1683, col: 24, offset: 54415},
									run: (*parser).callonRangeExpression5,
									expr: &seqExpr{
										pos: position{line: 1683, col: 24, offset: 54415},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1683, col: 24, offset: 54415},
												label: "var1I",
												expr: &actionExpr{
													pos: position{line: 2371, col: 12, offset: 80907},
													run: (*parser).callonRangeExpression8,
													expr: &labeledExpr{
														pos:   position{line: 2371, col: 12, offset: 80907},
														label: "ident",
														expr: &seqExpr{
															pos: position{line: 2410, col: 17, offset: 81833},
															exprs: []any{
																&charClassMatcher{
																	pos:        position{line: 2393, col: 20, offset: 81588},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2410, col: 26, offset: 81842},
																	expr: &charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
											},
											&labeledExpr{
												pos:   position{line: 1683, col: 38, offset: 54429},
												label: "var2I",
												expr: &zeroOrOneExpr{
													pos: position{line: 1683, col: 44, offset: 54435},
													expr: &seqExpr{
														pos: position{line: 1683, col: 45, offset: 54436},
														exprs: []any{
															&zeroOrMoreExpr{
																pos: position{line: 1683, col: 45, offset: 54436},
																expr: &litMatcher{
																	pos:        position{line: 1683, col: 45, offset: 54436},
																	val:        " ",
																	ignoreCase: false,
																	want:       "\" \"",
																},
															},
															&litMatcher{
																pos:        position{line: 1683, col: 50, offset: 54441},
																val:        ",",
																ignoreCase: false,
																want:       "\",\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1683, col: 54, offset: 54445},
																expr: &litMatcher{
																	pos:        position{line: 1683, col: 54, offset: 54445},
																	val:        " ",
																	ignoreCase: false,
																	want:       "\" \"",
																},
															},
															&actionExpr{
																pos: position{line: 2371, col: 12, offset: 80907},
																run: (*parser).callonRangeExpression22,
																expr: &labeledExpr{
																	pos:   position{line: 2371, col: 12, offset: 80907},
																	label: "ident",
																	expr: &seqExpr{
																		pos: position{line: 2410, col: 17, offset: 81833},
																		exprs: []any{
																			&charClassMatcher{
																				pos:        position{line: 2393, col: 20, offset: 81588},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2410, col: 26, offset: 81842},
																				expr: &charClassMatcher{
																					pos:        position{line: 2393, col: 20, offset: 81588},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&zeroOrMoreExpr{
												pos: position{line: 1683, col: 69, offset: 54460},
												expr: &litMatcher{
													pos:        position{line: 1683, col: 69, offset: 54460},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&labeledExpr{
												pos:   position{line: 1683, col: 74, offset: 54465},
												label: "eqPosI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonRangeExpression31,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&labeledExpr{
												pos:   position{line: 1683, col: 85, offset: 54476},
												label: "declaresI",
												expr: &zeroOrOneExpr{
													pos: position{line: 1683, col: 95, offset: 54486},
													expr: &litMatcher{
														pos:        position{line: 1683, col: 95, offset: 54486},
														val:        ":",
														ignoreCase: false,
														want:       "\":\"",
													},
												},
											},
											&litMatcher{
												pos:        position{line: 1683, col: 100, offset: 54491},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1683, col: 104, offset: 54495},
												expr: &litMatcher{
													pos:        position{line: 1683, col: 104, offset: 54495},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1649, col: 47, offset: 53470},
							label: "orderedI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1649, col: 56, offset: 53479},
								expr: &seqExpr{
									pos: position{line: 1649, col: 57, offset: 53480},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 1649, col: 57, offset: 53480},
											val:        "ordered",
											ignoreCase: false,
											want:       "\"ordered\"",
										},
										&oneOrMoreExpr{
											pos: position{line: 1649, col: 67, offset: 53490},
											expr: &litMatcher{
												pos:        position{line: 1649, col: 67, offset: 53490},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1649, col: 74, offset: 53497},
							val:        "range",
							ignoreCase: false,
							want:       "\"range\"",
						},
						&oneOrMoreExpr{
							pos: position{line: 1649, col: 82, offset: 53505},
							expr: &litMatcher{
								pos:        position{line: 1649, col: 82, offset: 53505},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1649, col: 87, offset: 53510},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1649, col: 93, offset: 53516},
								name: "SingleLineExpression",
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineRangeExpression",
			pos:  position{line: 1666, col: 1, offset: 53903},
			expr: &actionExpr{
				pos: position{line: 1666, col: 30, offset: 53932},
				run: (*parser).callonSingleLineRangeExpression1,
				expr: &seqExpr{
					pos: position{line: 1666, col: 30, offset: 53932},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1666, col: 30, offset: 53932},
							label: "varsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1666, col: 36, offset: 53938},
								expr: &actionExpr{
									pos: position{line: 1683, col: 24, offset: 54415},
									run: (*parser).callonSingleLineRangeExpression5,
									expr: &seqExpr{
										pos: position{line: 1683, col: 24, offset: 54415},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1683, col: 24, offset: 54415},
												label: "var1I",
												expr: &actionExpr{
													pos: position{line: 2371, col: 12, offset: 80907},
													run: (*parser).callonSingleLineRangeExpression8,
													expr: &labeledExpr{
														pos:   position{line: 2371, col: 12, offset: 80907},
														label: "ident",
														expr: &seqExpr{
															pos: position{line: 2410, col: 17, offset: 81833},
															exprs: []any{
																&charClassMatcher{
																	pos:        position{line: 2393, col: 20, offset: 81588},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2410, col: 26, offset: 81842},
																	expr: &charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
											},
											&labeledExpr{
												pos:   position{line: 1683, col: 38, offset: 54429},
												label: "var2I",
												expr: &zeroOrOneExpr{
													pos: position{line: 1683, col: 44, offset: 54435},
													expr: &seqExpr{
														pos: position{line: 1683, col: 45, offset: 54436},
														exprs: []any{
															&zeroOrMoreExpr{
																pos: position{line: 1683, col: 45, offset: 54436},
																expr: &litMatcher{
																	pos:        position{line: 1683, col: 45, offset: 54436},
																	val:        " ",
																	ignoreCase: false,
																	want:       "\" \"",
																},
															},
															&litMatcher{
																pos:        position{line: 1683, col: 50, offset: 54441},
																val:        ",",
																ignoreCase: false,
																want:       "\",\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1683, col: 54, offset: 54445},
																expr: &litMatcher{
																	pos:        position{line: 1683, col: 54, offset: 54445},
																	val:        " ",
																	ignoreCase: false,
																	want:       "\" \"",
																},
															},
															&actionExpr{
																pos: position{line: 2371, col: 12, offset: 80907},
																run: (*parser).callonSingleLineRangeExpression22,
																expr: &labeledExpr{
																	pos:   position{line: 2371, col: 12, offset: 80907},
																	label: "ident",
																	expr: &seqExpr{
																		pos: position{line: 2410, col: 17, offset: 81833},
																		exprs: []any{
																			&charClassMatcher{
																				pos:        position{line: 2393, col: 20, offset: 81588},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2410, col: 26, offset: 81842},
																				expr: &charClassMatcher{
																					pos:        position{line: 2393, col: 20, offset: 81588},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&zeroOrMoreExpr{
												pos: position{line: 1683, col: 69, offset: 54460},
												expr: &litMatcher{
													pos:        position{line: 1683, col: 69, offset: 54460},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&labeledExpr{
												pos:   position{line: 1683, col: 74, offset: 54465},
												label: "eqPosI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonSingleLineRangeExpression31,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&labeledExpr{
												pos:   position{line: 1683, col: 85, offset: 54476},
												label: "declaresI",
												expr: &zeroOrOneExpr{
													pos: position{line: 1683, col: 95, offset: 54486},
													expr: &litMatcher{
														pos:        position{line: 1683, col: 95, offset: 54486},
														val:        ":",
														ignoreCase: false,
														want:       "\":\"",
													},
												},
											},
											&litMatcher{
												pos:        position{line: 1683, col: 100, offset: 54491},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1683, col: 104, offset: 54495},
												expr: &litMatcher{
													pos:        position{line: 1683, col: 104, offset: 54495},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1666, col: 57, offset: 53959},
							label: "orderedI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1666, col: 66, offset: 53968},
								expr: &seqExpr{
									pos: position{line: 1666, col: 67, offset: 53969},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 1666, col: 67, offset: 53969},
											val:        "ordered",
											ignoreCase: false,
											want:       "\"ordered\"",
										},
										&oneOrMoreExpr{
											pos: position{line: 1666, col: 77, offset: 53979},
											expr: &litMatcher{
												pos:        position{line: 1666, col: 77, offset: 53979},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1666, col: 84, offset: 53986},
							val:        "range",
							ignoreCase: false,
							want:       "\"range\"",
						},
						&oneOrMoreExpr{
							pos: position{line: 1666, col: 92, offset: 53994},
							expr: &litMatcher{
								pos:        position{line: 1666, col: 92, offset: 53994},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1666, col: 97, offset: 53999},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1666, col: 103, offset: 54005},
								name: "SingleLineExpression",
							},
						},
					},
				},
			},
		},
		{
			name: "StringExpression",
			pos:  position{line: 1704, col: 1, offset: 55024},
			expr: &choiceExpr{
				pos: position{line: 1704, col: 21, offset: 55044},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 1704, col: 21, offset: 55044},
						name: "InterpretedStringExpression",
					},
					&ruleRefExpr{
						pos:  position{line: 1704, col: 51, offset: 55074},
						name: "RawStringExpression",
					},
				},
			},
		},
		{
			name: "InterpretedStringExpression",
			pos:  position{line: 1706, col: 1, offset: 55095},
			expr: &choiceExpr{
				pos: position{line: 1706, col: 32, offset: 55126},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1706, col: 32, offset: 55126},
						run: (*parser).callonInterpretedStringExpression2,
						expr: &seqExpr{
							pos: position{line: 1706, col: 32, offset: 55126},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1706, col: 32, offset: 55126},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
								&labeledExpr{
									pos:   position{line: 1706, col: 36, offset: 55130},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1706, col: 46, offset: 55140},
										expr: &ruleRefExpr{
											pos:  position{line: 1706, col: 46, offset: 55140},
											name: "InterpretedStringExpressionItem",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1706, col: 79, offset: 55173},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1712, col: 5, offset: 55342},
						run: (*parser).callonInterpretedStringExpression9,
						expr: &seqExpr{
							pos: position{line: 1712, col: 5, offset: 55342},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1712, col: 5, offset: 55342},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
								&labeledExpr{
									pos:   position{line: 1712, col: 9, offset: 55346},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonInterpretedStringExpression13,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1712, col: 23, offset: 55360},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1712, col: 33, offset: 55370},
										expr: &ruleRefExpr{
											pos:  position{line: 1712, col: 33, offset: 55370},
											name: "InterpretedStringExpressionItem",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "RawStringExpression",
			pos:  position{line: 1732, col: 1, offset: 56020},
			expr: &choiceExpr{
				pos: position{line: 1732, col: 24, offset: 56043},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1732, col: 24, offset: 56043},
						run: (*parser).callonRawStringExpression2,
						expr: &seqExpr{
							pos: position{line: 1732, col: 24, offset: 56043},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1732, col: 24, offset: 56043},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
								&labeledExpr{
									pos:   position{line: 1732, col: 28, offset: 56047},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1732, col: 38, offset: 56057},
										expr: &ruleRefExpr{
											pos:  position{line: 1732, col: 38, offset: 56057},
											name: "RawStringExpressionItem",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1732, col: 63, offset: 56082},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1738, col: 5, offset: 56251},
						run: (*parser).callonRawStringExpression9,
						expr: &seqExpr{
							pos: position{line: 1738, col: 5, offset: 56251},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1738, col: 5, offset: 56251},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
								&labeledExpr{
									pos:   position{line: 1738, col: 9, offset: 56255},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonRawStringExpression13,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1738, col: 23, offset: 56269},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1738, col: 33, offset: 56279},
										expr: &ruleRefExpr{
											pos:  position{line: 1738, col: 33, offset: 56279},
											name: "RawStringExpressionItem",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InterpretedStringExpressionItem",
			pos:  position{line: 1759, col: 1, offset: 56921},
			expr: &choiceExpr{
				pos: position{line: 1759, col: 36, offset: 56956},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1762, col: 36, offset: 57147},
						run: (*parser).callonInterpretedStringExpressionItem2,
						expr: &oneOrMoreExpr{
							pos: position{line: 1762, col: 36, offset: 57147},
							expr: &choiceExpr{
								pos: position{line: 1762, col: 37, offset: 57148},
								alternatives: []any{
									&litMatcher{
										pos:        position{line: 1762, col: 37, offset: 57148},
										val:        "##",
										ignoreCase: false,
										want:       "\"##\"",
									},
									&seqExpr{
										pos: position{line: 1762, col: 44, offset: 57155},
										exprs: []any{
											&notExpr{
												pos: position{line: 1762, col: 44, offset: 57155},
												expr: &litMatcher{
													pos:        position{line: 1762, col: 45, offset: 57156},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
											},
											&choiceExpr{
												pos: position{line: 2760, col: 36, offset: 95508},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 2505, col: 19, offset: 85311},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2505, col: 19, offset: 85311},
																val:        "\\u",
																ignoreCase: false,
																want:       "\"\\\\u\"",
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&actionExpr{
														pos: position{line: 2506, col: 5, offset: 85370},
														run: (*parser).callonInterpretedStringExpressionItem16,
														expr: &seqExpr{
															pos: position{line: 2506, col: 5, offset: 85370},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2506, col: 5, offset: 85370},
																	val:        "\\u",
																	ignoreCase: false,
																	want:       "\"\\\\u\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2506, col: 14, offset: 85379},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2506, col: 26, offset: 85391},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2506, col: 38, offset: 85403},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2506, col: 50, offset: 85415},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
													&seqExpr{
														pos: position{line: 2535, col: 16, offset: 86551},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2535, col: 16, offset: 86551},
																val:        "\\U",
																ignoreCase: false,
																want:       "\"\\\\U\"",
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&actionExpr{
														pos: position{line: 2536, col: 5, offset: 86654},
														run: (*parser).callonInterpretedStringExpressionItem37,
														expr: &seqExpr{
															pos: position{line: 2536, col: 5, offset: 86654},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2536, col: 5, offset: 86654},
																	val:        "\\U",
																	ignoreCase: false,
																	want:       "\"\\\\U\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 14, offset: 86663},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 26, offset: 86675},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 38, offset: 86687},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 50, offset: 86699},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 62, offset: 86711},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 74, offset: 86723},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 86, offset: 86735},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 98, offset: 86747},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
													&seqExpr{
														pos: position{line: 2763, col: 36, offset: 95684},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2763, col: 36, offset: 95684},
																val:        "\\",
																ignoreCase: false,
																want:       "\"\\\\\"",
															},
															&charClassMatcher{
																pos:        position{line: 2763, col: 41, offset: 95689},
																val:        "[abfnrtv\\\\\"]",
																chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 2761, col: 38, offset: 95576},
														val:        "[^\"\\\\\\n]",
														chars:      []rune{'"', '\\', '\n'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
									},
									&seqExpr{
										pos: position{line: 2486, col: 24, offset: 84569},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 2486, col: 24, offset: 84569},
												val:        "\\",
												ignoreCase: false,
												want:       "\"\\\\\"",
											},
											&charClassMatcher{
												pos:        position{line: 2403, col: 19, offset: 81758},
												val:        "[0-7]",
												ranges:     []rune{'0', '7'},
												ignoreCase: false,
												inverted:   false,
											},
											&charClassMatcher{
												pos:        position{line: 2403, col: 19, offset: 81758},
												val:        "[0-7]",
												ranges:     []rune{'0', '7'},
												ignoreCase: false,
												inverted:   false,
											},
											&charClassMatcher{
												pos:        position{line: 2403, col: 19, offset: 81758},
												val:        "[0-7]",
												ranges:     []rune{'0', '7'},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
									&seqExpr{
										pos: position{line: 2487, col: 24, offset: 84636},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 2487, col: 24, offset: 84636},
												val:        "\\x",
												ignoreCase: false,
												want:       "\"\\\\x\"",
											},
											&charClassMatcher{
												pos:        position{line: 2404, col: 19, offset: 81782},
												val:        "[0-9A-Fa-f]",
												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
												ignoreCase: false,
												inverted:   false,
											},
											&charClassMatcher{
												pos:        position{line: 2404, col: 19, offset: 81782},
												val:        "[0-9A-Fa-f]",
												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
									&actionExpr{
										pos: position{line: 2488, col: 5, offset: 84673},
										run: (*parser).callonInterpretedStringExpressionItem69,
										expr: &seqExpr{
											pos: position{line: 2488, col: 5, offset: 84673},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 2488, col: 5, offset: 84673},
													val:        "\\x",
													ignoreCase: false,
													want:       "\"\\\\x\"",
												},
												&zeroOrOneExpr{
													pos: position{line: 2488, col: 14, offset: 84682},
													expr: &charClassMatcher{
														pos:        position{line: 2404, col: 19, offset: 81782},
														val:        "[0-9A-Fa-f]",
														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 2488, col: 26, offset: 84694},
													expr: &charClassMatcher{
														pos:        position{line: 2404, col: 19, offset: 81782},
														val:        "[0-9A-Fa-f]",
														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
														ignoreCase: false,
														inverted:   false,
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 2650, col: 37, offset: 91334},
										run: (*parser).callonInterpretedStringExpressionItem76,
										expr: &seqExpr{
											pos: position{line: 2650, col: 37, offset: 91334},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 2650, col: 37, offset: 91334},
													val:        "\\",
													ignoreCase: false,
													want:       "\"\\\\\"",
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 2674, col: 5, offset: 92351},
										run: (*parser).callonInterpretedStringExpressionItem87,
										expr: &seqExpr{
											pos: position{line: 2674, col: 5, offset: 92351},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 2674, col: 5, offset: 92351},
													val:        "\\",
													ignoreCase: false,
													want:       "\"\\\\\"",
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 2695, col: 5, offset: 93193},
										run: (*parser).callonInterpretedStringExpressionItem94,
										expr: &seqExpr{
											pos: position{line: 2695, col: 5, offset: 93193},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 2695, col: 5, offset: 93193},
													val:        "\\",
													ignoreCase: false,
													want:       "\"\\\\\"",
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2404, col: 19, offset: 81782},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 2713, col: 5, offset: 93879},
										run: (*parser).callonInterpretedStringExpressionItem99,
										expr: &seqExpr{
											pos: position{line: 2713, col: 5, offset: 93879},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 2713, col: 5, offset: 93879},
													val:        "\\",
													ignoreCase: false,
													want:       "\"\\\\\"",
												},
												&zeroOrOneExpr{
													pos: position{line: 2713, col: 10, offset: 93884},
													expr: &charClassMatcher{
														pos:        position{line: 3797, col: 12, offset: 129189},
														val:        "[^\\r\\n]",
														chars:      []rune{'\r', '\n'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1759, col: 70, offset: 56990},
						name: "StringExpressionInterpolation",
					},
				},
			},
		},
		{
			name: "RawStringExpressionItem",
			pos:  position{line: 1760, col: 1, offset: 57020},
			expr: &choiceExpr{
				pos: position{line: 1760, col: 36, offset: 57055},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1768, col: 28, offset: 57379},
						run: (*parser).callonRawStringExpressionItem2,
						expr: &oneOrMoreExpr{
							pos: position{line: 1768, col: 28, offset: 57379},
							expr: &choiceExpr{
								pos: position{line: 1768, col: 29, offset: 57380},
								alternatives: []any{
									&litMatcher{
										pos:        position{line: 1768, col: 29, offset: 57380},
										val:        "##",
										ignoreCase: false,
										want:       "\"##\"",
									},
									&seqExpr{
										pos: position{line: 1768, col: 36, offset: 57387},
										exprs: []any{
											&notExpr{
												pos: position{line: 1768, col: 36, offset: 57387},
												expr: &litMatcher{
													pos:        position{line: 1768, col: 37, offset: 57388},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
											},
											&charClassMatcher{
												pos:        position{line: 2747, col: 27, offset: 94906},
												val:        "[^\\n`]",
												chars:      []rune{'\n', '`'},
												ignoreCase: false,
												inverted:   true,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1760, col: 62, offset: 57081},
						name: "StringExpressionInterpolation",
					},
				},
			},
		},
		{
			name: "StringExpressionInterpolation",
			pos:  position{line: 1775, col: 1, offset: 57527},
			expr: &choiceExpr{
				pos: position{line: 1775, col: 34, offset: 57560},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1775, col: 34, offset: 57560},
						run: (*parser).callonStringExpressionInterpolation2,
						expr: &seqExpr{
							pos: position{line: 1775, col: 34, offset: 57560},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1775, col: 34, offset: 57560},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1775, col: 38, offset: 57564},
									label: "fmtDirectiveI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1775, col: 52, offset: 57578},
										expr: &choiceExpr{
											pos: position{line: 1840, col: 17, offset: 60144},
											alternatives: []any{
												&actionExpr{
													pos: position{line: 1840, col: 17, offset: 60144},
													run: (*parser).callonStringExpressionInterpolation8,
													expr: &seqExpr{
														pos: position{line: 1840, col: 17, offset: 60144},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 1840, col: 17, offset: 60144},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1840, col: 21, offset: 60148},
																expr: &charClassMatcher{
																	pos:        position{line: 1856, col: 12, offset: 60825},
																	val:        "[ 0+-#]",
																	chars:      []rune{' ', '0'},
																	ranges:     []rune{'+', '#'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1840, col: 30, offset: 60157},
																expr: &seqExpr{
																	pos: position{line: 1840, col: 31, offset: 60158},
																	exprs: []any{
																		&charClassMatcher{
																			pos:        position{line: 1840, col: 31, offset: 60158},
																			val:        "[1-9]",
																			ranges:     []rune{'1', '9'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1840, col: 36, offset: 60163},
																			expr: &charClassMatcher{
																				pos:        position{line: 1840, col: 36, offset: 60163},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1840, col: 45, offset: 60172},
																expr: &seqExpr{
																	pos: position{line: 1840, col: 46, offset: 60173},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 1840, col: 46, offset: 60173},
																			val:        ".",
																			ignoreCase: false,
																			want:       "\".\"",
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1840, col: 50, offset: 60177},
																			expr: &charClassMatcher{
																				pos:        position{line: 1840, col: 50, offset: 60177},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&choiceExpr{
																pos: position{line: 1857, col: 12, offset: 60844},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 1857, col: 12, offset: 60844},
																		val:        "[vTtbcdoOqxXUeEfFgGsp]",
																		chars:      []rune{'v', 'T', 't', 'b', 'c', 'd', 'o', 'O', 'q', 'x', 'X', 'U', 'e', 'E', 'f', 'F', 'g', 'G', 's', 'p'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&actionExpr{
																		pos: position{line: 1857, col: 74, offset: 60906},
																		run: (*parser).callonStringExpressionInterpolation25,
																		expr: &andExpr{
																			pos: position{line: 1857, col: 74, offset: 60906},
																			expr: &charClassMatcher{
																				pos:        position{line: 1857, col: 76, offset: 60908},
																				val:        "[{\"`]",
																				chars:      []rune{'{', '"', '`'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 1869, col: 5, offset: 61445},
																		run: (*parser).callonStringExpressionInterpolation28,
																		expr: &anyMatcher{
																			line: 1869, col: 5, offset: 61445,
																		},
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 1842, col: 5, offset: 60235},
													run: (*parser).callonStringExpressionInterpolation30,
													expr: &seqExpr{
														pos: position{line: 1842, col: 5, offset: 60235},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 1842, col: 5, offset: 60235},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1842, col: 9, offset: 60239},
																expr: &charClassMatcher{
																	pos:        position{line: 1842, col: 9, offset: 60239},
																	val:        "[^`\"{]",
																	chars:      []rune{'`', '"', '{'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
															&labeledExpr{
																pos:   position{line: 1842, col: 17, offset: 60247},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3799, col: 8, offset: 129205},
																	run: (*parser).callonStringExpressionInterpolation36,
																	expr: &choiceExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		alternatives: []any{
																			&andExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				expr: &anyMatcher{
																					line: 3799, col: 10, offset: 129207,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3799, col: 14, offset: 129211},
																				expr: &anyMatcher{
																					line: 3799, col: 15, offset: 129212,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1775, col: 66, offset: 57592},
									label: "lBracePosI",
									expr: &actionExpr{
										pos: position{line: 3821, col: 12, offset: 129918},
										run: (*parser).callonStringExpressionInterpolation43,
										expr: &litMatcher{
											pos:        position{line: 3821, col: 12, offset: 129918},
											val:        "{",
											ignoreCase: false,
											want:       "\"{\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1775, col: 85, offset: 57611},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1775, col: 91, offset: 57617},
										name: "SingleLineExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1775, col: 112, offset: 57638},
									label: "rBracePosI",
									expr: &actionExpr{
										pos: position{line: 3822, col: 12, offset: 129956},
										run: (*parser).callonStringExpressionInterpolation48,
										expr: &litMatcher{
											pos:        position{line: 3822, col: 12, offset: 129956},
											val:        "}",
											ignoreCase: false,
											want:       "\"}\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1783, col: 5, offset: 57948},
						run: (*parser).callonStringExpressionInterpolation50,
						expr: &seqExpr{
							pos: position{line: 1783, col: 5, offset: 57948},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1783, col: 5, offset: 57948},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1783, col: 9, offset: 57952},
									label: "fmtDirectiveI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1783, col: 23, offset: 57966},
										expr: &choiceExpr{
											pos: position{line: 1840, col: 17, offset: 60144},
											alternatives: []any{
												&actionExpr{
													pos: position{line: 1840, col: 17, offset: 60144},
													run: (*parser).callonStringExpressionInterpolation56,
													expr: &seqExpr{
														pos: position{line: 1840, col: 17, offset: 60144},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 1840, col: 17, offset: 60144},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1840, col: 21, offset: 60148},
																expr: &charClassMatcher{
																	pos:        position{line: 1856, col: 12, offset: 60825},
																	val:        "[ 0+-#]",
																	chars:      []rune{' ', '0'},
																	ranges:     []rune{'+', '#'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1840, col: 30, offset: 60157},
																expr: &seqExpr{
																	pos: position{line: 1840, col: 31, offset: 60158},
																	exprs: []any{
																		&charClassMatcher{
																			pos:        position{line: 1840, col: 31, offset: 60158},
																			val:        "[1-9]",
																			ranges:     []rune{'1', '9'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1840, col: 36, offset: 60163},
																			expr: &charClassMatcher{
																				pos:        position{line: 1840, col: 36, offset: 60163},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1840, col: 45, offset: 60172},
																expr: &seqExpr{
																	pos: position{line: 1840, col: 46, offset: 60173},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 1840, col: 46, offset: 60173},
																			val:        ".",
																			ignoreCase: false,
																			want:       "\".\"",
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1840, col: 50, offset: 60177},
																			expr: &charClassMatcher{
																				pos:        position{line: 1840, col: 50, offset: 60177},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&choiceExpr{
																pos: position{line: 1857, col: 12, offset: 60844},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 1857, col: 12, offset: 60844},
																		val:        "[vTtbcdoOqxXUeEfFgGsp]",
																		chars:      []rune{'v', 'T', 't', 'b', 'c', 'd', 'o', 'O', 'q', 'x', 'X', 'U', 'e', 'E', 'f', 'F', 'g', 'G', 's', 'p'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&actionExpr{
																		pos: position{line: 1857, col: 74, offset: 60906},
																		run: (*parser).callonStringExpressionInterpolation73,
																		expr: &andExpr{
																			pos: position{line: 1857, col: 74, offset: 60906},
																			expr: &charClassMatcher{
																				pos:        position{line: 1857, col: 76, offset: 60908},
																				val:        "[{\"`]",
																				chars:      []rune{'{', '"', '`'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 1869, col: 5, offset: 61445},
																		run: (*parser).callonStringExpressionInterpolation76,
																		expr: &anyMatcher{
																			line: 1869, col: 5, offset: 61445,
																		},
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 1842, col: 5, offset: 60235},
													run: (*parser).callonStringExpressionInterpolation78,
													expr: &seqExpr{
														pos: position{line: 1842, col: 5, offset: 60235},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 1842, col: 5, offset: 60235},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1842, col: 9, offset: 60239},
																expr: &charClassMatcher{
																	pos:        position{line: 1842, col: 9, offset: 60239},
																	val:        "[^`\"{]",
																	chars:      []rune{'`', '"', '{'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
															&labeledExpr{
																pos:   position{line: 1842, col: 17, offset: 60247},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3799, col: 8, offset: 129205},
																	run: (*parser).callonStringExpressionInterpolation84,
																	expr: &choiceExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		alternatives: []any{
																			&andExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				expr: &anyMatcher{
																					line: 3799, col: 10, offset: 129207,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3799, col: 14, offset: 129211},
																				expr: &anyMatcher{
																					line: 3799, col: 15, offset: 129212,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1783, col: 37, offset: 57980},
									label: "parenPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonStringExpressionInterpolation91,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1810, col: 5, offset: 58981},
						run: (*parser).callonStringExpressionInterpolation97,
						expr: &seqExpr{
							pos: position{line: 1810, col: 5, offset: 58981},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1810, col: 5, offset: 58981},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1810, col: 9, offset: 58985},
									label: "fmtDirectiveI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1810, col: 23, offset: 58999},
										expr: &choiceExpr{
											pos: position{line: 1840, col: 17, offset: 60144},
											alternatives: []any{
												&actionExpr{
													pos: position{line: 1840, col: 17, offset: 60144},
													run: (*parser).callonStringExpressionInterpolation103,
													expr: &seqExpr{
														pos: position{line: 1840, col: 17, offset: 60144},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 1840, col: 17, offset: 60144},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1840, col: 21, offset: 60148},
																expr: &charClassMatcher{
																	pos:        position{line: 1856, col: 12, offset: 60825},
																	val:        "[ 0+-#]",
																	chars:      []rune{' ', '0'},
																	ranges:     []rune{'+', '#'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1840, col: 30, offset: 60157},
																expr: &seqExpr{
																	pos: position{line: 1840, col: 31, offset: 60158},
																	exprs: []any{
																		&charClassMatcher{
																			pos:        position{line: 1840, col: 31, offset: 60158},
																			val:        "[1-9]",
																			ranges:     []rune{'1', '9'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1840, col: 36, offset: 60163},
																			expr: &charClassMatcher{
																				pos:        position{line: 1840, col: 36, offset: 60163},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1840, col: 45, offset: 60172},
																expr: &seqExpr{
																	pos: position{line: 1840, col: 46, offset: 60173},
																	exprs: []any{
																		&litMatcher{
																			pos:        position{line: 1840, col: 46, offset: 60173},
																			val:        ".",
																			ignoreCase: false,
																			want:       "\".\"",
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1840, col: 50, offset: 60177},
																			expr: &charClassMatcher{
																				pos:        position{line: 1840, col: 50, offset: 60177},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&choiceExpr{
																pos: position{line: 1857, col: 12, offset: 60844},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 1857, col: 12, offset: 60844},
																		val:        "[vTtbcdoOqxXUeEfFgGsp]",
																		chars:      []rune{'v', 'T', 't', 'b', 'c', 'd', 'o', 'O', 'q', 'x', 'X', 'U', 'e', 'E', 'f', 'F', 'g', 'G', 's', 'p'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&actionExpr{
																		pos: position{line: 1857, col: 74, offset: 60906},
																		run: (*parser).callonStringExpressionInterpolation120,
																		expr: &andExpr{
																			pos: position{line: 1857, col: 74, offset: 60906},
																			expr: &charClassMatcher{
																				pos:        position{line: 1857, col: 76, offset: 60908},
																				val:        "[{\"`]",
																				chars:      []rune{'{', '"', '`'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 1869, col: 5, offset: 61445},
																		run: (*parser).callonStringExpressionInterpolation123,
																		expr: &anyMatcher{
																			line: 1869, col: 5, offset: 61445,
																		},
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 1842, col: 5, offset: 60235},
													run: (*parser).callonStringExpressionInterpolation125,
													expr: &seqExpr{
														pos: position{line: 1842, col: 5, offset: 60235},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 1842, col: 5, offset: 60235},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1842, col: 9, offset: 60239},
																expr: &charClassMatcher{
																	pos:        position{line: 1842, col: 9, offset: 60239},
																	val:        "[^`\"{]",
																	chars:      []rune{'`', '"', '{'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
															&labeledExpr{
																pos:   position{line: 1842, col: 17, offset: 60247},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3799, col: 8, offset: 129205},
																	run: (*parser).callonStringExpressionInterpolation131,
																	expr: &choiceExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		alternatives: []any{
																			&andExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				expr: &anyMatcher{
																					line: 3799, col: 10, offset: 129207,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3799, col: 14, offset: 129211},
																				expr: &anyMatcher{
																					line: 3799, col: 15, offset: 129212,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1810, col: 37, offset: 59013},
									label: "parenPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonStringExpressionInterpolation138,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1810, col: 51, offset: 59027},
									label: "lBracePosI",
									expr: &actionExpr{
										pos: position{line: 3821, col: 12, offset: 129918},
										run: (*parser).callonStringExpressionInterpolation145,
										expr: &litMatcher{
											pos:        position{line: 3821, col: 12, offset: 129918},
											val:        "{",
											ignoreCase: false,
											want:       "\"{\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1810, col: 70, offset: 59046},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonStringExpressionInterpolation148,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1810, col: 84, offset: 59060},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1810, col: 90, offset: 59066},
										name: "SingleLineExpression",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TernaryExpression",
			pos:  position{line: 1893, col: 1, offset: 62260},
			expr: &choiceExpr{
				pos: position{line: 1893, col: 22, offset: 62281},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1893, col: 22, offset: 62281},
						run: (*parser).callonTernaryExpression2,
						expr: &seqExpr{
							pos: position{line: 1893, col: 22, offset: 62281},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1893, col: 22, offset: 62281},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1893, col: 27, offset: 62286},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1893, col: 31, offset: 62290},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1893, col: 42, offset: 62301},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1893, col: 64, offset: 62323},
									expr: &litMatcher{
										pos:        position{line: 1893, col: 64, offset: 62323},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1893, col: 69, offset: 62328},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1893, col: 73, offset: 62332},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1893, col: 77, offset: 62336},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1893, col: 85, offset: 62344},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1893, col: 107, offset: 62366},
									expr: &litMatcher{
										pos:        position{line: 1893, col: 107, offset: 62366},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1893, col: 112, offset: 62371},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1893, col: 116, offset: 62375},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1893, col: 120, offset: 62379},
									label: "ifFalseI",
									expr: &ruleRefExpr{
										pos:  position{line: 1893, col: 129, offset: 62388},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1893, col: 151, offset: 62410},
									expr: &litMatcher{
										pos:        position{line: 1893, col: 151, offset: 62410},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1893, col: 156, offset: 62415},
									expr: &seqExpr{
										pos: position{line: 1893, col: 157, offset: 62416},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 1893, col: 157, offset: 62416},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1893, col: 161, offset: 62420},
												expr: &choiceExpr{
													pos: position{line: 3812, col: 20, offset: 129621},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															exprs: []any{
																&zeroOrOneExpr{
																	pos: position{line: 3809, col: 36, offset: 129544},
																	expr: &litMatcher{
																		pos:        position{line: 3809, col: 36, offset: 129544},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3809, col: 42, offset: 129550},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1893, col: 167, offset: 62426},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonTernaryExpression51,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1901, col: 5, offset: 62707},
						run: (*parser).callonTernaryExpression53,
						expr: &seqExpr{
							pos: position{line: 1901, col: 5, offset: 62707},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1901, col: 5, offset: 62707},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&labeledExpr{
									pos:   position{line: 1901, col: 10, offset: 62712},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonTernaryExpression57,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1901, col: 24, offset: 62726},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1901, col: 28, offset: 62730},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonTernaryExpression71,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1915, col: 5, offset: 63321},
						run: (*parser).callonTernaryExpression73,
						expr: &seqExpr{
							pos: position{line: 1915, col: 5, offset: 63321},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1915, col: 5, offset: 63321},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1915, col: 10, offset: 63326},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1915, col: 14, offset: 63330},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1915, col: 25, offset: 63341},
										name: "multiLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1915, col: 47, offset: 63363},
									label: "startPosI",
									expr: &choiceExpr{
										pos: position{line: 1887, col: 13, offset: 62171},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 1887, col: 13, offset: 62171},
												run: (*parser).callonTernaryExpression87,
												expr: &seqExpr{
													pos: position{line: 1887, col: 13, offset: 62171},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 1887, col: 13, offset: 62171},
															expr: &litMatcher{
																pos:        position{line: 1887, col: 13, offset: 62171},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&litMatcher{
															pos:        position{line: 1887, col: 18, offset: 62176},
															val:        ",",
															ignoreCase: false,
															want:       "\",\"",
														},
														&labeledExpr{
															pos:   position{line: 1887, col: 22, offset: 62180},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonTernaryExpression93,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1887, col: 31, offset: 62189},
															expr: &choiceExpr{
																pos: position{line: 3812, col: 20, offset: 129621},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 3808, col: 36, offset: 129503},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 3809, col: 36, offset: 129544},
																		exprs: []any{
																			&zeroOrOneExpr{
																				pos: position{line: 3809, col: 36, offset: 129544},
																				expr: &litMatcher{
																					pos:        position{line: 3809, col: 36, offset: 129544},
																					val:        "\r",
																					ignoreCase: false,
																					want:       "\"\\r\"",
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 3809, col: 42, offset: 129550},
																				val:        "\n",
																				ignoreCase: false,
																				want:       "\"\\n\"",
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 1889, col: 5, offset: 62220},
												run: (*parser).callonTernaryExpression106,
												expr: &seqExpr{
													pos: position{line: 1889, col: 5, offset: 62220},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 1889, col: 5, offset: 62220},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonTernaryExpression109,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 14, offset: 62229},
															expr: &litMatcher{
																pos:        position{line: 1889, col: 14, offset: 62229},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1915, col: 66, offset: 63382},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonTernaryExpression118,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1930, col: 5, offset: 64008},
						run: (*parser).callonTernaryExpression120,
						expr: &seqExpr{
							pos: position{line: 1930, col: 5, offset: 64008},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1930, col: 5, offset: 64008},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1930, col: 10, offset: 64013},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1930, col: 14, offset: 64017},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1930, col: 25, offset: 64028},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1930, col: 47, offset: 64050},
									expr: &litMatcher{
										pos:        position{line: 1930, col: 47, offset: 64050},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1930, col: 52, offset: 64055},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1930, col: 56, offset: 64059},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1930, col: 60, offset: 64063},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1930, col: 68, offset: 64071},
										name: "multiLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1930, col: 90, offset: 64093},
									label: "startPosI",
									expr: &choiceExpr{
										pos: position{line: 1887, col: 13, offset: 62171},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 1887, col: 13, offset: 62171},
												run: (*parser).callonTernaryExpression146,
												expr: &seqExpr{
													pos: position{line: 1887, col: 13, offset: 62171},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 1887, col: 13, offset: 62171},
															expr: &litMatcher{
																pos:        position{line: 1887, col: 13, offset: 62171},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&litMatcher{
															pos:        position{line: 1887, col: 18, offset: 62176},
															val:        ",",
															ignoreCase: false,
															want:       "\",\"",
														},
														&labeledExpr{
															pos:   position{line: 1887, col: 22, offset: 62180},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonTernaryExpression152,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1887, col: 31, offset: 62189},
															expr: &choiceExpr{
																pos: position{line: 3812, col: 20, offset: 129621},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 3808, col: 36, offset: 129503},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 3809, col: 36, offset: 129544},
																		exprs: []any{
																			&zeroOrOneExpr{
																				pos: position{line: 3809, col: 36, offset: 129544},
																				expr: &litMatcher{
																					pos:        position{line: 3809, col: 36, offset: 129544},
																					val:        "\r",
																					ignoreCase: false,
																					want:       "\"\\r\"",
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 3809, col: 42, offset: 129550},
																				val:        "\n",
																				ignoreCase: false,
																				want:       "\"\\n\"",
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 1889, col: 5, offset: 62220},
												run: (*parser).callonTernaryExpression165,
												expr: &seqExpr{
													pos: position{line: 1889, col: 5, offset: 62220},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 1889, col: 5, offset: 62220},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonTernaryExpression168,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 14, offset: 62229},
															expr: &litMatcher{
																pos:        position{line: 1889, col: 14, offset: 62229},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1930, col: 109, offset: 64112},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonTernaryExpression177,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineTernaryExpression",
			pos:  position{line: 1948, col: 1, offset: 64759},
			expr: &choiceExpr{
				pos: position{line: 1948, col: 32, offset: 64790},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1948, col: 32, offset: 64790},
						run: (*parser).callonSingleLineTernaryExpression2,
						expr: &seqExpr{
							pos: position{line: 1948, col: 32, offset: 64790},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1948, col: 32, offset: 64790},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1948, col: 37, offset: 64795},
									expr: &litMatcher{
										pos:        position{line: 1948, col: 37, offset: 64795},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1948, col: 42, offset: 64800},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1948, col: 53, offset: 64811},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1948, col: 76, offset: 64834},
									expr: &litMatcher{
										pos:        position{line: 1948, col: 76, offset: 64834},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1948, col: 81, offset: 64839},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1948, col: 85, offset: 64843},
									expr: &litMatcher{
										pos:        position{line: 1948, col: 85, offset: 64843},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1948, col: 90, offset: 64848},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1948, col: 98, offset: 64856},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1948, col: 121, offset: 64879},
									expr: &litMatcher{
										pos:        position{line: 1948, col: 121, offset: 64879},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1948, col: 126, offset: 64884},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1948, col: 130, offset: 64888},
									expr: &litMatcher{
										pos:        position{line: 1948, col: 130, offset: 64888},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1948, col: 135, offset: 64893},
									label: "ifFalseI",
									expr: &ruleRefExpr{
										pos:  position{line: 1948, col: 144, offset: 64902},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1948, col: 167, offset: 64925},
									expr: &litMatcher{
										pos:        position{line: 1948, col: 167, offset: 64925},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1948, col: 172, offset: 64930},
									expr: &seqExpr{
										pos: position{line: 1948, col: 173, offset: 64931},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 1948, col: 173, offset: 64931},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1948, col: 177, offset: 64935},
												expr: &litMatcher{
													pos:        position{line: 1948, col: 177, offset: 64935},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1948, col: 184, offset: 64942},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonSingleLineTernaryExpression31,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1956, col: 5, offset: 65223},
						run: (*parser).callonSingleLineTernaryExpression33,
						expr: &seqExpr{
							pos: position{line: 1956, col: 5, offset: 65223},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1956, col: 5, offset: 65223},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&labeledExpr{
									pos:   position{line: 1956, col: 10, offset: 65228},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonSingleLineTernaryExpression37,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1956, col: 24, offset: 65242},
									expr: &litMatcher{
										pos:        position{line: 1956, col: 24, offset: 65242},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1956, col: 29, offset: 65247},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonSingleLineTernaryExpression46,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1970, col: 5, offset: 65838},
						run: (*parser).callonSingleLineTernaryExpression48,
						expr: &seqExpr{
							pos: position{line: 1970, col: 5, offset: 65838},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1970, col: 5, offset: 65838},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1970, col: 10, offset: 65843},
									expr: &litMatcher{
										pos:        position{line: 1970, col: 10, offset: 65843},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1970, col: 15, offset: 65848},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1970, col: 26, offset: 65859},
										name: "SingleLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1970, col: 49, offset: 65882},
									label: "startPosI",
									expr: &choiceExpr{
										pos: position{line: 1887, col: 13, offset: 62171},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 1887, col: 13, offset: 62171},
												run: (*parser).callonSingleLineTernaryExpression57,
												expr: &seqExpr{
													pos: position{line: 1887, col: 13, offset: 62171},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 1887, col: 13, offset: 62171},
															expr: &litMatcher{
																pos:        position{line: 1887, col: 13, offset: 62171},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&litMatcher{
															pos:        position{line: 1887, col: 18, offset: 62176},
															val:        ",",
															ignoreCase: false,
															want:       "\",\"",
														},
														&labeledExpr{
															pos:   position{line: 1887, col: 22, offset: 62180},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonSingleLineTernaryExpression63,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1887, col: 31, offset: 62189},
															expr: &choiceExpr{
																pos: position{line: 3812, col: 20, offset: 129621},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 3808, col: 36, offset: 129503},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 3809, col: 36, offset: 129544},
																		exprs: []any{
																			&zeroOrOneExpr{
																				pos: position{line: 3809, col: 36, offset: 129544},
																				expr: &litMatcher{
																					pos:        position{line: 3809, col: 36, offset: 129544},
																					val:        "\r",
																					ignoreCase: false,
																					want:       "\"\\r\"",
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 3809, col: 42, offset: 129550},
																				val:        "\n",
																				ignoreCase: false,
																				want:       "\"\\n\"",
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 1889, col: 5, offset: 62220},
												run: (*parser).callonSingleLineTernaryExpression76,
												expr: &seqExpr{
													pos: position{line: 1889, col: 5, offset: 62220},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 1889, col: 5, offset: 62220},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonSingleLineTernaryExpression79,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 14, offset: 62229},
															expr: &litMatcher{
																pos:        position{line: 1889, col: 14, offset: 62229},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1970, col: 68, offset: 65901},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonSingleLineTernaryExpression88,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1985, col: 5, offset: 66527},
						run: (*parser).callonSingleLineTernaryExpression90,
						expr: &seqExpr{
							pos: position{line: 1985, col: 5, offset: 66527},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1985, col: 5, offset: 66527},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1985, col: 10, offset: 66532},
									expr: &litMatcher{
										pos:        position{line: 1985, col: 10, offset: 66532},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1985, col: 15, offset: 66537},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1985, col: 26, offset: 66548},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1985, col: 49, offset: 66571},
									expr: &litMatcher{
										pos:        position{line: 1985, col: 49, offset: 66571},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1985, col: 54, offset: 66576},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1985, col: 58, offset: 66580},
									expr: &litMatcher{
										pos:        position{line: 1985, col: 58, offset: 66580},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1985, col: 63, offset: 66585},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1985, col: 71, offset: 66593},
										name: "SingleLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1985, col: 94, offset: 66616},
									label: "startPosI",
									expr: &choiceExpr{
										pos: position{line: 1887, col: 13, offset: 62171},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 1887, col: 13, offset: 62171},
												run: (*parser).callonSingleLineTernaryExpression106,
												expr: &seqExpr{
													pos: position{line: 1887, col: 13, offset: 62171},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 1887, col: 13, offset: 62171},
															expr: &litMatcher{
																pos:        position{line: 1887, col: 13, offset: 62171},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&litMatcher{
															pos:        position{line: 1887, col: 18, offset: 62176},
															val:        ",",
															ignoreCase: false,
															want:       "\",\"",
														},
														&labeledExpr{
															pos:   position{line: 1887, col: 22, offset: 62180},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonSingleLineTernaryExpression112,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1887, col: 31, offset: 62189},
															expr: &choiceExpr{
																pos: position{line: 3812, col: 20, offset: 129621},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 3808, col: 36, offset: 129503},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 3809, col: 36, offset: 129544},
																		exprs: []any{
																			&zeroOrOneExpr{
																				pos: position{line: 3809, col: 36, offset: 129544},
																				expr: &litMatcher{
																					pos:        position{line: 3809, col: 36, offset: 129544},
																					val:        "\r",
																					ignoreCase: false,
																					want:       "\"\\r\"",
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 3809, col: 42, offset: 129550},
																				val:        "\n",
																				ignoreCase: false,
																				want:       "\"\\n\"",
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 1889, col: 5, offset: 62220},
												run: (*parser).callonSingleLineTernaryExpression125,
												expr: &seqExpr{
													pos: position{line: 1889, col: 5, offset: 62220},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 1889, col: 5, offset: 62220},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonSingleLineTernaryExpression128,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 14, offset: 62229},
															expr: &litMatcher{
																pos:        position{line: 1889, col: 14, offset: 62229},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1985, col: 113, offset: 66635},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonSingleLineTernaryExpression137,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ChainExpression",
			pos:  position{line: 2007, col: 1, offset: 67473},
			expr: &choiceExpr{
				pos: position{line: 2007, col: 20, offset: 67492},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 2007, col: 20, offset: 67492},
						run: (*parser).callonChainExpression2,
						expr: &seqExpr{
							pos: position{line: 2007, col: 20, offset: 67492},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 2007, col: 20, offset: 67492},
									label: "derefsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2007, col: 28, offset: 67500},
										expr: &litMatcher{
											pos:        position{line: 2007, col: 28, offset: 67500},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2007, col: 33, offset: 67505},
									label: "rootI",
									expr: &ruleRefExpr{
										pos:  position{line: 2007, col: 39, offset: 67511},
										name: "chainExpressionRoot",
									},
								},
								&labeledExpr{
									pos:   position{line: 2007, col: 59, offset: 67531},
									label: "checkRootI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2007, col: 70, offset: 67542},
										expr: &litMatcher{
											pos:        position{line: 2007, col: 70, offset: 67542},
											val:        "?",
											ignoreCase: false,
											want:       "\"?\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2007, col: 75, offset: 67547},
									label: "chainI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2007, col: 82, offset: 67554},
										expr: &ruleRefExpr{
											pos:  position{line: 2007, col: 82, offset: 67554},
											name: "ChainExpressionItem",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2008, col: 20, offset: 67594},
									label: "defaultI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2008, col: 29, offset: 67603},
										expr: &seqExpr{
											pos: position{line: 2008, col: 30, offset: 67604},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 2008, col: 30, offset: 67604},
													expr: &litMatcher{
														pos:        position{line: 2008, col: 30, offset: 67604},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&labeledExpr{
													pos:   position{line: 2008, col: 35, offset: 67609},
													label: "defaultPosI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonChainExpression21,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
												&litMatcher{
													pos:        position{line: 2008, col: 51, offset: 67625},
													val:        "~",
													ignoreCase: false,
													want:       "\"~\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 2008, col: 55, offset: 67629},
													expr: &choiceExpr{
														pos: position{line: 3812, col: 20, offset: 129621},
														alternatives: []any{
															&charClassMatcher{
																pos:        position{line: 3808, col: 36, offset: 129503},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
															&seqExpr{
																pos: position{line: 3809, col: 36, offset: 129544},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3809, col: 36, offset: 129544},
																		expr: &litMatcher{
																			pos:        position{line: 3809, col: 36, offset: 129544},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3809, col: 42, offset: 129550},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
														},
													},
												},
												&ruleRefExpr{
													pos:  position{line: 2008, col: 59, offset: 67633},
													name: "GoExpression",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2008, col: 74, offset: 67648},
									label: "endPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonChainExpression37,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&andExpr{
									pos: position{line: 2008, col: 86, offset: 67660},
									expr: &choiceExpr{
										pos: position{line: 2008, col: 88, offset: 67662},
										alternatives: []any{
											&seqExpr{
												pos: position{line: 3796, col: 12, offset: 129156},
												exprs: []any{
													&zeroOrMoreExpr{
														pos: position{line: 3796, col: 12, offset: 129156},
														expr: &charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		expr: &litMatcher{
																			pos:        position{line: 3796, col: 16, offset: 129160},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3796, col: 22, offset: 129166},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3795, col: 12, offset: 129142},
																expr: &anyMatcher{
																	line: 3795, col: 13, offset: 129143,
																},
															},
														},
													},
												},
											},
											&seqExpr{
												pos: position{line: 2008, col: 94, offset: 67668},
												exprs: []any{
													&zeroOrMoreExpr{
														pos: position{line: 2008, col: 94, offset: 67668},
														expr: &litMatcher{
															pos:        position{line: 2008, col: 94, offset: 67668},
															val:        " ",
															ignoreCase: false,
															want:       "\" \"",
														},
													},
													&choiceExpr{
														pos: position{line: 1405, col: 25, offset: 44841},
														alternatives: []any{
															&charClassMatcher{
																pos:        position{line: 1405, col: 25, offset: 44841},
																val:        "[)}],]",
																chars:      []rune{')', '}', ']', ','},
																ignoreCase: false,
																inverted:   false,
															},
															&seqExpr{
																pos: position{line: 1405, col: 40, offset: 44856},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 1405, col: 40, offset: 44856},
																		val:        ":",
																		ignoreCase: false,
																		want:       "\":\"",
																	},
																	&notExpr{
																		pos: position{line: 1405, col: 44, offset: 44860},
																		expr: &litMatcher{
																			pos:        position{line: 1405, col: 45, offset: 44861},
																			val:        "=",
																			ignoreCase: false,
																			want:       "\"=\"",
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&andCodeExpr{
									pos: position{line: 2008, col: 121, offset: 67695},
									run: (*parser).callonChainExpression64,
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2026, col: 5, offset: 68328},
						run: (*parser).callonChainExpression65,
						expr: &seqExpr{
							pos: position{line: 2026, col: 5, offset: 68328},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 2026, col: 5, offset: 68328},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonChainExpression68,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2026, col: 19, offset: 68342},
									label: "derefsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2026, col: 27, offset: 68350},
										expr: &litMatcher{
											pos:        position{line: 2026, col: 27, offset: 68350},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2026, col: 32, offset: 68355},
									label: "rootI",
									expr: &ruleRefExpr{
										pos:  position{line: 2026, col: 38, offset: 68361},
										name: "chainExpressionRoot",
									},
								},
								&labeledExpr{
									pos:   position{line: 2026, col: 58, offset: 68381},
									label: "checkRootI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2026, col: 69, offset: 68392},
										expr: &litMatcher{
											pos:        position{line: 2026, col: 69, offset: 68392},
											val:        "?",
											ignoreCase: false,
											want:       "\"?\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2026, col: 74, offset: 68397},
									label: "chainI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2026, col: 81, offset: 68404},
										expr: &ruleRefExpr{
											pos:  position{line: 2026, col: 81, offset: 68404},
											name: "ChainExpressionItem",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2026, col: 102, offset: 68425},
									label: "endPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonChainExpression86,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&andCodeExpr{
									pos: position{line: 2026, col: 114, offset: 68437},
									run: (*parser).callonChainExpression92,
								},
								&labeledExpr{
									pos:   position{line: 2028, col: 3, offset: 68544},
									label: "malStartPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonChainExpression94,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2028, col: 20, offset: 68561},
									name: "GoExpression",
								},
								&labeledExpr{
									pos:   position{line: 2028, col: 33, offset: 68574},
									label: "malEndPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonChainExpression102,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "chainExpressionRoot",
			pos:  position{line: 2069, col: 1, offset: 70025},
			expr: &choiceExpr{
				pos: position{line: 2069, col: 24, offset: 70048},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 2069, col: 24, offset: 70048},
						run: (*parser).callonchainExpressionRoot2,
						expr: &seqExpr{
							pos: position{line: 2069, col: 24, offset: 70048},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2069, col: 24, offset: 70048},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 2069, col: 28, offset: 70052},
									expr: &ruleRefExpr{
										pos:  position{line: 2069, col: 28, offset: 70052},
										name: "chainExpressionRootParenContent",
									},
								},
								&litMatcher{
									pos:        position{line: 2069, col: 61, offset: 70085},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2074, col: 5, offset: 70198},
						run: (*parser).callonchainExpressionRoot8,
						expr: &labeledExpr{
							pos:   position{line: 2074, col: 5, offset: 70198},
							label: "identI",
							expr: &actionExpr{
								pos: position{line: 2371, col: 12, offset: 80907},
								run: (*parser).callonchainExpressionRoot10,
								expr: &labeledExpr{
									pos:   position{line: 2371, col: 12, offset: 80907},
									label: "ident",
									expr: &seqExpr{
										pos: position{line: 2410, col: 17, offset: 81833},
										exprs: []any{
											&charClassMatcher{
												pos:        position{line: 2393, col: 20, offset: 81588},
												val:        "[_\\pL]",
												chars:      []rune{'_'},
												classes:    []*unicode.RangeTable{rangeTable("L")},
												ignoreCase: false,
												inverted:   false,
											},
											&zeroOrMoreExpr{
												pos: position{line: 2410, col: 26, offset: 81842},
												expr: &charClassMatcher{
													pos:        position{line: 2393, col: 20, offset: 81588},
													val:        "[_\\pL\\pNd]",
													chars:      []rune{'_'},
													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "chainExpressionRootParenContent",
			pos:  position{line: 2081, col: 1, offset: 70360},
			expr: &choiceExpr{
				pos: position{line: 2081, col: 36, offset: 70395},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 2081, col: 36, offset: 70395},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 2081, col: 36, offset: 70395},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2081, col: 40, offset: 70399},
								name: "chainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2081, col: 72, offset: 70431},
								val:        ")",
								ignoreCase: false,
								want:       "\")\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2082, col: 36, offset: 70472},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 2082, col: 36, offset: 70472},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2082, col: 40, offset: 70476},
								name: "chainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2082, col: 72, offset: 70508},
								val:        "]",
								ignoreCase: false,
								want:       "\"]\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2083, col: 36, offset: 70549},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 2083, col: 36, offset: 70549},
								val:        "{",
								ignoreCase: false,
								want:       "\"{\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2083, col: 40, offset: 70553},
								name: "chainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2083, col: 72, offset: 70585},
								val:        "}",
								ignoreCase: false,
								want:       "\"}\"",
							},
						},
					},
					&oneOrMoreExpr{
						pos: position{line: 2084, col: 36, offset: 70626},
						expr: &charClassMatcher{
							pos:        position{line: 2084, col: 36, offset: 70626},
							val:        "[^({[]})]",
							chars:      []rune{'(', '{', '[', ']', '}', ')'},
							ignoreCase: false,
							inverted:   true,
						},
					},
				},
			},
		},
		{
			name: "SingleLineChainExpression",
			pos:  position{line: 2086, col: 1, offset: 70639},
			expr: &choiceExpr{
				pos: position{line: 2086, col: 30, offset: 70668},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 2086, col: 30, offset: 70668},
						run: (*parser).callonSingleLineChainExpression2,
						expr: &seqExpr{
							pos: position{line: 2086, col: 30, offset: 70668},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 2086, col: 30, offset: 70668},
									label: "derefsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2086, col: 38, offset: 70676},
										expr: &litMatcher{
											pos:        position{line: 2086, col: 38, offset: 70676},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2086, col: 43, offset: 70681},
									label: "rootI",
									expr: &ruleRefExpr{
										pos:  position{line: 2086, col: 49, offset: 70687},
										name: "chainExpressionRoot",
									},
								},
								&labeledExpr{
									pos:   position{line: 2086, col: 69, offset: 70707},
									label: "checkRootI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2086, col: 80, offset: 70718},
										expr: &litMatcher{
											pos:        position{line: 2086, col: 80, offset: 70718},
											val:        "?",
											ignoreCase: false,
											want:       "\"?\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2086, col: 85, offset: 70723},
									label: "chainI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2086, col: 92, offset: 70730},
										expr: &ruleRefExpr{
											pos:  position{line: 2086, col: 92, offset: 70730},
											name: "SingleLineChainExpressionItem",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2087, col: 30, offset: 70790},
									label: "defaultI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2087, col: 39, offset: 70799},
										expr: &seqExpr{
											pos: position{line: 2087, col: 40, offset: 70800},
											exprs: []any{
												&zeroOrMoreExpr{
													pos: position{line: 2087, col: 40, offset: 70800},
													expr: &litMatcher{
														pos:        position{line: 2087, col: 40, offset: 70800},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&labeledExpr{
													pos:   position{line: 2087, col: 45, offset: 70805},
													label: "defaultPosI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonSingleLineChainExpression21,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
												&litMatcher{
													pos:        position{line: 2087, col: 61, offset: 70821},
													val:        "~",
													ignoreCase: false,
													want:       "\"~\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 2087, col: 65, offset: 70825},
													expr: &litMatcher{
														pos:        position{line: 2087, col: 65, offset: 70825},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&ruleRefExpr{
													pos:  position{line: 2087, col: 70, offset: 70830},
													name: "SingleLineGoExpression",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2087, col: 95, offset: 70855},
									label: "endPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonSingleLineChainExpression32,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&andExpr{
									pos: position{line: 2087, col: 107, offset: 70867},
									expr: &choiceExpr{
										pos: position{line: 2087, col: 109, offset: 70869},
										alternatives: []any{
											&seqExpr{
												pos: position{line: 3796, col: 12, offset: 129156},
												exprs: []any{
													&zeroOrMoreExpr{
														pos: position{line: 3796, col: 12, offset: 129156},
														expr: &charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		expr: &litMatcher{
																			pos:        position{line: 3796, col: 16, offset: 129160},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3796, col: 22, offset: 129166},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3795, col: 12, offset: 129142},
																expr: &anyMatcher{
																	line: 3795, col: 13, offset: 129143,
																},
															},
														},
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 1405, col: 25, offset: 44841},
												val:        "[)}],]",
												chars:      []rune{')', '}', ']', ','},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 1405, col: 40, offset: 44856},
												exprs: []any{
													&litMatcher{
														pos:        position{line: 1405, col: 40, offset: 44856},
														val:        ":",
														ignoreCase: false,
														want:       "\":\"",
													},
													&notExpr{
														pos: position{line: 1405, col: 44, offset: 44860},
														expr: &litMatcher{
															pos:        position{line: 1405, col: 45, offset: 44861},
															val:        "=",
															ignoreCase: false,
															want:       "\"=\"",
														},
													},
												},
											},
										},
									},
								},
								&andCodeExpr{
									pos: position{line: 2087, col: 137, offset: 70897},
									run: (*parser).callonSingleLineChainExpression55,
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 2105, col: 5, offset: 71530},
						exprs: []any{
							&labeledExpr{
								pos:   position{line: 2105, col: 5, offset: 71530},
								label: "startPosI",
								expr: &actionExpr{
									pos: position{line: 3799, col: 8, offset: 129205},
									run: (*parser).callonSingleLineChainExpression58,
									expr: &choiceExpr{
										pos: position{line: 3799, col: 9, offset: 129206},
										alternatives: []any{
											&andExpr{
												pos: position{line: 3799, col: 9, offset: 129206},
												expr: &anyMatcher{
													line: 3799, col: 10, offset: 129207,
												},
											},
											&notExpr{
												pos: position{line: 3799, col: 14, offset: 129211},
												expr: &anyMatcher{
													line: 3799, col: 15, offset: 129212,
												},
											},
										},
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 2105, col: 19, offset: 71544},
								label: "derefsI",
								expr: &zeroOrMoreExpr{
									pos: position{line: 2105, col: 27, offset: 71552},
									expr: &litMatcher{
										pos:        position{line: 2105, col: 27, offset: 71552},
										val:        "*",
										ignoreCase: false,
										want:       "\"*\"",
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 2105, col: 32, offset: 71557},
								label: "rootI",
								expr: &ruleRefExpr{
									pos:  position{line: 2105, col: 38, offset: 71563},
									name: "chainExpressionRoot",
								},
							},
							&labeledExpr{
								pos:   position{line: 2105, col: 58, offset: 71583},
								label: "checkRootI",
								expr: &zeroOrOneExpr{
									pos: position{line: 2105, col: 69, offset: 71594},
									expr: &litMatcher{
										pos:        position{line: 2105, col: 69, offset: 71594},
										val:        "?",
										ignoreCase: false,
										want:       "\"?\"",
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 2105, col: 74, offset: 71599},
								label: "chainI",
								expr: &zeroOrMoreExpr{
									pos: position{line: 2105, col: 81, offset: 71606},
									expr: &ruleRefExpr{
										pos:  position{line: 2105, col: 81, offset: 71606},
										name: "SingleLineChainExpressionItem",
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 2105, col: 112, offset: 71637},
								label: "endPosI",
								expr: &actionExpr{
									pos: position{line: 3799, col: 8, offset: 129205},
									run: (*parser).callonSingleLineChainExpression76,
									expr: &choiceExpr{
										pos: position{line: 3799, col: 9, offset: 129206},
										alternatives: []any{
											&andExpr{
												pos: position{line: 3799, col: 9, offset: 129206},
												expr: &anyMatcher{
													line: 3799, col: 10, offset: 129207,
												},
											},
											&notExpr{
												pos: position{line: 3799, col: 14, offset: 129211},
												expr: &anyMatcher{
													line: 3799, col: 15, offset: 129212,
												},
											},
										},
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 2105, col: 124, offset: 71649},
								run: (*parser).callonSingleLineChainExpression82,
							},
							&labeledExpr{
								pos:   position{line: 2107, col: 3, offset: 71715},
								label: "malStartPosI",
								expr: &actionExpr{
									pos: position{line: 3799, col: 8, offset: 129205},
									run: (*parser).callonSingleLineChainExpression84,
									expr: &choiceExpr{
										pos: position{line: 3799, col: 9, offset: 129206},
										alternatives: []any{
											&andExpr{
												pos: position{line: 3799, col: 9, offset: 129206},
												expr: &anyMatcher{
													line: 3799, col: 10, offset: 129207,
												},
											},
											&notExpr{
												pos: position{line: 3799, col: 14, offset: 129211},
												expr: &anyMatcher{
													line: 3799, col: 15, offset: 129212,
												},
											},
										},
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 2107, col: 20, offset: 71732},
								name: "SingleLineGoExpression",
							},
							&labeledExpr{
								pos:   position{line: 2107, col: 43, offset: 71755},
								label: "malEndPosI",
								expr: &actionExpr{
									pos: position{line: 3799, col: 8, offset: 129205},
									run: (*parser).callonSingleLineChainExpression92,
									expr: &choiceExpr{
										pos: position{line: 3799, col: 9, offset: 129206},
										alternatives: []any{
											&andExpr{
												pos: position{line: 3799, col: 9, offset: 129206},
												expr: &anyMatcher{
													line: 3799, col: 10, offset: 129207,
												},
											},
											&notExpr{
												pos: position{line: 3799, col: 14, offset: 129211},
												expr: &anyMatcher{
													line: 3799, col: 15, offset: 129212,
												},
											},
										},
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 2107, col: 58, offset: 71770},
								run: (*parser).callonSingleLineChainExpression98,
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineChainExpressionRootParenContent",
			pos:  position{line: 2147, col: 1, offset: 73145},
			expr: &choiceExpr{
				pos: position{line: 2147, col: 46, offset: 73190},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 2147, col: 46, offset: 73190},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 2147, col: 46, offset: 73190},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2147, col: 50, offset: 73194},
								name: "singleLineChainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2147, col: 92, offset: 73236},
								val:        ")",
								ignoreCase: false,
								want:       "\")\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2148, col: 46, offset: 73287},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 2148, col: 46, offset: 73287},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2148, col: 50, offset: 73291},
								name: "singleLineChainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2148, col: 92, offset: 73333},
								val:        "]",
								ignoreCase: false,
								want:       "\"]\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2149, col: 46, offset: 73384},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 2149, col: 46, offset: 73384},
								val:        "{",
								ignoreCase: false,
								want:       "\"{\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2149, col: 50, offset: 73388},
								name: "singleLineChainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2149, col: 92, offset: 73430},
								val:        "}",
								ignoreCase: false,
								want:       "\"}\"",
							},
						},
					},
					&oneOrMoreExpr{
						pos: position{line: 2150, col: 46, offset: 73481},
						expr: &charClassMatcher{
							pos:        position{line: 2150, col: 46, offset: 73481},
							val:        "[^({[]})\\r\\n]",
							chars:      []rune{'(', '{', '[', ']', '}', ')', '\r', '\n'},
							ignoreCase: false,
							inverted:   true,
						},
					},
				},
			},
		},
		{
			name: "ChainExpressionItem",
			pos:  position{line: 2156, col: 1, offset: 73530},
			expr: &choiceExpr{
				pos: position{line: 2156, col: 34, offset: 73563},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 2156, col: 34, offset: 73563},
						name: "IndexExpression",
					},
					&actionExpr{
						pos: position{line: 2200, col: 23, offset: 75425},
						run: (*parser).callonChainExpressionItem3,
						expr: &seqExpr{
							pos: position{line: 2200, col: 23, offset: 75425},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2200, col: 23, offset: 75425},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2200, col: 27, offset: 75429},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2200, col: 31, offset: 75433},
									label: "identI",
									expr: &actionExpr{
										pos: position{line: 2371, col: 12, offset: 80907},
										run: (*parser).callonChainExpressionItem14,
										expr: &labeledExpr{
											pos:   position{line: 2371, col: 12, offset: 80907},
											label: "ident",
											expr: &seqExpr{
												pos: position{line: 2410, col: 17, offset: 81833},
												exprs: []any{
													&charClassMatcher{
														pos:        position{line: 2393, col: 20, offset: 81588},
														val:        "[_\\pL]",
														chars:      []rune{'_'},
														classes:    []*unicode.RangeTable{rangeTable("L")},
														ignoreCase: false,
														inverted:   false,
													},
													&zeroOrMoreExpr{
														pos: position{line: 2410, col: 26, offset: 81842},
														expr: &charClassMatcher{
															pos:        position{line: 2393, col: 20, offset: 81588},
															val:        "[_\\pL\\pNd]",
															chars:      []rune{'_'},
															classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
															ignoreCase: false,
															inverted:   false,
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2200, col: 46, offset: 75448},
									label: "checkI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2200, col: 53, offset: 75455},
										expr: &litMatcher{
											pos:        position{line: 2200, col: 53, offset: 75455},
											val:        "?",
											ignoreCase: false,
											want:       "\"?\"",
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2156, col: 73, offset: 73602},
						name: "ParenExpression",
					},
					&actionExpr{
						pos: position{line: 2256, col: 28, offset: 77141},
						run: (*parser).callonChainExpressionItem24,
						expr: &seqExpr{
							pos: position{line: 2256, col: 28, offset: 77141},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2256, col: 28, offset: 77141},
									val:        ".(",
									ignoreCase: false,
									want:       "\".(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2256, col: 33, offset: 77146},
									expr: &litMatcher{
										pos:        position{line: 2256, col: 33, offset: 77146},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2256, col: 38, offset: 77151},
									label: "ptrsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2256, col: 44, offset: 77157},
										expr: &litMatcher{
											pos:        position{line: 2256, col: 44, offset: 77157},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2256, col: 49, offset: 77162},
									expr: &litMatcher{
										pos:        position{line: 2256, col: 49, offset: 77162},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2256, col: 54, offset: 77167},
									label: "packageI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2256, col: 63, offset: 77176},
										expr: &seqExpr{
											pos: position{line: 2256, col: 64, offset: 77177},
											exprs: []any{
												&actionExpr{
													pos: position{line: 2371, col: 12, offset: 80907},
													run: (*parser).callonChainExpressionItem37,
													expr: &labeledExpr{
														pos:   position{line: 2371, col: 12, offset: 80907},
														label: "ident",
														expr: &seqExpr{
															pos: position{line: 2410, col: 17, offset: 81833},
															exprs: []any{
																&charClassMatcher{
																	pos:        position{line: 2393, col: 20, offset: 81588},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2410, col: 26, offset: 81842},
																	expr: &charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&litMatcher{
													pos:        position{line: 2256, col: 72, offset: 77185},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 2256, col: 76, offset: 77189},
													expr: &litMatcher{
														pos:        position{line: 2256, col: 76, offset: 77189},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2256, col: 83, offset: 77196},
									label: "typeI",
									expr: &actionExpr{
										pos: position{line: 2371, col: 12, offset: 80907},
										run: (*parser).callonChainExpressionItem47,
										expr: &labeledExpr{
											pos:   position{line: 2371, col: 12, offset: 80907},
											label: "ident",
											expr: &seqExpr{
												pos: position{line: 2410, col: 17, offset: 81833},
												exprs: []any{
													&charClassMatcher{
														pos:        position{line: 2393, col: 20, offset: 81588},
														val:        "[_\\pL]",
														chars:      []rune{'_'},
														classes:    []*unicode.RangeTable{rangeTable("L")},
														ignoreCase: false,
														inverted:   false,
													},
													&zeroOrMoreExpr{
														pos: position{line: 2410, col: 26, offset: 81842},
														expr: &charClassMatcher{
															pos:        position{line: 2393, col: 20, offset: 81588},
															val:        "[_\\pL\\pNd]",
															chars:      []rune{'_'},
															classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
															ignoreCase: false,
															inverted:   false,
														},
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2256, col: 97, offset: 77210},
									expr: &litMatcher{
										pos:        position{line: 2256, col: 97, offset: 77210},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2256, col: 102, offset: 77215},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonChainExpressionItem56,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2256, col: 121, offset: 77234},
									label: "checkI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2256, col: 128, offset: 77241},
										expr: &litMatcher{
											pos:        position{line: 2256, col: 128, offset: 77241},
											val:        "?",
											ignoreCase: false,
											want:       "\"?\"",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineChainExpressionItem",
			pos:  position{line: 2157, col: 1, offset: 73644},
			expr: &choiceExpr{
				pos: position{line: 2157, col: 34, offset: 73677},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 2157, col: 34, offset: 73677},
						name: "SingleLineIndexExpression",
					},
					&actionExpr{
						pos: position{line: 2208, col: 33, offset: 75638},
						run: (*parser).callonSingleLineChainExpressionItem3,
						expr: &seqExpr{
							pos: position{line: 2208, col: 33, offset: 75638},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2208, col: 33, offset: 75638},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2208, col: 37, offset: 75642},
									expr: &litMatcher{
										pos:        position{line: 2208, col: 37, offset: 75642},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2208, col: 42, offset: 75647},
									label: "identI",
									expr: &actionExpr{
										pos: position{line: 2371, col: 12, offset: 80907},
										run: (*parser).callonSingleLineChainExpressionItem9,
										expr: &labeledExpr{
											pos:   position{line: 2371, col: 12, offset: 80907},
											label: "ident",
											expr: &seqExpr{
												pos: position{line: 2410, col: 17, offset: 81833},
												exprs: []any{
													&charClassMatcher{
														pos:        position{line: 2393, col: 20, offset: 81588},
														val:        "[_\\pL]",
														chars:      []rune{'_'},
														classes:    []*unicode.RangeTable{rangeTable("L")},
														ignoreCase: false,
														inverted:   false,
													},
													&zeroOrMoreExpr{
														pos: position{line: 2410, col: 26, offset: 81842},
														expr: &charClassMatcher{
															pos:        position{line: 2393, col: 20, offset: 81588},
															val:        "[_\\pL\\pNd]",
															chars:      []rune{'_'},
															classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
															ignoreCase: false,
															inverted:   false,
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2208, col: 57, offset: 75662},
									label: "checkI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2208, col: 64, offset: 75669},
										expr: &litMatcher{
											pos:        position{line: 2208, col: 64, offset: 75669},
											val:        "?",
											ignoreCase: false,
											want:       "\"?\"",
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2158, col: 34, offset: 73769},
						name: "SingleLineParenExpression",
					},
					&actionExpr{
						pos: position{line: 2256, col: 28, offset: 77141},
						run: (*parser).callonSingleLineChainExpressionItem19,
						expr: &seqExpr{
							pos: position{line: 2256, col: 28, offset: 77141},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2256, col: 28, offset: 77141},
									val:        ".(",
									ignoreCase: false,
									want:       "\".(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2256, col: 33, offset: 77146},
									expr: &litMatcher{
										pos:        position{line: 2256, col: 33, offset: 77146},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2256, col: 38, offset: 77151},
									label: "ptrsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2256, col: 44, offset: 77157},
										expr: &litMatcher{
											pos:        position{line: 2256, col: 44, offset: 77157},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2256, col: 49, offset: 77162},
									expr: &litMatcher{
										pos:        position{line: 2256, col: 49, offset: 77162},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2256, col: 54, offset: 77167},
									label: "packageI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2256, col: 63, offset: 77176},
										expr: &seqExpr{
											pos: position{line: 2256, col: 64, offset: 77177},
											exprs: []any{
												&actionExpr{
													pos: position{line: 2371, col: 12, offset: 80907},
													run: (*parser).callonSingleLineChainExpressionItem32,
													expr: &labeledExpr{
														pos:   position{line: 2371, col: 12, offset: 80907},
														label: "ident",
														expr: &seqExpr{
															pos: position{line: 2410, col: 17, offset: 81833},
															exprs: []any{
																&charClassMatcher{
																	pos:        position{line: 2393, col: 20, offset: 81588},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2410, col: 26, offset: 81842},
																	expr: &charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&litMatcher{
													pos:        position{line: 2256, col: 72, offset: 77185},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 2256, col: 76, offset: 77189},
													expr: &litMatcher{
														pos:        position{line: 2256, col: 76, offset: 77189},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2256, col: 83, offset: 77196},
									label: "typeI",
									expr: &actionExpr{
										pos: position{line: 2371, col: 12, offset: 80907},
										run: (*parser).callonSingleLineChainExpressionItem42,
										expr: &labeledExpr{
											pos:   position{line: 2371, col: 12, offset: 80907},
											label: "ident",
											expr: &seqExpr{
												pos: position{line: 2410, col: 17, offset: 81833},
												exprs: []any{
													&charClassMatcher{
														pos:        position{line: 2393, col: 20, offset: 81588},
														val:        "[_\\pL]",
														chars:      []rune{'_'},
														classes:    []*unicode.RangeTable{rangeTable("L")},
														ignoreCase: false,
														inverted:   false,
													},
													&zeroOrMoreExpr{
														pos: position{line: 2410, col: 26, offset: 81842},
														expr: &charClassMatcher{
															pos:        position{line: 2393, col: 20, offset: 81588},
															val:        "[_\\pL\\pNd]",
															chars:      []rune{'_'},
															classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
															ignoreCase: false,
															inverted:   false,
														},
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2256, col: 97, offset: 77210},
									expr: &litMatcher{
										pos:        position{line: 2256, col: 97, offset: 77210},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2256, col: 102, offset: 77215},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonSingleLineChainExpressionItem51,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2256, col: 121, offset: 77234},
									label: "checkI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2256, col: 128, offset: 77241},
										expr: &litMatcher{
											pos:        position{line: 2256, col: 128, offset: 77241},
											val:        "?",
											ignoreCase: false,
											want:       "\"?\"",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "IndexExpression",
			pos:  position{line: 2160, col: 1, offset: 73832},
			expr: &actionExpr{
				pos: position{line: 2160, col: 20, offset: 73851},
				run: (*parser).callonIndexExpression1,
				expr: &seqExpr{
					pos: position{line: 2160, col: 20, offset: 73851},
					exprs: []any{
						&actionExpr{
							pos: position{line: 3824, col: 14, offset: 129997},
							run: (*parser).callonIndexExpression3,
							expr: &litMatcher{
								pos:        position{line: 3824, col: 14, offset: 129997},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2160, col: 30, offset: 73861},
							expr: &choiceExpr{
								pos: position{line: 3812, col: 20, offset: 129621},
								alternatives: []any{
									&charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
									&seqExpr{
										pos: position{line: 3809, col: 36, offset: 129544},
										exprs: []any{
											&zeroOrOneExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												expr: &litMatcher{
													pos:        position{line: 3809, col: 36, offset: 129544},
													val:        "\r",
													ignoreCase: false,
													want:       "\"\\r\"",
												},
											},
											&litMatcher{
												pos:        position{line: 3809, col: 42, offset: 129550},
												val:        "\n",
												ignoreCase: false,
												want:       "\"\\n\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2160, col: 34, offset: 73865},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 2160, col: 40, offset: 73871},
								name: "indexExpressionIndex",
							},
						},
						&labeledExpr{
							pos:   position{line: 2160, col: 61, offset: 73892},
							label: "checkIndexI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2160, col: 73, offset: 73904},
								expr: &litMatcher{
									pos:        position{line: 2160, col: 73, offset: 73904},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2160, col: 78, offset: 73909},
							expr: &seqExpr{
								pos: position{line: 2160, col: 79, offset: 73910},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 2160, col: 79, offset: 73910},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2160, col: 83, offset: 73914},
										expr: &choiceExpr{
											pos: position{line: 3812, col: 20, offset: 129621},
											alternatives: []any{
												&charClassMatcher{
													pos:        position{line: 3808, col: 36, offset: 129503},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
												&seqExpr{
													pos: position{line: 3809, col: 36, offset: 129544},
													exprs: []any{
														&zeroOrOneExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															expr: &litMatcher{
																pos:        position{line: 3809, col: 36, offset: 129544},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3809, col: 42, offset: 129550},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2160, col: 89, offset: 73920},
							expr: &litMatcher{
								pos:        position{line: 2160, col: 89, offset: 73920},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2160, col: 94, offset: 73925},
							label: "rBracePosI",
							expr: &actionExpr{
								pos: position{line: 3825, col: 14, offset: 130037},
								run: (*parser).callonIndexExpression30,
								expr: &litMatcher{
									pos:        position{line: 3825, col: 14, offset: 130037},
									val:        "]",
									ignoreCase: false,
									want:       "\"]\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2160, col: 115, offset: 73946},
							label: "checkValueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2160, col: 127, offset: 73958},
								expr: &litMatcher{
									pos:        position{line: 2160, col: 127, offset: 73958},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "indexExpressionIndex",
			pos:  position{line: 2172, col: 1, offset: 74271},
			expr: &actionExpr{
				pos: position{line: 2172, col: 25, offset: 74295},
				run: (*parser).callonindexExpressionIndex1,
				expr: &labeledExpr{
					pos:   position{line: 2172, col: 25, offset: 74295},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 2172, col: 32, offset: 74302},
						expr: &choiceExpr{
							pos: position{line: 2173, col: 5, offset: 74308},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 2173, col: 5, offset: 74308},
									name: "goParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 2173, col: 19, offset: 74322},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 2173, col: 38, offset: 74341},
									name: "TernaryExpression",
								},
								&actionExpr{
									pos: position{line: 1477, col: 15, offset: 47305},
									run: (*parser).callonindexExpressionIndex8,
									expr: &seqExpr{
										pos: position{line: 1477, col: 15, offset: 47305},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1477, col: 15, offset: 47305},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonindexExpressionIndex11,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&choiceExpr{
												pos: position{line: 2457, col: 14, offset: 83160},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 2457, col: 14, offset: 83160},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2457, col: 14, offset: 83160},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&choiceExpr{
																pos: position{line: 2457, col: 20, offset: 83166},
																alternatives: []any{
																	&seqExpr{
																		pos: position{line: 2505, col: 19, offset: 85311},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2505, col: 19, offset: 85311},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2506, col: 5, offset: 85370},
																		run: (*parser).callonindexExpressionIndex27,
																		expr: &seqExpr{
																			pos: position{line: 2506, col: 5, offset: 85370},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2506, col: 5, offset: 85370},
																					val:        "\\u",
																					ignoreCase: false,
																					want:       "\"\\\\u\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 14, offset: 85379},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 26, offset: 85391},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 38, offset: 85403},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 50, offset: 85415},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2535, col: 16, offset: 86551},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2535, col: 16, offset: 86551},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2536, col: 5, offset: 86654},
																		run: (*parser).callonindexExpressionIndex48,
																		expr: &seqExpr{
																			pos: position{line: 2536, col: 5, offset: 86654},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2536, col: 5, offset: 86654},
																					val:        "\\U",
																					ignoreCase: false,
																					want:       "\"\\\\U\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 14, offset: 86663},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 26, offset: 86675},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 38, offset: 86687},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 50, offset: 86699},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 62, offset: 86711},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 74, offset: 86723},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 86, offset: 86735},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 98, offset: 86747},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2570, col: 24, offset: 88132},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2570, col: 24, offset: 88132},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2570, col: 29, offset: 88137},
																				val:        "[abfnrtv\\\\\\]",
																				chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 2484, col: 75, offset: 84423},
																		val:        "[^\\\\\\\\n]",
																		chars:      []rune{'\'', '\\', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																	&seqExpr{
																		pos: position{line: 2486, col: 24, offset: 84569},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2486, col: 24, offset: 84569},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2487, col: 24, offset: 84636},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2487, col: 24, offset: 84636},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2488, col: 5, offset: 84673},
																		run: (*parser).callonindexExpressionIndex80,
																		expr: &seqExpr{
																			pos: position{line: 2488, col: 5, offset: 84673},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2488, col: 5, offset: 84673},
																					val:        "\\x",
																					ignoreCase: false,
																					want:       "\"\\\\x\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 14, offset: 84682},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 26, offset: 84694},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2571, col: 24, offset: 88215},
																		run: (*parser).callonindexExpressionIndex87,
																		expr: &seqExpr{
																			pos: position{line: 2571, col: 24, offset: 88215},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2571, col: 24, offset: 88215},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2595, col: 5, offset: 89231},
																		run: (*parser).callonindexExpressionIndex98,
																		expr: &seqExpr{
																			pos: position{line: 2595, col: 5, offset: 89231},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2595, col: 5, offset: 89231},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2616, col: 5, offset: 90072},
																		run: (*parser).callonindexExpressionIndex105,
																		expr: &seqExpr{
																			pos: position{line: 2616, col: 5, offset: 90072},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2616, col: 5, offset: 90072},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2634, col: 5, offset: 90757},
																		run: (*parser).callonindexExpressionIndex110,
																		expr: &seqExpr{
																			pos: position{line: 2634, col: 5, offset: 90757},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2634, col: 5, offset: 90757},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2634, col: 10, offset: 90762},
																					expr: &charClassMatcher{
																						pos:        position{line: 3797, col: 12, offset: 129189},
																						val:        "[^\\r\\n]",
																						chars:      []rune{'\r', '\n'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2457, col: 76, offset: 83222},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
														},
													},
													&actionExpr{
														pos: position{line: 2458, col: 5, offset: 83233},
														run: (*parser).callonindexExpressionIndex116,
														expr: &seqExpr{
															pos: position{line: 2458, col: 5, offset: 83233},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2458, col: 5, offset: 83233},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 10, offset: 83238},
																	label: "valsI",
																	expr: &zeroOrMoreExpr{
																		pos: position{line: 2458, col: 16, offset: 83244},
																		expr: &choiceExpr{
																			pos: position{line: 2458, col: 17, offset: 83245},
																			alternatives: []any{
																				&seqExpr{
																					pos: position{line: 2505, col: 19, offset: 85311},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2505, col: 19, offset: 85311},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2506, col: 5, offset: 85370},
																					run: (*parser).callonindexExpressionIndex128,
																					expr: &seqExpr{
																						pos: position{line: 2506, col: 5, offset: 85370},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2506, col: 5, offset: 85370},
																								val:        "\\u",
																								ignoreCase: false,
																								want:       "\"\\\\u\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 14, offset: 85379},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 26, offset: 85391},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 38, offset: 85403},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 50, offset: 85415},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2535, col: 16, offset: 86551},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2535, col: 16, offset: 86551},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2536, col: 5, offset: 86654},
																					run: (*parser).callonindexExpressionIndex149,
																					expr: &seqExpr{
																						pos: position{line: 2536, col: 5, offset: 86654},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2536, col: 5, offset: 86654},
																								val:        "\\U",
																								ignoreCase: false,
																								want:       "\"\\\\U\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 14, offset: 86663},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 26, offset: 86675},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 38, offset: 86687},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 50, offset: 86699},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 62, offset: 86711},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 74, offset: 86723},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 86, offset: 86735},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 98, offset: 86747},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2570, col: 24, offset: 88132},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2570, col: 24, offset: 88132},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2570, col: 29, offset: 88137},
																							val:        "[abfnrtv\\\\\\]",
																							chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2484, col: 75, offset: 84423},
																					val:        "[^\\\\\\\\n]",
																					chars:      []rune{'\'', '\\', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																				&seqExpr{
																					pos: position{line: 2486, col: 24, offset: 84569},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2486, col: 24, offset: 84569},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2487, col: 24, offset: 84636},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2487, col: 24, offset: 84636},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2488, col: 5, offset: 84673},
																					run: (*parser).callonindexExpressionIndex181,
																					expr: &seqExpr{
																						pos: position{line: 2488, col: 5, offset: 84673},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2488, col: 5, offset: 84673},
																								val:        "\\x",
																								ignoreCase: false,
																								want:       "\"\\\\x\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 14, offset: 84682},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 26, offset: 84694},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2571, col: 24, offset: 88215},
																					run: (*parser).callonindexExpressionIndex188,
																					expr: &seqExpr{
																						pos: position{line: 2571, col: 24, offset: 88215},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2571, col: 24, offset: 88215},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2595, col: 5, offset: 89231},
																					run: (*parser).callonindexExpressionIndex199,
																					expr: &seqExpr{
																						pos: position{line: 2595, col: 5, offset: 89231},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2595, col: 5, offset: 89231},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2616, col: 5, offset: 90072},
																					run: (*parser).callonindexExpressionIndex206,
																					expr: &seqExpr{
																						pos: position{line: 2616, col: 5, offset: 90072},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2616, col: 5, offset: 90072},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2634, col: 5, offset: 90757},
																					run: (*parser).callonindexExpressionIndex211,
																					expr: &seqExpr{
																						pos: position{line: 2634, col: 5, offset: 90757},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2634, col: 5, offset: 90757},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2634, col: 10, offset: 90762},
																								expr: &charClassMatcher{
																									pos:        position{line: 3797, col: 12, offset: 129189},
																									val:        "[^\\r\\n]",
																									chars:      []rune{'\r', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&litMatcher{
																	pos:        position{line: 2458, col: 74, offset: 83302},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 79, offset: 83307},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonindexExpressionIndex218,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 2174, col: 5, offset: 74378},
									run: (*parser).callonindexExpressionIndex224,
									expr: &seqExpr{
										pos: position{line: 2174, col: 5, offset: 74378},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 2174, col: 5, offset: 74378},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonindexExpressionIndex227,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&notExpr{
												pos: position{line: 2174, col: 14, offset: 74387},
												expr: &choiceExpr{
													pos: position{line: 2170, col: 35, offset: 74240},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 2170, col: 35, offset: 74240},
															val:        "[)}]?,]",
															chars:      []rune{')', '}', ']', '?', ','},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 2170, col: 56, offset: 74261},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2170, col: 56, offset: 74261},
																	val:        ":",
																	ignoreCase: false,
																	want:       "\":\"",
																},
																&notExpr{
																	pos: position{line: 2170, col: 60, offset: 74265},
																	expr: &litMatcher{
																		pos:        position{line: 2170, col: 61, offset: 74266},
																		val:        "=",
																		ignoreCase: false,
																		want:       "\"=\"",
																	},
																},
															},
														},
													},
												},
											},
											&anyMatcher{
												line: 2174, col: 46, offset: 74419,
											},
											&zeroOrMoreExpr{
												pos: position{line: 2174, col: 48, offset: 74421},
												expr: &seqExpr{
													pos: position{line: 2174, col: 49, offset: 74422},
													exprs: []any{
														&notExpr{
															pos: position{line: 2174, col: 49, offset: 74422},
															expr: &choiceExpr{
																pos: position{line: 2170, col: 35, offset: 74240},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 2170, col: 35, offset: 74240},
																		val:        "[)}]?,]",
																		chars:      []rune{')', '}', ']', '?', ','},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 2170, col: 56, offset: 74261},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2170, col: 56, offset: 74261},
																				val:        ":",
																				ignoreCase: false,
																				want:       "\":\"",
																			},
																			&notExpr{
																				pos: position{line: 2170, col: 60, offset: 74265},
																				expr: &litMatcher{
																					pos:        position{line: 2170, col: 61, offset: 74266},
																					val:        "=",
																					ignoreCase: false,
																					want:       "\"=\"",
																				},
																			},
																		},
																	},
																},
															},
														},
														&charClassMatcher{
															pos:        position{line: 2174, col: 81, offset: 74454},
															val:        "[^\\\"`?([{]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineIndexExpression",
			pos:  position{line: 2181, col: 1, offset: 74619},
			expr: &actionExpr{
				pos: position{line: 2181, col: 30, offset: 74648},
				run: (*parser).callonSingleLineIndexExpression1,
				expr: &seqExpr{
					pos: position{line: 2181, col: 30, offset: 74648},
					exprs: []any{
						&actionExpr{
							pos: position{line: 3824, col: 14, offset: 129997},
							run: (*parser).callonSingleLineIndexExpression3,
							expr: &litMatcher{
								pos:        position{line: 3824, col: 14, offset: 129997},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2181, col: 40, offset: 74658},
							expr: &choiceExpr{
								pos: position{line: 3812, col: 20, offset: 129621},
								alternatives: []any{
									&charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
									&seqExpr{
										pos: position{line: 3809, col: 36, offset: 129544},
										exprs: []any{
											&zeroOrOneExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												expr: &litMatcher{
													pos:        position{line: 3809, col: 36, offset: 129544},
													val:        "\r",
													ignoreCase: false,
													want:       "\"\\r\"",
												},
											},
											&litMatcher{
												pos:        position{line: 3809, col: 42, offset: 129550},
												val:        "\n",
												ignoreCase: false,
												want:       "\"\\n\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2181, col: 44, offset: 74662},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 2181, col: 50, offset: 74668},
								name: "singleLineIndexExpressionIndex",
							},
						},
						&labeledExpr{
							pos:   position{line: 2181, col: 81, offset: 74699},
							label: "checkIndexI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2181, col: 93, offset: 74711},
								expr: &litMatcher{
									pos:        position{line: 2181, col: 93, offset: 74711},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2181, col: 98, offset: 74716},
							expr: &seqExpr{
								pos: position{line: 2181, col: 99, offset: 74717},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 2181, col: 99, offset: 74717},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2181, col: 103, offset: 74721},
										expr: &litMatcher{
											pos:        position{line: 2181, col: 103, offset: 74721},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2181, col: 110, offset: 74728},
							expr: &litMatcher{
								pos:        position{line: 2181, col: 110, offset: 74728},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2181, col: 115, offset: 74733},
							label: "rBracePosI",
							expr: &actionExpr{
								pos: position{line: 3825, col: 14, offset: 130037},
								run: (*parser).callonSingleLineIndexExpression25,
								expr: &litMatcher{
									pos:        position{line: 3825, col: 14, offset: 130037},
									val:        "]",
									ignoreCase: false,
									want:       "\"]\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2181, col: 136, offset: 74754},
							label: "checkValueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2181, col: 148, offset: 74766},
								expr: &litMatcher{
									pos:        position{line: 2181, col: 148, offset: 74766},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineIndexExpressionIndex",
			pos:  position{line: 2191, col: 1, offset: 75014},
			expr: &actionExpr{
				pos: position{line: 2191, col: 35, offset: 75048},
				run: (*parser).callonsingleLineIndexExpressionIndex1,
				expr: &labeledExpr{
					pos:   position{line: 2191, col: 35, offset: 75048},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 2191, col: 42, offset: 75055},
						expr: &choiceExpr{
							pos: position{line: 2192, col: 5, offset: 75061},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 2192, col: 5, offset: 75061},
									name: "singleLineGoParenExpr",
								},
								&ruleRefExpr{
									pos:  position{line: 2192, col: 29, offset: 75085},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 2192, col: 48, offset: 75104},
									name: "SingleLineTernaryExpression",
								},
								&actionExpr{
									pos: position{line: 1477, col: 15, offset: 47305},
									run: (*parser).callonsingleLineIndexExpressionIndex8,
									expr: &seqExpr{
										pos: position{line: 1477, col: 15, offset: 47305},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 1477, col: 15, offset: 47305},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonsingleLineIndexExpressionIndex11,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&choiceExpr{
												pos: position{line: 2457, col: 14, offset: 83160},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 2457, col: 14, offset: 83160},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2457, col: 14, offset: 83160},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&choiceExpr{
																pos: position{line: 2457, col: 20, offset: 83166},
																alternatives: []any{
																	&seqExpr{
																		pos: position{line: 2505, col: 19, offset: 85311},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2505, col: 19, offset: 85311},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2506, col: 5, offset: 85370},
																		run: (*parser).callonsingleLineIndexExpressionIndex27,
																		expr: &seqExpr{
																			pos: position{line: 2506, col: 5, offset: 85370},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2506, col: 5, offset: 85370},
																					val:        "\\u",
																					ignoreCase: false,
																					want:       "\"\\\\u\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 14, offset: 85379},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 26, offset: 85391},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 38, offset: 85403},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2506, col: 50, offset: 85415},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2535, col: 16, offset: 86551},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2535, col: 16, offset: 86551},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2536, col: 5, offset: 86654},
																		run: (*parser).callonsingleLineIndexExpressionIndex48,
																		expr: &seqExpr{
																			pos: position{line: 2536, col: 5, offset: 86654},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2536, col: 5, offset: 86654},
																					val:        "\\U",
																					ignoreCase: false,
																					want:       "\"\\\\U\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 14, offset: 86663},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 26, offset: 86675},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 38, offset: 86687},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 50, offset: 86699},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 62, offset: 86711},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 74, offset: 86723},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 86, offset: 86735},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2536, col: 98, offset: 86747},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2570, col: 24, offset: 88132},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2570, col: 24, offset: 88132},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2570, col: 29, offset: 88137},
																				val:        "[abfnrtv\\\\\\]",
																				chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 2484, col: 75, offset: 84423},
																		val:        "[^\\\\\\\\n]",
																		chars:      []rune{'\'', '\\', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																	&seqExpr{
																		pos: position{line: 2486, col: 24, offset: 84569},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2486, col: 24, offset: 84569},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2403, col: 19, offset: 81758},
																				val:        "[0-7]",
																				ranges:     []rune{'0', '7'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&seqExpr{
																		pos: position{line: 2487, col: 24, offset: 84636},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2487, col: 24, offset: 84636},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2404, col: 19, offset: 81782},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2488, col: 5, offset: 84673},
																		run: (*parser).callonsingleLineIndexExpressionIndex80,
																		expr: &seqExpr{
																			pos: position{line: 2488, col: 5, offset: 84673},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2488, col: 5, offset: 84673},
																					val:        "\\x",
																					ignoreCase: false,
																					want:       "\"\\\\x\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 14, offset: 84682},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2488, col: 26, offset: 84694},
																					expr: &charClassMatcher{
																						pos:        position{line: 2404, col: 19, offset: 81782},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2571, col: 24, offset: 88215},
																		run: (*parser).callonsingleLineIndexExpressionIndex87,
																		expr: &seqExpr{
																			pos: position{line: 2571, col: 24, offset: 88215},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2571, col: 24, offset: 88215},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2595, col: 5, offset: 89231},
																		run: (*parser).callonsingleLineIndexExpressionIndex98,
																		expr: &seqExpr{
																			pos: position{line: 2595, col: 5, offset: 89231},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2595, col: 5, offset: 89231},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2616, col: 5, offset: 90072},
																		run: (*parser).callonsingleLineIndexExpressionIndex105,
																		expr: &seqExpr{
																			pos: position{line: 2616, col: 5, offset: 90072},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2616, col: 5, offset: 90072},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2404, col: 19, offset: 81782},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2634, col: 5, offset: 90757},
																		run: (*parser).callonsingleLineIndexExpressionIndex110,
																		expr: &seqExpr{
																			pos: position{line: 2634, col: 5, offset: 90757},
																			exprs: []any{
																				&litMatcher{
																					pos:        position{line: 2634, col: 5, offset: 90757},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 2634, col: 10, offset: 90762},
																					expr: &charClassMatcher{
																						pos:        position{line: 3797, col: 12, offset: 129189},
																						val:        "[^\\r\\n]",
																						chars:      []rune{'\r', '\n'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2457, col: 76, offset: 83222},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
														},
													},
													&actionExpr{
														pos: position{line: 2458, col: 5, offset: 83233},
														run: (*parser).callonsingleLineIndexExpressionIndex116,
														expr: &seqExpr{
															pos: position{line: 2458, col: 5, offset: 83233},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2458, col: 5, offset: 83233},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 10, offset: 83238},
																	label: "valsI",
																	expr: &zeroOrMoreExpr{
																		pos: position{line: 2458, col: 16, offset: 83244},
																		expr: &choiceExpr{
																			pos: position{line: 2458, col: 17, offset: 83245},
																			alternatives: []any{
																				&seqExpr{
																					pos: position{line: 2505, col: 19, offset: 85311},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2505, col: 19, offset: 85311},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2506, col: 5, offset: 85370},
																					run: (*parser).callonsingleLineIndexExpressionIndex128,
																					expr: &seqExpr{
																						pos: position{line: 2506, col: 5, offset: 85370},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2506, col: 5, offset: 85370},
																								val:        "\\u",
																								ignoreCase: false,
																								want:       "\"\\\\u\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 14, offset: 85379},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 26, offset: 85391},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 38, offset: 85403},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2506, col: 50, offset: 85415},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2535, col: 16, offset: 86551},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2535, col: 16, offset: 86551},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2536, col: 5, offset: 86654},
																					run: (*parser).callonsingleLineIndexExpressionIndex149,
																					expr: &seqExpr{
																						pos: position{line: 2536, col: 5, offset: 86654},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2536, col: 5, offset: 86654},
																								val:        "\\U",
																								ignoreCase: false,
																								want:       "\"\\\\U\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 14, offset: 86663},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 26, offset: 86675},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 38, offset: 86687},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 50, offset: 86699},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 62, offset: 86711},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 74, offset: 86723},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 86, offset: 86735},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2536, col: 98, offset: 86747},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2570, col: 24, offset: 88132},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2570, col: 24, offset: 88132},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2570, col: 29, offset: 88137},
																							val:        "[abfnrtv\\\\\\]",
																							chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2484, col: 75, offset: 84423},
																					val:        "[^\\\\\\\\n]",
																					chars:      []rune{'\'', '\\', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																				&seqExpr{
																					pos: position{line: 2486, col: 24, offset: 84569},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2486, col: 24, offset: 84569},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2403, col: 19, offset: 81758},
																							val:        "[0-7]",
																							ranges:     []rune{'0', '7'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&seqExpr{
																					pos: position{line: 2487, col: 24, offset: 84636},
																					exprs: []any{
																						&litMatcher{
																							pos:        position{line: 2487, col: 24, offset: 84636},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2404, col: 19, offset: 81782},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2488, col: 5, offset: 84673},
																					run: (*parser).callonsingleLineIndexExpressionIndex181,
																					expr: &seqExpr{
																						pos: position{line: 2488, col: 5, offset: 84673},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2488, col: 5, offset: 84673},
																								val:        "\\x",
																								ignoreCase: false,
																								want:       "\"\\\\x\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 14, offset: 84682},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2488, col: 26, offset: 84694},
																								expr: &charClassMatcher{
																									pos:        position{line: 2404, col: 19, offset: 81782},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2571, col: 24, offset: 88215},
																					run: (*parser).callonsingleLineIndexExpressionIndex188,
																					expr: &seqExpr{
																						pos: position{line: 2571, col: 24, offset: 88215},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2571, col: 24, offset: 88215},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2595, col: 5, offset: 89231},
																					run: (*parser).callonsingleLineIndexExpressionIndex199,
																					expr: &seqExpr{
																						pos: position{line: 2595, col: 5, offset: 89231},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2595, col: 5, offset: 89231},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2616, col: 5, offset: 90072},
																					run: (*parser).callonsingleLineIndexExpressionIndex206,
																					expr: &seqExpr{
																						pos: position{line: 2616, col: 5, offset: 90072},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2616, col: 5, offset: 90072},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2404, col: 19, offset: 81782},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																				&actionExpr{
																					pos: position{line: 2634, col: 5, offset: 90757},
																					run: (*parser).callonsingleLineIndexExpressionIndex211,
																					expr: &seqExpr{
																						pos: position{line: 2634, col: 5, offset: 90757},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 2634, col: 5, offset: 90757},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&zeroOrOneExpr{
																								pos: position{line: 2634, col: 10, offset: 90762},
																								expr: &charClassMatcher{
																									pos:        position{line: 3797, col: 12, offset: 129189},
																									val:        "[^\\r\\n]",
																									chars:      []rune{'\r', '\n'},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&litMatcher{
																	pos:        position{line: 2458, col: 74, offset: 83302},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&labeledExpr{
																	pos:   position{line: 2458, col: 79, offset: 83307},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonsingleLineIndexExpressionIndex218,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 2193, col: 5, offset: 75151},
									run: (*parser).callonsingleLineIndexExpressionIndex224,
									expr: &seqExpr{
										pos: position{line: 2193, col: 5, offset: 75151},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 2193, col: 5, offset: 75151},
												label: "posI",
												expr: &actionExpr{
													pos: position{line: 3799, col: 8, offset: 129205},
													run: (*parser).callonsingleLineIndexExpressionIndex227,
													expr: &choiceExpr{
														pos: position{line: 3799, col: 9, offset: 129206},
														alternatives: []any{
															&andExpr{
																pos: position{line: 3799, col: 9, offset: 129206},
																expr: &anyMatcher{
																	line: 3799, col: 10, offset: 129207,
																},
															},
															&notExpr{
																pos: position{line: 3799, col: 14, offset: 129211},
																expr: &anyMatcher{
																	line: 3799, col: 15, offset: 129212,
																},
															},
														},
													},
												},
											},
											&notExpr{
												pos: position{line: 2193, col: 14, offset: 75160},
												expr: &choiceExpr{
													pos: position{line: 2170, col: 35, offset: 74240},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 2170, col: 35, offset: 74240},
															val:        "[)}]?,]",
															chars:      []rune{')', '}', ']', '?', ','},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 2170, col: 56, offset: 74261},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2170, col: 56, offset: 74261},
																	val:        ":",
																	ignoreCase: false,
																	want:       "\":\"",
																},
																&notExpr{
																	pos: position{line: 2170, col: 60, offset: 74265},
																	expr: &litMatcher{
																		pos:        position{line: 2170, col: 61, offset: 74266},
																		val:        "=",
																		ignoreCase: false,
																		want:       "\"=\"",
																	},
																},
															},
														},
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 3797, col: 12, offset: 129189},
												val:        "[^\\r\\n]",
												chars:      []rune{'\r', '\n'},
												ignoreCase: false,
												inverted:   true,
											},
											&zeroOrMoreExpr{
												pos: position{line: 2193, col: 54, offset: 75200},
												expr: &seqExpr{
													pos: position{line: 2193, col: 55, offset: 75201},
													exprs: []any{
														&notExpr{
															pos: position{line: 2193, col: 55, offset: 75201},
															expr: &choiceExpr{
																pos: position{line: 2170, col: 35, offset: 74240},
																alternatives: []any{
																	&charClassMatcher{
																		pos:        position{line: 2170, col: 35, offset: 74240},
																		val:        "[)}]?,]",
																		chars:      []rune{')', '}', ']', '?', ','},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 2170, col: 56, offset: 74261},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 2170, col: 56, offset: 74261},
																				val:        ":",
																				ignoreCase: false,
																				want:       "\":\"",
																			},
																			&notExpr{
																				pos: position{line: 2170, col: 60, offset: 74265},
																				expr: &litMatcher{
																					pos:        position{line: 2170, col: 61, offset: 74266},
																					val:        "=",
																					ignoreCase: false,
																					want:       "\"=\"",
																				},
																			},
																		},
																	},
																},
															},
														},
														&notExpr{
															pos: position{line: 2193, col: 87, offset: 75233},
															expr: &seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
														},
														&charClassMatcher{
															pos:        position{line: 2193, col: 92, offset: 75238},
															val:        "[^\\\"`?([{]",
															chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ParenExpression",
			pos:  position{line: 2216, col: 1, offset: 75820},
			expr: &actionExpr{
				pos: position{line: 2216, col: 20, offset: 75839},
				run: (*parser).callonParenExpression1,
				expr: &seqExpr{
					pos: position{line: 2216, col: 20, offset: 75839},
					exprs: []any{
						&actionExpr{
							pos: position{line: 3818, col: 12, offset: 129841},
							run: (*parser).callonParenExpression3,
							expr: &litMatcher{
								pos:        position{line: 3818, col: 12, offset: 129841},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2216, col: 28, offset: 75847},
							expr: &litMatcher{
								pos:        position{line: 2216, col: 28, offset: 75847},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2216, col: 33, offset: 75852},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2216, col: 39, offset: 75858},
								expr: &ruleRefExpr{
									pos:  position{line: 2216, col: 39, offset: 75858},
									name: "parenExpressionArgs",
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2216, col: 60, offset: 75879},
							expr: &litMatcher{
								pos:        position{line: 2216, col: 60, offset: 75879},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2216, col: 65, offset: 75884},
							expr: &seqExpr{
								pos: position{line: 2216, col: 66, offset: 75885},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 2216, col: 66, offset: 75885},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2216, col: 70, offset: 75889},
										expr: &choiceExpr{
											pos: position{line: 3812, col: 20, offset: 129621},
											alternatives: []any{
												&charClassMatcher{
													pos:        position{line: 3808, col: 36, offset: 129503},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
												&seqExpr{
													pos: position{line: 3809, col: 36, offset: 129544},
													exprs: []any{
														&zeroOrOneExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															expr: &litMatcher{
																pos:        position{line: 3809, col: 36, offset: 129544},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3809, col: 42, offset: 129550},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2216, col: 76, offset: 75895},
							label: "rParenPosI",
							expr: &actionExpr{
								pos: position{line: 3819, col: 12, offset: 129879},
								run: (*parser).callonParenExpression23,
								expr: &litMatcher{
									pos:        position{line: 3819, col: 12, offset: 129879},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2216, col: 95, offset: 75914},
							label: "checkI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2216, col: 102, offset: 75921},
								expr: &litMatcher{
									pos:        position{line: 2216, col: 102, offset: 75921},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "parenExpressionArgs",
			pos:  position{line: 2224, col: 1, offset: 76112},
			expr: &actionExpr{
				pos: position{line: 2224, col: 24, offset: 76135},
				run: (*parser).callonparenExpressionArgs1,
				expr: &seqExpr{
					pos: position{line: 2224, col: 24, offset: 76135},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 2224, col: 24, offset: 76135},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 2224, col: 31, offset: 76142},
								name: "GoExpression",
							},
						},
						&labeledExpr{
							pos:   position{line: 2224, col: 44, offset: 76155},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2224, col: 50, offset: 76161},
								expr: &seqExpr{
									pos: position{line: 2224, col: 51, offset: 76162},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 2224, col: 51, offset: 76162},
											expr: &litMatcher{
												pos:        position{line: 2224, col: 51, offset: 76162},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 2224, col: 56, offset: 76167},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2224, col: 60, offset: 76171},
											expr: &choiceExpr{
												pos: position{line: 3812, col: 20, offset: 129621},
												alternatives: []any{
													&charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														exprs: []any{
															&zeroOrOneExpr{
																pos: position{line: 3809, col: 36, offset: 129544},
																expr: &litMatcher{
																	pos:        position{line: 3809, col: 36, offset: 129544},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3809, col: 42, offset: 129550},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2224, col: 64, offset: 76175},
											name: "GoExpression",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineParenExpression",
			pos:  position{line: 2236, col: 1, offset: 76442},
			expr: &actionExpr{
				pos: position{line: 2236, col: 30, offset: 76471},
				run: (*parser).callonSingleLineParenExpression1,
				expr: &seqExpr{
					pos: position{line: 2236, col: 30, offset: 76471},
					exprs: []any{
						&actionExpr{
							pos: position{line: 3818, col: 12, offset: 129841},
							run: (*parser).callonSingleLineParenExpression3,
							expr: &litMatcher{
								pos:        position{line: 3818, col: 12, offset: 129841},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2236, col: 38, offset: 76479},
							expr: &litMatcher{
								pos:        position{line: 2236, col: 38, offset: 76479},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2236, col: 43, offset: 76484},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2236, col: 49, offset: 76490},
								expr: &ruleRefExpr{
									pos:  position{line: 2236, col: 49, offset: 76490},
									name: "singleLinearenExpressionArgs",
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2236, col: 79, offset: 76520},
							expr: &litMatcher{
								pos:        position{line: 2236, col: 79, offset: 76520},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2236, col: 84, offset: 76525},
							expr: &seqExpr{
								pos: position{line: 2236, col: 85, offset: 76526},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 2236, col: 85, offset: 76526},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2236, col: 89, offset: 76530},
										expr: &litMatcher{
											pos:        position{line: 2236, col: 89, offset: 76530},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2236, col: 96, offset: 76537},
							label: "rParenPosI",
							expr: &actionExpr{
								pos: position{line: 3819, col: 12, offset: 129879},
								run: (*parser).callonSingleLineParenExpression18,
								expr: &litMatcher{
									pos:        position{line: 3819, col: 12, offset: 129879},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2236, col: 115, offset: 76556},
							label: "checkI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2236, col: 122, offset: 76563},
								expr: &litMatcher{
									pos:        position{line: 2236, col: 122, offset: 76563},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLinearenExpressionArgs",
			pos:  position{line: 2244, col: 1, offset: 76754},
			expr: &actionExpr{
				pos: position{line: 2244, col: 33, offset: 76786},
				run: (*parser).callonsingleLinearenExpressionArgs1,
				expr: &seqExpr{
					pos: position{line: 2244, col: 33, offset: 76786},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 2244, col: 33, offset: 76786},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 2244, col: 40, offset: 76793},
								name: "SingleLineGoExpression",
							},
						},
						&labeledExpr{
							pos:   position{line: 2244, col: 63, offset: 76816},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2244, col: 69, offset: 76822},
								expr: &seqExpr{
									pos: position{line: 2244, col: 70, offset: 76823},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 2244, col: 70, offset: 76823},
											expr: &litMatcher{
												pos:        position{line: 2244, col: 70, offset: 76823},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 2244, col: 75, offset: 76828},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2244, col: 79, offset: 76832},
											expr: &litMatcher{
												pos:        position{line: 2244, col: 79, offset: 76832},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2244, col: 84, offset: 76837},
											name: "SingleLineGoExpression",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Filter",
			pos:  position{line: 2274, col: 1, offset: 77721},
			expr: &choiceExpr{
				pos: position{line: 2274, col: 11, offset: 77731},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 2274, col: 11, offset: 77731},
						name: "RawFilter",
					},
					&ruleRefExpr{
						pos:  position{line: 2274, col: 23, offset: 77743},
						name: "CommandFilter",
					},
					&ruleRefExpr{
						pos:  position{line: 2274, col: 39, offset: 77759},
						name: "BadFilter",
					},
				},
			},
		},
		{
			name: "RawFilter",
			pos:  position{line: 2280, col: 1, offset: 77955},
			expr: &actionExpr{
				pos: position{line: 2280, col: 14, offset: 77968},
				run: (*parser).callonRawFilter1,
				expr: &seqExpr{
					pos: position{line: 2280, col: 14, offset: 77968},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 2280, col: 14, offset: 77968},
							val:        ":raw",
							ignoreCase: false,
							want:       "\":raw\"",
						},
						&labeledExpr{
							pos:   position{line: 2280, col: 21, offset: 77975},
							label: "typI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2280, col: 26, offset: 77980},
								expr: &seqExpr{
									pos: position{line: 2280, col: 27, offset: 77981},
									exprs: []any{
										&oneOrMoreExpr{
											pos: position{line: 2280, col: 27, offset: 77981},
											expr: &litMatcher{
												pos:        position{line: 2280, col: 27, offset: 77981},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&choiceExpr{
											pos: position{line: 2293, col: 18, offset: 78295},
											alternatives: []any{
												&actionExpr{
													pos: position{line: 2293, col: 18, offset: 78295},
													run: (*parser).callonRawFilter10,
													expr: &choiceExpr{
														pos: position{line: 2293, col: 19, offset: 78296},
														alternatives: []any{
															&litMatcher{
																pos:        position{line: 2293, col: 19, offset: 78296},
																val:        "html",
																ignoreCase: false,
																want:       "\"html\"",
															},
															&litMatcher{
																pos:        position{line: 2293, col: 28, offset: 78305},
																val:        "svg",
																ignoreCase: false,
																want:       "\"svg\"",
															},
															&litMatcher{
																pos:        position{line: 2293, col: 36, offset: 78313},
																val:        "js",
																ignoreCase: false,
																want:       "\"js\"",
															},
															&litMatcher{
																pos:        position{line: 2293, col: 43, offset: 78320},
																val:        "css",
																ignoreCase: false,
																want:       "\"css\"",
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 2295, col: 5, offset: 78384},
													run: (*parser).callonRawFilter16,
													expr: &oneOrMoreExpr{
														pos: position{line: 2295, col: 5, offset: 78384},
														expr: &charClassMatcher{
															pos:        position{line: 3797, col: 12, offset: 129189},
															val:        "[^\\r\\n]",
															chars:      []rune{'\r', '\n'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							expr: &charClassMatcher{
								pos:        position{line: 3808, col: 36, offset: 129503},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3796, col: 16, offset: 129160},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											expr: &litMatcher{
												pos:        position{line: 3796, col: 16, offset: 129160},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3796, col: 22, offset: 129166},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3795, col: 12, offset: 129142},
									expr: &anyMatcher{
										line: 3795, col: 13, offset: 129143,
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2280, col: 52, offset: 78006},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2280, col: 58, offset: 78012},
								expr: &ruleRefExpr{
									pos:  position{line: 2280, col: 58, offset: 78012},
									name: "filterBody",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "CommandFilter",
			pos:  position{line: 2315, col: 1, offset: 79057},
			expr: &actionExpr{
				pos: position{line: 2315, col: 18, offset: 79074},
				run: (*parser).callonCommandFilter1,
				expr: &seqExpr{
					pos: position{line: 2315, col: 18, offset: 79074},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 2315, col: 18, offset: 79074},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&labeledExpr{
							pos:   position{line: 2315, col: 22, offset: 79078},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2315, col: 28, offset: 79084},
								expr: &charClassMatcher{
									pos:        position{line: 2315, col: 28, offset: 79084},
									val:        "[^ \\t\\r\\n]",
									chars:      []rune{' ', '\t', '\r', '\n'},
									ignoreCase: false,
									inverted:   true,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2315, col: 40, offset: 79096},
							label: "argsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2315, col: 46, offset: 79102},
								expr: &seqExpr{
									pos: position{line: 2315, col: 47, offset: 79103},
									exprs: []any{
										&oneOrMoreExpr{
											pos: position{line: 2315, col: 47, offset: 79103},
											expr: &litMatcher{
												pos:        position{line: 2315, col: 47, offset: 79103},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&choiceExpr{
											pos: position{line: 2324, col: 21, offset: 79395},
											alternatives: []any{
												&actionExpr{
													pos: position{line: 2326, col: 27, offset: 79458},
													run: (*parser).callonCommandFilter13,
													expr: &labeledExpr{
														pos:   position{line: 2326, col: 27, offset: 79458},
														label: "stringI",
														expr: &choiceExpr{
															pos: position{line: 822, col: 11, offset: 25102},
															alternatives: []any{
																&actionExpr{
																	pos: position{line: 828, col: 14, offset: 25189},
																	run: (*parser).callonCommandFilter16,
																	expr: &seqExpr{
																		pos: position{line: 828, col: 14, offset: 25189},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 828, col: 14, offset: 25189},
																				val:        "`",
																				ignoreCase: false,
																				want:       "\"`\"",
																			},
																			&labeledExpr{
																				pos:   position{line: 828, col: 18, offset: 25193},
																				label: "strI",
																				expr: &zeroOrMoreExpr{
																					pos: position{line: 828, col: 23, offset: 25198},
																					expr: &charClassMatcher{
																						pos:        position{line: 2747, col: 27, offset: 94906},
																						val:        "[^\\n`]",
																						chars:      []rune{'\n', '`'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 828, col: 47, offset: 25222},
																				val:        "`",
																				ignoreCase: false,
																				want:       "\"`\"",
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 830, col: 5, offset: 25314},
																	run: (*parser).callonCommandFilter23,
																	expr: &seqExpr{
																		pos: position{line: 830, col: 5, offset: 25314},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 830, col: 5, offset: 25314},
																				val:        "`",
																				ignoreCase: false,
																				want:       "\"`\"",
																			},
																			&labeledExpr{
																				pos:   position{line: 830, col: 9, offset: 25318},
																				label: "strI",
																				expr: &zeroOrMoreExpr{
																					pos: position{line: 830, col: 14, offset: 25323},
																					expr: &charClassMatcher{
																						pos:        position{line: 2747, col: 27, offset: 94906},
																						val:        "[^\\n`]",
																						chars:      []rune{'\n', '`'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																			},
																			&andExpr{
																				pos: position{line: 830, col: 38, offset: 25347},
																				expr: &seqExpr{
																					pos: position{line: 3796, col: 12, offset: 129156},
																					exprs: []any{
																						&zeroOrMoreExpr{
																							pos: position{line: 3796, col: 12, offset: 129156},
																							expr: &charClassMatcher{
																								pos:        position{line: 3808, col: 36, offset: 129503},
																								val:        "[ \\t]",
																								chars:      []rune{' ', '\t'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&choiceExpr{
																							pos: position{line: 3796, col: 16, offset: 129160},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 3796, col: 16, offset: 129160},
																									exprs: []any{
																										&zeroOrOneExpr{
																											pos: position{line: 3796, col: 16, offset: 129160},
																											expr: &litMatcher{
																												pos:        position{line: 3796, col: 16, offset: 129160},
																												val:        "\r",
																												ignoreCase: false,
																												want:       "\"\\r\"",
																											},
																										},
																										&litMatcher{
																											pos:        position{line: 3796, col: 22, offset: 129166},
																											val:        "\n",
																											ignoreCase: false,
																											want:       "\"\\n\"",
																										},
																									},
																								},
																								&notExpr{
																									pos: position{line: 3795, col: 12, offset: 129142},
																									expr: &anyMatcher{
																										line: 3795, col: 13, offset: 129143,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 849, col: 22, offset: 25751},
																	run: (*parser).callonCommandFilter40,
																	expr: &seqExpr{
																		pos: position{line: 849, col: 22, offset: 25751},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 849, col: 22, offset: 25751},
																				val:        "\"",
																				ignoreCase: false,
																				want:       "\"\\\"\"",
																			},
																			&labeledExpr{
																				pos:   position{line: 849, col: 26, offset: 25755},
																				label: "strI",
																				expr: &zeroOrMoreExpr{
																					pos: position{line: 849, col: 31, offset: 25760},
																					expr: &choiceExpr{
																						pos: position{line: 849, col: 32, offset: 25761},
																						alternatives: []any{
																							&seqExpr{
																								pos: position{line: 2486, col: 24, offset: 84569},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2486, col: 24, offset: 84569},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2403, col: 19, offset: 81758},
																										val:        "[0-7]",
																										ranges:     []rune{'0', '7'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2403, col: 19, offset: 81758},
																										val:        "[0-7]",
																										ranges:     []rune{'0', '7'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2403, col: 19, offset: 81758},
																										val:        "[0-7]",
																										ranges:     []rune{'0', '7'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&seqExpr{
																								pos: position{line: 2487, col: 24, offset: 84636},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2487, col: 24, offset: 84636},
																										val:        "\\x",
																										ignoreCase: false,
																										want:       "\"\\\\x\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2488, col: 5, offset: 84673},
																								run: (*parser).callonCommandFilter55,
																								expr: &seqExpr{
																									pos: position{line: 2488, col: 5, offset: 84673},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2488, col: 5, offset: 84673},
																											val:        "\\x",
																											ignoreCase: false,
																											want:       "\"\\\\x\"",
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2488, col: 14, offset: 84682},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2488, col: 26, offset: 84694},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																							},
																							&seqExpr{
																								pos: position{line: 2505, col: 19, offset: 85311},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2505, col: 19, offset: 85311},
																										val:        "\\u",
																										ignoreCase: false,
																										want:       "\"\\\\u\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2506, col: 5, offset: 85370},
																								run: (*parser).callonCommandFilter68,
																								expr: &seqExpr{
																									pos: position{line: 2506, col: 5, offset: 85370},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2506, col: 5, offset: 85370},
																											val:        "\\u",
																											ignoreCase: false,
																											want:       "\"\\\\u\"",
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2506, col: 14, offset: 85379},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2506, col: 26, offset: 85391},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2506, col: 38, offset: 85403},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2506, col: 50, offset: 85415},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																							},
																							&seqExpr{
																								pos: position{line: 2535, col: 16, offset: 86551},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2535, col: 16, offset: 86551},
																										val:        "\\U",
																										ignoreCase: false,
																										want:       "\"\\\\U\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2536, col: 5, offset: 86654},
																								run: (*parser).callonCommandFilter89,
																								expr: &seqExpr{
																									pos: position{line: 2536, col: 5, offset: 86654},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2536, col: 5, offset: 86654},
																											val:        "\\U",
																											ignoreCase: false,
																											want:       "\"\\\\U\"",
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 14, offset: 86663},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 26, offset: 86675},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 38, offset: 86687},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 50, offset: 86699},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 62, offset: 86711},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 74, offset: 86723},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 86, offset: 86735},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 98, offset: 86747},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																							},
																							&seqExpr{
																								pos: position{line: 2763, col: 36, offset: 95684},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2763, col: 36, offset: 95684},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2763, col: 41, offset: 95689},
																										val:        "[abfnrtv\\\\\"]",
																										chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&charClassMatcher{
																								pos:        position{line: 2761, col: 38, offset: 95576},
																								val:        "[^\"\\\\\\n]",
																								chars:      []rune{'"', '\\', '\n'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																							&actionExpr{
																								pos: position{line: 2650, col: 37, offset: 91334},
																								run: (*parser).callonCommandFilter112,
																								expr: &seqExpr{
																									pos: position{line: 2650, col: 37, offset: 91334},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2650, col: 37, offset: 91334},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2674, col: 5, offset: 92351},
																								run: (*parser).callonCommandFilter123,
																								expr: &seqExpr{
																									pos: position{line: 2674, col: 5, offset: 92351},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2674, col: 5, offset: 92351},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2695, col: 5, offset: 93193},
																								run: (*parser).callonCommandFilter130,
																								expr: &seqExpr{
																									pos: position{line: 2695, col: 5, offset: 93193},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2695, col: 5, offset: 93193},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2713, col: 5, offset: 93879},
																								run: (*parser).callonCommandFilter135,
																								expr: &seqExpr{
																									pos: position{line: 2713, col: 5, offset: 93879},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2713, col: 5, offset: 93879},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2713, col: 10, offset: 93884},
																											expr: &charClassMatcher{
																												pos:        position{line: 3797, col: 12, offset: 129189},
																												val:        "[^\\r\\n]",
																												chars:      []rune{'\r', '\n'},
																												ignoreCase: false,
																												inverted:   true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 849, col: 115, offset: 25844},
																				val:        "\"",
																				ignoreCase: false,
																				want:       "\"\\\"\"",
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 851, col: 5, offset: 25936},
																	run: (*parser).callonCommandFilter141,
																	expr: &seqExpr{
																		pos: position{line: 851, col: 5, offset: 25936},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 851, col: 5, offset: 25936},
																				val:        "\"",
																				ignoreCase: false,
																				want:       "\"\\\"\"",
																			},
																			&labeledExpr{
																				pos:   position{line: 851, col: 9, offset: 25940},
																				label: "strI",
																				expr: &zeroOrMoreExpr{
																					pos: position{line: 851, col: 14, offset: 25945},
																					expr: &choiceExpr{
																						pos: position{line: 851, col: 15, offset: 25946},
																						alternatives: []any{
																							&seqExpr{
																								pos: position{line: 2486, col: 24, offset: 84569},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2486, col: 24, offset: 84569},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2403, col: 19, offset: 81758},
																										val:        "[0-7]",
																										ranges:     []rune{'0', '7'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2403, col: 19, offset: 81758},
																										val:        "[0-7]",
																										ranges:     []rune{'0', '7'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2403, col: 19, offset: 81758},
																										val:        "[0-7]",
																										ranges:     []rune{'0', '7'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&seqExpr{
																								pos: position{line: 2487, col: 24, offset: 84636},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2487, col: 24, offset: 84636},
																										val:        "\\x",
																										ignoreCase: false,
																										want:       "\"\\\\x\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2488, col: 5, offset: 84673},
																								run: (*parser).callonCommandFilter156,
																								expr: &seqExpr{
																									pos: position{line: 2488, col: 5, offset: 84673},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2488, col: 5, offset: 84673},
																											val:        "\\x",
																											ignoreCase: false,
																											want:       "\"\\\\x\"",
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2488, col: 14, offset: 84682},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2488, col: 26, offset: 84694},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																							},
																							&seqExpr{
																								pos: position{line: 2505, col: 19, offset: 85311},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2505, col: 19, offset: 85311},
																										val:        "\\u",
																										ignoreCase: false,
																										want:       "\"\\\\u\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2506, col: 5, offset: 85370},
																								run: (*parser).callonCommandFilter169,
																								expr: &seqExpr{
																									pos: position{line: 2506, col: 5, offset: 85370},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2506, col: 5, offset: 85370},
																											val:        "\\u",
																											ignoreCase: false,
																											want:       "\"\\\\u\"",
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2506, col: 14, offset: 85379},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2506, col: 26, offset: 85391},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2506, col: 38, offset: 85403},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2506, col: 50, offset: 85415},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																							},
																							&seqExpr{
																								pos: position{line: 2535, col: 16, offset: 86551},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2535, col: 16, offset: 86551},
																										val:        "\\U",
																										ignoreCase: false,
																										want:       "\"\\\\U\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2404, col: 19, offset: 81782},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2536, col: 5, offset: 86654},
																								run: (*parser).callonCommandFilter190,
																								expr: &seqExpr{
																									pos: position{line: 2536, col: 5, offset: 86654},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2536, col: 5, offset: 86654},
																											val:        "\\U",
																											ignoreCase: false,
																											want:       "\"\\\\U\"",
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 14, offset: 86663},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 26, offset: 86675},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 38, offset: 86687},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 50, offset: 86699},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 62, offset: 86711},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 74, offset: 86723},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 86, offset: 86735},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2536, col: 98, offset: 86747},
																											expr: &charClassMatcher{
																												pos:        position{line: 2404, col: 19, offset: 81782},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																							},
																							&seqExpr{
																								pos: position{line: 2763, col: 36, offset: 95684},
																								exprs: []any{
																									&litMatcher{
																										pos:        position{line: 2763, col: 36, offset: 95684},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2763, col: 41, offset: 95689},
																										val:        "[abfnrtv\\\\\"]",
																										chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&charClassMatcher{
																								pos:        position{line: 2761, col: 38, offset: 95576},
																								val:        "[^\"\\\\\\n]",
																								chars:      []rune{'"', '\\', '\n'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																							&actionExpr{
																								pos: position{line: 2650, col: 37, offset: 91334},
																								run: (*parser).callonCommandFilter213,
																								expr: &seqExpr{
																									pos: position{line: 2650, col: 37, offset: 91334},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2650, col: 37, offset: 91334},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2674, col: 5, offset: 92351},
																								run: (*parser).callonCommandFilter224,
																								expr: &seqExpr{
																									pos: position{line: 2674, col: 5, offset: 92351},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2674, col: 5, offset: 92351},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2695, col: 5, offset: 93193},
																								run: (*parser).callonCommandFilter231,
																								expr: &seqExpr{
																									pos: position{line: 2695, col: 5, offset: 93193},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2695, col: 5, offset: 93193},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2404, col: 19, offset: 81782},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 2713, col: 5, offset: 93879},
																								run: (*parser).callonCommandFilter236,
																								expr: &seqExpr{
																									pos: position{line: 2713, col: 5, offset: 93879},
																									exprs: []any{
																										&litMatcher{
																											pos:        position{line: 2713, col: 5, offset: 93879},
																											val:        "\\",
																											ignoreCase: false,
																											want:       "\"\\\\\"",
																										},
																										&zeroOrOneExpr{
																											pos: position{line: 2713, col: 10, offset: 93884},
																											expr: &charClassMatcher{
																												pos:        position{line: 3797, col: 12, offset: 129189},
																												val:        "[^\\r\\n]",
																												chars:      []rune{'\r', '\n'},
																												ignoreCase: false,
																												inverted:   true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&labeledExpr{
																				pos:   position{line: 851, col: 98, offset: 26029},
																				label: "endPosI",
																				expr: &actionExpr{
																					pos: position{line: 3799, col: 8, offset: 129205},
																					run: (*parser).callonCommandFilter242,
																					expr: &choiceExpr{
																						pos: position{line: 3799, col: 9, offset: 129206},
																						alternatives: []any{
																							&andExpr{
																								pos: position{line: 3799, col: 9, offset: 129206},
																								expr: &anyMatcher{
																									line: 3799, col: 10, offset: 129207,
																								},
																							},
																							&notExpr{
																								pos: position{line: 3799, col: 14, offset: 129211},
																								expr: &anyMatcher{
																									line: 3799, col: 15, offset: 129212,
																								},
																							},
																						},
																					},
																				},
																			},
																			&andExpr{
																				pos: position{line: 851, col: 110, offset: 26041},
																				expr: &seqExpr{
																					pos: position{line: 3796, col: 12, offset: 129156},
																					exprs: []any{
																						&zeroOrMoreExpr{
																							pos: position{line: 3796, col: 12, offset: 129156},
																							expr: &charClassMatcher{
																								pos:        position{line: 3808, col: 36, offset: 129503},
																								val:        "[ \\t]",
																								chars:      []rune{' ', '\t'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&choiceExpr{
																							pos: position{line: 3796, col: 16, offset: 129160},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 3796, col: 16, offset: 129160},
																									exprs: []any{
																										&zeroOrOneExpr{
																											pos: position{line: 3796, col: 16, offset: 129160},
																											expr: &litMatcher{
																												pos:        position{line: 3796, col: 16, offset: 129160},
																												val:        "\r",
																												ignoreCase: false,
																												want:       "\"\\r\"",
																											},
																										},
																										&litMatcher{
																											pos:        position{line: 3796, col: 22, offset: 129166},
																											val:        "\n",
																											ignoreCase: false,
																											want:       "\"\\n\"",
																										},
																									},
																								},
																								&notExpr{
																									pos: position{line: 3795, col: 12, offset: 129142},
																									expr: &anyMatcher{
																										line: 3795, col: 13, offset: 129143,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 870, col: 22, offset: 26447},
																	run: (*parser).callonCommandFilter259,
																	expr: &seqExpr{
																		pos: position{line: 870, col: 22, offset: 26447},
																		exprs: []any{
																			&litMatcher{
																				pos:        position{line: 870, col: 22, offset: 26447},
																				val:        "'",
																				ignoreCase: false,
																				want:       "\"'\"",
																			},
																			&labeledExpr{
																				pos:   position{line: 870, col: 27, offset: 26452},
																				label: "strI",
																				expr: &zeroOrMoreExpr{
																					pos: position{line: 870, col: 32, offset: 26457},
																					expr: &charClassMatcher{
																						pos:        position{line: 870, col: 32, offset: 26457},
																						val:        "[^\\\\r\\n]",
																						chars:      []rune{'\'', '\r', '\n'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 870, col: 42, offset: 26467},
																				val:        "'",
																				ignoreCase: false,
																				want:       "\"'\"",
																			},
																			&labeledExpr{
																				pos:   position{line: 870, col: 47, offset: 26472},
																				label: "endPosI",
																				expr: &actionExpr{
																					pos: position{line: 3799, col: 8, offset: 129205},
																					run: (*parser).callonCommandFilter267,
																					expr: &choiceExpr{
																						pos: position{line: 3799, col: 9, offset: 129206},
																						alternatives: []any{
																							&andExpr{
																								pos: position{line: 3799, col: 9, offset: 129206},
																								expr: &anyMatcher{
																									line: 3799, col: 10, offset: 129207,
																								},
																							},
																							&notExpr{
																								pos: position{line: 3799, col: 14, offset: 129211},
																								expr: &anyMatcher{
																									line: 3799, col: 15, offset: 129212,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 2330, col: 15, offset: 79559},
													run: (*parser).callonCommandFilter273,
													expr: &labeledExpr{
														pos:   position{line: 2330, col: 15, offset: 79559},
														label: "argI",
														expr: &oneOrMoreExpr{
															pos: position{line: 2330, col: 20, offset: 79564},
															expr: &charClassMatcher{
																pos:        position{line: 2330, col: 20, offset: 79564},
																val:        "[^ \\t\\r\\n]",
																chars:      []rune{' ', '\t', '\r', '\n'},
																ignoreCase: false,
																inverted:   true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							expr: &charClassMatcher{
								pos:        position{line: 3808, col: 36, offset: 129503},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3796, col: 16, offset: 129160},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											expr: &litMatcher{
												pos:        position{line: 3796, col: 16, offset: 129160},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3796, col: 22, offset: 129166},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3795, col: 12, offset: 129142},
									expr: &anyMatcher{
										line: 3795, col: 13, offset: 129143,
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2315, col: 75, offset: 79131},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2315, col: 81, offset: 79137},
								expr: &ruleRefExpr{
									pos:  position{line: 2315, col: 81, offset: 79137},
									name: "filterBody",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BadFilter",
			pos:  position{line: 2338, col: 1, offset: 79846},
			expr: &actionExpr{
				pos: position{line: 2338, col: 14, offset: 79859},
				run: (*parser).callonBadFilter1,
				expr: &seqExpr{
					pos: position{line: 2338, col: 14, offset: 79859},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 2338, col: 14, offset: 79859},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							expr: &charClassMatcher{
								pos:        position{line: 3808, col: 36, offset: 129503},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3796, col: 16, offset: 129160},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											expr: &litMatcher{
												pos:        position{line: 3796, col: 16, offset: 129160},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3796, col: 22, offset: 129166},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3795, col: 12, offset: 129142},
									expr: &anyMatcher{
										line: 3795, col: 13, offset: 129143,
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2338, col: 22, offset: 79867},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2338, col: 28, offset: 79873},
								expr: &ruleRefExpr{
									pos:  position{line: 2338, col: 28, offset: 79873},
									name: "filterBody",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "filterBody",
			pos:  position{line: 2356, col: 1, offset: 80414},
			expr: &actionExpr{
				pos: position{line: 2356, col: 15, offset: 80428},
				run: (*parser).callonfilterBody1,
				expr: &seqExpr{
					pos: position{line: 2356, col: 15, offset: 80428},
					exprs: []any{
						&stateCodeExpr{
							pos: position{line: 4284, col: 11, offset: 150129},
							run: (*parser).callonfilterBody3,
						},
						&labeledExpr{
							pos:   position{line: 2356, col: 22, offset: 80435},
							label: "linesI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2356, col: 29, offset: 80442},
								expr: &seqExpr{
									pos: position{line: 2356, col: 30, offset: 80443},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 2356, col: 30, offset: 80443},
											expr: &oneOrMoreExpr{
												pos: position{line: 3810, col: 36, offset: 129590},
												expr: &seqExpr{
													pos: position{line: 3810, col: 37, offset: 129591},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 3810, col: 37, offset: 129591},
															expr: &charClassMatcher{
																pos:        position{line: 3808, col: 36, offset: 129503},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&zeroOrOneExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															expr: &litMatcher{
																pos:        position{line: 3809, col: 36, offset: 129544},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3809, col: 42, offset: 129550},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2356, col: 39, offset: 80452},
											name: "filterLine",
										},
									},
								},
							},
						},
						&stateCodeExpr{
							pos: position{line: 4289, col: 11, offset: 150234},
							run: (*parser).callonfilterBody16,
						},
					},
				},
			},
		},
		{
			name: "filterLine",
			pos:  position{line: 2360, col: 1, offset: 80543},
			expr: &actionExpr{
				pos: position{line: 2360, col: 15, offset: 80557},
				run: (*parser).callonfilterLine1,
				expr: &seqExpr{
					pos: position{line: 2360, col: 15, offset: 80557},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 2360, col: 15, offset: 80557},
							name: "INDENTATION_IGNORE_ADDITIONAL",
						},
						&labeledExpr{
							pos:   position{line: 2360, col: 45, offset: 80587},
							label: "posI",
							expr: &actionExpr{
								pos: position{line: 3799, col: 8, offset: 129205},
								run: (*parser).callonfilterLine5,
								expr: &choiceExpr{
									pos: position{line: 3799, col: 9, offset: 129206},
									alternatives: []any{
										&andExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											expr: &anyMatcher{
												line: 3799, col: 10, offset: 129207,
											},
										},
										&notExpr{
											pos: position{line: 3799, col: 14, offset: 129211},
											expr: &anyMatcher{
												line: 3799, col: 15, offset: 129212,
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2360, col: 54, offset: 80596},
							label: "lineI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2360, col: 60, offset: 80602},
								expr: &charClassMatcher{
									pos:        position{line: 3797, col: 12, offset: 129189},
									val:        "[^\\r\\n]",
									chars:      []rune{'\r', '\n'},
									ignoreCase: false,
									inverted:   true,
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							expr: &charClassMatcher{
								pos:        position{line: 3808, col: 36, offset: 129503},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3796, col: 16, offset: 129160},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											expr: &litMatcher{
												pos:        position{line: 3796, col: 16, offset: 129160},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3796, col: 22, offset: 129166},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3795, col: 12, offset: 129142},
									expr: &anyMatcher{
										line: 3795, col: 13, offset: 129143,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "GoType",
			pos:  position{line: 2379, col: 1, offset: 81181},
			expr: &actionExpr{
				pos: position{line: 2379, col: 11, offset: 81191},
				run: (*parser).callonGoType1,
				expr: &labeledExpr{
					pos:   position{line: 2379, col: 11, offset: 81191},
					label: "goTypeI",
					expr: &ruleRefExpr{
						pos:  position{line: 2379, col: 19, offset: 81199},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goType",
			pos:  position{line: 2769, col: 1, offset: 95761},
			expr: &choiceExpr{
				pos: position{line: 2769, col: 15, offset: 95775},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 2769, col: 16, offset: 95776},
						exprs: []any{
							&choiceExpr{
								pos: position{line: 2770, col: 15, offset: 95860},
								alternatives: []any{
									&seqExpr{
										pos: position{line: 2427, col: 21, offset: 82385},
										exprs: []any{
											&charClassMatcher{
												pos:        position{line: 2393, col: 20, offset: 81588},
												val:        "[_\\pL]",
												chars:      []rune{'_'},
												classes:    []*unicode.RangeTable{rangeTable("L")},
												ignoreCase: false,
												inverted:   false,
											},
											&zeroOrMoreExpr{
												pos: position{line: 2410, col: 26, offset: 81842},
												expr: &charClassMatcher{
													pos:        position{line: 2393, col: 20, offset: 81588},
													val:        "[_\\pL\\pNd]",
													chars:      []rune{'_'},
													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&zeroOrMoreExpr{
												pos: position{line: 2427, col: 35, offset: 82399},
												expr: &litMatcher{
													pos:        position{line: 2427, col: 35, offset: 82399},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 2427, col: 40, offset: 82404},
												val:        ".",
												ignoreCase: false,
												want:       "\".\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2427, col: 44, offset: 82408},
												expr: &litMatcher{
													pos:        position{line: 2427, col: 44, offset: 82408},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&charClassMatcher{
												pos:        position{line: 2393, col: 20, offset: 81588},
												val:        "[_\\pL]",
												chars:      []rune{'_'},
												classes:    []*unicode.RangeTable{rangeTable("L")},
												ignoreCase: false,
												inverted:   false,
											},
											&zeroOrMoreExpr{
												pos: position{line: 2410, col: 26, offset: 81842},
												expr: &charClassMatcher{
													pos:        position{line: 2393, col: 20, offset: 81588},
													val:        "[_\\pL\\pNd]",
													chars:      []rune{'_'},
													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
									&seqExpr{
										pos: position{line: 2410, col: 17, offset: 81833},
										exprs: []any{
											&charClassMatcher{
												pos:        position{line: 2393, col: 20, offset: 81588},
												val:        "[_\\pL]",
												chars:      []rune{'_'},
												classes:    []*unicode.RangeTable{rangeTable("L")},
												ignoreCase: false,
												inverted:   false,
											},
											&zeroOrMoreExpr{
												pos: position{line: 2410, col: 26, offset: 81842},
												expr: &charClassMatcher{
													pos:        position{line: 2393, col: 20, offset: 81588},
													val:        "[_\\pL\\pNd]",
													chars:      []rune{'_'},
													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
								},
							},
							&zeroOrOneExpr{
								pos: position{line: 2769, col: 27, offset: 95787},
								expr: &seqExpr{
									pos: position{line: 2769, col: 28, offset: 95788},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 2769, col: 28, offset: 95788},
											expr: &litMatcher{
												pos:        position{line: 2769, col: 28, offset: 95788},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2769, col: 33, offset: 95793},
											name: "goTypeArgs",
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2769, col: 49, offset: 95809},
						name: "goTypeLit",
					},
					&seqExpr{
						pos: position{line: 2769, col: 61, offset: 95821},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 2769, col: 61, offset: 95821},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
							&zeroOrMoreExpr{
								pos: position{line: 2769, col: 65, offset: 95825},
								expr: &litMatcher{
									pos:        position{line: 2769, col: 65, offset: 95825},
									val:        " ",
									ignoreCase: false,
									want:       "\" \"",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 2769, col: 70, offset: 95830},
								name: "goType",
							},
							&zeroOrMoreExpr{
								pos: position{line: 2769, col: 77, offset: 95837},
								expr: &litMatcher{
									pos:        position{line: 2769, col: 77, offset: 95837},
									val:        " ",
									ignoreCase: false,
									want:       "\" \"",
								},
							},
							&litMatcher{
								pos:        position{line: 2769, col: 82, offset: 95842},
								val:        ")",
								ignoreCase: false,
								want:       "\")\"",
							},
						},
					},
				},
			},
		},
		{
			name: "goTypeArgs",
			pos:  position{line: 2771, col: 1, offset: 95892},
			expr: &seqExpr{
				pos: position{line: 2771, col: 15, offset: 95906},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 2771, col: 15, offset: 95906},
						val:        "[",
						ignoreCase: false,
						want:       "\"[\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2771, col: 19, offset: 95910},
						expr: &litMatcher{
							pos:        position{line: 2771, col: 19, offset: 95910},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2771, col: 24, offset: 95915},
						name: "goTypeList",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2771, col: 35, offset: 95926},
						expr: &litMatcher{
							pos:        position{line: 2771, col: 35, offset: 95926},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2771, col: 40, offset: 95931},
						expr: &seqExpr{
							pos: position{line: 2771, col: 41, offset: 95932},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2771, col: 41, offset: 95932},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2771, col: 45, offset: 95936},
									expr: &litMatcher{
										pos:        position{line: 2771, col: 45, offset: 95936},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2771, col: 52, offset: 95943},
						val:        "]",
						ignoreCase: false,
						want:       "\"]\"",
					},
				},
			},
		},
		{
			name: "goTypeList",
			pos:  position{line: 2772, col: 1, offset: 95947},
			expr: &seqExpr{
				pos: position{line: 2772, col: 15, offset: 95961},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 2772, col: 15, offset: 95961},
						name: "goType",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2772, col: 22, offset: 95968},
						expr: &litMatcher{
							pos:        position{line: 2772, col: 22, offset: 95968},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2772, col: 27, offset: 95973},
						expr: &seqExpr{
							pos: position{line: 2772, col: 28, offset: 95974},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2772, col: 28, offset: 95974},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2772, col: 32, offset: 95978},
									expr: &litMatcher{
										pos:        position{line: 2772, col: 32, offset: 95978},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2772, col: 37, offset: 95983},
									name: "goType",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goTypeLit",
			pos:  position{line: 2773, col: 1, offset: 95992},
			expr: &choiceExpr{
				pos: position{line: 2773, col: 16, offset: 96007},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 2773, col: 16, offset: 96007},
						name: "goArrayType",
					},
					&ruleRefExpr{
						pos:  position{line: 2773, col: 30, offset: 96021},
						name: "goStructType",
					},
					&ruleRefExpr{
						pos:  position{line: 2773, col: 45, offset: 96036},
						name: "goPointerType",
					},
					&ruleRefExpr{
						pos:  position{line: 2773, col: 61, offset: 96052},
						name: "goFunctionType",
					},
					&ruleRefExpr{
						pos:  position{line: 2773, col: 78, offset: 96069},
						name: "goInterfaceType",
					},
					&ruleRefExpr{
						pos:  position{line: 2773, col: 96, offset: 96087},
						name: "goSliceType",
					},
					&ruleRefExpr{
						pos:  position{line: 2773, col: 110, offset: 96101},
						name: "goMapType",
					},
					&ruleRefExpr{
						pos:  position{line: 2773, col: 122, offset: 96113},
						name: "goChannelType",
					},
				},
			},
		},
		{
			name: "goArrayType",
			pos:  position{line: 2779, col: 1, offset: 96151},
			expr: &seqExpr{
				pos: position{line: 2779, col: 18, offset: 96168},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 2779, col: 18, offset: 96168},
						val:        "[",
						ignoreCase: false,
						want:       "\"[\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2779, col: 22, offset: 96172},
						expr: &litMatcher{
							pos:        position{line: 2779, col: 22, offset: 96172},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2779, col: 27, offset: 96177},
						name: "goArrayLength",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2779, col: 41, offset: 96191},
						expr: &litMatcher{
							pos:        position{line: 2779, col: 41, offset: 96191},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2779, col: 46, offset: 96196},
						val:        "]",
						ignoreCase: false,
						want:       "\"]\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2779, col: 50, offset: 96200},
						expr: &litMatcher{
							pos:        position{line: 2779, col: 50, offset: 96200},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2779, col: 55, offset: 96205},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "goArrayLength",
			pos:  position{line: 2780, col: 1, offset: 96219},
			expr: &seqExpr{
				pos: position{line: 2780, col: 18, offset: 96236},
				exprs: []any{
					&oneOrMoreExpr{
						pos: position{line: 2780, col: 18, offset: 96236},
						expr: &charClassMatcher{
							pos:        position{line: 2780, col: 18, offset: 96236},
							val:        "[0-9]",
							ranges:     []rune{'0', '9'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2780, col: 25, offset: 96243},
						expr: &seqExpr{
							pos: position{line: 2780, col: 26, offset: 96244},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 2780, col: 26, offset: 96244},
									expr: &litMatcher{
										pos:        position{line: 2780, col: 26, offset: 96244},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&choiceExpr{
									pos: position{line: 2780, col: 32, offset: 96250},
									alternatives: []any{
										&litMatcher{
											pos:        position{line: 2780, col: 32, offset: 96250},
											val:        "<<",
											ignoreCase: false,
											want:       "\"<<\"",
										},
										&litMatcher{
											pos:        position{line: 2780, col: 39, offset: 96257},
											val:        ">>",
											ignoreCase: false,
											want:       "\">>\"",
										},
										&charClassMatcher{
											pos:        position{line: 2780, col: 46, offset: 96264},
											val:        "[+-*/]",
											chars:      []rune{'+', '-', '*', '/'},
											ignoreCase: false,
											inverted:   false,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2780, col: 69, offset: 96287},
									expr: &litMatcher{
										pos:        position{line: 2780, col: 69, offset: 96287},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2780, col: 74, offset: 96292},
									name: "goArrayLength",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goElementType",
			pos:  position{line: 2781, col: 1, offset: 96389},
			expr: &ruleRefExpr{
				pos:  position{line: 2781, col: 18, offset: 96406},
				name: "goType",
			},
		},
		{
			name: "goSliceType",
			pos:  position{line: 2787, col: 1, offset: 96436},
			expr: &seqExpr{
				pos: position{line: 2787, col: 16, offset: 96451},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 2787, col: 16, offset: 96451},
						val:        "[]",
						ignoreCase: false,
						want:       "\"[]\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2787, col: 21, offset: 96456},
						expr: &litMatcher{
							pos:        position{line: 2787, col: 21, offset: 96456},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2787, col: 26, offset: 96461},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "goStructType",
			pos:  position{line: 2793, col: 1, offset: 96499},
			expr: &seqExpr{
				pos: position{line: 2793, col: 20, offset: 96518},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 2793, col: 20, offset: 96518},
						val:        "struct",
						ignoreCase: false,
						want:       "\"struct\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2793, col: 29, offset: 96527},
						expr: &litMatcher{
							pos:        position{line: 2793, col: 29, offset: 96527},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2793, col: 34, offset: 96532},
						val:        "{",
						ignoreCase: false,
						want:       "\"{\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2793, col: 38, offset: 96536},
						expr: &seqExpr{
							pos: position{line: 2793, col: 39, offset: 96537},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 2793, col: 39, offset: 96537},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2793, col: 43, offset: 96541},
									expr: &ruleRefExpr{
										pos:  position{line: 2793, col: 43, offset: 96541},
										name: "goFieldDecl",
									},
								},
								&choiceExpr{
									pos: position{line: 2793, col: 57, offset: 96555},
									alternatives: []any{
										&litMatcher{
											pos:        position{line: 2793, col: 57, offset: 96555},
											val:        ";",
											ignoreCase: false,
											want:       "\";\"",
										},
										&seqExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3809, col: 36, offset: 129544},
													expr: &litMatcher{
														pos:        position{line: 3809, col: 36, offset: 129544},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3809, col: 42, offset: 129550},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
							},
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2793, col: 71, offset: 96569},
						expr: &choiceExpr{
							pos: position{line: 3812, col: 20, offset: 129621},
							alternatives: []any{
								&charClassMatcher{
									pos:        position{line: 3808, col: 36, offset: 129503},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
								&seqExpr{
									pos: position{line: 3809, col: 36, offset: 129544},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2793, col: 75, offset: 96573},
						val:        "}",
						ignoreCase: false,
						want:       "\"}\"",
					},
				},
			},
		},
		{
			name: "goFieldDecl",
			pos:  position{line: 2794, col: 1, offset: 96577},
			expr: &seqExpr{
				pos: position{line: 2794, col: 20, offset: 96596},
				exprs: []any{
					&choiceExpr{
						pos: position{line: 2794, col: 21, offset: 96597},
						alternatives: []any{
							&seqExpr{
								pos: position{line: 2794, col: 21, offset: 96597},
								exprs: []any{
									&charClassMatcher{
										pos:        position{line: 2393, col: 20, offset: 81588},
										val:        "[_\\pL]",
										chars:      []rune{'_'},
										classes:    []*unicode.RangeTable{rangeTable("L")},
										ignoreCase: false,
										inverted:   false,
									},
									&zeroOrMoreExpr{
										pos: position{line: 2410, col: 26, offset: 81842},
										expr: &charClassMatcher{
											pos:        position{line: 2393, col: 20, offset: 81588},
											val:        "[_\\pL\\pNd]",
											chars:      []rune{'_'},
											classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
											ignoreCase: false,
											inverted:   false,
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 2845, col: 34, offset: 97828},
										expr: &litMatcher{
											pos:        position{line: 2845, col: 34, offset: 97828},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 2845, col: 39, offset: 97833},
										expr: &seqExpr{
											pos: position{line: 2845, col: 40, offset: 97834},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 2845, col: 40, offset: 97834},
													val:        ",",
													ignoreCase: false,
													want:       "\",\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 2845, col: 44, offset: 97838},
													expr: &choiceExpr{
														pos: position{line: 3812, col: 20, offset: 129621},
														alternatives: []any{
															&charClassMatcher{
																pos:        position{line: 3808, col: 36, offset: 129503},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
															&seqExpr{
																pos: position{line: 3809, col: 36, offset: 129544},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3809, col: 36, offset: 129544},
																		expr: &litMatcher{
																			pos:        position{line: 3809, col: 36, offset: 129544},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3809, col: 42, offset: 129550},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
														},
													},
												},
												&charClassMatcher{
													pos:        position{line: 2393, col: 20, offset: 81588},
													val:        "[_\\pL]",
													chars:      []rune{'_'},
													classes:    []*unicode.RangeTable{rangeTable("L")},
													ignoreCase: false,
													inverted:   false,
												},
												&zeroOrMoreExpr{
													pos: position{line: 2410, col: 26, offset: 81842},
													expr: &charClassMatcher{
														pos:        position{line: 2393, col: 20, offset: 81588},
														val:        "[_\\pL\\pNd]",
														chars:      []rune{'_'},
														classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
														ignoreCase: false,
														inverted:   false,
													},
												},
											},
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 2794, col: 38, offset: 96614},
										expr: &litMatcher{
											pos:        position{line: 2794, col: 38, offset: 96614},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&ruleRefExpr{
										pos:  position{line: 2794, col: 43, offset: 96619},
										name: "goType",
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 2794, col: 52, offset: 96628},
								name: "goEmbeddedField",
							},
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2794, col: 69, offset: 96645},
						expr: &choiceExpr{
							pos: position{line: 2734, col: 16, offset: 94463},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 2736, col: 19, offset: 94522},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 2736, col: 19, offset: 94522},
											val:        "`",
											ignoreCase: false,
											want:       "\"`\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2736, col: 23, offset: 94526},
											expr: &charClassMatcher{
												pos:        position{line: 2747, col: 27, offset: 94906},
												val:        "[^\\n`]",
												chars:      []rune{'\n', '`'},
												ignoreCase: false,
												inverted:   true,
											},
										},
										&litMatcher{
											pos:        position{line: 2736, col: 47, offset: 94550},
											val:        "`",
											ignoreCase: false,
											want:       "\"`\"",
										},
									},
								},
								&actionExpr{
									pos: position{line: 2737, col: 5, offset: 94560},
									run: (*parser).callongoFieldDecl33,
									expr: &seqExpr{
										pos: position{line: 2737, col: 5, offset: 94560},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 2737, col: 5, offset: 94560},
												val:        "`",
												ignoreCase: false,
												want:       "\"`\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2737, col: 9, offset: 94564},
												expr: &charClassMatcher{
													pos:        position{line: 2747, col: 27, offset: 94906},
													val:        "[^\\n`]",
													chars:      []rune{'\n', '`'},
													ignoreCase: false,
													inverted:   true,
												},
											},
											&zeroOrMoreExpr{
												pos: position{line: 3796, col: 12, offset: 129156},
												expr: &charClassMatcher{
													pos:        position{line: 3808, col: 36, offset: 129503},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&choiceExpr{
												pos: position{line: 3796, col: 16, offset: 129160},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														exprs: []any{
															&zeroOrOneExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																expr: &litMatcher{
																	pos:        position{line: 3796, col: 16, offset: 129160},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3796, col: 22, offset: 129166},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
													&notExpr{
														pos: position{line: 3795, col: 12, offset: 129142},
														expr: &anyMatcher{
															line: 3795, col: 13, offset: 129143,
														},
													},
												},
											},
										},
									},
								},
								&seqExpr{
									pos: position{line: 2749, col: 27, offset: 94990},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 2749, col: 27, offset: 94990},
											val:        "\"",
											ignoreCase: false,
											want:       "\"\\\"\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2749, col: 31, offset: 94994},
											expr: &choiceExpr{
												pos: position{line: 2749, col: 32, offset: 94995},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 2505, col: 19, offset: 85311},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2505, col: 19, offset: 85311},
																val:        "\\u",
																ignoreCase: false,
																want:       "\"\\\\u\"",
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&actionExpr{
														pos: position{line: 2506, col: 5, offset: 85370},
														run: (*parser).callongoFieldDecl57,
														expr: &seqExpr{
															pos: position{line: 2506, col: 5, offset: 85370},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2506, col: 5, offset: 85370},
																	val:        "\\u",
																	ignoreCase: false,
																	want:       "\"\\\\u\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2506, col: 14, offset: 85379},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2506, col: 26, offset: 85391},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2506, col: 38, offset: 85403},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2506, col: 50, offset: 85415},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
													&seqExpr{
														pos: position{line: 2535, col: 16, offset: 86551},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2535, col: 16, offset: 86551},
																val:        "\\U",
																ignoreCase: false,
																want:       "\"\\\\U\"",
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&actionExpr{
														pos: position{line: 2536, col: 5, offset: 86654},
														run: (*parser).callongoFieldDecl78,
														expr: &seqExpr{
															pos: position{line: 2536, col: 5, offset: 86654},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2536, col: 5, offset: 86654},
																	val:        "\\U",
																	ignoreCase: false,
																	want:       "\"\\\\U\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 14, offset: 86663},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 26, offset: 86675},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 38, offset: 86687},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 50, offset: 86699},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 62, offset: 86711},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 74, offset: 86723},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 86, offset: 86735},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2536, col: 98, offset: 86747},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
													&seqExpr{
														pos: position{line: 2763, col: 36, offset: 95684},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2763, col: 36, offset: 95684},
																val:        "\\",
																ignoreCase: false,
																want:       "\"\\\\\"",
															},
															&charClassMatcher{
																pos:        position{line: 2763, col: 41, offset: 95689},
																val:        "[abfnrtv\\\\\"]",
																chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 2761, col: 38, offset: 95576},
														val:        "[^\"\\\\\\n]",
														chars:      []rune{'"', '\\', '\n'},
														ignoreCase: false,
														inverted:   true,
													},
													&seqExpr{
														pos: position{line: 2486, col: 24, offset: 84569},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2486, col: 24, offset: 84569},
																val:        "\\",
																ignoreCase: false,
																want:       "\"\\\\\"",
															},
															&charClassMatcher{
																pos:        position{line: 2403, col: 19, offset: 81758},
																val:        "[0-7]",
																ranges:     []rune{'0', '7'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2403, col: 19, offset: 81758},
																val:        "[0-7]",
																ranges:     []rune{'0', '7'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2403, col: 19, offset: 81758},
																val:        "[0-7]",
																ranges:     []rune{'0', '7'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&seqExpr{
														pos: position{line: 2487, col: 24, offset: 84636},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 2487, col: 24, offset: 84636},
																val:        "\\x",
																ignoreCase: false,
																want:       "\"\\\\x\"",
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2404, col: 19, offset: 81782},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&actionExpr{
														pos: position{line: 2488, col: 5, offset: 84673},
														run: (*parser).callongoFieldDecl110,
														expr: &seqExpr{
															pos: position{line: 2488, col: 5, offset: 84673},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2488, col: 5, offset: 84673},
																	val:        "\\x",
																	ignoreCase: false,
																	want:       "\"\\\\x\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2488, col: 14, offset: 84682},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2488, col: 26, offset: 84694},
																	expr: &charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 2650, col: 37, offset: 91334},
														run: (*parser).callongoFieldDecl117,
														expr: &seqExpr{
															pos: position{line: 2650, col: 37, offset: 91334},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2650, col: 37, offset: 91334},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 2674, col: 5, offset: 92351},
														run: (*parser).callongoFieldDecl128,
														expr: &seqExpr{
															pos: position{line: 2674, col: 5, offset: 92351},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2674, col: 5, offset: 92351},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 2695, col: 5, offset: 93193},
														run: (*parser).callongoFieldDecl135,
														expr: &seqExpr{
															pos: position{line: 2695, col: 5, offset: 93193},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2695, col: 5, offset: 93193},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 2713, col: 5, offset: 93879},
														run: (*parser).callongoFieldDecl140,
														expr: &seqExpr{
															pos: position{line: 2713, col: 5, offset: 93879},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2713, col: 5, offset: 93879},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2713, col: 10, offset: 93884},
																	expr: &charClassMatcher{
																		pos:        position{line: 3797, col: 12, offset: 129189},
																		val:        "[^\\r\\n]",
																		chars:      []rune{'\r', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 2749, col: 115, offset: 95078},
											val:        "\"",
											ignoreCase: false,
											want:       "\"\\\"\"",
										},
									},
								},
								&actionExpr{
									pos: position{line: 2750, col: 5, offset: 95088},
									run: (*parser).callongoFieldDecl146,
									expr: &seqExpr{
										pos: position{line: 2750, col: 5, offset: 95088},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 2750, col: 5, offset: 95088},
												val:        "\"",
												ignoreCase: false,
												want:       "\"\\\"\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2750, col: 9, offset: 95092},
												expr: &choiceExpr{
													pos: position{line: 2750, col: 10, offset: 95093},
													alternatives: []any{
														&seqExpr{
															pos: position{line: 2505, col: 19, offset: 85311},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2505, col: 19, offset: 85311},
																	val:        "\\u",
																	ignoreCase: false,
																	want:       "\"\\\\u\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&actionExpr{
															pos: position{line: 2506, col: 5, offset: 85370},
															run: (*parser).callongoFieldDecl157,
															expr: &seqExpr{
																pos: position{line: 2506, col: 5, offset: 85370},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 2506, col: 5, offset: 85370},
																		val:        "\\u",
																		ignoreCase: false,
																		want:       "\"\\\\u\"",
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2506, col: 14, offset: 85379},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2506, col: 26, offset: 85391},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2506, col: 38, offset: 85403},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2506, col: 50, offset: 85415},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
														&seqExpr{
															pos: position{line: 2535, col: 16, offset: 86551},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2535, col: 16, offset: 86551},
																	val:        "\\U",
																	ignoreCase: false,
																	want:       "\"\\\\U\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&actionExpr{
															pos: position{line: 2536, col: 5, offset: 86654},
															run: (*parser).callongoFieldDecl178,
															expr: &seqExpr{
																pos: position{line: 2536, col: 5, offset: 86654},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 2536, col: 5, offset: 86654},
																		val:        "\\U",
																		ignoreCase: false,
																		want:       "\"\\\\U\"",
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2536, col: 14, offset: 86663},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2536, col: 26, offset: 86675},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2536, col: 38, offset: 86687},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2536, col: 50, offset: 86699},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2536, col: 62, offset: 86711},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2536, col: 74, offset: 86723},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2536, col: 86, offset: 86735},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2536, col: 98, offset: 86747},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
														&seqExpr{
															pos: position{line: 2763, col: 36, offset: 95684},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2763, col: 36, offset: 95684},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2763, col: 41, offset: 95689},
																	val:        "[abfnrtv\\\\\"]",
																	chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&charClassMatcher{
															pos:        position{line: 2761, col: 38, offset: 95576},
															val:        "[^\"\\\\\\n]",
															chars:      []rune{'"', '\\', '\n'},
															ignoreCase: false,
															inverted:   true,
														},
														&seqExpr{
															pos: position{line: 2486, col: 24, offset: 84569},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2486, col: 24, offset: 84569},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2403, col: 19, offset: 81758},
																	val:        "[0-7]",
																	ranges:     []rune{'0', '7'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2403, col: 19, offset: 81758},
																	val:        "[0-7]",
																	ranges:     []rune{'0', '7'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2403, col: 19, offset: 81758},
																	val:        "[0-7]",
																	ranges:     []rune{'0', '7'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&seqExpr{
															pos: position{line: 2487, col: 24, offset: 84636},
															exprs: []any{
																&litMatcher{
																	pos:        position{line: 2487, col: 24, offset: 84636},
																	val:        "\\x",
																	ignoreCase: false,
																	want:       "\"\\\\x\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2404, col: 19, offset: 81782},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&actionExpr{
															pos: position{line: 2488, col: 5, offset: 84673},
															run: (*parser).callongoFieldDecl210,
															expr: &seqExpr{
																pos: position{line: 2488, col: 5, offset: 84673},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 2488, col: 5, offset: 84673},
																		val:        "\\x",
																		ignoreCase: false,
																		want:       "\"\\\\x\"",
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2488, col: 14, offset: 84682},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2488, col: 26, offset: 84694},
																		expr: &charClassMatcher{
																			pos:        position{line: 2404, col: 19, offset: 81782},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 2650, col: 37, offset: 91334},
															run: (*parser).callongoFieldDecl217,
															expr: &seqExpr{
																pos: position{line: 2650, col: 37, offset: 91334},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 2650, col: 37, offset: 91334},
																		val:        "\\",
																		ignoreCase: false,
																		want:       "\"\\\\\"",
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 2674, col: 5, offset: 92351},
															run: (*parser).callongoFieldDecl228,
															expr: &seqExpr{
																pos: position{line: 2674, col: 5, offset: 92351},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 2674, col: 5, offset: 92351},
																		val:        "\\",
																		ignoreCase: false,
																		want:       "\"\\\\\"",
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 2695, col: 5, offset: 93193},
															run: (*parser).callongoFieldDecl235,
															expr: &seqExpr{
																pos: position{line: 2695, col: 5, offset: 93193},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 2695, col: 5, offset: 93193},
																		val:        "\\",
																		ignoreCase: false,
																		want:       "\"\\\\\"",
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2404, col: 19, offset: 81782},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 2713, col: 5, offset: 93879},
															run: (*parser).callongoFieldDecl240,
															expr: &seqExpr{
																pos: position{line: 2713, col: 5, offset: 93879},
																exprs: []any{
																	&litMatcher{
																		pos:        position{line: 2713, col: 5, offset: 93879},
																		val:        "\\",
																		ignoreCase: false,
																		want:       "\"\\\\\"",
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2713, col: 10, offset: 93884},
																		expr: &charClassMatcher{
																			pos:        position{line: 3797, col: 12, offset: 129189},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																},
															},
														},
													},
												},
											},
											&notExpr{
												pos: position{line: 3795, col: 12, offset: 129142},
												expr: &anyMatcher{
													line: 3795, col: 13, offset: 129143,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goEmbeddedField",
			pos:  position{line: 2795, col: 1, offset: 96652},
			expr: &seqExpr{
				pos: position{line: 2795, col: 20, offset: 96671},
				exprs: []any{
					&zeroOrOneExpr{
						pos: position{line: 2795, col: 20, offset: 96671},
						expr: &litMatcher{
							pos:        position{line: 2795, col: 20, offset: 96671},
							val:        "*",
							ignoreCase: false,
							want:       "\"*\"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2795, col: 25, offset: 96676},
						expr: &litMatcher{
							pos:        position{line: 2795, col: 25, offset: 96676},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&choiceExpr{
						pos: position{line: 2770, col: 15, offset: 95860},
						alternatives: []any{
							&seqExpr{
								pos: position{line: 2427, col: 21, offset: 82385},
								exprs: []any{
									&charClassMatcher{
										pos:        position{line: 2393, col: 20, offset: 81588},
										val:        "[_\\pL]",
										chars:      []rune{'_'},
										classes:    []*unicode.RangeTable{rangeTable("L")},
										ignoreCase: false,
										inverted:   false,
									},
									&zeroOrMoreExpr{
										pos: position{line: 2410, col: 26, offset: 81842},
										expr: &charClassMatcher{
											pos:        position{line: 2393, col: 20, offset: 81588},
											val:        "[_\\pL\\pNd]",
											chars:      []rune{'_'},
											classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
											ignoreCase: false,
											inverted:   false,
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 2427, col: 35, offset: 82399},
										expr: &litMatcher{
											pos:        position{line: 2427, col: 35, offset: 82399},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&litMatcher{
										pos:        position{line: 2427, col: 40, offset: 82404},
										val:        ".",
										ignoreCase: false,
										want:       "\".\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2427, col: 44, offset: 82408},
										expr: &litMatcher{
											pos:        position{line: 2427, col: 44, offset: 82408},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&charClassMatcher{
										pos:        position{line: 2393, col: 20, offset: 81588},
										val:        "[_\\pL]",
										chars:      []rune{'_'},
										classes:    []*unicode.RangeTable{rangeTable("L")},
										ignoreCase: false,
										inverted:   false,
									},
									&zeroOrMoreExpr{
										pos: position{line: 2410, col: 26, offset: 81842},
										expr: &charClassMatcher{
											pos:        position{line: 2393, col: 20, offset: 81588},
											val:        "[_\\pL\\pNd]",
											chars:      []rune{'_'},
											classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
											ignoreCase: false,
											inverted:   false,
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 2410, col: 17, offset: 81833},
								exprs: []any{
									&charClassMatcher{
										pos:        position{line: 2393, col: 20, offset: 81588},
										val:        "[_\\pL]",
										chars:      []rune{'_'},
										classes:    []*unicode.RangeTable{rangeTable("L")},
										ignoreCase: false,
										inverted:   false,
									},
									&zeroOrMoreExpr{
										pos: position{line: 2410, col: 26, offset: 81842},
										expr: &charClassMatcher{
											pos:        position{line: 2393, col: 20, offset: 81588},
											val:        "[_\\pL\\pNd]",
											chars:      []rune{'_'},
											classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
											ignoreCase: false,
											inverted:   false,
										},
									},
								},
							},
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2795, col: 41, offset: 96692},
						expr: &litMatcher{
							pos:        position{line: 2795, col: 41, offset: 96692},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2795, col: 46, offset: 96697},
						expr: &ruleRefExpr{
							pos:  position{line: 2795, col: 46, offset: 96697},
							name: "goTypeArgs",
						},
					},
				},
			},
		},
		{
			name: "goPointerType",
			pos:  position{line: 2802, col: 1, offset: 96765},
			expr: &seqExpr{
				pos: position{line: 2802, col: 18, offset: 96782},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 2802, col: 18, offset: 96782},
						val:        "*",
						ignoreCase: false,
						want:       "\"*\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2802, col: 22, offset: 96786},
						expr: &litMatcher{
							pos:        position{line: 2802, col: 22, offset: 96786},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2802, col: 27, offset: 96791},
						name: "goBaseType",
					},
				},
			},
		},
		{
			name: "goBaseType",
			pos:  position{line: 2803, col: 1, offset: 96802},
			expr: &ruleRefExpr{
				pos:  position{line: 2803, col: 18, offset: 96819},
				name: "goType",
			},
		},
		{
			name: "goFunctionType",
			pos:  position{line: 2809, col: 1, offset: 96852},
			expr: &seqExpr{
				pos: position{line: 2809, col: 20, offset: 96871},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 2809, col: 20, offset: 96871},
						val:        "func",
						ignoreCase: false,
						want:       "\"func\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2809, col: 27, offset: 96878},
						expr: &litMatcher{
							pos:        position{line: 2809, col: 27, offset: 96878},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2809, col: 32, offset: 96883},
						name: "goSignature",
					},
				},
			},
		},
		{
			name: "goSignature",
			pos:  position{line: 2810, col: 1, offset: 96895},
			expr: &seqExpr{
				pos: position{line: 2810, col: 20, offset: 96914},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 2810, col: 20, offset: 96914},
						name: "goParameters",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2810, col: 33, offset: 96927},
						expr: &litMatcher{
							pos:        position{line: 2810, col: 33, offset: 96927},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2810, col: 38, offset: 96932},
						expr: &ruleRefExpr{
							pos:  position{line: 2810, col: 38, offset: 96932},
							name: "goResult",
						},
					},
				},
			},
		},
		{
			name: "goResult",
			pos:  position{line: 2811, col: 1, offset: 96942},
			expr: &choiceExpr{
				pos: position{line: 2811, col: 20, offset: 96961},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 2811, col: 20, offset: 96961},
						name: "goParameters",
					},
					&ruleRefExpr{
						pos:  position{line: 2811, col: 35, offset: 96976},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goParameters",
			pos:  position{line: 2812, col: 1, offset: 96983},
			expr: &seqExpr{
				pos: position{line: 2812, col: 20, offset: 97002},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 2812, col: 20, offset: 97002},
						val:        "(",
						ignoreCase: false,
						want:       "\"(\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2812, col: 24, offset: 97006},
						expr: &choiceExpr{
							pos: position{line: 3812, col: 20, offset: 129621},
							alternatives: []any{
								&charClassMatcher{
									pos:        position{line: 3808, col: 36, offset: 129503},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
								&seqExpr{
									pos: position{line: 3809, col: 36, offset: 129544},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2812, col: 28, offset: 97010},
						expr: &seqExpr{
							pos: position{line: 2812, col: 29, offset: 97011},
							exprs: []any{
								&ruleRefExpr{
									pos:  position{line: 2812, col: 29, offset: 97011},
									name: "goParameterList",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2812, col: 45, offset: 97027},
									expr: &litMatcher{
										pos:        position{line: 2812, col: 45, offset: 97027},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2812, col: 50, offset: 97032},
									expr: &seqExpr{
										pos: position{line: 2812, col: 51, offset: 97033},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 2812, col: 51, offset: 97033},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2812, col: 55, offset: 97037},
												expr: &choiceExpr{
													pos: position{line: 3812, col: 20, offset: 129621},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															exprs: []any{
																&zeroOrOneExpr{
																	pos: position{line: 3809, col: 36, offset: 129544},
																	expr: &litMatcher{
																		pos:        position{line: 3809, col: 36, offset: 129544},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3809, col: 42, offset: 129550},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2812, col: 63, offset: 97045},
						val:        ")",
						ignoreCase: false,
						want:       "\")\"",
					},
				},
			},
		},
		{
			name: "goParameterList",
			pos:  position{line: 2813, col: 1, offset: 97049},
			expr: &seqExpr{
				pos: position{line: 2813, col: 20, offset: 97068},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 2813, col: 20, offset: 97068},
						name: "goParameterDecl",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2813, col: 36, offset: 97084},
						expr: &litMatcher{
							pos:        position{line: 2813, col: 36, offset: 97084},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2813, col: 41, offset: 97089},
						expr: &seqExpr{
							pos: position{line: 2813, col: 42, offset: 97090},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2813, col: 42, offset: 97090},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2813, col: 46, offset: 97094},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2813, col: 50, offset: 97098},
									name: "goParameterDecl",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goParameterDecl",
			pos:  position{line: 2814, col: 1, offset: 97116},
			expr: &seqExpr{
				pos: position{line: 2814, col: 20, offset: 97135},
				exprs: []any{
					&zeroOrOneExpr{
						pos: position{line: 2814, col: 20, offset: 97135},
						expr: &seqExpr{
							pos: position{line: 2845, col: 21, offset: 97815},
							exprs: []any{
								&charClassMatcher{
									pos:        position{line: 2393, col: 20, offset: 81588},
									val:        "[_\\pL]",
									chars:      []rune{'_'},
									classes:    []*unicode.RangeTable{rangeTable("L")},
									ignoreCase: false,
									inverted:   false,
								},
								&zeroOrMoreExpr{
									pos: position{line: 2410, col: 26, offset: 81842},
									expr: &charClassMatcher{
										pos:        position{line: 2393, col: 20, offset: 81588},
										val:        "[_\\pL\\pNd]",
										chars:      []rune{'_'},
										classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2845, col: 34, offset: 97828},
									expr: &litMatcher{
										pos:        position{line: 2845, col: 34, offset: 97828},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2845, col: 39, offset: 97833},
									expr: &seqExpr{
										pos: position{line: 2845, col: 40, offset: 97834},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 2845, col: 40, offset: 97834},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2845, col: 44, offset: 97838},
												expr: &choiceExpr{
													pos: position{line: 3812, col: 20, offset: 129621},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															exprs: []any{
																&zeroOrOneExpr{
																	pos: position{line: 3809, col: 36, offset: 129544},
																	expr: &litMatcher{
																		pos:        position{line: 3809, col: 36, offset: 129544},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3809, col: 42, offset: 129550},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 2393, col: 20, offset: 81588},
												val:        "[_\\pL]",
												chars:      []rune{'_'},
												classes:    []*unicode.RangeTable{rangeTable("L")},
												ignoreCase: false,
												inverted:   false,
											},
											&zeroOrMoreExpr{
												pos: position{line: 2410, col: 26, offset: 81842},
												expr: &charClassMatcher{
													pos:        position{line: 2393, col: 20, offset: 81588},
													val:        "[_\\pL\\pNd]",
													chars:      []rune{'_'},
													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
								},
							},
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2814, col: 38, offset: 97153},
						expr: &litMatcher{
							pos:        position{line: 2814, col: 38, offset: 97153},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2814, col: 43, offset: 97158},
						expr: &litMatcher{
							pos:        position{line: 2814, col: 43, offset: 97158},
							val:        "...",
							ignoreCase: false,
							want:       "\"...\"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2814, col: 50, offset: 97165},
						expr: &litMatcher{
							pos:        position{line: 2814, col: 50, offset: 97165},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2814, col: 55, offset: 97170},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goInterfaceType",
			pos:  position{line: 2820, col: 1, offset: 97204},
			expr: &seqExpr{
				pos: position{line: 2820, col: 21, offset: 97224},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 2820, col: 21, offset: 97224},
						val:        "interface",
						ignoreCase: false,
						want:       "\"interface\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2820, col: 33, offset: 97236},
						expr: &litMatcher{
							pos:        position{line: 2820, col: 33, offset: 97236},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2820, col: 38, offset: 97241},
						val:        "{",
						ignoreCase: false,
						want:       "\"{\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2820, col: 42, offset: 97245},
						expr: &seqExpr{
							pos: position{line: 2820, col: 43, offset: 97246},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 2820, col: 43, offset: 97246},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2820, col: 47, offset: 97250},
									name: "goInterfaceElem",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2820, col: 63, offset: 97266},
									expr: &litMatcher{
										pos:        position{line: 2820, col: 63, offset: 97266},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&choiceExpr{
									pos: position{line: 2820, col: 69, offset: 97272},
									alternatives: []any{
										&litMatcher{
											pos:        position{line: 2820, col: 69, offset: 97272},
											val:        ";",
											ignoreCase: false,
											want:       "\";\"",
										},
										&oneOrMoreExpr{
											pos: position{line: 3810, col: 36, offset: 129590},
											expr: &seqExpr{
												pos: position{line: 3810, col: 37, offset: 129591},
												exprs: []any{
													&zeroOrMoreExpr{
														pos: position{line: 3810, col: 37, offset: 129591},
														expr: &charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2820, col: 86, offset: 97289},
						expr: &choiceExpr{
							pos: position{line: 3812, col: 20, offset: 129621},
							alternatives: []any{
								&charClassMatcher{
									pos:        position{line: 3808, col: 36, offset: 129503},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
								&seqExpr{
									pos: position{line: 3809, col: 36, offset: 129544},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 3809, col: 36, offset: 129544},
											expr: &litMatcher{
												pos:        position{line: 3809, col: 36, offset: 129544},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3809, col: 42, offset: 129550},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2820, col: 90, offset: 97293},
						val:        "}",
						ignoreCase: false,
						want:       "\"}\"",
					},
				},
			},
		},
		{
			name: "goInterfaceElem",
			pos:  position{line: 2821, col: 1, offset: 97297},
			expr: &choiceExpr{
				pos: position{line: 2821, col: 21, offset: 97317},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 2821, col: 21, offset: 97317},
						name: "goMethodElem",
					},
					&ruleRefExpr{
						pos:  position{line: 2821, col: 36, offset: 97332},
						name: "goTypeElem",
					},
				},
			},
		},
		{
			name: "goMethodElem",
			pos:  position{line: 2822, col: 1, offset: 97343},
			expr: &seqExpr{
				pos: position{line: 2822, col: 21, offset: 97363},
				exprs: []any{
					&charClassMatcher{
						pos:        position{line: 2393, col: 20, offset: 81588},
						val:        "[_\\pL]",
						chars:      []rune{'_'},
						classes:    []*unicode.RangeTable{rangeTable("L")},
						ignoreCase: false,
						inverted:   false,
					},
					&zeroOrMoreExpr{
						pos: position{line: 2410, col: 26, offset: 81842},
						expr: &charClassMatcher{
							pos:        position{line: 2393, col: 20, offset: 81588},
							val:        "[_\\pL\\pNd]",
							chars:      []rune{'_'},
							classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2822, col: 34, offset: 97376},
						name: "goSignature",
					},
				},
			},
		},
		{
			name: "goTypeElem",
			pos:  position{line: 2824, col: 1, offset: 97421},
			expr: &seqExpr{
				pos: position{line: 2824, col: 21, offset: 97441},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 2824, col: 21, offset: 97441},
						name: "goTypeTerm",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2824, col: 32, offset: 97452},
						expr: &seqExpr{
							pos: position{line: 2824, col: 33, offset: 97453},
							exprs: []any{
								&zeroOrMoreExpr{
									pos: position{line: 2824, col: 33, offset: 97453},
									expr: &litMatcher{
										pos:        position{line: 2824, col: 33, offset: 97453},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 2824, col: 38, offset: 97458},
									val:        "|",
									ignoreCase: false,
									want:       "\"|\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2824, col: 42, offset: 97462},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2824, col: 46, offset: 97466},
									name: "goTypeTerm",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goTypeTerm",
			pos:  position{line: 2825, col: 1, offset: 97479},
			expr: &choiceExpr{
				pos: position{line: 2825, col: 21, offset: 97499},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 2825, col: 21, offset: 97499},
						name: "goType",
					},
					&ruleRefExpr{
						pos:  position{line: 2825, col: 30, offset: 97508},
						name: "goUnderlyingType",
					},
				},
			},
		},
		{
			name: "goUnderlyingType",
			pos:  position{line: 2826, col: 1, offset: 97525},
			expr: &seqExpr{
				pos: position{line: 2826, col: 21, offset: 97545},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 2826, col: 21, offset: 97545},
						val:        "~",
						ignoreCase: false,
						want:       "\"~\"",
					},
					&ruleRefExpr{
						pos:  position{line: 2826, col: 25, offset: 97549},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goMapType",
			pos:  position{line: 2832, col: 1, offset: 97577},
			expr: &seqExpr{
				pos: position{line: 2832, col: 14, offset: 97590},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 2832, col: 14, offset: 97590},
						val:        "map",
						ignoreCase: false,
						want:       "\"map\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2832, col: 20, offset: 97596},
						expr: &litMatcher{
							pos:        position{line: 2832, col: 20, offset: 97596},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2832, col: 25, offset: 97601},
						val:        "[",
						ignoreCase: false,
						want:       "\"[\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2832, col: 29, offset: 97605},
						expr: &litMatcher{
							pos:        position{line: 2832, col: 29, offset: 97605},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2832, col: 34, offset: 97610},
						name: "goKeyType",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2832, col: 44, offset: 97620},
						expr: &litMatcher{
							pos:        position{line: 2832, col: 44, offset: 97620},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2832, col: 49, offset: 97625},
						val:        "]",
						ignoreCase: false,
						want:       "\"]\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2832, col: 53, offset: 97629},
						expr: &litMatcher{
							pos:        position{line: 2832, col: 53, offset: 97629},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2832, col: 58, offset: 97634},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "goKeyType",
			pos:  position{line: 2833, col: 1, offset: 97648},
			expr: &ruleRefExpr{
				pos:  position{line: 2833, col: 14, offset: 97661},
				name: "goType",
			},
		},
		{
			name: "goChannelType",
			pos:  position{line: 2839, col: 1, offset: 97693},
			expr: &seqExpr{
				pos: position{line: 2839, col: 18, offset: 97710},
				exprs: []any{
					&zeroOrOneExpr{
						pos: position{line: 2839, col: 18, offset: 97710},
						expr: &seqExpr{
							pos: position{line: 2839, col: 19, offset: 97711},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2839, col: 19, offset: 97711},
									val:        "<-",
									ignoreCase: false,
									want:       "\"<-\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2839, col: 24, offset: 97716},
									expr: &litMatcher{
										pos:        position{line: 2839, col: 24, offset: 97716},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2839, col: 31, offset: 97723},
						val:        "chan",
						ignoreCase: false,
						want:       "\"chan\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2839, col: 38, offset: 97730},
						expr: &litMatcher{
							pos:        position{line: 2839, col: 38, offset: 97730},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2839, col: 43, offset: 97735},
						expr: &seqExpr{
							pos: position{line: 2839, col: 44, offset: 97736},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2839, col: 44, offset: 97736},
									val:        "<-",
									ignoreCase: false,
									want:       "\"<-\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2839, col: 49, offset: 97741},
									expr: &litMatcher{
										pos:        position{line: 2839, col: 49, offset: 97741},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2839, col: 56, offset: 97748},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "Mixin",
			pos:  position{line: 2899, col: 1, offset: 100198},
			expr: &choiceExpr{
				pos: position{line: 2899, col: 10, offset: 100207},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 2899, col: 10, offset: 100207},
						run: (*parser).callonMixin2,
						expr: &seqExpr{
							pos: position{line: 2899, col: 10, offset: 100207},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2899, col: 10, offset: 100207},
									val:        "mixin",
									ignoreCase: false,
									want:       "\"mixin\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 2899, col: 18, offset: 100215},
									expr: &litMatcher{
										pos:        position{line: 2899, col: 18, offset: 100215},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2899, col: 23, offset: 100220},
									label: "nameI",
									expr: &choiceExpr{
										pos: position{line: 773, col: 14, offset: 23557},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 773, col: 14, offset: 23557},
												run: (*parser).callonMixin9,
												expr: &labeledExpr{
													pos:   position{line: 773, col: 14, offset: 23557},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 759, col: 10, offset: 23002},
														alternatives: []any{
															&actionExpr{
																pos: position{line: 759, col: 10, offset: 23002},
																run: (*parser).callonMixin12,
																expr: &labeledExpr{
																	pos:   position{line: 759, col: 10, offset: 23002},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 2410, col: 17, offset: 81833},
																		exprs: []any{
																			&charClassMatcher{
																				pos:        position{line: 2393, col: 20, offset: 81588},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2410, col: 26, offset: 81842},
																				expr: &charClassMatcher{
																					pos:        position{line: 2393, col: 20, offset: 81588},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 761, col: 5, offset: 23096},
																run: (*parser).callonMixin18,
																expr: &seqExpr{
																	pos: position{line: 761, col: 5, offset: 23096},
																	exprs: []any{
																		&labeledExpr{
																			pos:   position{line: 761, col: 5, offset: 23096},
																			label: "identI",
																			expr: &seqExpr{
																				pos: position{line: 761, col: 13, offset: 23104},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 761, col: 13, offset: 23104},
																						expr: &litMatcher{
																							pos:        position{line: 761, col: 13, offset: 23104},
																							val:        "$",
																							ignoreCase: false,
																							want:       "\"$\"",
																						},
																					},
																					&oneOrMoreExpr{
																						pos: position{line: 761, col: 18, offset: 23109},
																						expr: &choiceExpr{
																							pos: position{line: 761, col: 19, offset: 23110},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 761, col: 19, offset: 23110},
																									exprs: []any{
																										&charClassMatcher{
																											pos:        position{line: 761, col: 19, offset: 23110},
																											val:        "[\\pNd]",
																											classes:    []*unicode.RangeTable{rangeTable("Nd")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 761, col: 28, offset: 23119},
																											val:        "[_-\\pL]",
																											chars:      []rune{'_', '-'},
																											classes:    []*unicode.RangeTable{rangeTable("L")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 761, col: 38, offset: 23129},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 761, col: 49, offset: 23140},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonMixin31,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 775, col: 5, offset: 23599},
												run: (*parser).callonMixin37,
												expr: &seqExpr{
													pos: position{line: 775, col: 5, offset: 23599},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 775, col: 5, offset: 23599},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonMixin40,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
														&andExpr{
															pos: position{line: 775, col: 14, offset: 23608},
															expr: &choiceExpr{
																pos: position{line: 775, col: 16, offset: 23610},
																alternatives: []any{
																	&seqExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		exprs: []any{
																			&zeroOrMoreExpr{
																				pos: position{line: 3796, col: 12, offset: 129156},
																				expr: &charClassMatcher{
																					pos:        position{line: 3808, col: 36, offset: 129503},
																					val:        "[ \\t]",
																					chars:      []rune{' ', '\t'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&choiceExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				alternatives: []any{
																					&seqExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						exprs: []any{
																							&zeroOrOneExpr{
																								pos: position{line: 3796, col: 16, offset: 129160},
																								expr: &litMatcher{
																									pos:        position{line: 3796, col: 16, offset: 129160},
																									val:        "\r",
																									ignoreCase: false,
																									want:       "\"\\r\"",
																								},
																							},
																							&litMatcher{
																								pos:        position{line: 3796, col: 22, offset: 129166},
																								val:        "\n",
																								ignoreCase: false,
																								want:       "\"\\n\"",
																							},
																						},
																					},
																					&notExpr{
																						pos: position{line: 3795, col: 12, offset: 129142},
																						expr: &anyMatcher{
																							line: 3795, col: 13, offset: 129143,
																						},
																					},
																				},
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 775, col: 22, offset: 23616},
																		val:        "[:!=()]",
																		chars:      []rune{':', '!', '=', '(', ')'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 786, col: 5, offset: 23948},
												run: (*parser).callonMixin59,
												expr: &seqExpr{
													pos: position{line: 786, col: 5, offset: 23948},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 786, col: 5, offset: 23948},
															label: "identI",
															expr: &oneOrMoreExpr{
																pos: position{line: 786, col: 12, offset: 23955},
																expr: &charClassMatcher{
																	pos:        position{line: 786, col: 12, offset: 23955},
																	val:        "[^ \\t\\r\\n:!=()]",
																	chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 786, col: 29, offset: 23972},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonMixin65,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2899, col: 39, offset: 100236},
									label: "paramsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2899, col: 47, offset: 100244},
										expr: &ruleRefExpr{
											pos:  position{line: 2899, col: 47, offset: 100244},
											name: "mixinParamList",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2899, col: 63, offset: 100260},
									label: "bodyI",
									expr: &ruleRefExpr{
										pos:  position{line: 2899, col: 69, offset: 100266},
										name: "Beaitb",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2909, col: 5, offset: 100560},
						run: (*parser).callonMixin76,
						expr: &seqExpr{
							pos: position{line: 2909, col: 5, offset: 100560},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2909, col: 5, offset: 100560},
									val:        "mixin",
									ignoreCase: false,
									want:       "\"mixin\"",
								},
								&labeledExpr{
									pos:   position{line: 2909, col: 13, offset: 100568},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonMixin80,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2909, col: 22, offset: 100577},
									label: "bodyI",
									expr: &ruleRefExpr{
										pos:  position{line: 2909, col: 28, offset: 100583},
										name: "Beaitb",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParamList",
			pos:  position{line: 2925, col: 1, offset: 100996},
			expr: &choiceExpr{
				pos: position{line: 2925, col: 19, offset: 101014},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 2925, col: 19, offset: 101014},
						run: (*parser).callonmixinParamList2,
						expr: &seqExpr{
							pos: position{line: 2925, col: 19, offset: 101014},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2925, col: 19, offset: 101014},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2925, col: 23, offset: 101018},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2925, col: 27, offset: 101022},
									label: "paramsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2925, col: 35, offset: 101030},
										expr: &ruleRefExpr{
											pos:  position{line: 2925, col: 35, offset: 101030},
											name: "mixinParams",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2925, col: 48, offset: 101043},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2925, col: 51, offset: 101046},
									expr: &seqExpr{
										pos: position{line: 2925, col: 52, offset: 101047},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 2925, col: 52, offset: 101047},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2925, col: 56, offset: 101051},
												expr: &choiceExpr{
													pos: position{line: 3812, col: 20, offset: 129621},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															exprs: []any{
																&zeroOrOneExpr{
																	pos: position{line: 3809, col: 36, offset: 129544},
																	expr: &litMatcher{
																		pos:        position{line: 3809, col: 36, offset: 129544},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3809, col: 42, offset: 129550},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2925, col: 62, offset: 101057},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonmixinParamList28,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2931, col: 5, offset: 101258},
						run: (*parser).callonmixinParamList30,
						expr: &seqExpr{
							pos: position{line: 2931, col: 5, offset: 101258},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2931, col: 5, offset: 101258},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2931, col: 9, offset: 101262},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2931, col: 13, offset: 101266},
									label: "paramsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2931, col: 21, offset: 101274},
										expr: &ruleRefExpr{
											pos:  position{line: 2931, col: 21, offset: 101274},
											name: "mixinParams",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2931, col: 34, offset: 101287},
									expr: &seqExpr{
										pos: position{line: 2931, col: 35, offset: 101288},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 2931, col: 35, offset: 101288},
												expr: &charClassMatcher{
													pos:        position{line: 3808, col: 36, offset: 129503},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&litMatcher{
												pos:        position{line: 2931, col: 38, offset: 101291},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2931, col: 44, offset: 101297},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonmixinParamList49,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParams",
			pos:  position{line: 2950, col: 1, offset: 101842},
			expr: &actionExpr{
				pos: position{line: 2950, col: 16, offset: 101857},
				run: (*parser).callonmixinParams1,
				expr: &seqExpr{
					pos: position{line: 2950, col: 16, offset: 101857},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 2950, col: 16, offset: 101857},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 2950, col: 23, offset: 101864},
								name: "mixinParam",
							},
						},
						&labeledExpr{
							pos:   position{line: 2950, col: 34, offset: 101875},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2950, col: 40, offset: 101881},
								expr: &seqExpr{
									pos: position{line: 2950, col: 41, offset: 101882},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 2950, col: 41, offset: 101882},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&litMatcher{
											pos:        position{line: 2950, col: 44, offset: 101885},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2950, col: 48, offset: 101889},
											expr: &choiceExpr{
												pos: position{line: 3812, col: 20, offset: 129621},
												alternatives: []any{
													&charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														exprs: []any{
															&zeroOrOneExpr{
																pos: position{line: 3809, col: 36, offset: 129544},
																expr: &litMatcher{
																	pos:        position{line: 3809, col: 36, offset: 129544},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3809, col: 42, offset: 129550},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2950, col: 52, offset: 101893},
											name: "mixinParam",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParam",
			pos:  position{line: 2961, col: 1, offset: 102171},
			expr: &actionExpr{
				pos: position{line: 2961, col: 15, offset: 102185},
				run: (*parser).callonmixinParam1,
				expr: &seqExpr{
					pos: position{line: 2961, col: 15, offset: 102185},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 2961, col: 15, offset: 102185},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 801, col: 20, offset: 24418},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 801, col: 20, offset: 24418},
										run: (*parser).callonmixinParam5,
										expr: &labeledExpr{
											pos:   position{line: 801, col: 20, offset: 24418},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 759, col: 10, offset: 23002},
												alternatives: []any{
													&actionExpr{
														pos: position{line: 759, col: 10, offset: 23002},
														run: (*parser).callonmixinParam8,
														expr: &labeledExpr{
															pos:   position{line: 759, col: 10, offset: 23002},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2410, col: 17, offset: 81833},
																exprs: []any{
																	&charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2410, col: 26, offset: 81842},
																		expr: &charClassMatcher{
																			pos:        position{line: 2393, col: 20, offset: 81588},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 761, col: 5, offset: 23096},
														run: (*parser).callonmixinParam14,
														expr: &seqExpr{
															pos: position{line: 761, col: 5, offset: 23096},
															exprs: []any{
																&labeledExpr{
																	pos:   position{line: 761, col: 5, offset: 23096},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 761, col: 13, offset: 23104},
																		exprs: []any{
																			&zeroOrOneExpr{
																				pos: position{line: 761, col: 13, offset: 23104},
																				expr: &litMatcher{
																					pos:        position{line: 761, col: 13, offset: 23104},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 761, col: 18, offset: 23109},
																				expr: &choiceExpr{
																					pos: position{line: 761, col: 19, offset: 23110},
																					alternatives: []any{
																						&seqExpr{
																							pos: position{line: 761, col: 19, offset: 23110},
																							exprs: []any{
																								&charClassMatcher{
																									pos:        position{line: 761, col: 19, offset: 23110},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 761, col: 28, offset: 23119},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 761, col: 38, offset: 23129},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 761, col: 49, offset: 23140},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonmixinParam27,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 803, col: 5, offset: 24460},
										run: (*parser).callonmixinParam33,
										expr: &seqExpr{
											pos: position{line: 803, col: 5, offset: 24460},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 803, col: 5, offset: 24460},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 803, col: 12, offset: 24467},
														expr: &charClassMatcher{
															pos:        position{line: 803, col: 12, offset: 24467},
															val:        "[^ \\t\\r\\n:!=()]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 803, col: 29, offset: 24484},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonmixinParam39,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2961, col: 37, offset: 102207},
							label: "posI",
							expr: &actionExpr{
								pos: position{line: 3799, col: 8, offset: 129205},
								run: (*parser).callonmixinParam46,
								expr: &choiceExpr{
									pos: position{line: 3799, col: 9, offset: 129206},
									alternatives: []any{
										&andExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											expr: &anyMatcher{
												line: 3799, col: 10, offset: 129207,
											},
										},
										&notExpr{
											pos: position{line: 3799, col: 14, offset: 129211},
											expr: &anyMatcher{
												line: 3799, col: 15, offset: 129212,
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2961, col: 46, offset: 102216},
							label: "typeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2961, col: 52, offset: 102222},
								expr: &seqExpr{
									pos: position{line: 2961, col: 53, offset: 102223},
									exprs: []any{
										&oneOrMoreExpr{
											pos: position{line: 2961, col: 53, offset: 102223},
											expr: &litMatcher{
												pos:        position{line: 2961, col: 53, offset: 102223},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2961, col: 58, offset: 102228},
											name: "GoType",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2961, col: 67, offset: 102237},
							label: "defaultI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2961, col: 76, offset: 102246},
								expr: &seqExpr{
									pos: position{line: 2961, col: 77, offset: 102247},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 2961, col: 77, offset: 102247},
											expr: &litMatcher{
												pos:        position{line: 2961, col: 77, offset: 102247},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2961, col: 82, offset: 102252},
											name: "mixinParamDefault",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParamDefault",
			pos:  position{line: 2999, col: 1, offset: 103472},
			expr: &choiceExpr{
				pos: position{line: 2999, col: 22, offset: 103493},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 2999, col: 22, offset: 103493},
						run: (*parser).callonmixinParamDefault2,
						expr: &seqExpr{
							pos: position{line: 2999, col: 22, offset: 103493},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 2999, col: 22, offset: 103493},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2999, col: 26, offset: 103497},
									expr: &litMatcher{
										pos:        position{line: 2999, col: 26, offset: 103497},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2999, col: 31, offset: 103502},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 2999, col: 37, offset: 103508},
										name: "GoExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3004, col: 5, offset: 103649},
						run: (*parser).callonmixinParamDefault9,
						expr: &seqExpr{
							pos: position{line: 3004, col: 5, offset: 103649},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3004, col: 5, offset: 103649},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&labeledExpr{
									pos:   position{line: 3004, col: 9, offset: 103653},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonmixinParamDefault13,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Return",
			pos:  position{line: 3029, col: 1, offset: 104445},
			expr: &actionExpr{
				pos: position{line: 3029, col: 11, offset: 104455},
				run: (*parser).callonReturn1,
				expr: &seqExpr{
					pos: position{line: 3029, col: 11, offset: 104455},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 3029, col: 11, offset: 104455},
							val:        "return",
							ignoreCase: false,
							want:       "\"return\"",
						},
						&labeledExpr{
							pos:   position{line: 3029, col: 20, offset: 104464},
							label: "errExprI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3029, col: 29, offset: 104473},
								expr: &ruleRefExpr{
									pos:  position{line: 3029, col: 29, offset: 104473},
									name: "Expression",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 3029, col: 41, offset: 104485},
							expr: &actionExpr{
								pos: position{line: 1386, col: 21, offset: 44240},
								run: (*parser).callonReturn8,
								expr: &oneOrMoreExpr{
									pos: position{line: 1386, col: 21, offset: 44240},
									expr: &charClassMatcher{
										pos:        position{line: 3797, col: 12, offset: 129189},
										val:        "[^\\r\\n]",
										chars:      []rune{'\r', '\n'},
										ignoreCase: false,
										inverted:   true,
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							expr: &charClassMatcher{
								pos:        position{line: 3808, col: 36, offset: 129503},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3796, col: 16, offset: 129160},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											expr: &litMatcher{
												pos:        position{line: 3796, col: 16, offset: 129160},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3796, col: 22, offset: 129166},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3795, col: 12, offset: 129142},
									expr: &anyMatcher{
										line: 3795, col: 13, offset: 129143,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "MixinCall",
			pos:  position{line: 3040, col: 1, offset: 104808},
			expr: &actionExpr{
				pos: position{line: 3040, col: 14, offset: 104821},
				run: (*parser).callonMixinCall1,
				expr: &seqExpr{
					pos: position{line: 3040, col: 14, offset: 104821},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 3040, col: 14, offset: 104821},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 3040, col: 18, offset: 104825},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3040, col: 29, offset: 104836},
								expr: &seqExpr{
									pos: position{line: 3040, col: 30, offset: 104837},
									exprs: []any{
										&choiceExpr{
											pos: position{line: 759, col: 10, offset: 23002},
											alternatives: []any{
												&actionExpr{
													pos: position{line: 759, col: 10, offset: 23002},
													run: (*parser).callonMixinCall8,
													expr: &labeledExpr{
														pos:   position{line: 759, col: 10, offset: 23002},
														label: "identI",
														expr: &seqExpr{
															pos: position{line: 2410, col: 17, offset: 81833},
															exprs: []any{
																&charClassMatcher{
																	pos:        position{line: 2393, col: 20, offset: 81588},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2410, col: 26, offset: 81842},
																	expr: &charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 761, col: 5, offset: 23096},
													run: (*parser).callonMixinCall14,
													expr: &seqExpr{
														pos: position{line: 761, col: 5, offset: 23096},
														exprs: []any{
															&labeledExpr{
																pos:   position{line: 761, col: 5, offset: 23096},
																label: "identI",
																expr: &seqExpr{
																	pos: position{line: 761, col: 13, offset: 23104},
																	exprs: []any{
																		&zeroOrOneExpr{
																			pos: position{line: 761, col: 13, offset: 23104},
																			expr: &litMatcher{
																				pos:        position{line: 761, col: 13, offset: 23104},
																				val:        "$",
																				ignoreCase: false,
																				want:       "\"$\"",
																			},
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 761, col: 18, offset: 23109},
																			expr: &choiceExpr{
																				pos: position{line: 761, col: 19, offset: 23110},
																				alternatives: []any{
																					&seqExpr{
																						pos: position{line: 761, col: 19, offset: 23110},
																						exprs: []any{
																							&charClassMatcher{
																								pos:        position{line: 761, col: 19, offset: 23110},
																								val:        "[\\pNd]",
																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 761, col: 28, offset: 23119},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 761, col: 38, offset: 23129},
																						val:        "[_-\\pL]",
																						chars:      []rune{'_', '-'},
																						classes:    []*unicode.RangeTable{rangeTable("L")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&labeledExpr{
																pos:   position{line: 761, col: 49, offset: 23140},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3799, col: 8, offset: 129205},
																	run: (*parser).callonMixinCall27,
																	expr: &choiceExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		alternatives: []any{
																			&andExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				expr: &anyMatcher{
																					line: 3799, col: 10, offset: 129207,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3799, col: 14, offset: 129211},
																				expr: &anyMatcher{
																					line: 3799, col: 15, offset: 129212,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 3040, col: 36, offset: 104843},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3040, col: 42, offset: 104849},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 773, col: 14, offset: 23557},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 773, col: 14, offset: 23557},
										run: (*parser).callonMixinCall36,
										expr: &labeledExpr{
											pos:   position{line: 773, col: 14, offset: 23557},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 759, col: 10, offset: 23002},
												alternatives: []any{
													&actionExpr{
														pos: position{line: 759, col: 10, offset: 23002},
														run: (*parser).callonMixinCall39,
														expr: &labeledExpr{
															pos:   position{line: 759, col: 10, offset: 23002},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2410, col: 17, offset: 81833},
																exprs: []any{
																	&charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2410, col: 26, offset: 81842},
																		expr: &charClassMatcher{
																			pos:        position{line: 2393, col: 20, offset: 81588},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 761, col: 5, offset: 23096},
														run: (*parser).callonMixinCall45,
														expr: &seqExpr{
															pos: position{line: 761, col: 5, offset: 23096},
															exprs: []any{
																&labeledExpr{
																	pos:   position{line: 761, col: 5, offset: 23096},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 761, col: 13, offset: 23104},
																		exprs: []any{
																			&zeroOrOneExpr{
																				pos: position{line: 761, col: 13, offset: 23104},
																				expr: &litMatcher{
																					pos:        position{line: 761, col: 13, offset: 23104},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 761, col: 18, offset: 23109},
																				expr: &choiceExpr{
																					pos: position{line: 761, col: 19, offset: 23110},
																					alternatives: []any{
																						&seqExpr{
																							pos: position{line: 761, col: 19, offset: 23110},
																							exprs: []any{
																								&charClassMatcher{
																									pos:        position{line: 761, col: 19, offset: 23110},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 761, col: 28, offset: 23119},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 761, col: 38, offset: 23129},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 761, col: 49, offset: 23140},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonMixinCall58,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 775, col: 5, offset: 23599},
										run: (*parser).callonMixinCall64,
										expr: &seqExpr{
											pos: position{line: 775, col: 5, offset: 23599},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 775, col: 5, offset: 23599},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonMixinCall67,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
												&andExpr{
													pos: position{line: 775, col: 14, offset: 23608},
													expr: &choiceExpr{
														pos: position{line: 775, col: 16, offset: 23610},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 775, col: 22, offset: 23616},
																val:        "[:!=()]",
																chars:      []rune{':', '!', '=', '(', ')'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 786, col: 5, offset: 23948},
										run: (*parser).callonMixinCall86,
										expr: &seqExpr{
											pos: position{line: 786, col: 5, offset: 23948},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 786, col: 5, offset: 23948},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 786, col: 12, offset: 23955},
														expr: &charClassMatcher{
															pos:        position{line: 786, col: 12, offset: 23955},
															val:        "[^ \\t\\r\\n:!=()]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 786, col: 29, offset: 23972},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonMixinCall92,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3040, col: 58, offset: 104865},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3040, col: 64, offset: 104871},
								expr: &ruleRefExpr{
									pos:  position{line: 3040, col: 64, offset: 104871},
									name: "mixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3040, col: 78, offset: 104885},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 3040, col: 84, offset: 104891},
								name: "mixinCallBody",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineMixinCall",
			pos:  position{line: 3059, col: 1, offset: 105341},
			expr: &actionExpr{
				pos: position{line: 3059, col: 20, offset: 105360},
				run: (*parser).callonInlineMixinCall1,
				expr: &seqExpr{
					pos: position{line: 3059, col: 20, offset: 105360},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 3059, col: 20, offset: 105360},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 3059, col: 24, offset: 105364},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3059, col: 35, offset: 105375},
								expr: &seqExpr{
									pos: position{line: 3059, col: 36, offset: 105376},
									exprs: []any{
										&choiceExpr{
											pos: position{line: 759, col: 10, offset: 23002},
											alternatives: []any{
												&actionExpr{
													pos: position{line: 759, col: 10, offset: 23002},
													run: (*parser).callonInlineMixinCall8,
													expr: &labeledExpr{
														pos:   position{line: 759, col: 10, offset: 23002},
														label: "identI",
														expr: &seqExpr{
															pos: position{line: 2410, col: 17, offset: 81833},
															exprs: []any{
																&charClassMatcher{
																	pos:        position{line: 2393, col: 20, offset: 81588},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2410, col: 26, offset: 81842},
																	expr: &charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 761, col: 5, offset: 23096},
													run: (*parser).callonInlineMixinCall14,
													expr: &seqExpr{
														pos: position{line: 761, col: 5, offset: 23096},
														exprs: []any{
															&labeledExpr{
																pos:   position{line: 761, col: 5, offset: 23096},
																label: "identI",
																expr: &seqExpr{
																	pos: position{line: 761, col: 13, offset: 23104},
																	exprs: []any{
																		&zeroOrOneExpr{
																			pos: position{line: 761, col: 13, offset: 23104},
																			expr: &litMatcher{
																				pos:        position{line: 761, col: 13, offset: 23104},
																				val:        "$",
																				ignoreCase: false,
																				want:       "\"$\"",
																			},
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 761, col: 18, offset: 23109},
																			expr: &choiceExpr{
																				pos: position{line: 761, col: 19, offset: 23110},
																				alternatives: []any{
																					&seqExpr{
																						pos: position{line: 761, col: 19, offset: 23110},
																						exprs: []any{
																							&charClassMatcher{
																								pos:        position{line: 761, col: 19, offset: 23110},
																								val:        "[\\pNd]",
																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 761, col: 28, offset: 23119},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 761, col: 38, offset: 23129},
																						val:        "[_-\\pL]",
																						chars:      []rune{'_', '-'},
																						classes:    []*unicode.RangeTable{rangeTable("L")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&labeledExpr{
																pos:   position{line: 761, col: 49, offset: 23140},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3799, col: 8, offset: 129205},
																	run: (*parser).callonInlineMixinCall27,
																	expr: &choiceExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		alternatives: []any{
																			&andExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				expr: &anyMatcher{
																					line: 3799, col: 10, offset: 129207,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3799, col: 14, offset: 129211},
																				expr: &anyMatcher{
																					line: 3799, col: 15, offset: 129212,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 3059, col: 42, offset: 105382},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3059, col: 48, offset: 105388},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 773, col: 14, offset: 23557},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 773, col: 14, offset: 23557},
										run: (*parser).callonInlineMixinCall36,
										expr: &labeledExpr{
											pos:   position{line: 773, col: 14, offset: 23557},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 759, col: 10, offset: 23002},
												alternatives: []any{
													&actionExpr{
														pos: position{line: 759, col: 10, offset: 23002},
														run: (*parser).callonInlineMixinCall39,
														expr: &labeledExpr{
															pos:   position{line: 759, col: 10, offset: 23002},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2410, col: 17, offset: 81833},
																exprs: []any{
																	&charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2410, col: 26, offset: 81842},
																		expr: &charClassMatcher{
																			pos:        position{line: 2393, col: 20, offset: 81588},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 761, col: 5, offset: 23096},
														run: (*parser).callonInlineMixinCall45,
														expr: &seqExpr{
															pos: position{line: 761, col: 5, offset: 23096},
															exprs: []any{
																&labeledExpr{
																	pos:   position{line: 761, col: 5, offset: 23096},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 761, col: 13, offset: 23104},
																		exprs: []any{
																			&zeroOrOneExpr{
																				pos: position{line: 761, col: 13, offset: 23104},
																				expr: &litMatcher{
																					pos:        position{line: 761, col: 13, offset: 23104},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 761, col: 18, offset: 23109},
																				expr: &choiceExpr{
																					pos: position{line: 761, col: 19, offset: 23110},
																					alternatives: []any{
																						&seqExpr{
																							pos: position{line: 761, col: 19, offset: 23110},
																							exprs: []any{
																								&charClassMatcher{
																									pos:        position{line: 761, col: 19, offset: 23110},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 761, col: 28, offset: 23119},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 761, col: 38, offset: 23129},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 761, col: 49, offset: 23140},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonInlineMixinCall58,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 775, col: 5, offset: 23599},
										run: (*parser).callonInlineMixinCall64,
										expr: &seqExpr{
											pos: position{line: 775, col: 5, offset: 23599},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 775, col: 5, offset: 23599},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonInlineMixinCall67,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
												&andExpr{
													pos: position{line: 775, col: 14, offset: 23608},
													expr: &choiceExpr{
														pos: position{line: 775, col: 16, offset: 23610},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 775, col: 22, offset: 23616},
																val:        "[:!=()]",
																chars:      []rune{':', '!', '=', '(', ')'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 786, col: 5, offset: 23948},
										run: (*parser).callonInlineMixinCall86,
										expr: &seqExpr{
											pos: position{line: 786, col: 5, offset: 23948},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 786, col: 5, offset: 23948},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 786, col: 12, offset: 23955},
														expr: &charClassMatcher{
															pos:        position{line: 786, col: 12, offset: 23955},
															val:        "[^ \\t\\r\\n:!=()]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 786, col: 29, offset: 23972},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonInlineMixinCall92,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3059, col: 64, offset: 105404},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3059, col: 70, offset: 105410},
								expr: &ruleRefExpr{
									pos:  position{line: 3059, col: 70, offset: 105410},
									name: "singleLineMixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3059, col: 94, offset: 105434},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 3059, col: 100, offset: 105440},
								name: "singleLineMixinCallBody",
							},
						},
					},
				},
			},
		},
		{
			name: "mixinArgList",
			pos:  position{line: 3078, col: 1, offset: 105900},
			expr: &choiceExpr{
				pos: position{line: 3078, col: 17, offset: 105916},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3078, col: 17, offset: 105916},
						run: (*parser).callonmixinArgList2,
						expr: &seqExpr{
							pos: position{line: 3078, col: 17, offset: 105916},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3078, col: 17, offset: 105916},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3078, col: 21, offset: 105920},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3078, col: 25, offset: 105924},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3078, col: 31, offset: 105930},
										expr: &ruleRefExpr{
											pos:  position{line: 3078, col: 31, offset: 105930},
											name: "mixinArgs",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3078, col: 42, offset: 105941},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3078, col: 45, offset: 105944},
									expr: &seqExpr{
										pos: position{line: 3078, col: 46, offset: 105945},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 3078, col: 46, offset: 105945},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 3078, col: 50, offset: 105949},
												expr: &choiceExpr{
													pos: position{line: 3812, col: 20, offset: 129621},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3809, col: 36, offset: 129544},
															exprs: []any{
																&zeroOrOneExpr{
																	pos: position{line: 3809, col: 36, offset: 129544},
																	expr: &litMatcher{
																		pos:        position{line: 3809, col: 36, offset: 129544},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3809, col: 42, offset: 129550},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3078, col: 56, offset: 105955},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonmixinArgList28,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3084, col: 5, offset: 106154},
						run: (*parser).callonmixinArgList30,
						expr: &seqExpr{
							pos: position{line: 3084, col: 5, offset: 106154},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3084, col: 5, offset: 106154},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3084, col: 9, offset: 106158},
									expr: &choiceExpr{
										pos: position{line: 3812, col: 20, offset: 129621},
										alternatives: []any{
											&charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3809, col: 36, offset: 129544},
												exprs: []any{
													&zeroOrOneExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														expr: &litMatcher{
															pos:        position{line: 3809, col: 36, offset: 129544},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3809, col: 42, offset: 129550},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3084, col: 13, offset: 106162},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3084, col: 19, offset: 106168},
										expr: &ruleRefExpr{
											pos:  position{line: 3084, col: 19, offset: 106168},
											name: "mixinArgs",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3084, col: 30, offset: 106179},
									expr: &seqExpr{
										pos: position{line: 3084, col: 31, offset: 106180},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 3084, col: 31, offset: 106180},
												expr: &charClassMatcher{
													pos:        position{line: 3808, col: 36, offset: 129503},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&litMatcher{
												pos:        position{line: 3084, col: 34, offset: 106183},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3084, col: 40, offset: 106189},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonmixinArgList49,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinArgList",
			pos:  position{line: 3102, col: 1, offset: 106725},
			expr: &choiceExpr{
				pos: position{line: 3102, col: 27, offset: 106751},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3102, col: 27, offset: 106751},
						run: (*parser).callonsingleLineMixinArgList2,
						expr: &seqExpr{
							pos: position{line: 3102, col: 27, offset: 106751},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3102, col: 27, offset: 106751},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3102, col: 31, offset: 106755},
									expr: &litMatcher{
										pos:        position{line: 3102, col: 31, offset: 106755},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3102, col: 36, offset: 106760},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3102, col: 42, offset: 106766},
										expr: &ruleRefExpr{
											pos:  position{line: 3102, col: 42, offset: 106766},
											name: "singleLineMixinArgs",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3102, col: 63, offset: 106787},
									expr: &litMatcher{
										pos:        position{line: 3102, col: 63, offset: 106787},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3102, col: 68, offset: 106792},
									expr: &seqExpr{
										pos: position{line: 3102, col: 69, offset: 106793},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 3102, col: 69, offset: 106793},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 3102, col: 73, offset: 106797},
												expr: &litMatcher{
													pos:        position{line: 3102, col: 73, offset: 106797},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3102, col: 80, offset: 106804},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3819, col: 12, offset: 129879},
										run: (*parser).callonsingleLineMixinArgList18,
										expr: &litMatcher{
											pos:        position{line: 3819, col: 12, offset: 129879},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3108, col: 5, offset: 107003},
						run: (*parser).callonsingleLineMixinArgList20,
						expr: &seqExpr{
							pos: position{line: 3108, col: 5, offset: 107003},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3108, col: 5, offset: 107003},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3108, col: 9, offset: 107007},
									expr: &litMatcher{
										pos:        position{line: 3108, col: 9, offset: 107007},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3108, col: 14, offset: 107012},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3108, col: 20, offset: 107018},
										expr: &ruleRefExpr{
											pos:  position{line: 3108, col: 20, offset: 107018},
											name: "singleLineMixinArgs",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3108, col: 41, offset: 107039},
									expr: &seqExpr{
										pos: position{line: 3108, col: 42, offset: 107040},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 3108, col: 42, offset: 107040},
												expr: &litMatcher{
													pos:        position{line: 3108, col: 42, offset: 107040},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 3108, col: 47, offset: 107045},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3108, col: 53, offset: 107051},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonsingleLineMixinArgList34,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinArgs",
			pos:  position{line: 3127, col: 1, offset: 107588},
			expr: &actionExpr{
				pos: position{line: 3127, col: 14, offset: 107601},
				run: (*parser).callonmixinArgs1,
				expr: &seqExpr{
					pos: position{line: 3127, col: 14, offset: 107601},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 3127, col: 14, offset: 107601},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 3127, col: 21, offset: 107608},
								name: "mixinArg",
							},
						},
						&labeledExpr{
							pos:   position{line: 3127, col: 30, offset: 107617},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3127, col: 36, offset: 107623},
								expr: &seqExpr{
									pos: position{line: 3127, col: 37, offset: 107624},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3127, col: 37, offset: 107624},
											expr: &charClassMatcher{
												pos:        position{line: 3808, col: 36, offset: 129503},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&litMatcher{
											pos:        position{line: 3127, col: 40, offset: 107627},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 3127, col: 44, offset: 107631},
											expr: &choiceExpr{
												pos: position{line: 3812, col: 20, offset: 129621},
												alternatives: []any{
													&charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														exprs: []any{
															&zeroOrOneExpr{
																pos: position{line: 3809, col: 36, offset: 129544},
																expr: &litMatcher{
																	pos:        position{line: 3809, col: 36, offset: 129544},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3809, col: 42, offset: 129550},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3127, col: 48, offset: 107635},
											name: "mixinArg",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinArgs",
			pos:  position{line: 3137, col: 1, offset: 107896},
			expr: &actionExpr{
				pos: position{line: 3137, col: 24, offset: 107919},
				run: (*parser).callonsingleLineMixinArgs1,
				expr: &seqExpr{
					pos: position{line: 3137, col: 24, offset: 107919},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 3137, col: 24, offset: 107919},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 3137, col: 31, offset: 107926},
								name: "singleLineMixinArg",
							},
						},
						&labeledExpr{
							pos:   position{line: 3137, col: 50, offset: 107945},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3137, col: 56, offset: 107951},
								expr: &seqExpr{
									pos: position{line: 3137, col: 57, offset: 107952},
									exprs: []any{
										&zeroOrMoreExpr{
											pos: position{line: 3137, col: 57, offset: 107952},
											expr: &litMatcher{
												pos:        position{line: 3137, col: 57, offset: 107952},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 3137, col: 62, offset: 107957},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 3137, col: 66, offset: 107961},
											expr: &litMatcher{
												pos:        position{line: 3137, col: 66, offset: 107961},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3137, col: 71, offset: 107966},
											name: "singleLineMixinArg",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinArg",
			pos:  position{line: 3148, col: 1, offset: 108238},
			expr: &choiceExpr{
				pos: position{line: 3148, col: 13, offset: 108250},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3148, col: 13, offset: 108250},
						run: (*parser).callonmixinArg2,
						expr: &seqExpr{
							pos: position{line: 3148, col: 13, offset: 108250},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3148, col: 13, offset: 108250},
									label: "nameI",
									expr: &choiceExpr{
										pos: position{line: 801, col: 20, offset: 24418},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 801, col: 20, offset: 24418},
												run: (*parser).callonmixinArg6,
												expr: &labeledExpr{
													pos:   position{line: 801, col: 20, offset: 24418},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 759, col: 10, offset: 23002},
														alternatives: []any{
															&actionExpr{
																pos: position{line: 759, col: 10, offset: 23002},
																run: (*parser).callonmixinArg9,
																expr: &labeledExpr{
																	pos:   position{line: 759, col: 10, offset: 23002},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 2410, col: 17, offset: 81833},
																		exprs: []any{
																			&charClassMatcher{
																				pos:        position{line: 2393, col: 20, offset: 81588},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2410, col: 26, offset: 81842},
																				expr: &charClassMatcher{
																					pos:        position{line: 2393, col: 20, offset: 81588},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 761, col: 5, offset: 23096},
																run: (*parser).callonmixinArg15,
																expr: &seqExpr{
																	pos: position{line: 761, col: 5, offset: 23096},
																	exprs: []any{
																		&labeledExpr{
																			pos:   position{line: 761, col: 5, offset: 23096},
																			label: "identI",
																			expr: &seqExpr{
																				pos: position{line: 761, col: 13, offset: 23104},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 761, col: 13, offset: 23104},
																						expr: &litMatcher{
																							pos:        position{line: 761, col: 13, offset: 23104},
																							val:        "$",
																							ignoreCase: false,
																							want:       "\"$\"",
																						},
																					},
																					&oneOrMoreExpr{
																						pos: position{line: 761, col: 18, offset: 23109},
																						expr: &choiceExpr{
																							pos: position{line: 761, col: 19, offset: 23110},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 761, col: 19, offset: 23110},
																									exprs: []any{
																										&charClassMatcher{
																											pos:        position{line: 761, col: 19, offset: 23110},
																											val:        "[\\pNd]",
																											classes:    []*unicode.RangeTable{rangeTable("Nd")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 761, col: 28, offset: 23119},
																											val:        "[_-\\pL]",
																											chars:      []rune{'_', '-'},
																											classes:    []*unicode.RangeTable{rangeTable("L")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 761, col: 38, offset: 23129},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 761, col: 49, offset: 23140},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonmixinArg28,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 803, col: 5, offset: 24460},
												run: (*parser).callonmixinArg34,
												expr: &seqExpr{
													pos: position{line: 803, col: 5, offset: 24460},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 803, col: 5, offset: 24460},
															label: "identI",
															expr: &oneOrMoreExpr{
																pos: position{line: 803, col: 12, offset: 24467},
																expr: &charClassMatcher{
																	pos:        position{line: 803, col: 12, offset: 24467},
																	val:        "[^ \\t\\r\\n:!=()]",
																	chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 803, col: 29, offset: 24484},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonmixinArg40,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3148, col: 35, offset: 108272},
									expr: &litMatcher{
										pos:        position{line: 3148, col: 35, offset: 108272},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 3148, col: 40, offset: 108277},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3148, col: 44, offset: 108281},
									expr: &litMatcher{
										pos:        position{line: 3148, col: 44, offset: 108281},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3148, col: 49, offset: 108286},
									label: "valI",
									expr: &ruleRefExpr{
										pos:  position{line: 3148, col: 54, offset: 108291},
										name: "Expression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3153, col: 5, offset: 108418},
						run: (*parser).callonmixinArg53,
						expr: &seqExpr{
							pos: position{line: 3153, col: 5, offset: 108418},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3153, col: 5, offset: 108418},
									label: "nameI",
									expr: &choiceExpr{
										pos: position{line: 801, col: 20, offset: 24418},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 801, col: 20, offset: 24418},
												run: (*parser).callonmixinArg57,
												expr: &labeledExpr{
													pos:   position{line: 801, col: 20, offset: 24418},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 759, col: 10, offset: 23002},
														alternatives: []any{
															&actionExpr{
																pos: position{line: 759, col: 10, offset: 23002},
																run: (*parser).callonmixinArg60,
																expr: &labeledExpr{
																	pos:   position{line: 759, col: 10, offset: 23002},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 2410, col: 17, offset: 81833},
																		exprs: []any{
																			&charClassMatcher{
																				pos:        position{line: 2393, col: 20, offset: 81588},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2410, col: 26, offset: 81842},
																				expr: &charClassMatcher{
																					pos:        position{line: 2393, col: 20, offset: 81588},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 761, col: 5, offset: 23096},
																run: (*parser).callonmixinArg66,
																expr: &seqExpr{
																	pos: position{line: 761, col: 5, offset: 23096},
																	exprs: []any{
																		&labeledExpr{
																			pos:   position{line: 761, col: 5, offset: 23096},
																			label: "identI",
																			expr: &seqExpr{
																				pos: position{line: 761, col: 13, offset: 23104},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 761, col: 13, offset: 23104},
																						expr: &litMatcher{
																							pos:        position{line: 761, col: 13, offset: 23104},
																							val:        "$",
																							ignoreCase: false,
																							want:       "\"$\"",
																						},
																					},
																					&oneOrMoreExpr{
																						pos: position{line: 761, col: 18, offset: 23109},
																						expr: &choiceExpr{
																							pos: position{line: 761, col: 19, offset: 23110},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 761, col: 19, offset: 23110},
																									exprs: []any{
																										&charClassMatcher{
																											pos:        position{line: 761, col: 19, offset: 23110},
																											val:        "[\\pNd]",
																											classes:    []*unicode.RangeTable{rangeTable("Nd")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 761, col: 28, offset: 23119},
																											val:        "[_-\\pL]",
																											chars:      []rune{'_', '-'},
																											classes:    []*unicode.RangeTable{rangeTable("L")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 761, col: 38, offset: 23129},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 761, col: 49, offset: 23140},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonmixinArg79,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 803, col: 5, offset: 24460},
												run: (*parser).callonmixinArg85,
												expr: &seqExpr{
													pos: position{line: 803, col: 5, offset: 24460},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 803, col: 5, offset: 24460},
															label: "identI",
															expr: &oneOrMoreExpr{
																pos: position{line: 803, col: 12, offset: 24467},
																expr: &charClassMatcher{
																	pos:        position{line: 803, col: 12, offset: 24467},
																	val:        "[^ \\t\\r\\n:!=()]",
																	chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 803, col: 29, offset: 24484},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonmixinArg91,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3153, col: 27, offset: 108440},
									expr: &seqExpr{
										pos: position{line: 3153, col: 28, offset: 108441},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 3153, col: 28, offset: 108441},
												expr: &litMatcher{
													pos:        position{line: 3153, col: 28, offset: 108441},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 3153, col: 33, offset: 108446},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3153, col: 39, offset: 108452},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonmixinArg103,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinArg",
			pos:  position{line: 3168, col: 1, offset: 108946},
			expr: &choiceExpr{
				pos: position{line: 3168, col: 23, offset: 108968},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3168, col: 23, offset: 108968},
						run: (*parser).callonsingleLineMixinArg2,
						expr: &seqExpr{
							pos: position{line: 3168, col: 23, offset: 108968},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3168, col: 23, offset: 108968},
									label: "nameI",
									expr: &choiceExpr{
										pos: position{line: 801, col: 20, offset: 24418},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 801, col: 20, offset: 24418},
												run: (*parser).callonsingleLineMixinArg6,
												expr: &labeledExpr{
													pos:   position{line: 801, col: 20, offset: 24418},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 759, col: 10, offset: 23002},
														alternatives: []any{
															&actionExpr{
																pos: position{line: 759, col: 10, offset: 23002},
																run: (*parser).callonsingleLineMixinArg9,
																expr: &labeledExpr{
																	pos:   position{line: 759, col: 10, offset: 23002},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 2410, col: 17, offset: 81833},
																		exprs: []any{
																			&charClassMatcher{
																				pos:        position{line: 2393, col: 20, offset: 81588},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2410, col: 26, offset: 81842},
																				expr: &charClassMatcher{
																					pos:        position{line: 2393, col: 20, offset: 81588},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 761, col: 5, offset: 23096},
																run: (*parser).callonsingleLineMixinArg15,
																expr: &seqExpr{
																	pos: position{line: 761, col: 5, offset: 23096},
																	exprs: []any{
																		&labeledExpr{
																			pos:   position{line: 761, col: 5, offset: 23096},
																			label: "identI",
																			expr: &seqExpr{
																				pos: position{line: 761, col: 13, offset: 23104},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 761, col: 13, offset: 23104},
																						expr: &litMatcher{
																							pos:        position{line: 761, col: 13, offset: 23104},
																							val:        "$",
																							ignoreCase: false,
																							want:       "\"$\"",
																						},
																					},
																					&oneOrMoreExpr{
																						pos: position{line: 761, col: 18, offset: 23109},
																						expr: &choiceExpr{
																							pos: position{line: 761, col: 19, offset: 23110},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 761, col: 19, offset: 23110},
																									exprs: []any{
																										&charClassMatcher{
																											pos:        position{line: 761, col: 19, offset: 23110},
																											val:        "[\\pNd]",
																											classes:    []*unicode.RangeTable{rangeTable("Nd")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 761, col: 28, offset: 23119},
																											val:        "[_-\\pL]",
																											chars:      []rune{'_', '-'},
																											classes:    []*unicode.RangeTable{rangeTable("L")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 761, col: 38, offset: 23129},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 761, col: 49, offset: 23140},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonsingleLineMixinArg28,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 803, col: 5, offset: 24460},
												run: (*parser).callonsingleLineMixinArg34,
												expr: &seqExpr{
													pos: position{line: 803, col: 5, offset: 24460},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 803, col: 5, offset: 24460},
															label: "identI",
															expr: &oneOrMoreExpr{
																pos: position{line: 803, col: 12, offset: 24467},
																expr: &charClassMatcher{
																	pos:        position{line: 803, col: 12, offset: 24467},
																	val:        "[^ \\t\\r\\n:!=()]",
																	chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 803, col: 29, offset: 24484},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonsingleLineMixinArg40,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3168, col: 45, offset: 108990},
									expr: &litMatcher{
										pos:        position{line: 3168, col: 45, offset: 108990},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 3168, col: 50, offset: 108995},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3168, col: 54, offset: 108999},
									expr: &litMatcher{
										pos:        position{line: 3168, col: 54, offset: 108999},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3168, col: 59, offset: 109004},
									label: "valI",
									expr: &ruleRefExpr{
										pos:  position{line: 3168, col: 64, offset: 109009},
										name: "SingleLineExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3173, col: 5, offset: 109146},
						run: (*parser).callonsingleLineMixinArg53,
						expr: &seqExpr{
							pos: position{line: 3173, col: 5, offset: 109146},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3173, col: 5, offset: 109146},
									label: "nameI",
									expr: &choiceExpr{
										pos: position{line: 801, col: 20, offset: 24418},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 801, col: 20, offset: 24418},
												run: (*parser).callonsingleLineMixinArg57,
												expr: &labeledExpr{
													pos:   position{line: 801, col: 20, offset: 24418},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 759, col: 10, offset: 23002},
														alternatives: []any{
															&actionExpr{
																pos: position{line: 759, col: 10, offset: 23002},
																run: (*parser).callonsingleLineMixinArg60,
																expr: &labeledExpr{
																	pos:   position{line: 759, col: 10, offset: 23002},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 2410, col: 17, offset: 81833},
																		exprs: []any{
																			&charClassMatcher{
																				pos:        position{line: 2393, col: 20, offset: 81588},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2410, col: 26, offset: 81842},
																				expr: &charClassMatcher{
																					pos:        position{line: 2393, col: 20, offset: 81588},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 761, col: 5, offset: 23096},
																run: (*parser).callonsingleLineMixinArg66,
																expr: &seqExpr{
																	pos: position{line: 761, col: 5, offset: 23096},
																	exprs: []any{
																		&labeledExpr{
																			pos:   position{line: 761, col: 5, offset: 23096},
																			label: "identI",
																			expr: &seqExpr{
																				pos: position{line: 761, col: 13, offset: 23104},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 761, col: 13, offset: 23104},
																						expr: &litMatcher{
																							pos:        position{line: 761, col: 13, offset: 23104},
																							val:        "$",
																							ignoreCase: false,
																							want:       "\"$\"",
																						},
																					},
																					&oneOrMoreExpr{
																						pos: position{line: 761, col: 18, offset: 23109},
																						expr: &choiceExpr{
																							pos: position{line: 761, col: 19, offset: 23110},
																							alternatives: []any{
																								&seqExpr{
																									pos: position{line: 761, col: 19, offset: 23110},
																									exprs: []any{
																										&charClassMatcher{
																											pos:        position{line: 761, col: 19, offset: 23110},
																											val:        "[\\pNd]",
																											classes:    []*unicode.RangeTable{rangeTable("Nd")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 761, col: 28, offset: 23119},
																											val:        "[_-\\pL]",
																											chars:      []rune{'_', '-'},
																											classes:    []*unicode.RangeTable{rangeTable("L")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 761, col: 38, offset: 23129},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 761, col: 49, offset: 23140},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3799, col: 8, offset: 129205},
																				run: (*parser).callonsingleLineMixinArg79,
																				expr: &choiceExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					alternatives: []any{
																						&andExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							expr: &anyMatcher{
																								line: 3799, col: 10, offset: 129207,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3799, col: 14, offset: 129211},
																							expr: &anyMatcher{
																								line: 3799, col: 15, offset: 129212,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 803, col: 5, offset: 24460},
												run: (*parser).callonsingleLineMixinArg85,
												expr: &seqExpr{
													pos: position{line: 803, col: 5, offset: 24460},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 803, col: 5, offset: 24460},
															label: "identI",
															expr: &oneOrMoreExpr{
																pos: position{line: 803, col: 12, offset: 24467},
																expr: &charClassMatcher{
																	pos:        position{line: 803, col: 12, offset: 24467},
																	val:        "[^ \\t\\r\\n:!=()]",
																	chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 803, col: 29, offset: 24484},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3799, col: 8, offset: 129205},
																run: (*parser).callonsingleLineMixinArg91,
																expr: &choiceExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	alternatives: []any{
																		&andExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			expr: &anyMatcher{
																				line: 3799, col: 10, offset: 129207,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3799, col: 14, offset: 129211},
																			expr: &anyMatcher{
																				line: 3799, col: 15, offset: 129212,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3173, col: 27, offset: 109168},
									expr: &seqExpr{
										pos: position{line: 3173, col: 28, offset: 109169},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 3173, col: 28, offset: 109169},
												expr: &litMatcher{
													pos:        position{line: 3173, col: 28, offset: 109169},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 3173, col: 33, offset: 109174},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3173, col: 39, offset: 109180},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonsingleLineMixinArg103,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallBody",
			pos:  position{line: 3189, col: 1, offset: 109675},
			expr: &choiceExpr{
				pos: position{line: 3189, col: 18, offset: 109692},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3189, col: 18, offset: 109692},
						run: (*parser).callonmixinCallBody2,
						expr: &labeledExpr{
							pos:   position{line: 3189, col: 18, offset: 109692},
							label: "shI",
							expr: &ruleRefExpr{
								pos:  position{line: 3189, col: 22, offset: 109696},
								name: "MixinMainBlockShorthand",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 3191, col: 5, offset: 109789},
						name: "Beaitb",
					},
				},
			},
		},
		{
			name: "singleLineMixinCallBody",
			pos:  position{line: 3192, col: 1, offset: 109796},
			expr: &ruleRefExpr{
				pos:  position{line: 3192, col: 28, offset: 109823},
				name: "Beait",
			},
		},
		{
			name: "MixinMainBlockShorthand",
			pos:  position{line: 3198, col: 1, offset: 110031},
			expr: &choiceExpr{
				pos: position{line: 3198, col: 28, offset: 110058},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3198, col: 28, offset: 110058},
						run: (*parser).callonMixinMainBlockShorthand2,
						expr: &seqExpr{
							pos: position{line: 3198, col: 28, offset: 110058},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3198, col: 28, offset: 110058},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 3198, col: 33, offset: 110063},
									expr: &actionExpr{
										pos: position{line: 1386, col: 21, offset: 44240},
										run: (*parser).callonMixinMainBlockShorthand6,
										expr: &oneOrMoreExpr{
											pos: position{line: 1386, col: 21, offset: 44240},
											expr: &charClassMatcher{
												pos:        position{line: 3797, col: 12, offset: 129189},
												val:        "[^\\r\\n]",
												chars:      []rune{'\r', '\n'},
												ignoreCase: false,
												inverted:   true,
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3198, col: 55, offset: 110085},
									label: "bodyI",
									expr: &ruleRefExpr{
										pos:  position{line: 3198, col: 61, offset: 110091},
										name: "Body",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3203, col: 5, offset: 110214},
						run: (*parser).callonMixinMainBlockShorthand20,
						expr: &seqExpr{
							pos: position{line: 3203, col: 5, offset: 110214},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3203, col: 5, offset: 110214},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 3203, col: 10, offset: 110219},
									expr: &actionExpr{
										pos: position{line: 1386, col: 21, offset: 44240},
										run: (*parser).callonMixinMainBlockShorthand24,
										expr: &oneOrMoreExpr{
											pos: position{line: 1386, col: 21, offset: 44240},
											expr: &charClassMatcher{
												pos:        position{line: 3797, col: 12, offset: 129189},
												val:        "[^\\r\\n]",
												chars:      []rune{'\r', '\n'},
												ignoreCase: false,
												inverted:   true,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3203, col: 28, offset: 110237},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonMixinMainBlockShorthand28,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Func",
			pos:  position{line: 3405, col: 1, offset: 116196},
			expr: &choiceExpr{
				pos: position{line: 3405, col: 9, offset: 116204},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3405, col: 9, offset: 116204},
						run: (*parser).callonFunc2,
						expr: &seqExpr{
							pos: position{line: 3405, col: 9, offset: 116204},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3405, col: 9, offset: 116204},
									val:        "func",
									ignoreCase: false,
									want:       "\"func\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 3405, col: 16, offset: 116211},
									expr: &litMatcher{
										pos:        position{line: 3405, col: 16, offset: 116211},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3405, col: 21, offset: 116216},
									label: "nameI",
									expr: &actionExpr{
										pos: position{line: 2371, col: 12, offset: 80907},
										run: (*parser).callonFunc8,
										expr: &labeledExpr{
											pos:   position{line: 2371, col: 12, offset: 80907},
											label: "ident",
											expr: &seqExpr{
												pos: position{line: 2410, col: 17, offset: 81833},
												exprs: []any{
													&charClassMatcher{
														pos:        position{line: 2393, col: 20, offset: 81588},
														val:        "[_\\pL]",
														chars:      []rune{'_'},
														classes:    []*unicode.RangeTable{rangeTable("L")},
														ignoreCase: false,
														inverted:   false,
													},
													&zeroOrMoreExpr{
														pos: position{line: 2410, col: 26, offset: 81842},
														expr: &charClassMatcher{
															pos:        position{line: 2393, col: 20, offset: 81588},
															val:        "[_\\pL\\pNd]",
															chars:      []rune{'_'},
															classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
															ignoreCase: false,
															inverted:   false,
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3405, col: 35, offset: 116230},
									label: "paramsI",
									expr: &choiceExpr{
										pos: position{line: 3406, col: 5, offset: 116244},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 3406, col: 5, offset: 116244},
												run: (*parser).callonFunc16,
												expr: &seqExpr{
													pos: position{line: 3406, col: 5, offset: 116244},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 3406, col: 5, offset: 116244},
															label: "lParenPosI",
															expr: &actionExpr{
																pos: position{line: 3818, col: 12, offset: 129841},
																run: (*parser).callonFunc19,
																expr: &litMatcher{
																	pos:        position{line: 3818, col: 12, offset: 129841},
																	val:        "(",
																	ignoreCase: false,
																	want:       "\"(\"",
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 3406, col: 24, offset: 116263},
															label: "paramsI",
															expr: &choiceExpr{
																pos: position{line: 3407, col: 9, offset: 116281},
																alternatives: []any{
																	&actionExpr{
																		pos: position{line: 3407, col: 9, offset: 116281},
																		run: (*parser).callonFunc23,
																		expr: &seqExpr{
																			pos: position{line: 3407, col: 9, offset: 116281},
																			exprs: []any{
																				&zeroOrMoreExpr{
																					pos: position{line: 3407, col: 9, offset: 116281},
																					expr: &choiceExpr{
																						pos: position{line: 3812, col: 20, offset: 129621},
																						alternatives: []any{
																							&charClassMatcher{
																								pos:        position{line: 3808, col: 36, offset: 129503},
																								val:        "[ \\t]",
																								chars:      []rune{' ', '\t'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&seqExpr{
																								pos: position{line: 3809, col: 36, offset: 129544},
																								exprs: []any{
																									&zeroOrOneExpr{
																										pos: position{line: 3809, col: 36, offset: 129544},
																										expr: &litMatcher{
																											pos:        position{line: 3809, col: 36, offset: 129544},
																											val:        "\r",
																											ignoreCase: false,
																											want:       "\"\\r\"",
																										},
																									},
																									&litMatcher{
																										pos:        position{line: 3809, col: 42, offset: 129550},
																										val:        "\n",
																										ignoreCase: false,
																										want:       "\"\\n\"",
																									},
																								},
																							},
																						},
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 3407, col: 13, offset: 116285},
																					label: "paramsI",
																					expr: &zeroOrOneExpr{
																						pos: position{line: 3407, col: 21, offset: 116293},
																						expr: &ruleRefExpr{
																							pos:  position{line: 3407, col: 21, offset: 116293},
																							name: "funcParamList",
																						},
																					},
																				},
																				&zeroOrMoreExpr{
																					pos: position{line: 3407, col: 36, offset: 116308},
																					expr: &litMatcher{
																						pos:        position{line: 3407, col: 36, offset: 116308},
																						val:        " ",
																						ignoreCase: false,
																						want:       "\" \"",
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 3407, col: 41, offset: 116313},
																					expr: &seqExpr{
																						pos: position{line: 3407, col: 42, offset: 116314},
																						exprs: []any{
																							&litMatcher{
																								pos:        position{line: 3407, col: 42, offset: 116314},
																								val:        ",",
																								ignoreCase: false,
																								want:       "\",\"",
																							},
																							&zeroOrMoreExpr{
																								pos: position{line: 3407, col: 46, offset: 116318},
																								expr: &choiceExpr{
																									pos: position{line: 3812, col: 20, offset: 129621},
																									alternatives: []any{
																										&charClassMatcher{
																											pos:        position{line: 3808, col: 36, offset: 129503},
																											val:        "[ \\t]",
																											chars:      []rune{' ', '\t'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&seqExpr{
																											pos: position{line: 3809, col: 36, offset: 129544},
																											exprs: []any{
																												&zeroOrOneExpr{
																													pos: position{line: 3809, col: 36, offset: 129544},
																													expr: &litMatcher{
																														pos:        position{line: 3809, col: 36, offset: 129544},
																														val:        "\r",
																														ignoreCase: false,
																														want:       "\"\\r\"",
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 3809, col: 42, offset: 129550},
																													val:        "\n",
																													ignoreCase: false,
																													want:       "\"\\n\"",
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 3409, col: 13, offset: 116402},
																		run: (*parser).callonFunc47,
																		expr: &seqExpr{
																			pos: position{line: 3409, col: 13, offset: 116402},
																			exprs: []any{
																				&zeroOrMoreExpr{
																					pos: position{line: 3409, col: 13, offset: 116402},
																					expr: &charClassMatcher{
																						pos:        position{line: 3409, col: 13, offset: 116402},
																						val:        "[^)]",
																						chars:      []rune{')'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 3409, col: 19, offset: 116408},
																					label: "endPosI",
																					expr: &actionExpr{
																						pos: position{line: 3799, col: 8, offset: 129205},
																						run: (*parser).callonFunc52,
																						expr: &choiceExpr{
																							pos: position{line: 3799, col: 9, offset: 129206},
																							alternatives: []any{
																								&andExpr{
																									pos: position{line: 3799, col: 9, offset: 129206},
																									expr: &anyMatcher{
																										line: 3799, col: 10, offset: 129207,
																									},
																								},
																								&notExpr{
																									pos: position{line: 3799, col: 14, offset: 129211},
																									expr: &anyMatcher{
																										line: 3799, col: 15, offset: 129212,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 3419, col: 7, offset: 116801},
															label: "rParenPosI",
															expr: &actionExpr{
																pos: position{line: 3819, col: 12, offset: 129879},
																run: (*parser).callonFunc59,
																expr: &litMatcher{
																	pos:        position{line: 3819, col: 12, offset: 129879},
																	val:        ")",
																	ignoreCase: false,
																	want:       "\")\"",
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 3425, col: 9, offset: 117021},
												run: (*parser).callonFunc61,
												expr: &zeroOrMoreExpr{
													pos: position{line: 3425, col: 9, offset: 117021},
													expr: &charClassMatcher{
														pos:        position{line: 3797, col: 12, offset: 129189},
														val:        "[^\\r\\n]",
														chars:      []rune{'\r', '\n'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3444, col: 5, offset: 117565},
						run: (*parser).callonFunc73,
						expr: &seqExpr{
							pos: position{line: 3444, col: 5, offset: 117565},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3444, col: 5, offset: 117565},
									val:        "func",
									ignoreCase: false,
									want:       "\"func\"",
								},
								&labeledExpr{
									pos:   position{line: 3444, col: 12, offset: 117572},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonFunc77,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "funcParamList",
			pos:  position{line: 3456, col: 1, offset: 117921},
			expr: &choiceExpr{
				pos: position{line: 3456, col: 18, offset: 117938},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 3456, col: 18, offset: 117938},
						name: "funcOtherParamList",
					},
					&ruleRefExpr{
						pos:  position{line: 3456, col: 39, offset: 117959},
						name: "funcOnlyVariadicParamList",
					},
				},
			},
		},
		{
			name: "funcOnlyVariadicParamList",
			pos:  position{line: 3457, col: 1, offset: 117985},
			expr: &actionExpr{
				pos: position{line: 3457, col: 30, offset: 118014},
				run: (*parser).callonfuncOnlyVariadicParamList1,
				expr: &labeledExpr{
					pos:   position{line: 3457, col: 30, offset: 118014},
					label: "variadicI",
					expr: &ruleRefExpr{
						pos:  position{line: 3457, col: 40, offset: 118024},
						name: "funcVariadicParam",
					},
				},
			},
		},
		{
			name: "funcOtherParamList",
			pos:  position{line: 3460, col: 1, offset: 118107},
			expr: &actionExpr{
				pos: position{line: 3460, col: 23, offset: 118129},
				run: (*parser).callonfuncOtherParamList1,
				expr: &seqExpr{
					pos: position{line: 3460, col: 23, offset: 118129},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 3460, col: 23, offset: 118129},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 3460, col: 30, offset: 118136},
								name: "funcParam",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3460, col: 40, offset: 118146},
							expr: &litMatcher{
								pos:        position{line: 3460, col: 40, offset: 118146},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 3460, col: 45, offset: 118151},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3460, col: 51, offset: 118157},
								expr: &seqExpr{
									pos: position{line: 3460, col: 52, offset: 118158},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 3460, col: 52, offset: 118158},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 3460, col: 56, offset: 118162},
											expr: &choiceExpr{
												pos: position{line: 3812, col: 20, offset: 129621},
												alternatives: []any{
													&charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														exprs: []any{
															&zeroOrOneExpr{
																pos: position{line: 3809, col: 36, offset: 129544},
																expr: &litMatcher{
																	pos:        position{line: 3809, col: 36, offset: 129544},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3809, col: 42, offset: 129550},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3460, col: 60, offset: 118166},
											name: "funcParam",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3460, col: 72, offset: 118178},
							label: "variadicI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3460, col: 82, offset: 118188},
								expr: &seqExpr{
									pos: position{line: 3460, col: 83, offset: 118189},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 3460, col: 83, offset: 118189},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 3460, col: 87, offset: 118193},
											expr: &choiceExpr{
												pos: position{line: 3812, col: 20, offset: 129621},
												alternatives: []any{
													&charClassMatcher{
														pos:        position{line: 3808, col: 36, offset: 129503},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3809, col: 36, offset: 129544},
														exprs: []any{
															&zeroOrOneExpr{
																pos: position{line: 3809, col: 36, offset: 129544},
																expr: &litMatcher{
																	pos:        position{line: 3809, col: 36, offset: 129544},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3809, col: 42, offset: 129550},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3460, col: 91, offset: 118197},
											name: "funcVariadicParam",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "funcParam",
			pos:  position{line: 3481, col: 1, offset: 118648},
			expr: &choiceExpr{
				pos: position{line: 3481, col: 14, offset: 118661},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3481, col: 14, offset: 118661},
						run: (*parser).callonfuncParam2,
						expr: &seqExpr{
							pos: position{line: 3481, col: 14, offset: 118661},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3481, col: 14, offset: 118661},
									label: "namesI",
									expr: &actionExpr{
										pos: position{line: 3504, col: 18, offset: 119241},
										run: (*parser).callonfuncParam5,
										expr: &seqExpr{
											pos: position{line: 3504, col: 18, offset: 119241},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 3504, col: 18, offset: 119241},
													label: "firstI",
													expr: &actionExpr{
														pos: position{line: 2371, col: 12, offset: 80907},
														run: (*parser).callonfuncParam8,
														expr: &labeledExpr{
															pos:   position{line: 2371, col: 12, offset: 80907},
															label: "ident",
															expr: &seqExpr{
																pos: position{line: 2410, col: 17, offset: 81833},
																exprs: []any{
																	&charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2410, col: 26, offset: 81842},
																		expr: &charClassMatcher{
																			pos:        position{line: 2393, col: 20, offset: 81588},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 3504, col: 33, offset: 119256},
													label: "restI",
													expr: &zeroOrMoreExpr{
														pos: position{line: 3504, col: 39, offset: 119262},
														expr: &seqExpr{
															pos: position{line: 3504, col: 40, offset: 119263},
															exprs: []any{
																&zeroOrMoreExpr{
																	pos: position{line: 3504, col: 40, offset: 119263},
																	expr: &litMatcher{
																		pos:        position{line: 3504, col: 40, offset: 119263},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3504, col: 45, offset: 119268},
																	val:        ",",
																	ignoreCase: false,
																	want:       "\",\"",
																},
																&zeroOrMoreExpr{
																	pos: position{line: 3504, col: 49, offset: 119272},
																	expr: &choiceExpr{
																		pos: position{line: 3812, col: 20, offset: 129621},
																		alternatives: []any{
																			&charClassMatcher{
																				pos:        position{line: 3808, col: 36, offset: 129503},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&seqExpr{
																				pos: position{line: 3809, col: 36, offset: 129544},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3809, col: 36, offset: 129544},
																						expr: &litMatcher{
																							pos:        position{line: 3809, col: 36, offset: 129544},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3809, col: 42, offset: 129550},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2371, col: 12, offset: 80907},
																	run: (*parser).callonfuncParam27,
																	expr: &labeledExpr{
																		pos:   position{line: 2371, col: 12, offset: 80907},
																		label: "ident",
																		expr: &seqExpr{
																			pos: position{line: 2410, col: 17, offset: 81833},
																			exprs: []any{
																				&charClassMatcher{
																					pos:        position{line: 2393, col: 20, offset: 81588},
																					val:        "[_\\pL]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&zeroOrMoreExpr{
																					pos: position{line: 2410, col: 26, offset: 81842},
																					expr: &charClassMatcher{
																						pos:        position{line: 2393, col: 20, offset: 81588},
																						val:        "[_\\pL\\pNd]",
																						chars:      []rune{'_'},
																						classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&oneOrMoreExpr{
									pos: position{line: 3481, col: 35, offset: 118682},
									expr: &litMatcher{
										pos:        position{line: 3481, col: 35, offset: 118682},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3481, col: 40, offset: 118687},
									label: "typeI",
									expr: &ruleRefExpr{
										pos:  position{line: 3481, col: 46, offset: 118693},
										name: "funcType",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3486, col: 5, offset: 118821},
						run: (*parser).callonfuncParam37,
						expr: &labeledExpr{
							pos:   position{line: 3486, col: 5, offset: 118821},
							label: "typeI",
							expr: &ruleRefExpr{
								pos:  position{line: 3486, col: 11, offset: 118827},
								name: "funcType",
							},
						},
					},
				},
			},
		},
		{
			name: "funcVariadicParam",
			pos:  position{line: 3491, col: 1, offset: 118913},
			expr: &actionExpr{
				pos: position{line: 3491, col: 22, offset: 118934},
				run: (*parser).callonfuncVariadicParam1,
				expr: &seqExpr{
					pos: position{line: 3491, col: 22, offset: 118934},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 3491, col: 22, offset: 118934},
							label: "nameI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3491, col: 28, offset: 118940},
								expr: &seqExpr{
									pos: position{line: 3491, col: 29, offset: 118941},
									exprs: []any{
										&actionExpr{
											pos: position{line: 2371, col: 12, offset: 80907},
											run: (*parser).callonfuncVariadicParam6,
											expr: &labeledExpr{
												pos:   position{line: 2371, col: 12, offset: 80907},
												label: "ident",
												expr: &seqExpr{
													pos: position{line: 2410, col: 17, offset: 81833},
													exprs: []any{
														&charClassMatcher{
															pos:        position{line: 2393, col: 20, offset: 81588},
															val:        "[_\\pL]",
															chars:      []rune{'_'},
															classes:    []*unicode.RangeTable{rangeTable("L")},
															ignoreCase: false,
															inverted:   false,
														},
														&zeroOrMoreExpr{
															pos: position{line: 2410, col: 26, offset: 81842},
															expr: &charClassMatcher{
																pos:        position{line: 2393, col: 20, offset: 81588},
																val:        "[_\\pL\\pNd]",
																chars:      []rune{'_'},
																classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
										&oneOrMoreExpr{
											pos: position{line: 3491, col: 37, offset: 118949},
											expr: &litMatcher{
												pos:        position{line: 3491, col: 37, offset: 118949},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 3491, col: 44, offset: 118956},
							val:        "...",
							ignoreCase: false,
							want:       "\"...\"",
						},
						&labeledExpr{
							pos:   position{line: 3491, col: 50, offset: 118962},
							label: "typeI",
							expr: &ruleRefExpr{
								pos:  position{line: 3491, col: 56, offset: 118968},
								name: "funcType",
							},
						},
					},
				},
			},
		},
		{
			name: "funcType",
			pos:  position{line: 3516, col: 1, offset: 119547},
			expr: &choiceExpr{
				pos: position{line: 3516, col: 13, offset: 119559},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 3516, col: 13, offset: 119559},
						name: "GoType",
					},
					&actionExpr{
						pos: position{line: 3516, col: 22, offset: 119568},
						run: (*parser).callonfuncType3,
						expr: &seqExpr{
							pos: position{line: 3516, col: 22, offset: 119568},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3516, col: 22, offset: 119568},
									label: "typeI",
									expr: &oneOrMoreExpr{
										pos: position{line: 3516, col: 28, offset: 119574},
										expr: &charClassMatcher{
											pos:        position{line: 3516, col: 28, offset: 119574},
											val:        "[^,)]",
											chars:      []rune{',', ')'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3516, col: 35, offset: 119581},
									label: "endPosI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonfuncType9,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineText",
			pos:  position{line: 3534, col: 1, offset: 120099},
			expr: &actionExpr{
				pos: position{line: 3534, col: 15, offset: 120113},
				run: (*parser).callonInlineText1,
				expr: &seqExpr{
					pos: position{line: 3534, col: 15, offset: 120113},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 3534, col: 15, offset: 120113},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
						&labeledExpr{
							pos:   position{line: 3534, col: 19, offset: 120117},
							label: "lineI",
							expr: &ruleRefExpr{
								pos:  position{line: 3534, col: 25, offset: 120123},
								name: "TextLine",
							},
						},
					},
				},
			},
		},
		{
			name: "ArrowBlock",
			pos:  position{line: 3545, col: 1, offset: 120425},
			expr: &choiceExpr{
				pos: position{line: 3545, col: 15, offset: 120439},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3545, col: 15, offset: 120439},
						run: (*parser).callonArrowBlock2,
						expr: &seqExpr{
							pos: position{line: 3545, col: 15, offset: 120439},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3545, col: 15, offset: 120439},
									val:        "> ",
									ignoreCase: false,
									want:       "\"> \"",
								},
								&labeledExpr{
									pos:   position{line: 3545, col: 20, offset: 120444},
									label: "firstLineI",
									expr: &choiceExpr{
										pos: position{line: 3545, col: 32, offset: 120456},
										alternatives: []any{
											&ruleRefExpr{
												pos:  position{line: 3545, col: 32, offset: 120456},
												name: "TextLine",
											},
											&seqExpr{
												pos: position{line: 3796, col: 12, offset: 129156},
												exprs: []any{
													&zeroOrMoreExpr{
														pos: position{line: 3796, col: 12, offset: 129156},
														expr: &charClassMatcher{
															pos:        position{line: 3808, col: 36, offset: 129503},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3796, col: 16, offset: 129160},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 16, offset: 129160},
																exprs: []any{
																	&zeroOrOneExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		expr: &litMatcher{
																			pos:        position{line: 3796, col: 16, offset: 129160},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3796, col: 22, offset: 129166},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3795, col: 12, offset: 129142},
																expr: &anyMatcher{
																	line: 3795, col: 13, offset: 129143,
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3545, col: 48, offset: 120472},
									label: "additionalLinesI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3545, col: 65, offset: 120489},
										expr: &seqExpr{
											pos: position{line: 3545, col: 66, offset: 120490},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3545, col: 66, offset: 120490},
													expr: &oneOrMoreExpr{
														pos: position{line: 3810, col: 36, offset: 129590},
														expr: &seqExpr{
															pos: position{line: 3810, col: 37, offset: 129591},
															exprs: []any{
																&zeroOrMoreExpr{
																	pos: position{line: 3810, col: 37, offset: 129591},
																	expr: &charClassMatcher{
																		pos:        position{line: 3808, col: 36, offset: 129503},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 3809, col: 36, offset: 129544},
																	expr: &litMatcher{
																		pos:        position{line: 3809, col: 36, offset: 129544},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3809, col: 42, offset: 129550},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
												&ruleRefExpr{
													pos:  position{line: 3545, col: 75, offset: 120499},
													name: "INDENTATION2",
												},
												&ruleRefExpr{
													pos:  position{line: 3545, col: 88, offset: 120512},
													name: "TextLine",
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3566, col: 5, offset: 121027},
						run: (*parser).callonArrowBlock31,
						expr: &seqExpr{
							pos: position{line: 3566, col: 5, offset: 121027},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3566, col: 5, offset: 121027},
									val:        ">",
									ignoreCase: false,
									want:       "\">\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineArrowBlock",
			pos:  position{line: 3570, col: 1, offset: 121090},
			expr: &choiceExpr{
				pos: position{line: 3570, col: 21, offset: 121110},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3570, col: 21, offset: 121110},
						run: (*parser).callonInlineArrowBlock2,
						expr: &seqExpr{
							pos: position{line: 3570, col: 21, offset: 121110},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3570, col: 21, offset: 121110},
									val:        "> ",
									ignoreCase: false,
									want:       "\"> \"",
								},
								&labeledExpr{
									pos:   position{line: 3570, col: 26, offset: 121115},
									label: "lineI",
									expr: &ruleRefExpr{
										pos:  position{line: 3570, col: 32, offset: 121121},
										name: "TextLine",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3575, col: 5, offset: 121256},
						run: (*parser).callonInlineArrowBlock7,
						expr: &seqExpr{
							pos: position{line: 3575, col: 5, offset: 121256},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3575, col: 5, offset: 121256},
									val:        ">",
									ignoreCase: false,
									want:       "\">\"",
								},
								&labeledExpr{
									pos:   position{line: 3575, col: 9, offset: 121260},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3799, col: 8, offset: 129205},
										run: (*parser).callonInlineArrowBlock11,
										expr: &choiceExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											alternatives: []any{
												&andExpr{
													pos: position{line: 3799, col: 9, offset: 129206},
													expr: &anyMatcher{
														line: 3799, col: 10, offset: 129207,
													},
												},
												&notExpr{
													pos: position{line: 3799, col: 14, offset: 129211},
													expr: &anyMatcher{
														line: 3799, col: 15, offset: 129212,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3575, col: 18, offset: 121269},
									label: "lineI",
									expr: &ruleRefExpr{
										pos:  position{line: 3575, col: 24, offset: 121275},
										name: "TextLine",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TextLine",
			pos:  position{line: 3593, col: 1, offset: 121855},
			expr: &actionExpr{
				pos: position{line: 3593, col: 13, offset: 121867},
				run: (*parser).callonTextLine1,
				expr: &seqExpr{
					pos: position{line: 3593, col: 13, offset: 121867},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 3593, col: 13, offset: 121867},
							label: "itemsI",
							expr: &oneOrMoreExpr{
								pos: position{line: 3593, col: 20, offset: 121874},
								expr: &ruleRefExpr{
									pos:  position{line: 3593, col: 20, offset: 121874},
									name: "TextItem",
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3796, col: 12, offset: 129156},
							expr: &charClassMatcher{
								pos:        position{line: 3808, col: 36, offset: 129503},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3796, col: 16, offset: 129160},
							alternatives: []any{
								&seqExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									exprs: []any{
										&zeroOrOneExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											expr: &litMatcher{
												pos:        position{line: 3796, col: 16, offset: 129160},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3796, col: 22, offset: 129166},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3795, col: 12, offset: 129142},
									expr: &anyMatcher{
										line: 3795, col: 13, offset: 129143,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TextItem",
			pos:  position{line: 3601, col: 1, offset: 122141},
			expr: &choiceExpr{
				pos: position{line: 3601, col: 13, offset: 122153},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3607, col: 9, offset: 122362},
						run: (*parser).callonTextItem2,
						expr: &labeledExpr{
							pos:   position{line: 3607, col: 9, offset: 122362},
							label: "textI",
							expr: &oneOrMoreExpr{
								pos: position{line: 3607, col: 15, offset: 122368},
								expr: &choiceExpr{
									pos: position{line: 3607, col: 16, offset: 122369},
									alternatives: []any{
										&oneOrMoreExpr{
											pos: position{line: 3607, col: 16, offset: 122369},
											expr: &seqExpr{
												pos: position{line: 3607, col: 17, offset: 122370},
												exprs: []any{
													&notExpr{
														pos: position{line: 3607, col: 17, offset: 122370},
														expr: &seqExpr{
															pos: position{line: 3796, col: 12, offset: 129156},
															exprs: []any{
																&zeroOrMoreExpr{
																	pos: position{line: 3796, col: 12, offset: 129156},
																	expr: &charClassMatcher{
																		pos:        position{line: 3808, col: 36, offset: 129503},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&choiceExpr{
																	pos: position{line: 3796, col: 16, offset: 129160},
																	alternatives: []any{
																		&seqExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			exprs: []any{
																				&zeroOrOneExpr{
																					pos: position{line: 3796, col: 16, offset: 129160},
																					expr: &litMatcher{
																						pos:        position{line: 3796, col: 16, offset: 129160},
																						val:        "\r",
																						ignoreCase: false,
																						want:       "\"\\r\"",
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 3796, col: 22, offset: 129166},
																					val:        "\n",
																					ignoreCase: false,
																					want:       "\"\\n\"",
																				},
																			},
																		},
																		&notExpr{
																			pos: position{line: 3795, col: 12, offset: 129142},
																			expr: &anyMatcher{
																				line: 3795, col: 13, offset: 129143,
																			},
																		},
																	},
																},
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 3607, col: 22, offset: 122375},
														val:        "[^#]",
														chars:      []rune{'#'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 3607, col: 31, offset: 122384},
											val:        "##",
											ignoreCase: false,
											want:       "\"##\"",
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 3601, col: 20, offset: 122160},
						name: "Interpolation",
					},
				},
			},
		},
		{
			name: "Interpolation",
			pos:  position{line: 3618, col: 1, offset: 122672},
			expr: &choiceExpr{
				pos: position{line: 3618, col: 18, offset: 122689},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 3618, col: 18, offset: 122689},
						name: "SimpleInterpolation",
					},
					&ruleRefExpr{
						pos:  position{line: 3618, col: 40, offset: 122711},
						name: "ElementInterpolation",
					},
					&ruleRefExpr{
						pos:  position{line: 3618, col: 63, offset: 122734},
						name: "MixinCallInterpolation",
					},
					&actionExpr{
						pos: position{line: 3620, col: 21, offset: 122797},
						run: (*parser).callonInterpolation5,
						expr: &litMatcher{
							pos:        position{line: 3620, col: 21, offset: 122797},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
					},
				},
			},
		},
		{
			name: "SimpleInterpolation",
			pos:  position{line: 3644, col: 1, offset: 123635},
			expr: &choiceExpr{
				pos: position{line: 3644, col: 24, offset: 123658},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3644, col: 24, offset: 123658},
						run: (*parser).callonSimpleInterpolation2,
						expr: &seqExpr{
							pos: position{line: 3644, col: 24, offset: 123658},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3644, col: 24, offset: 123658},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 3644, col: 28, offset: 123662},
									label: "noEscapeI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3644, col: 38, offset: 123672},
										expr: &litMatcher{
											pos:        position{line: 3644, col: 38, offset: 123672},
											val:        "!",
											ignoreCase: false,
											want:       "\"!\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3644, col: 43, offset: 123677},
									label: "valueI",
									expr: &choiceExpr{
										pos: position{line: 3721, col: 27, offset: 126477},
										alternatives: []any{
											&actionExpr{
												pos: position{line: 3721, col: 27, offset: 126477},
												run: (*parser).callonSimpleInterpolation10,
												expr: &seqExpr{
													pos: position{line: 3721, col: 27, offset: 126477},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 3721, col: 27, offset: 126477},
															label: "lBracketPosI",
															expr: &actionExpr{
																pos: position{line: 3824, col: 14, offset: 129997},
																run: (*parser).callonSimpleInterpolation13,
																expr: &litMatcher{
																	pos:        position{line: 3824, col: 14, offset: 129997},
																	val:        "[",
																	ignoreCase: false,
																	want:       "\"[\"",
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 3721, col: 50, offset: 126500},
															label: "textI",
															expr: &zeroOrMoreExpr{
																pos: position{line: 3721, col: 56, offset: 126506},
																expr: &charClassMatcher{
																	pos:        position{line: 3721, col: 56, offset: 126506},
																	val:        "[^]\\r\\n]",
																	chars:      []rune{']', '\r', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 3721, col: 67, offset: 126517},
															label: "rBracketPosI",
															expr: &actionExpr{
																pos: position{line: 3825, col: 14, offset: 130037},
																run: (*parser).callonSimpleInterpolation19,
																expr: &litMatcher{
																	pos:        position{line: 3825, col: 14, offset: 130037},
																	val:        "]",
																	ignoreCase: false,
																	want:       "\"]\"",
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 3727, col: 5, offset: 126728},
												run: (*parser).callonSimpleInterpolation21,
												expr: &seqExpr{
													pos: position{line: 3727, col: 5, offset: 126728},
													exprs: []any{
														&labeledExpr{
															pos:   position{line: 3727, col: 5, offset: 126728},
															label: "lBracketPosI",
															expr: &actionExpr{
																pos: position{line: 3824, col: 14, offset: 129997},
																run: (*parser).callonSimpleInterpolation24,
																expr: &litMatcher{
																	pos:        position{line: 3824, col: 14, offset: 129997},
																	val:        "[",
																	ignoreCase: false,
																	want:       "\"[\"",
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 3727, col: 28, offset: 126751},
															label: "textI",
															expr: &zeroOrMoreExpr{
																pos: position{line: 3727, col: 34, offset: 126757},
																expr: &charClassMatcher{
																	pos:        position{line: 3727, col: 34, offset: 126757},
																	val:        "[^]\\r\\n]",
																	chars:      []rune{']', '\r', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 3796, col: 12, offset: 129156},
															expr: &charClassMatcher{
																pos:        position{line: 3808, col: 36, offset: 129503},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&choiceExpr{
															pos: position{line: 3796, col: 16, offset: 129160},
															alternatives: []any{
																&seqExpr{
																	pos: position{line: 3796, col: 16, offset: 129160},
																	exprs: []any{
																		&zeroOrOneExpr{
																			pos: position{line: 3796, col: 16, offset: 129160},
																			expr: &litMatcher{
																				pos:        position{line: 3796, col: 16, offset: 129160},
																				val:        "\r",
																				ignoreCase: false,
																				want:       "\"\\r\"",
																			},
																		},
																		&litMatcher{
																			pos:        position{line: 3796, col: 22, offset: 129166},
																			val:        "\n",
																			ignoreCase: false,
																			want:       "\"\\n\"",
																		},
																	},
																},
																&notExpr{
																	pos: position{line: 3795, col: 12, offset: 129142},
																	expr: &anyMatcher{
																		line: 3795, col: 13, offset: 129143,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3650, col: 5, offset: 123872},
						run: (*parser).callonSimpleInterpolation38,
						expr: &seqExpr{
							pos: position{line: 3650, col: 5, offset: 123872},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 3650, col: 5, offset: 123872},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 3650, col: 9, offset: 123876},
									label: "valueI",
									expr: &choiceExpr{
										pos: position{line: 3650, col: 17, offset: 123884},
										alternatives: []any{
											&ruleRefExpr{
												pos:  position{line: 3650, col: 17, offset: 123884},
												name: "expressionInterpolationValue",
											},
											&ruleRefExpr{
												pos:  position{line: 3650, col: 48, offset: 123915},
												name: "fmtExpressionInterpolationValue",
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ElementInterpolation",
			pos:  position{line: 3661, col: 1, offset: 124271},
			expr: &actionExpr{
				pos: position{line: 3661, col: 25, offset: 124295},
				run: (*parser).callonElementInterpolation1,
				expr: &seqExpr{
					pos: position{line: 3661, col: 25, offset: 124295},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 3661, col: 25, offset: 124295},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&labeledExpr{
							pos:   position{line: 3661, col: 29, offset: 124299},
							label: "elPosI",
							expr: &actionExpr{
								pos: position{line: 3799, col: 8, offset: 129205},
								run: (*parser).callonElementInterpolation5,
								expr: &choiceExpr{
									pos: position{line: 3799, col: 9, offset: 129206},
									alternatives: []any{
										&andExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											expr: &anyMatcher{
												line: 3799, col: 10, offset: 129207,
											},
										},
										&notExpr{
											pos: position{line: 3799, col: 14, offset: 129211},
											expr: &anyMatcher{
												line: 3799, col: 15, offset: 129212,
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3661, col: 40, offset: 124310},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2879, col: 16, offset: 99517},
								expr: &charClassMatcher{
									pos:        position{line: 2865, col: 27, offset: 98856},
									val:        "[0-9A-Za-z]",
									ranges:     []rune{'0', '9', 'A', 'Z', 'a', 'z'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3661, col: 58, offset: 124328},
							label: "attrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3661, col: 65, offset: 124335},
								expr: &ruleRefExpr{
									pos:  position{line: 3661, col: 65, offset: 124335},
									name: "SingleLineAttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3661, col: 96, offset: 124366},
							label: "valueI",
							expr: &ruleRefExpr{
								pos:  position{line: 3661, col: 103, offset: 124373},
								name: "elementInterpolationValue",
							},
						},
					},
				},
			},
		},
		{
			name: "elementInterpolationValue",
			pos:  position{line: 3674, col: 1, offset: 124778},
			expr: &choiceExpr{
				pos: position{line: 3674, col: 30, offset: 124807},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3721, col: 27, offset: 126477},
						run: (*parser).callonelementInterpolationValue2,
						expr: &seqExpr{
							pos: position{line: 3721, col: 27, offset: 126477},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3721, col: 27, offset: 126477},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3824, col: 14, offset: 129997},
										run: (*parser).callonelementInterpolationValue5,
										expr: &litMatcher{
											pos:        position{line: 3824, col: 14, offset: 129997},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3721, col: 50, offset: 126500},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3721, col: 56, offset: 126506},
										expr: &charClassMatcher{
											pos:        position{line: 3721, col: 56, offset: 126506},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3721, col: 67, offset: 126517},
									label: "rBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3825, col: 14, offset: 130037},
										run: (*parser).callonelementInterpolationValue11,
										expr: &litMatcher{
											pos:        position{line: 3825, col: 14, offset: 130037},
											val:        "]",
											ignoreCase: false,
											want:       "\"]\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3727, col: 5, offset: 126728},
						run: (*parser).callonelementInterpolationValue13,
						expr: &seqExpr{
							pos: position{line: 3727, col: 5, offset: 126728},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3727, col: 5, offset: 126728},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3824, col: 14, offset: 129997},
										run: (*parser).callonelementInterpolationValue16,
										expr: &litMatcher{
											pos:        position{line: 3824, col: 14, offset: 129997},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3727, col: 28, offset: 126751},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3727, col: 34, offset: 126757},
										expr: &charClassMatcher{
											pos:        position{line: 3727, col: 34, offset: 126757},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 3674, col: 55, offset: 124832},
						name: "expressionInterpolationValue",
					},
					&actionExpr{
						pos: position{line: 3674, col: 86, offset: 124863},
						run: (*parser).callonelementInterpolationValue31,
						expr: &litMatcher{
							pos:        position{line: 3674, col: 86, offset: 124863},
							val:        "/",
							ignoreCase: false,
							want:       "\"/\"",
						},
					},
					&actionExpr{
						pos: position{line: 3676, col: 5, offset: 124915},
						run: (*parser).callonelementInterpolationValue33,
						expr: &andExpr{
							pos: position{line: 3676, col: 5, offset: 124915},
							expr: &choiceExpr{
								pos: position{line: 3676, col: 7, offset: 124917},
								alternatives: []any{
									&anyMatcher{
										line: 3676, col: 7, offset: 124917,
									},
									&notExpr{
										pos: position{line: 3676, col: 11, offset: 124921},
										expr: &anyMatcher{
											line: 3676, col: 12, offset: 124922,
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "MixinCallInterpolation",
			pos:  position{line: 3690, col: 1, offset: 125402},
			expr: &actionExpr{
				pos: position{line: 3690, col: 27, offset: 125428},
				run: (*parser).callonMixinCallInterpolation1,
				expr: &seqExpr{
					pos: position{line: 3690, col: 27, offset: 125428},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 3690, col: 27, offset: 125428},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&labeledExpr{
							pos:   position{line: 3690, col: 31, offset: 125432},
							label: "mcPosI",
							expr: &actionExpr{
								pos: position{line: 3799, col: 8, offset: 129205},
								run: (*parser).callonMixinCallInterpolation5,
								expr: &choiceExpr{
									pos: position{line: 3799, col: 9, offset: 129206},
									alternatives: []any{
										&andExpr{
											pos: position{line: 3799, col: 9, offset: 129206},
											expr: &anyMatcher{
												line: 3799, col: 10, offset: 129207,
											},
										},
										&notExpr{
											pos: position{line: 3799, col: 14, offset: 129211},
											expr: &anyMatcher{
												line: 3799, col: 15, offset: 129212,
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 3690, col: 42, offset: 125443},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 3690, col: 46, offset: 125447},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3690, col: 57, offset: 125458},
								expr: &seqExpr{
									pos: position{line: 3690, col: 58, offset: 125459},
									exprs: []any{
										&choiceExpr{
											pos: position{line: 759, col: 10, offset: 23002},
											alternatives: []any{
												&actionExpr{
													pos: position{line: 759, col: 10, offset: 23002},
													run: (*parser).callonMixinCallInterpolation16,
													expr: &labeledExpr{
														pos:   position{line: 759, col: 10, offset: 23002},
														label: "identI",
														expr: &seqExpr{
															pos: position{line: 2410, col: 17, offset: 81833},
															exprs: []any{
																&charClassMatcher{
																	pos:        position{line: 2393, col: 20, offset: 81588},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2410, col: 26, offset: 81842},
																	expr: &charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 761, col: 5, offset: 23096},
													run: (*parser).callonMixinCallInterpolation22,
													expr: &seqExpr{
														pos: position{line: 761, col: 5, offset: 23096},
														exprs: []any{
															&labeledExpr{
																pos:   position{line: 761, col: 5, offset: 23096},
																label: "identI",
																expr: &seqExpr{
																	pos: position{line: 761, col: 13, offset: 23104},
																	exprs: []any{
																		&zeroOrOneExpr{
																			pos: position{line: 761, col: 13, offset: 23104},
																			expr: &litMatcher{
																				pos:        position{line: 761, col: 13, offset: 23104},
																				val:        "$",
																				ignoreCase: false,
																				want:       "\"$\"",
																			},
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 761, col: 18, offset: 23109},
																			expr: &choiceExpr{
																				pos: position{line: 761, col: 19, offset: 23110},
																				alternatives: []any{
																					&seqExpr{
																						pos: position{line: 761, col: 19, offset: 23110},
																						exprs: []any{
																							&charClassMatcher{
																								pos:        position{line: 761, col: 19, offset: 23110},
																								val:        "[\\pNd]",
																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 761, col: 28, offset: 23119},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 761, col: 38, offset: 23129},
																						val:        "[_-\\pL]",
																						chars:      []rune{'_', '-'},
																						classes:    []*unicode.RangeTable{rangeTable("L")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&labeledExpr{
																pos:   position{line: 761, col: 49, offset: 23140},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3799, col: 8, offset: 129205},
																	run: (*parser).callonMixinCallInterpolation35,
																	expr: &choiceExpr{
																		pos: position{line: 3799, col: 9, offset: 129206},
																		alternatives: []any{
																			&andExpr{
																				pos: position{line: 3799, col: 9, offset: 129206},
																				expr: &anyMatcher{
																					line: 3799, col: 10, offset: 129207,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3799, col: 14, offset: 129211},
																				expr: &anyMatcher{
																					line: 3799, col: 15, offset: 129212,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 3690, col: 64, offset: 125465},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3690, col: 70, offset: 125471},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 773, col: 14, offset: 23557},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 773, col: 14, offset: 23557},
										run: (*parser).callonMixinCallInterpolation44,
										expr: &labeledExpr{
											pos:   position{line: 773, col: 14, offset: 23557},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 759, col: 10, offset: 23002},
												alternatives: []any{
													&actionExpr{
														pos: position{line: 759, col: 10, offset: 23002},
														run: (*parser).callonMixinCallInterpolation47,
														expr: &labeledExpr{
															pos:   position{line: 759, col: 10, offset: 23002},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2410, col: 17, offset: 81833},
																exprs: []any{
																	&charClassMatcher{
																		pos:        position{line: 2393, col: 20, offset: 81588},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2410, col: 26, offset: 81842},
																		expr: &charClassMatcher{
																			pos:        position{line: 2393, col: 20, offset: 81588},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 761, col: 5, offset: 23096},
														run: (*parser).callonMixinCallInterpolation53,
														expr: &seqExpr{
															pos: position{line: 761, col: 5, offset: 23096},
															exprs: []any{
																&labeledExpr{
																	pos:   position{line: 761, col: 5, offset: 23096},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 761, col: 13, offset: 23104},
																		exprs: []any{
																			&zeroOrOneExpr{
																				pos: position{line: 761, col: 13, offset: 23104},
																				expr: &litMatcher{
																					pos:        position{line: 761, col: 13, offset: 23104},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 761, col: 18, offset: 23109},
																				expr: &choiceExpr{
																					pos: position{line: 761, col: 19, offset: 23110},
																					alternatives: []any{
																						&seqExpr{
																							pos: position{line: 761, col: 19, offset: 23110},
																							exprs: []any{
																								&charClassMatcher{
																									pos:        position{line: 761, col: 19, offset: 23110},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 761, col: 28, offset: 23119},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 761, col: 38, offset: 23129},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 761, col: 49, offset: 23140},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3799, col: 8, offset: 129205},
																		run: (*parser).callonMixinCallInterpolation66,
																		expr: &choiceExpr{
																			pos: position{line: 3799, col: 9, offset: 129206},
																			alternatives: []any{
																				&andExpr{
																					pos: position{line: 3799, col: 9, offset: 129206},
																					expr: &anyMatcher{
																						line: 3799, col: 10, offset: 129207,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3799, col: 14, offset: 129211},
																					expr: &anyMatcher{
																						line: 3799, col: 15, offset: 129212,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 775, col: 5, offset: 23599},
										run: (*parser).callonMixinCallInterpolation72,
										expr: &seqExpr{
											pos: position{line: 775, col: 5, offset: 23599},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 775, col: 5, offset: 23599},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonMixinCallInterpolation75,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
												&andExpr{
													pos: position{line: 775, col: 14, offset: 23608},
													expr: &choiceExpr{
														pos: position{line: 775, col: 16, offset: 23610},
														alternatives: []any{
															&seqExpr{
																pos: position{line: 3796, col: 12, offset: 129156},
																exprs: []any{
																	&zeroOrMoreExpr{
																		pos: position{line: 3796, col: 12, offset: 129156},
																		expr: &charClassMatcher{
																			pos:        position{line: 3808, col: 36, offset: 129503},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3796, col: 16, offset: 129160},
																		alternatives: []any{
																			&seqExpr{
																				pos: position{line: 3796, col: 16, offset: 129160},
																				exprs: []any{
																					&zeroOrOneExpr{
																						pos: position{line: 3796, col: 16, offset: 129160},
																						expr: &litMatcher{
																							pos:        position{line: 3796, col: 16, offset: 129160},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3796, col: 22, offset: 129166},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3795, col: 12, offset: 129142},
																				expr: &anyMatcher{
																					line: 3795, col: 13, offset: 129143,
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 775, col: 22, offset: 23616},
																val:        "[:!=()]",
																chars:      []rune{':', '!', '=', '(', ')'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 786, col: 5, offset: 23948},
										run: (*parser).callonMixinCallInterpolation94,
										expr: &seqExpr{
											pos: position{line: 786, col: 5, offset: 23948},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 786, col: 5, offset: 23948},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 786, col: 12, offset: 23955},
														expr: &charClassMatcher{
															pos:        position{line: 786, col: 12, offset: 23955},
															val:        "[^ \\t\\r\\n:!=()]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '(', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 786, col: 29, offset: 23972},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonMixinCallInterpolation100,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3690, col: 86, offset: 125487},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3690, col: 92, offset: 125493},
								expr: &ruleRefExpr{
									pos:  position{line: 3690, col: 92, offset: 125493},
									name: "singleLineMixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3690, col: 116, offset: 125517},
							label: "valueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3690, col: 123, offset: 125524},
								expr: &ruleRefExpr{
									pos:  position{line: 3690, col: 123, offset: 125524},
									name: "mixinCallInterpolationValue",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallInterpolationValue",
			pos:  position{line: 3712, col: 1, offset: 126142},
			expr: &choiceExpr{
				pos: position{line: 3712, col: 32, offset: 126173},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3721, col: 27, offset: 126477},
						run: (*parser).callonmixinCallInterpolationValue2,
						expr: &seqExpr{
							pos: position{line: 3721, col: 27, offset: 126477},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3721, col: 27, offset: 126477},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3824, col: 14, offset: 129997},
										run: (*parser).callonmixinCallInterpolationValue5,
										expr: &litMatcher{
											pos:        position{line: 3824, col: 14, offset: 129997},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3721, col: 50, offset: 126500},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3721, col: 56, offset: 126506},
										expr: &charClassMatcher{
											pos:        position{line: 3721, col: 56, offset: 126506},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3721, col: 67, offset: 126517},
									label: "rBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3825, col: 14, offset: 130037},
										run: (*parser).callonmixinCallInterpolationValue11,
										expr: &litMatcher{
											pos:        position{line: 3825, col: 14, offset: 130037},
											val:        "]",
											ignoreCase: false,
											want:       "\"]\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3727, col: 5, offset: 126728},
						run: (*parser).callonmixinCallInterpolationValue13,
						expr: &seqExpr{
							pos: position{line: 3727, col: 5, offset: 126728},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3727, col: 5, offset: 126728},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3824, col: 14, offset: 129997},
										run: (*parser).callonmixinCallInterpolationValue16,
										expr: &litMatcher{
											pos:        position{line: 3824, col: 14, offset: 129997},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3727, col: 28, offset: 126751},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3727, col: 34, offset: 126757},
										expr: &charClassMatcher{
											pos:        position{line: 3727, col: 34, offset: 126757},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 3712, col: 57, offset: 126198},
						name: "expressionInterpolationValue",
					},
				},
			},
		},
		{
			name: "expressionInterpolationValue",
			pos:  position{line: 3755, col: 1, offset: 127579},
			expr: &choiceExpr{
				pos: position{line: 3755, col: 33, offset: 127611},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 3755, col: 33, offset: 127611},
						run: (*parser).callonexpressionInterpolationValue2,
						expr: &seqExpr{
							pos: position{line: 3755, col: 33, offset: 127611},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3755, col: 33, offset: 127611},
									label: "lBracePosI",
									expr: &actionExpr{
										pos: position{line: 3821, col: 12, offset: 129918},
										run: (*parser).callonexpressionInterpolationValue5,
										expr: &litMatcher{
											pos:        position{line: 3821, col: 12, offset: 129918},
											val:        "{",
											ignoreCase: false,
											want:       "\"{\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3755, col: 52, offset: 127630},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 3755, col: 58, offset: 127636},
										name: "SingleLineExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 3755, col: 79, offset: 127657},
									label: "rBracePosI",
									expr: &actionExpr{
										pos: position{line: 3822, col: 12, offset: 129956},
										run: (*parser).callonexpressionInterpolationValue10,
										expr: &litMatcher{
											pos:        position{line: 3822, col: 12, offset: 129956},
											val:        "}",
											ignoreCase: false,
											want:       "\"}\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3761, col: 5, offset: 127878},
						run: (*parser).callonexpressionInterpolationValue12,
						expr: &seqExpr{
							pos: position{line: 3761, col: 5, offset: 127878},
							exprs: []any{
								&labeledExpr{
									pos:   position{line: 3761, col: 5, offset: 127878},
									label: "lBracePosI",
									expr: &actionExpr{
										pos: position{line: 3821, col: 12, offset: 129918},
										run: (*parser).callonexpressionInterpolationValue15,
										expr: &litMatcher{
											pos:        position{line: 3821, col: 12, offset: 129918},
											val:        "{",
											ignoreCase: false,
											want:       "\"{\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3761, col: 24, offset: 127897},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 3761, col: 30, offset: 127903},
										name: "SingleLineExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3796, col: 12, offset: 129156},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3796, col: 16, offset: 129160},
									alternatives: []any{
										&seqExpr{
											pos: position{line: 3796, col: 16, offset: 129160},
											exprs: []any{
												&zeroOrOneExpr{
													pos: position{line: 3796, col: 16, offset: 129160},
													expr: &litMatcher{
														pos:        position{line: 3796, col: 16, offset: 129160},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3796, col: 22, offset: 129166},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3795, col: 12, offset: 129142},
											expr: &anyMatcher{
												line: 3795, col: 13, offset: 129143,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "fmtExpressionInterpolationValue",
			pos:  position{line: 3785, col: 1, offset: 128720},
			expr: &actionExpr{
				pos: position{line: 3785, col: 36, offset: 128755},
				run: (*parser).callonfmtExpressionInterpolationValue1,
				expr: &seqExpr{
					pos: position{line: 3785, col: 36, offset: 128755},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 3785, col: 36, offset: 128755},
							label: "fmtDirectiveI",
							expr: &choiceExpr{
								pos: position{line: 1840, col: 17, offset: 60144},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 1840, col: 17, offset: 60144},
										run: (*parser).callonfmtExpressionInterpolationValue5,
										expr: &seqExpr{
											pos: position{line: 1840, col: 17, offset: 60144},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 1840, col: 17, offset: 60144},
													val:        "%",
													ignoreCase: false,
													want:       "\"%\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 1840, col: 21, offset: 60148},
													expr: &charClassMatcher{
														pos:        position{line: 1856, col: 12, offset: 60825},
														val:        "[ 0+-#]",
														chars:      []rune{' ', '0'},
														ranges:     []rune{'+', '#'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 1840, col: 30, offset: 60157},
													expr: &seqExpr{
														pos: position{line: 1840, col: 31, offset: 60158},
														exprs: []any{
															&charClassMatcher{
																pos:        position{line: 1840, col: 31, offset: 60158},
																val:        "[1-9]",
																ranges:     []rune{'1', '9'},
																ignoreCase: false,
																inverted:   false,
															},
															&zeroOrMoreExpr{
																pos: position{line: 1840, col: 36, offset: 60163},
																expr: &charClassMatcher{
																	pos:        position{line: 1840, col: 36, offset: 60163},
																	val:        "[0-9]",
																	ranges:     []rune{'0', '9'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 1840, col: 45, offset: 60172},
													expr: &seqExpr{
														pos: position{line: 1840, col: 46, offset: 60173},
														exprs: []any{
															&litMatcher{
																pos:        position{line: 1840, col: 46, offset: 60173},
																val:        ".",
																ignoreCase: false,
																want:       "\".\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1840, col: 50, offset: 60177},
																expr: &charClassMatcher{
																	pos:        position{line: 1840, col: 50, offset: 60177},
																	val:        "[0-9]",
																	ranges:     []rune{'0', '9'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
												},
												&choiceExpr{
													pos: position{line: 1857, col: 12, offset: 60844},
													alternatives: []any{
														&charClassMatcher{
															pos:        position{line: 1857, col: 12, offset: 60844},
															val:        "[vTtbcdoOqxXUeEfFgGsp]",
															chars:      []rune{'v', 'T', 't', 'b', 'c', 'd', 'o', 'O', 'q', 'x', 'X', 'U', 'e', 'E', 'f', 'F', 'g', 'G', 's', 'p'},
															ignoreCase: false,
															inverted:   false,
														},
														&actionExpr{
															pos: position{line: 1857, col: 74, offset: 60906},
															run: (*parser).callonfmtExpressionInterpolationValue22,
															expr: &andExpr{
																pos: position{line: 1857, col: 74, offset: 60906},
																expr: &charClassMatcher{
																	pos:        position{line: 1857, col: 76, offset: 60908},
																	val:        "[{\"`]",
																	chars:      []rune{'{', '"', '`'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&actionExpr{
															pos: position{line: 1869, col: 5, offset: 61445},
															run: (*parser).callonfmtExpressionInterpolationValue25,
															expr: &anyMatcher{
																line: 1869, col: 5, offset: 61445,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1842, col: 5, offset: 60235},
										run: (*parser).callonfmtExpressionInterpolationValue27,
										expr: &seqExpr{
											pos: position{line: 1842, col: 5, offset: 60235},
											exprs: []any{
												&litMatcher{
													pos:        position{line: 1842, col: 5, offset: 60235},
													val:        "%",
													ignoreCase: false,
													want:       "\"%\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 1842, col: 9, offset: 60239},
													expr: &charClassMatcher{
														pos:        position{line: 1842, col: 9, offset: 60239},
														val:        "[^`\"{]",
														chars:      []rune{'`', '"', '{'},
														ignoreCase: false,
														inverted:   true,
													},
												},
												&labeledExpr{
													pos:   position{line: 1842, col: 17, offset: 60247},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3799, col: 8, offset: 129205},
														run: (*parser).callonfmtExpressionInterpolationValue33,
														expr: &choiceExpr{
															pos: position{line: 3799, col: 9, offset: 129206},
															alternatives: []any{
																&andExpr{
																	pos: position{line: 3799, col: 9, offset: 129206},
																	expr: &anyMatcher{
																		line: 3799, col: 10, offset: 129207,
																	},
																},
																&notExpr{
																	pos: position{line: 3799, col: 14, offset: 129211},
																	expr: &anyMatcher{
																		line: 3799, col: 15, offset: 129212,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3785, col: 63, offset: 128782},
							label: "eivI",
							expr: &ruleRefExpr{
								pos:  position{line: 3785, col: 68, offset: 128787},
								name: "expressionInterpolationValue",
							},
						},
					},
				},
			},
		},
		{
			name: "INDENTATION_IGNORE_ADDITIONAL",
			pos:  position{line: 4119, col: 1, offset: 143077},
			expr: &choiceExpr{
				pos: position{line: 4119, col: 34, offset: 143110},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 4119, col: 34, offset: 143110},
						exprs: []any{
							&andCodeExpr{
								pos: position{line: 4119, col: 34, offset: 143110},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL3,
							},
							&actionExpr{
								pos: position{line: 3897, col: 17, offset: 133397},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL4,
								expr: &zeroOrMoreExpr{
									pos: position{line: 3897, col: 17, offset: 133397},
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 3897, col: 41, offset: 133421},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL7,
							},
							&choiceExpr{
								pos: position{line: 3949, col: 5, offset: 135331},
								alternatives: []any{
									&andCodeExpr{
										pos: position{line: 3949, col: 5, offset: 135331},
										run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL9,
									},
									&seqExpr{
										pos: position{line: 3951, col: 9, offset: 135414},
										exprs: []any{
											&andCodeExpr{
												pos: position{line: 3951, col: 9, offset: 135414},
												run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL11,
											},
											&stateCodeExpr{
												pos: position{line: 3953, col: 7, offset: 135537},
												run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL12,
											},
										},
									},
									&seqExpr{
										pos: position{line: 3960, col: 9, offset: 135873},
										exprs: []any{
											&andCodeExpr{
												pos: position{line: 3960, col: 9, offset: 135873},
												run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL14,
											},
											&andCodeExpr{
												pos: position{line: 3962, col: 7, offset: 135981},
												run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL15,
											},
											&choiceExpr{
												pos: position{line: 4015, col: 9, offset: 138316},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 4015, col: 9, offset: 138316},
														exprs: []any{
															&andCodeExpr{
																pos: position{line: 4015, col: 9, offset: 138316},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL18,
															},
															&andCodeExpr{
																pos: position{line: 4019, col: 11, offset: 138566},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL19,
															},
															&stateCodeExpr{
																pos: position{line: 4085, col: 11, offset: 141772},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL20,
															},
														},
													},
													&seqExpr{
														pos: position{line: 4093, col: 13, offset: 142125},
														exprs: []any{
															&andCodeExpr{
																pos: position{line: 4093, col: 13, offset: 142125},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL22,
															},
															&andCodeExpr{
																pos: position{line: 4097, col: 11, offset: 142380},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL23,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 4122, col: 17, offset: 143261},
						exprs: []any{
							&andCodeExpr{
								pos: position{line: 4122, col: 17, offset: 143261},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL25,
							},
							&ruleRefExpr{
								pos:  position{line: 4124, col: 3, offset: 143327},
								name: "_INDENTATION_IGNORE_ADDITIONAL",
							},
						},
					},
				},
			},
		},
		{
			name: "_INDENTATION_IGNORE_ADDITIONAL",
			pos:  position{line: 4126, col: 1, offset: 143359},
			expr: &choiceExpr{
				pos: position{line: 4126, col: 35, offset: 143393},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 4127, col: 5, offset: 143399},
						exprs: []any{
							&choiceExpr{
								pos: position{line: 4128, col: 9, offset: 143409},
								alternatives: []any{
									&seqExpr{
										pos: position{line: 4128, col: 9, offset: 143409},
										exprs: []any{
											&andCodeExpr{
												pos: position{line: 4128, col: 9, offset: 143409},
												run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL5,
											},
											&choiceExpr{
												pos: position{line: 4133, col: 13, offset: 143673},
												alternatives: []any{
													&seqExpr{
														pos: position{line: 4133, col: 13, offset: 143673},
														exprs: []any{
															&andExpr{
																pos: position{line: 4133, col: 13, offset: 143673},
																expr: &charClassMatcher{
																	pos:        position{line: 3808, col: 36, offset: 129503},
																	val:        "[ \\t]",
																	chars:      []rune{' ', '\t'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&andCodeExpr{
																pos: position{line: 4133, col: 16, offset: 143676},
																run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL10,
															},
														},
													},
													&seqExpr{
														pos: position{line: 4144, col: 17, offset: 144070},
														exprs: []any{
															&notExpr{
																pos: position{line: 4144, col: 17, offset: 144070},
																expr: &charClassMatcher{
																	pos:        position{line: 3808, col: 36, offset: 129503},
																	val:        "[ \\t]",
																	chars:      []rune{' ', '\t'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&andCodeExpr{
																pos: position{line: 4144, col: 20, offset: 144073},
																run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL14,
															},
														},
													},
												},
											},
											&stateCodeExpr{
												pos: position{line: 4209, col: 11, offset: 147304},
												run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL15,
											},
										},
									},
									&seqExpr{
										pos: position{line: 4216, col: 13, offset: 147626},
										exprs: []any{
											&andCodeExpr{
												pos: position{line: 4216, col: 13, offset: 147626},
												run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL17,
											},
											&andCodeExpr{
												pos: position{line: 4220, col: 11, offset: 147881},
												run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL18,
											},
										},
									},
								},
							},
							&stateCodeExpr{
								pos: position{line: 4225, col: 7, offset: 148062},
								run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL19,
							},
						},
					},
					&seqExpr{
						pos: position{line: 4229, col: 5, offset: 148139},
						exprs: []any{
							&labeledExpr{
								pos:   position{line: 4229, col: 5, offset: 148139},
								label: "spaceI",
								expr: &actionExpr{
									pos: position{line: 4229, col: 13, offset: 148147},
									run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL22,
									expr: &charClassMatcher{
										pos:        position{line: 3808, col: 36, offset: 129503},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 4229, col: 39, offset: 148173},
								run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL24,
							},
							&stateCodeExpr{
								pos: position{line: 4279, col: 3, offset: 149985},
								run: (*parser).callon_INDENTATION_IGNORE_ADDITIONAL25,
							},
							&ruleRefExpr{
								pos:  position{line: 4282, col: 3, offset: 150087},
								name: "_INDENTATION_IGNORE_ADDITIONAL",
							},
						},
					},
				},
			},
		},
		{
			name: "INDENTATION2",
			pos:  position{line: 4302, col: 1, offset: 150756},
			expr: &choiceExpr{
				pos: position{line: 4302, col: 17, offset: 150772},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 4302, col: 17, offset: 150772},
						exprs: []any{
							&andCodeExpr{
								pos: position{line: 4302, col: 17, offset: 150772},
								run: (*parser).callonINDENTATION23,
							},
							&litMatcher{
								pos:        position{line: 4304, col: 3, offset: 150833},
								val:        "  ",
								ignoreCase: false,
								want:       "\"  \"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 4304, col: 10, offset: 150840},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 4304, col: 10, offset: 150840},
								name: "INDENTATION_IGNORE_ADDITIONAL",
							},
							&litMatcher{
								pos:        position{line: 4304, col: 40, offset: 150870},
								val:        "  ",
								ignoreCase: false,
								want:       "\"  \"",
							},
						},
					},
				},
			},
		},
	},
}

func (c *current) onFile3() error {
	c.state["Indentation.Level"] = 0       // the lvl we are in rn
	c.state["Indentation.Char"] = byte(0)  // the char used for indentation
	c.state["Indentation.Repetitions"] = 0 // num of repetitions of char per lvl
	c.state["Indentation.RefLine"] = 0     // the line no where we got char and repetitions from

	// a stack containing the actual number of repetitions of char per lvl
	// used to recover from inconsistent indentations errs
	c.state["Indentation.ActualRepetitions"] = &stack.Stack[int]{}
	c.state["Indentation.TotalRepetitions"] = 0 // sum of the stack above

	// used by INDENTATION_NO_INCREASE to count how many chars it has found
	c.state["Indentation.CharCount"] = 0
	return nil
}

func (p *parser) callonFile3() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile3()
}

func (c *current) onFile1(extendAndCommentsI, importsAndCommentsI, usesAndCommentsI, globalCodeAndFuncI, preScopeI, scopeI any) (any, error) {
	var f file.File

	if extendAndCommentsI != nil {
		f.Extend = ptrOrNil[file.Extend](getTuple[file.Extend](extendAndCommentsI, 0))
		f.TopLevelComments = append(f.TopLevelComments, getTuple[[]file.CorgiComment](extendAndCommentsI, 1)...)
	}

	if importsAndCommentsI != nil {
		f.Imports = getTuple[[]file.Import](importsAndCommentsI, 0)
		f.TopLevelComments = append(f.TopLevelComments, getTuple[[]file.CorgiComment](importsAndCommentsI, 1)...)
	}

	if usesAndCommentsI != nil {
		f.Uses = getTuple[[]file.Use](usesAndCommentsI, 0)
		f.TopLevelComments = append(f.TopLevelComments, getTuple[[]file.CorgiComment](usesAndCommentsI, 1)...)
	}

	if globalCodeAndFuncI != nil {
		partFile := globalCodeAndFuncI.(file.File)

		f.TopLevelComments = append(f.TopLevelComments, partFile.TopLevelComments...)
		f.GlobalCode = partFile.GlobalCode
		f.Func = partFile.Func
	}

	preScope := castedOrZero[file.Scope](preScopeI)
	s := castedOrZero[file.Scope](scopeI)

	f.Scope = append(preScope, s...)

	return &f, nil
}

func (p *parser) callonFile1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile1(stack["extendAndCommentsI"], stack["importsAndCommentsI"], stack["usesAndCommentsI"], stack["globalCodeAndFuncI"], stack["preScopeI"], stack["scopeI"])
}

func (c *current) onextendAndComments26(strI any) (any, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonextendAndComments26() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments26(stack["strI"])
}

func (c *current) onextendAndComments33(strI any) (any, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonextendAndComments33() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments33(stack["strI"])
}

func (c *current) onextendAndComments65() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonextendAndComments65() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments65()
}

func (c *current) onextendAndComments78() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonextendAndComments78() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments78()
}

func (c *current) onextendAndComments99() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonextendAndComments99() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments99()
}

func (c *current) onextendAndComments122() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonextendAndComments122() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments122()
}

func (c *current) onextendAndComments133() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonextendAndComments133() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments133()
}

func (c *current) onextendAndComments140() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonextendAndComments140() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments140()
}

func (c *current) onextendAndComments145() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonextendAndComments145() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments145()
}

func (c *current) onextendAndComments50(strI any) (any, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonextendAndComments50() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments50(stack["strI"])
}

func (c *current) onextendAndComments166() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonextendAndComments166() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments166()
}

func (c *current) onextendAndComments179() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonextendAndComments179() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments179()
}

func (c *current) onextendAndComments200() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonextendAndComments200() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments200()
}

func (c *current) onextendAndComments223() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonextendAndComments223() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments223()
}

func (c *current) onextendAndComments234() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonextendAndComments234() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments234()
}

func (c *current) onextendAndComments241() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonextendAndComments241() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments241()
}

func (c *current) onextendAndComments246() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonextendAndComments246() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments246()
}

func (c *current) onextendAndComments252() (any, error) {
	return pos(c), nil
}

func (p *parser) callonextendAndComments252() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments252()
}

func (c *current) onextendAndComments151(strI, endPosI any) (any, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonextendAndComments151() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments151(stack["strI"], stack["endPosI"])
}

func (c *current) onextendAndComments277() (any, error) {
	return pos(c), nil
}

func (p *parser) callonextendAndComments277() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments277()
}

func (c *current) onextendAndComments269(strI, endPosI any) (any, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonextendAndComments269() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments269(stack["strI"], stack["endPosI"])
}

func (c *current) onextendAndComments20(sI any) (any, error) {
	return sI, nil
}

func (p *parser) callonextendAndComments20() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments20(stack["sI"])
}

func (c *current) onextendAndComments283(pathI any) (any, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonextendAndComments283() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments283(stack["pathI"])
}

func (c *current) onextendAndComments15(extendI any) (any, error) {
	return file.Extend{Path: extendI.(file.String), Position: pos(c)}, nil
}

func (p *parser) callonextendAndComments15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments15(stack["extendI"])
}

func (c *current) onextendAndComments1(commsI, extI any) (any, error) {
	return []any{extI.(file.Extend), castedOrZero[[]file.CorgiComment](commsI)}, nil
}

func (p *parser) callonextendAndComments1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onextendAndComments1(stack["commsI"], stack["extI"])
}

func (c *current) onimportsAndComments43() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonimportsAndComments43() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments43()
}

func (c *current) onimportsAndComments55() (any, error) {
	return nil, nil
}

func (p *parser) callonimportsAndComments55() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments55()
}

func (c *current) onimportsAndComments58() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonimportsAndComments58() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments58()
}

func (c *current) onimportsAndComments60() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonimportsAndComments60() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments60()
}

func (c *current) onimportsAndComments62() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0 && len(c.text) > 0, nil

}

func (p *parser) callonimportsAndComments62() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments62()
}

func (c *current) onimportsAndComments63() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonimportsAndComments63() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments63()
}

func (c *current) onimportsAndComments65() (bool, error) {
	// this is NOT our first indentation
	return c.state["Indentation.RefLine"].(int) != 0, nil

}

func (p *parser) callonimportsAndComments65() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments65()
}

func (c *current) onimportsAndComments66() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonimportsAndComments66() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments66()
}

func (c *current) onimportsAndComments69() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonimportsAndComments69() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments69()
}

func (c *current) onimportsAndComments70() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonimportsAndComments70() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments70()
}

func (c *current) onimportsAndComments71() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonimportsAndComments71() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments71()
}

func (c *current) onimportsAndComments73() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonimportsAndComments73() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments73()
}

func (c *current) onimportsAndComments74() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	} else if actualCount < expectCount {
		return false, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonimportsAndComments74() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments74()
}

func (c *current) onimportsAndComments81() (any, error) {
	return file.GoIdent{Ident: ".", Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments81() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments81()
}

func (c *current) onimportsAndComments83(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments83() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments83(stack["ident"])
}

func (c *current) onimportsAndComments94() (any, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments94() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments94()
}

func (c *current) onimportsAndComments89(endPosI any) (any, error) {
	return file.GoIdent{
			Ident:    string(c.text),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid import alias",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
		}
}

func (p *parser) callonimportsAndComments89() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments89(stack["endPosI"])
}

func (c *current) onimportsAndComments104(strI any) (any, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments104() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments104(stack["strI"])
}

func (c *current) onimportsAndComments111(strI any) (any, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonimportsAndComments111() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments111(stack["strI"])
}

func (c *current) onimportsAndComments143() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonimportsAndComments143() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments143()
}

func (c *current) onimportsAndComments156() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments156() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments156()
}

func (c *current) onimportsAndComments177() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments177() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments177()
}

func (c *current) onimportsAndComments200() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments200() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments200()
}

func (c *current) onimportsAndComments211() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments211() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments211()
}

func (c *current) onimportsAndComments218() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments218() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments218()
}

func (c *current) onimportsAndComments223() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments223() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments223()
}

func (c *current) onimportsAndComments128(strI any) (any, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments128() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments128(stack["strI"])
}

func (c *current) onimportsAndComments244() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonimportsAndComments244() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments244()
}

func (c *current) onimportsAndComments257() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments257() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments257()
}

func (c *current) onimportsAndComments278() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments278() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments278()
}

func (c *current) onimportsAndComments301() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments301() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments301()
}

func (c *current) onimportsAndComments312() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments312() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments312()
}

func (c *current) onimportsAndComments319() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments319() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments319()
}

func (c *current) onimportsAndComments324() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments324() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments324()
}

func (c *current) onimportsAndComments330() (any, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments330() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments330()
}

func (c *current) onimportsAndComments229(strI, endPosI any) (any, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonimportsAndComments229() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments229(stack["strI"], stack["endPosI"])
}

func (c *current) onimportsAndComments355() (any, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments355() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments355()
}

func (c *current) onimportsAndComments347(strI, endPosI any) (any, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonimportsAndComments347() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments347(stack["strI"], stack["endPosI"])
}

func (c *current) onimportsAndComments361(pathI any) (any, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonimportsAndComments361() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments361(stack["pathI"])
}

func (c *current) onimportsAndComments75(aliasI, pathI any) (any, error) {
	var spec file.ImportSpec
	spec.Position = pos(c)

	if aliasI != nil {
		alias := getTuple[file.GoIdent](aliasI, 0)
		spec.Alias = &alias
	}

	spec.Path = pathI.(file.String)
	return spec, nil
}

func (p *parser) callonimportsAndComments75() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments75(stack["aliasI"], stack["pathI"])
}

func (c *current) onimportsAndComments374(importsI any) error {
	lvl := c.state["Indentation.Level"].(int)
	c.state["Indentation.Level"] = lvl - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonimportsAndComments374() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments374(stack["importsI"])
}

func (c *current) onimportsAndComments41(importsI any) (any, error) {
	return typedSliceFromTuples[file.ImportSpec](importsI, -1), nil
}

func (p *parser) callonimportsAndComments41() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments41(stack["importsI"])
}

func (c *current) onimportsAndComments28(specsI any) (any, error) {
	return file.Import{
		Imports:  specsI.([]file.ImportSpec),
		Position: pos(c),
	}, nil
}

func (p *parser) callonimportsAndComments28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments28(stack["specsI"])
}

func (c *current) onimportsAndComments387() (any, error) {
	return file.GoIdent{Ident: ".", Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments387() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments387()
}

func (c *current) onimportsAndComments389(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments389() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments389(stack["ident"])
}

func (c *current) onimportsAndComments400() (any, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments400() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments400()
}

func (c *current) onimportsAndComments395(endPosI any) (any, error) {
	return file.GoIdent{
			Ident:    string(c.text),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid import alias",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
		}
}

func (p *parser) callonimportsAndComments395() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments395(stack["endPosI"])
}

func (c *current) onimportsAndComments410(strI any) (any, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments410() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments410(stack["strI"])
}

func (c *current) onimportsAndComments417(strI any) (any, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonimportsAndComments417() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments417(stack["strI"])
}

func (c *current) onimportsAndComments449() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonimportsAndComments449() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments449()
}

func (c *current) onimportsAndComments462() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments462() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments462()
}

func (c *current) onimportsAndComments483() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments483() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments483()
}

func (c *current) onimportsAndComments506() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments506() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments506()
}

func (c *current) onimportsAndComments517() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments517() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments517()
}

func (c *current) onimportsAndComments524() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments524() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments524()
}

func (c *current) onimportsAndComments529() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments529() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments529()
}

func (c *current) onimportsAndComments434(strI any) (any, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments434() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments434(stack["strI"])
}

func (c *current) onimportsAndComments550() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonimportsAndComments550() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments550()
}

func (c *current) onimportsAndComments563() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments563() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments563()
}

func (c *current) onimportsAndComments584() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments584() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments584()
}

func (c *current) onimportsAndComments607() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments607() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments607()
}

func (c *current) onimportsAndComments618() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments618() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments618()
}

func (c *current) onimportsAndComments625() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments625() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments625()
}

func (c *current) onimportsAndComments630() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments630() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments630()
}

func (c *current) onimportsAndComments636() (any, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments636() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments636()
}

func (c *current) onimportsAndComments535(strI, endPosI any) (any, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonimportsAndComments535() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments535(stack["strI"], stack["endPosI"])
}

func (c *current) onimportsAndComments661() (any, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments661() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments661()
}

func (c *current) onimportsAndComments653(strI, endPosI any) (any, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonimportsAndComments653() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments653(stack["strI"], stack["endPosI"])
}

func (c *current) onimportsAndComments667(pathI any) (any, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonimportsAndComments667() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments667(stack["pathI"])
}

func (c *current) onimportsAndComments381(aliasI, pathI any) (any, error) {
	var spec file.ImportSpec
	spec.Position = pos(c)

	if aliasI != nil {
		alias := getTuple[file.GoIdent](aliasI, 0)
		spec.Alias = &alias
	}

	spec.Path = pathI.(file.String)
	return spec, nil
}

func (p *parser) callonimportsAndComments381() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments381(stack["aliasI"], stack["pathI"])
}

func (c *current) onimportsAndComments375(specI any) (any, error) {
	return file.Import{
		Imports:  []file.ImportSpec{specI.(file.ImportSpec)},
		Position: pos(c),
	}, nil
}

func (p *parser) callonimportsAndComments375() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments375(stack["specI"])
}

func (c *current) onimportsAndComments684() (any, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments684() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments684()
}

func (c *current) onimportsAndComments680(posI any) (any, error) {
	return file.Import{Position: pos(c)}, &corgierr.Error{
		Message: "missing import path",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			Annotation:  "expected an import path, optionally preceded by an import alias",
		}),
	}
}

func (p *parser) callonimportsAndComments680() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments680(stack["posI"])
}

func (c *current) onimportsAndComments15(importsI any) (any, error) {
	impTuples := islice(importsI)
	if impTuples == nil {
		return []file.Import(nil), nil
	}

	var imps []file.Import
	for _, impTuple := range impTuples {
		imps = append(imps, getTuple[file.Import](impTuple, 1))
	}

	return imps, nil
}

func (p *parser) callonimportsAndComments15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments15(stack["importsI"])
}

func (c *current) onimportsAndComments1(valsI any) (any, error) {
	tuples := islice(valsI)

	var comments []file.CorgiComment
	var imports []file.Import

	for _, t := range tuples {
		comments = append(comments, castedOrZero[[]file.CorgiComment](islice(t)[0])...)
		imports = append(imports, getTuple[[]file.Import](t, -1)...)
	}

	return []any{imports, comments}, nil
}

func (p *parser) callonimportsAndComments1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments1(stack["valsI"])
}

func (c *current) onusesAndComments43() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonusesAndComments43() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments43()
}

func (c *current) onusesAndComments55() (any, error) {
	return nil, nil
}

func (p *parser) callonusesAndComments55() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments55()
}

func (c *current) onusesAndComments58() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonusesAndComments58() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments58()
}

func (c *current) onusesAndComments60() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonusesAndComments60() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments60()
}

func (c *current) onusesAndComments62() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0 && len(c.text) > 0, nil

}

func (p *parser) callonusesAndComments62() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments62()
}

func (c *current) onusesAndComments63() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonusesAndComments63() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments63()
}

func (c *current) onusesAndComments65() (bool, error) {
	// this is NOT our first indentation
	return c.state["Indentation.RefLine"].(int) != 0, nil

}

func (p *parser) callonusesAndComments65() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments65()
}

func (c *current) onusesAndComments66() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonusesAndComments66() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments66()
}

func (c *current) onusesAndComments69() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonusesAndComments69() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments69()
}

func (c *current) onusesAndComments70() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonusesAndComments70() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments70()
}

func (c *current) onusesAndComments71() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonusesAndComments71() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments71()
}

func (c *current) onusesAndComments73() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonusesAndComments73() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments73()
}

func (c *current) onusesAndComments74() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	} else if actualCount < expectCount {
		return false, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonusesAndComments74() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments74()
}

func (c *current) onusesAndComments81() (any, error) {
	return file.Ident{Ident: ".", Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments81() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments81()
}

func (c *current) onusesAndComments83(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments83() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments83(stack["identI"])
}

func (c *current) onusesAndComments102() (any, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments102() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments102()
}

func (c *current) onusesAndComments89(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonusesAndComments89() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments89(stack["identI"], stack["endPosI"])
}

func (c *current) onusesAndComments113() (any, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments113() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments113()
}

func (c *current) onusesAndComments108(endPosI any) (any, error) {
	return file.Ident{
			Ident:    string(c.text),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid import alias",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
		}
}

func (p *parser) callonusesAndComments108() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments108(stack["endPosI"])
}

func (c *current) onusesAndComments123(strI any) (any, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments123() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments123(stack["strI"])
}

func (c *current) onusesAndComments130(strI any) (any, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonusesAndComments130() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments130(stack["strI"])
}

func (c *current) onusesAndComments162() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonusesAndComments162() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments162()
}

func (c *current) onusesAndComments175() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments175() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments175()
}

func (c *current) onusesAndComments196() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments196() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments196()
}

func (c *current) onusesAndComments219() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments219() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments219()
}

func (c *current) onusesAndComments230() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments230() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments230()
}

func (c *current) onusesAndComments237() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments237() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments237()
}

func (c *current) onusesAndComments242() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonusesAndComments242() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments242()
}

func (c *current) onusesAndComments147(strI any) (any, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments147() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments147(stack["strI"])
}

func (c *current) onusesAndComments263() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonusesAndComments263() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments263()
}

func (c *current) onusesAndComments276() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments276() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments276()
}

func (c *current) onusesAndComments297() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments297() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments297()
}

func (c *current) onusesAndComments320() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments320() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments320()
}

func (c *current) onusesAndComments331() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments331() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments331()
}

func (c *current) onusesAndComments338() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments338() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments338()
}

func (c *current) onusesAndComments343() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonusesAndComments343() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments343()
}

func (c *current) onusesAndComments349() (any, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments349() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments349()
}

func (c *current) onusesAndComments248(strI, endPosI any) (any, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonusesAndComments248() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments248(stack["strI"], stack["endPosI"])
}

func (c *current) onusesAndComments374() (any, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments374() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments374()
}

func (c *current) onusesAndComments366(strI, endPosI any) (any, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonusesAndComments366() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments366(stack["strI"], stack["endPosI"])
}

func (c *current) onusesAndComments380(pathI any) (any, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonusesAndComments380() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments380(stack["pathI"])
}

func (c *current) onusesAndComments75(aliasI, pathI any) (any, error) {
	var spec file.UseSpec
	spec.Position = pos(c)

	if aliasI != nil {
		alias := getTuple[file.Ident](aliasI, 0)
		spec.Alias = &alias
	}

	spec.Path = pathI.(file.String)
	return spec, nil
}

func (p *parser) callonusesAndComments75() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments75(stack["aliasI"], stack["pathI"])
}

func (c *current) onusesAndComments393(usesI any) error {
	lvl := c.state["Indentation.Level"].(int)
	c.state["Indentation.Level"] = lvl - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonusesAndComments393() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments393(stack["usesI"])
}

func (c *current) onusesAndComments41(usesI any) (any, error) {
	return typedSliceFromTuples[file.UseSpec](usesI, -1), nil
}

func (p *parser) callonusesAndComments41() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments41(stack["usesI"])
}

func (c *current) onusesAndComments28(specsI any) (any, error) {
	return file.Use{
		Uses:     specsI.([]file.UseSpec),
		Position: pos(c),
	}, nil
}

func (p *parser) callonusesAndComments28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments28(stack["specsI"])
}

func (c *current) onusesAndComments406() (any, error) {
	return file.Ident{Ident: ".", Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments406() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments406()
}

func (c *current) onusesAndComments408(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments408() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments408(stack["identI"])
}

func (c *current) onusesAndComments427() (any, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments427() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments427()
}

func (c *current) onusesAndComments414(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonusesAndComments414() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments414(stack["identI"], stack["endPosI"])
}

func (c *current) onusesAndComments438() (any, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments438() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments438()
}

func (c *current) onusesAndComments433(endPosI any) (any, error) {
	return file.Ident{
			Ident:    string(c.text),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid import alias",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
		}
}

func (p *parser) callonusesAndComments433() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments433(stack["endPosI"])
}

func (c *current) onusesAndComments448(strI any) (any, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments448() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments448(stack["strI"])
}

func (c *current) onusesAndComments455(strI any) (any, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonusesAndComments455() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments455(stack["strI"])
}

func (c *current) onusesAndComments487() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonusesAndComments487() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments487()
}

func (c *current) onusesAndComments500() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments500() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments500()
}

func (c *current) onusesAndComments521() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments521() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments521()
}

func (c *current) onusesAndComments544() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments544() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments544()
}

func (c *current) onusesAndComments555() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments555() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments555()
}

func (c *current) onusesAndComments562() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments562() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments562()
}

func (c *current) onusesAndComments567() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonusesAndComments567() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments567()
}

func (c *current) onusesAndComments472(strI any) (any, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments472() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments472(stack["strI"])
}

func (c *current) onusesAndComments588() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonusesAndComments588() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments588()
}

func (c *current) onusesAndComments601() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments601() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments601()
}

func (c *current) onusesAndComments622() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments622() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments622()
}

func (c *current) onusesAndComments645() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments645() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments645()
}

func (c *current) onusesAndComments656() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments656() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments656()
}

func (c *current) onusesAndComments663() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments663() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments663()
}

func (c *current) onusesAndComments668() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonusesAndComments668() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments668()
}

func (c *current) onusesAndComments674() (any, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments674() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments674()
}

func (c *current) onusesAndComments573(strI, endPosI any) (any, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonusesAndComments573() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments573(stack["strI"], stack["endPosI"])
}

func (c *current) onusesAndComments699() (any, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments699() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments699()
}

func (c *current) onusesAndComments691(strI, endPosI any) (any, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonusesAndComments691() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments691(stack["strI"], stack["endPosI"])
}

func (c *current) onusesAndComments705(pathI any) (any, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonusesAndComments705() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments705(stack["pathI"])
}

func (c *current) onusesAndComments400(aliasI, pathI any) (any, error) {
	var spec file.UseSpec
	spec.Position = pos(c)

	if aliasI != nil {
		alias := getTuple[file.Ident](aliasI, 0)
		spec.Alias = &alias
	}

	spec.Path = pathI.(file.String)
	return spec, nil
}

func (p *parser) callonusesAndComments400() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments400(stack["aliasI"], stack["pathI"])
}

func (c *current) onusesAndComments394(specI any) (any, error) {
	return file.Use{
		Uses:     []file.UseSpec{specI.(file.UseSpec)},
		Position: pos(c),
	}, nil
}

func (p *parser) callonusesAndComments394() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments394(stack["specI"])
}

func (c *current) onusesAndComments722() (any, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments722() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments722()
}

func (c *current) onusesAndComments718(posI any) (any, error) {
	return file.Use{Position: pos(c)}, &corgierr.Error{
		Message: "missing use path",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			Annotation:  "expected an use path, optionally preceded by an use alias",
		}),
	}
}

func (p *parser) callonusesAndComments718() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments718(stack["posI"])
}

func (c *current) onusesAndComments15(usesI any) (any, error) {
	useTuples := islice(usesI)
	if useTuples == nil {
		return []file.Use(nil), nil
	}

	var uses []file.Use
	for _, useTuple := range useTuples {
		uses = append(uses, getTuple[file.Use](useTuple, 1))
	}

	return uses, nil
}

func (p *parser) callonusesAndComments15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments15(stack["usesI"])
}

func (c *current) onusesAndComments1(valsI any) (any, error) {
	tuples := islice(valsI)

	var comments []file.CorgiComment
	var uses []file.Use

	for _, t := range tuples {
		comments = append(comments, castedOrZero[[]file.CorgiComment](islice(t)[0])...)
		uses = append(uses, getTuple[[]file.Use](t, -1)...)
	}

	return []any{uses, comments}, nil
}

func (p *parser) callonusesAndComments1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments1(stack["valsI"])
}

func (c *current) oncodesAndComments1(valsI any) (any, error) {
	tuples := islice(valsI)

	var comments []file.CorgiComment
	var codes []file.Code

	for _, t := range tuples {
		comments = append(comments, castedOrZero[[]file.CorgiComment](islice(t)[0])...)
		codes = append(codes, getTuple[[]file.Code](t, -1)...)
	}

	return []any{codes, comments}, nil
}

func (p *parser) calloncodesAndComments1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncodesAndComments1(stack["valsI"])
}

func (c *current) onglobalCodeAndFunc1(codesAndCommentsI, commentsI, funcI any) (any, error) {
	var f file.File

	if codesAndCommentsI != nil {
		f.GlobalCode = getTuple[[]file.Code](codesAndCommentsI, 0)
		f.TopLevelComments = append(f.TopLevelComments, getTuple[[]file.CorgiComment](codesAndCommentsI, 1)...)
	}

	if commentsI != nil {
		f.TopLevelComments = append(f.TopLevelComments, commentsI.([]file.CorgiComment)...)
	}

	fun := funcI.(file.Func)
	f.Func = &fun

	return f, nil
}

func (p *parser) callonglobalCodeAndFunc1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onglobalCodeAndFunc1(stack["codesAndCommentsI"], stack["commentsI"], stack["funcI"])
}

func (c *current) onpreScope39() (any, error) {
	return pos(c), nil
}

func (p *parser) callonpreScope39() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onpreScope39()
}

func (c *current) onpreScope35(startPosI any) (any, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			ToEOL:      true,
			Annotation: "doctypes other than the HTML5 doctype are not supported",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonpreScope35() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onpreScope35(stack["startPosI"])
}

func (c *current) onpreScope56() (any, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected `html`",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonpreScope56() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onpreScope56()
}

func (c *current) onpreScope20() (any, error) {
	return file.Doctype{Position: pos(c)}, nil
}

func (p *parser) callonpreScope20() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onpreScope20()
}

func (c *current) onpreScope90() (any, error) {
	return pos(c), nil
}

func (p *parser) callonpreScope90() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onpreScope90()
}

func (c *current) onpreScope86(startPosI any) (any, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			ToEOL:      true,
			Annotation: "doctypes other than the HTML5 doctype are not supported",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonpreScope86() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onpreScope86(stack["startPosI"])
}

func (c *current) onpreScope107() (any, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected `html`",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonpreScope107() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onpreScope107()
}

func (c *current) onpreScope71() (any, error) {
	return file.Doctype{Position: pos(c)}, &corgierr.Error{
		Message: "the corgi doctype directive does not start with a `!`",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "remove this",
		}),
		ShouldBe: "`doctype html`",
	}
}

func (p *parser) callonpreScope71() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onpreScope71()
}

func (c *current) onpreScope1(itmsI, doctypeI any) (any, error) {
	itmIs := islice(itmsI)
	n := len(itmIs)
	if doctypeI != nil {
		n++
	}

	itms := make(file.Scope, n)
	for i, itmI := range itmIs {
		itms[i] = getTuple[file.ScopeItem](itmI, 0)
	}

	if doctypeI != nil {
		itms[len(itms)-1] = doctypeI.(file.Doctype)
	}

	return itms, nil
}

func (p *parser) callonpreScope1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onpreScope1(stack["itmsI"], stack["doctypeI"])
}

func (c *current) onScope13() (any, error) {
	return nil, nil
}

func (p *parser) callonScope13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope13()
}

func (c *current) onScope16() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonScope16() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope16()
}

func (c *current) onScope18() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonScope18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope18()
}

func (c *current) onScope20() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0 && len(c.text) > 0, nil

}

func (p *parser) callonScope20() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope20()
}

func (c *current) onScope21() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonScope21() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope21()
}

func (c *current) onScope23() (bool, error) {
	// this is NOT our first indentation
	return c.state["Indentation.RefLine"].(int) != 0, nil

}

func (p *parser) callonScope23() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope23()
}

func (c *current) onScope24() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonScope24() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope24()
}

func (c *current) onScope27() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonScope27() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope27()
}

func (c *current) onScope28() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonScope28() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope28()
}

func (c *current) onScope29() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonScope29() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope29()
}

func (c *current) onScope31() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonScope31() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope31()
}

func (c *current) onScope32() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	} else if actualCount < expectCount {
		return false, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonScope32() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope32()
}

func (c *current) onScope1(itemsI any) (any, error) {
	itemTuples := islice(itemsI)

	scope := make(file.Scope, 0, len(itemTuples))
	for _, it := range itemTuples {
		tuple := islice(it)
		if si, ok := tuple[len(tuple)-1].(file.ScopeItem); ok {
			scope = append(scope, si)
		}
	}

	return scope, nil
}

func (p *parser) callonScope1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope1(stack["itemsI"])
}

func (c *current) onscopeItem25(strI any) (any, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonscopeItem25() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem25(stack["strI"])
}

func (c *current) onscopeItem32(strI any) (any, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonscopeItem32() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem32(stack["strI"])
}

func (c *current) onscopeItem64() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonscopeItem64() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem64()
}

func (c *current) onscopeItem77() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem77() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem77()
}

func (c *current) onscopeItem98() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem98() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem98()
}

func (c *current) onscopeItem121() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem121() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem121()
}

func (c *current) onscopeItem132() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem132() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem132()
}

func (c *current) onscopeItem139() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem139() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem139()
}

func (c *current) onscopeItem144() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonscopeItem144() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem144()
}

func (c *current) onscopeItem49(strI any) (any, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonscopeItem49() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem49(stack["strI"])
}

func (c *current) onscopeItem165() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonscopeItem165() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem165()
}

func (c *current) onscopeItem178() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem178() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem178()
}

func (c *current) onscopeItem199() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem199() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem199()
}

func (c *current) onscopeItem222() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem222() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem222()
}

func (c *current) onscopeItem233() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem233() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem233()
}

func (c *current) onscopeItem240() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem240() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem240()
}

func (c *current) onscopeItem245() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonscopeItem245() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem245()
}

func (c *current) onscopeItem251() (any, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem251() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem251()
}

func (c *current) onscopeItem150(strI, endPosI any) (any, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonscopeItem150() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem150(stack["strI"], stack["endPosI"])
}

func (c *current) onscopeItem276() (any, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem276() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem276()
}

func (c *current) onscopeItem268(strI, endPosI any) (any, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonscopeItem268() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem268(stack["strI"], stack["endPosI"])
}

func (c *current) onscopeItem19(sI any) (any, error) {
	return sI, nil
}

func (p *parser) callonscopeItem19() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem19(stack["sI"])
}

func (c *current) onscopeItem282(pathI any) (any, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonscopeItem282() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem282(stack["pathI"])
}

func (c *current) onscopeItem14(pathI any) (any, error) {
	return file.Include{
		Path:     pathI.(file.String),
		Position: pos(c),
	}, nil
}

func (p *parser) callonscopeItem14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem14(stack["pathI"])
}

func (c *current) onscopeItem315() (any, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem315() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem315()
}

func (c *current) onscopeItem311(startPosI any) (any, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			ToEOL:      true,
			Annotation: "doctypes other than the HTML5 doctype are not supported",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonscopeItem311() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem311(stack["startPosI"])
}

func (c *current) onscopeItem332() (any, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected `html`",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonscopeItem332() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem332()
}

func (c *current) onscopeItem296() (any, error) {
	return file.Doctype{Position: pos(c)}, nil
}

func (p *parser) callonscopeItem296() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem296()
}

func (c *current) onscopeItem366() (any, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem366() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem366()
}

func (c *current) onscopeItem362(startPosI any) (any, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			ToEOL:      true,
			Annotation: "doctypes other than the HTML5 doctype are not supported",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonscopeItem362() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem362(stack["startPosI"])
}

func (c *current) onscopeItem383() (any, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected `html`",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonscopeItem383() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem383()
}

func (c *current) onscopeItem347() (any, error) {
	return file.Doctype{Position: pos(c)}, &corgierr.Error{
		Message: "the corgi doctype directive does not start with a `!`",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "remove this",
		}),
		ShouldBe: "`doctype html`",
	}
}

func (p *parser) callonscopeItem347() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem347()
}

func (c *current) onscopeItem293(doctypeI any) (any, error) {
	return doctypeI, &corgierr.Error{
		Message: "`doctype` not first item",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             pos(c),
			ToEOL:             true,
			Annotation:        "cannot place doctype directive here",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "`doctype`s may only be placed as the first element after the `func` declaration\n" +
					"remove this `doctype` and move it right under the `func` of your file, if there isn't a doctype there already",
			},
		},
	}
}

func (p *parser) callonscopeItem293() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem293(stack["doctypeI"])
}

func (c *current) onBody3() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonBody3() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBody3()
}

func (c *current) onBody6(scopeI any) error {
	lvl := c.state["Indentation.Level"].(int)
	c.state["Indentation.Level"] = lvl - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonBody6() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBody6(stack["scopeI"])
}

func (c *current) onBody1(scopeI any) (any, error) {
	return scopeI, nil
}

func (p *parser) callonBody1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBody1(stack["scopeI"])
}

func (c *current) onBeaitb2(scopeItemI any) (any, error) {
	return file.Scope{scopeItemI.(file.ScopeItem)}, nil
}

func (p *parser) callonBeaitb2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb2(stack["scopeItemI"])
}

func (c *current) onBeaitb7(bodyI any) (any, error) {
	return bodyI, nil
}

func (p *parser) callonBeaitb7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb7(stack["bodyI"])
}

func (c *current) onBeaitb20() (any, error) {
	return file.Scope(nil), nil
}

func (p *parser) callonBeaitb20() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb20()
}

func (c *current) onBeaitb31(lineI, bodyI any) (any, error) {
	return file.Scope{file.BadItem{
			Line:     concat(lineI),
			Body:     castedOrZero[file.Scope](bodyI),
			Position: pos(c),
		}}, &corgierr.Error{
			Message: "unexpected tokens",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				ToEOL:      true,
				Annotation: "expected a block expansion (`:`), inline text, a body, or nothing",
			}),
		}
}

func (p *parser) callonBeaitb31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb31(stack["lineI"], stack["bodyI"])
}

func (c *current) onBeait2(scopeItemI any) (any, error) {
	return file.Scope{scopeItemI.(file.ScopeItem)}, nil
}

func (p *parser) callonBeait2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeait2(stack["scopeItemI"])
}

func (c *current) onBeait7() (any, error) {
	return file.Scope(nil), nil
}

func (p *parser) callonBeait7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeait7()
}

func (c *current) onBeait18(lineI any) (any, error) {
	return file.Scope{file.BadItem{
			Line:     concat(lineI),
			Position: pos(c),
		}}, &corgierr.Error{
			Message: "unexpected tokens",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				ToEOL:      true,
				Annotation: "expected a block expansion (`:`), inline text, or nothing",
			}),
		}
}

func (p *parser) callonBeait18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeait18(stack["lineI"])
}

func (c *current) onBadItem1(lineI, bodyI any) (any, error) {
	line := concat(lineI)

	firstWordLen := strings.IndexByte(line, ' ')
	if firstWordLen <= 0 {
		firstWordLen = len([]rune(line))
	}

	return file.BadItem{
			Line:     line,
			Body:     castedOrZero[file.Scope](bodyI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unrecognized directive or invalid element name",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Len:        firstWordLen,
				Annotation: "expected a valid corgi directive or an element name",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "if this is supposed to be an element name, make sure it conforms to the HTML spec"},
				{
					Suggestion: "use a valid corgi directive",
					ShouldBe: "a block (`block`, `append`, `prepend`), code (`-`), a conditional (`if`, `else if`, `else`, `switch`),\n" +
						"a loop (`for`), a filter (`:`), an include (`include`), a mixin (`mixin`), a mixin call (`+`),\n" +
						"a Go import (`import`), a corgi use (`use`), the func header (`func`), an arrow block (`>`)",
				},
			},
		}
}

func (p *parser) callonBadItem1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBadItem1(stack["lineI"], stack["bodyI"])
}

func (c *current) onBlock18(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonBlock18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock18(stack["identI"])
}

func (c *current) onBlock37() (any, error) {
	return pos(c), nil
}

func (p *parser) callonBlock37() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock37()
}

func (c *current) onBlock24(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonBlock24() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock24(stack["identI"], stack["endPosI"])
}

func (c *current) onBlock15(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonBlock15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock15(stack["identI"])
}

func (c *current) onBlock46() (any, error) {
	return pos(c), nil
}

func (p *parser) callonBlock46() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock46()
}

func (c *current) onBlock43(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonBlock43() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock43(stack["posI"])
}

func (c *current) onBlock71() (any, error) {
	return pos(c), nil
}

func (p *parser) callonBlock71() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock71()
}

func (c *current) onBlock65(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonBlock65() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock65(stack["identI"], stack["endPosI"])
}

func (c *current) onBlock9(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonBlock9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock9(stack["identI"])
}

func (c *current) onBlock77() (any, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonBlock77() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock77()
}

func (c *current) onBlock4(nameI any) (any, error) {
	name := nameI.(file.Ident)
	return file.Block{
		Type:     file.BlockTypeBlock,
		Name:     name,
		Position: pos(c),
	}, nil
}

func (p *parser) callonBlock4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock4(stack["nameI"])
}

func (c *current) onBlock1(blockI, bodyI any) (any, error) {
	block := blockI.(file.Block)
	block.Body = bodyI.(file.Scope)
	return block, nil
}

func (p *parser) callonBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock1(stack["blockI"], stack["bodyI"])
}

func (c *current) onInlineBlock18(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonInlineBlock18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock18(stack["identI"])
}

func (c *current) onInlineBlock37() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineBlock37() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock37()
}

func (c *current) onInlineBlock24(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonInlineBlock24() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock24(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineBlock15(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonInlineBlock15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock15(stack["identI"])
}

func (c *current) onInlineBlock46() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineBlock46() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock46()
}

func (c *current) onInlineBlock43(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonInlineBlock43() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock43(stack["posI"])
}

func (c *current) onInlineBlock71() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineBlock71() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock71()
}

func (c *current) onInlineBlock65(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonInlineBlock65() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock65(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineBlock9(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonInlineBlock9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock9(stack["identI"])
}

func (c *current) onInlineBlock77() (any, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonInlineBlock77() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock77()
}

func (c *current) onInlineBlock4(nameI any) (any, error) {
	name := nameI.(file.Ident)
	return file.Block{
		Type:     file.BlockTypeBlock,
		Name:     name,
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineBlock4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock4(stack["nameI"])
}

func (c *current) onInlineBlock1(blockI, scopeI any) (any, error) {
	block := blockI.(file.Block)
	block.Body = castedOrZero[file.Scope](scopeI)
	return block, nil
}

func (p *parser) callonInlineBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock1(stack["blockI"], stack["scopeI"])
}

func (c *current) onPrepend18(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonPrepend18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend18(stack["identI"])
}

func (c *current) onPrepend37() (any, error) {
	return pos(c), nil
}

func (p *parser) callonPrepend37() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend37()
}

func (c *current) onPrepend24(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonPrepend24() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend24(stack["identI"], stack["endPosI"])
}

func (c *current) onPrepend15(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonPrepend15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend15(stack["identI"])
}

func (c *current) onPrepend46() (any, error) {
	return pos(c), nil
}

func (p *parser) callonPrepend46() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend46()
}

func (c *current) onPrepend43(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonPrepend43() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend43(stack["posI"])
}

func (c *current) onPrepend71() (any, error) {
	return pos(c), nil
}

func (p *parser) callonPrepend71() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend71()
}

func (c *current) onPrepend65(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonPrepend65() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend65(stack["identI"], stack["endPosI"])
}

func (c *current) onPrepend9(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonPrepend9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend9(stack["identI"])
}

func (c *current) onPrepend77() (any, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonPrepend77() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend77()
}

func (c *current) onPrepend4(nameI any) (any, error) {
	name := nameI.(file.Ident)
	return file.Block{
		Type:     file.BlockTypePrepend,
		Name:     name,
		Position: pos(c),
	}, nil
}

func (p *parser) callonPrepend4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend4(stack["nameI"])
}

func (c *current) onPrepend1(blockI, bodyI any) (any, error) {
	block := blockI.(file.Block)
	block.Body = bodyI.(file.Scope)
	return block, nil
}

func (p *parser) callonPrepend1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend1(stack["blockI"], stack["bodyI"])
}

func (c *current) onAppend18(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonAppend18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend18(stack["identI"])
}

func (c *current) onAppend37() (any, error) {
	return pos(c), nil
}

func (p *parser) callonAppend37() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend37()
}

func (c *current) onAppend24(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonAppend24() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend24(stack["identI"], stack["endPosI"])
}

func (c *current) onAppend15(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonAppend15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend15(stack["identI"])
}

func (c *current) onAppend46() (any, error) {
	return pos(c), nil
}

func (p *parser) callonAppend46() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend46()
}

func (c *current) onAppend43(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonAppend43() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend43(stack["posI"])
}

func (c *current) onAppend71() (any, error) {
	return pos(c), nil
}

func (p *parser) callonAppend71() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend71()
}

func (c *current) onAppend65(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonAppend65() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend65(stack["identI"], stack["endPosI"])
}

func (c *current) onAppend9(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonAppend9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend9(stack["identI"])
}

func (c *current) onAppend77() (any, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonAppend77() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend77()
}

func (c *current) onAppend4(nameI any) (any, error) {
	name := nameI.(file.Ident)
	return file.Block{
		Type:     file.BlockTypeAppend,
		Name:     name,
		Position: pos(c),
	}, nil
}

func (p *parser) callonAppend4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend4(stack["nameI"])
}

func (c *current) onAppend1(blockI, bodyI any) (any, error) {
	block := blockI.(file.Block)
	block.Body = bodyI.(file.Scope)
	return block, nil
}

func (p *parser) callonAppend1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend1(stack["blockI"], stack["bodyI"])
}

func (c *current) onBlockExpansion1(sI any) (any, error) {
	return file.BlockExpansion{
		Item:     sI.(file.ScopeItem),
		Position: pos(c),
	}, nil
}

func (p *parser) callonBlockExpansion1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockExpansion1(stack["sI"])
}

func (c *current) onblockExpansionItem4(lineI any) (any, error) {
	firstWordLen := strings.IndexByte(string(c.text), ' ')
	if firstWordLen <= 0 {
		firstWordLen = len([]rune(string(c.text)))
	}

	bi := file.BadItem{
		Line:     concat(lineI),
		Position: pos(c),
	}

	var suggestions []corgierr.Suggestion
	if bi.Line != "" {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "if this is supposed to be an element name, make sure it conforms to the HTML spec",
		})
	}

	return bi, &corgierr.Error{
		Message: "malformed block expansion",
		ErrorAnnotation: anno(c, annotation{
			Start: pos(c),
			Len:   firstWordLen,
			Annotation: "expected a block directive, an inline element, an inline arrow block,\n" +
				"a mixin call, or inline &-attributes",
		}),
		Suggestions: suggestions,
	}
}

func (p *parser) callonblockExpansionItem4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onblockExpansionItem4(stack["lineI"])
}

func (c *current) onspacedBlockExpansionItem2(sI any) (any, error) {
	return sI, nil
}

func (p *parser) callonspacedBlockExpansionItem2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onspacedBlockExpansionItem2(stack["sI"])
}

func (c *current) onspacedBlockExpansionItem11() (any, error) {
	return pos(c), nil
}

func (p *parser) callonspacedBlockExpansionItem11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onspacedBlockExpansionItem11()
}

func (c *current) onspacedBlockExpansionItem8(posI, sI any) (any, error) {
	var fromThe string
	switch sI.(type) {
	case file.Block:
		fromThe = "block"
	case file.Element:
		fromThe = "inline element"
	case file.DivShorthand:
		fromThe = "div shorthand"
	case file.MixinCall:
		fromThe = "mixin call"
	case file.And:
		fromThe = "&"
	case file.If:
		fromThe = "if"
	case file.IfBlock:
		fromThe = "if block"
	case file.For:
		fromThe = "for"
	case file.Include:
		fromThe = "include"
	case file.Return:
		fromThe = "return"
	default:
		fromThe = "rest"
	}

	return file.BlockExpansion{
			Item:     sI.(file.ScopeItem),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing space",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a space here, separating the `:` from the " + fromThe,
			}),
		}
}

func (p *parser) callonspacedBlockExpansionItem8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onspacedBlockExpansionItem8(stack["posI"], stack["sI"])
}

func (c *current) on_spacedBlockExpansionItem20(strI any) (any, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callon_spacedBlockExpansionItem20() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem20(stack["strI"])
}

func (c *current) on_spacedBlockExpansionItem27(strI any) (any, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callon_spacedBlockExpansionItem27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem27(stack["strI"])
}

func (c *current) on_spacedBlockExpansionItem59() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callon_spacedBlockExpansionItem59() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem59()
}

func (c *current) on_spacedBlockExpansionItem72() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callon_spacedBlockExpansionItem72() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem72()
}

func (c *current) on_spacedBlockExpansionItem93() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callon_spacedBlockExpansionItem93() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem93()
}

func (c *current) on_spacedBlockExpansionItem116() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callon_spacedBlockExpansionItem116() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem116()
}

func (c *current) on_spacedBlockExpansionItem127() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callon_spacedBlockExpansionItem127() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem127()
}

func (c *current) on_spacedBlockExpansionItem134() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callon_spacedBlockExpansionItem134() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem134()
}

func (c *current) on_spacedBlockExpansionItem139() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callon_spacedBlockExpansionItem139() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem139()
}

func (c *current) on_spacedBlockExpansionItem44(strI any) (any, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callon_spacedBlockExpansionItem44() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem44(stack["strI"])
}

func (c *current) on_spacedBlockExpansionItem160() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callon_spacedBlockExpansionItem160() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem160()
}

func (c *current) on_spacedBlockExpansionItem173() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callon_spacedBlockExpansionItem173() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem173()
}

func (c *current) on_spacedBlockExpansionItem194() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callon_spacedBlockExpansionItem194() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem194()
}

func (c *current) on_spacedBlockExpansionItem217() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callon_spacedBlockExpansionItem217() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem217()
}

func (c *current) on_spacedBlockExpansionItem228() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callon_spacedBlockExpansionItem228() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem228()
}

func (c *current) on_spacedBlockExpansionItem235() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callon_spacedBlockExpansionItem235() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem235()
}

func (c *current) on_spacedBlockExpansionItem240() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callon_spacedBlockExpansionItem240() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem240()
}

func (c *current) on_spacedBlockExpansionItem246() (any, error) {
	return pos(c), nil
}

func (p *parser) callon_spacedBlockExpansionItem246() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem246()
}

func (c *current) on_spacedBlockExpansionItem145(strI, endPosI any) (any, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callon_spacedBlockExpansionItem145() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem145(stack["strI"], stack["endPosI"])
}

func (c *current) on_spacedBlockExpansionItem271() (any, error) {
	return pos(c), nil
}

func (p *parser) callon_spacedBlockExpansionItem271() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem271()
}

func (c *current) on_spacedBlockExpansionItem263(strI, endPosI any) (any, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callon_spacedBlockExpansionItem263() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem263(stack["strI"], stack["endPosI"])
}

func (c *current) on_spacedBlockExpansionItem14(sI any) (any, error) {
	return sI, nil
}

func (p *parser) callon_spacedBlockExpansionItem14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem14(stack["sI"])
}

func (c *current) on_spacedBlockExpansionItem277(pathI any) (any, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callon_spacedBlockExpansionItem277() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem277(stack["pathI"])
}

func (c *current) on_spacedBlockExpansionItem9(pathI any) (any, error) {
	return file.Include{
		Path:     pathI.(file.String),
		Position: pos(c),
	}, nil
}

func (p *parser) callon_spacedBlockExpansionItem9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_spacedBlockExpansionItem9(stack["pathI"])
}

func (c *current) onCodes1(codesI any) (any, error) {
	return typedSliceFromTuples[file.Code](codesI, 1), nil
}

func (p *parser) callonCodes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCodes1(stack["codesI"])
}

func (c *current) onCode6(code any) (any, error) {
	return file.CodeLine{Code: concat(code), Position: pos(c)}, nil
}

func (p *parser) callonCode6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode6(stack["code"])
}

func (c *current) onCode32(code any) (any, error) {
	return file.CodeLine{Code: concat(code), Position: pos(c)}, nil
}

func (p *parser) callonCode32() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode32(stack["code"])
}

func (c *current) onCode2(firstLineI, additionalLinesI any) (any, error) {
	additionalLineTuples := islice(additionalLinesI)

	lines := make([]file.CodeLine, 1+len(additionalLineTuples))
	lines[0] = firstLineI.(file.CodeLine)
	for i, lt := range additionalLineTuples {
		lines[i+1] = getTuple[file.CodeLine](lt, -1)
	}

	return file.Code{
		Lines:    lines,
		Position: pos(c),
	}, nil
}

func (p *parser) callonCode2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode2(stack["firstLineI"], stack["additionalLinesI"])
}

func (c *current) onCode50() (any, error) {
	return pos(c), nil
}

func (p *parser) callonCode50() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode50()
}

func (c *current) onCode46(posI any) (any, error) {
	return file.Code{Position: pos(c)}, &corgierr.Error{
		Message: "empty code block",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected code here",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "either write some code, or delete this line"},
		},
	}
}

func (p *parser) callonCode46() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode46(stack["posI"])
}

func (c *current) oncondition2(condI any) (any, error) {
	return condI, nil
}

func (p *parser) calloncondition2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition2(stack["condI"])
}

func (c *current) oncondition11() (any, error) {
	return pos(c), nil
}

func (p *parser) calloncondition11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition11()
}

func (c *current) oncondition8(posI any) (any, error) {
	return file.Expression{}, &corgierr.Error{
		Message: "missing condition",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			Annotation:  "expected an expression here",
		}),
	}
}

func (p *parser) calloncondition8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition8(stack["posI"])
}

func (c *current) oncondition30() (any, error) {
	return pos(c), nil
}

func (p *parser) calloncondition30() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition30()
}

func (c *current) oncondition28(posI any) (any, error) {
	return file.Expression{}, &corgierr.Error{
		Message: "missing condition",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an expression here",
		}),
	}
}

func (p *parser) calloncondition28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition28(stack["posI"])
}

func (c *current) onthen2(scopeI any) (any, error) {
	return scopeI, nil
}

func (p *parser) callonthen2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen2(stack["scopeI"])
}

func (c *current) onthen15(beI any) (any, error) {
	return file.Scope{beI.(file.BlockExpansion)}, nil
}

func (p *parser) callonthen15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen15(stack["beI"])
}

func (c *current) onthen18() (any, error) {
	return file.Scope(nil), &corgierr.Error{
		Message: "missing body",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected an indented body or a block expansion",
		}),
	}
}

func (p *parser) callonthen18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen18()
}

func (c *current) onthen30() (any, error) {
	return c.text, nil
}

func (p *parser) callonthen30() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen30()
}

func (c *current) onthen33() (bool, error) {
	return true, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected an indented body or a block expansion",
		}),
	}

}

func (p *parser) callonthen33() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen33()
}

func (c *current) onIf1(condI, thenI, elseIfsI, elseI any) (any, error) {
	return file.If{
		Condition: condI.(file.Expression),
		Then:      thenI.(file.Scope),
		ElseIfs:   typedSlice[file.ElseIf](elseIfsI),
		Else:      ptrOrNil[file.Else](elseI),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonIf1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIf1(stack["condI"], stack["thenI"], stack["elseIfsI"], stack["elseI"])
}

func (c *current) onInlineIf1(condI, thenI any) (any, error) {
	return file.If{
		Condition: condI.(file.Expression),
		Then:      file.Scope{thenI.(file.BlockExpansion)},
		Position:  pos(c),
	}, nil
}

func (p *parser) callonInlineIf1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIf1(stack["condI"], stack["thenI"])
}

func (c *current) onElseIf11() (any, error) {
	return nil, nil
}

func (p *parser) callonElseIf11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf11()
}

func (c *current) onElseIf14() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonElseIf14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf14()
}

func (c *current) onElseIf16() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonElseIf16() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf16()
}

func (c *current) onElseIf18() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0 && len(c.text) > 0, nil

}

func (p *parser) callonElseIf18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf18()
}

func (c *current) onElseIf19() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonElseIf19() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf19()
}

func (c *current) onElseIf21() (bool, error) {
	// this is NOT our first indentation
	return c.state["Indentation.RefLine"].(int) != 0, nil

}

func (p *parser) callonElseIf21() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf21()
}

func (c *current) onElseIf22() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonElseIf22() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf22()
}

func (c *current) onElseIf25() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonElseIf25() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf25()
}

func (c *current) onElseIf26() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonElseIf26() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf26()
}

func (c *current) onElseIf27() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonElseIf27() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf27()
}

func (c *current) onElseIf29() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonElseIf29() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf29()
}

func (c *current) onElseIf30() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	} else if actualCount < expectCount {
		return false, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonElseIf30() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf30()
}

func (c *current) onElseIf32() (any, error) {
	return pos(c), nil
}

func (p *parser) callonElseIf32() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf32()
}

func (c *current) onElseIf1(posI, condI, thenI any) (any, error) {
	return file.ElseIf{
		Condition: condI.(file.Expression),
		Then:      thenI.(file.Scope),
		Position:  posI.(file.Position),
	}, nil
}

func (p *parser) callonElseIf1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf1(stack["posI"], stack["condI"], stack["thenI"])
}

func (c *current) onElse11() (any, error) {
	return nil, nil
}

func (p *parser) callonElse11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse11()
}

func (c *current) onElse14() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonElse14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse14()
}

func (c *current) onElse16() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonElse16() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse16()
}

func (c *current) onElse18() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0 && len(c.text) > 0, nil

}

func (p *parser) callonElse18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse18()
}

func (c *current) onElse19() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonElse19() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse19()
}

func (c *current) onElse21() (bool, error) {
	// this is NOT our first indentation
	return c.state["Indentation.RefLine"].(int) != 0, nil

}

func (p *parser) callonElse21() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse21()
}

func (c *current) onElse22() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonElse22() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse22()
}

func (c *current) onElse25() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonElse25() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse25()
}

func (c *current) onElse26() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonElse26() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse26()
}

func (c *current) onElse27() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonElse27() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse27()
}

func (c *current) onElse29() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonElse29() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse29()
}

func (c *current) onElse30() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	} else if actualCount < expectCount {
		return false, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonElse30() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse30()
}

func (c *current) onElse1(thenI any) (any, error) {
	return file.Else{
		Then:     thenI.(file.Scope),
		Position: pos(c),
	}, nil
}

func (p *parser) callonElse1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse1(stack["thenI"])
}

func (c *current) onIfBlock15(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonIfBlock15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock15(stack["identI"])
}

func (c *current) onIfBlock34() (any, error) {
	return pos(c), nil
}

func (p *parser) callonIfBlock34() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock34()
}

func (c *current) onIfBlock21(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonIfBlock21() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock21(stack["identI"], stack["endPosI"])
}

func (c *current) onIfBlock12(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonIfBlock12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock12(stack["identI"])
}

func (c *current) onIfBlock43() (any, error) {
	return pos(c), nil
}

func (p *parser) callonIfBlock43() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock43()
}

func (c *current) onIfBlock40(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonIfBlock40() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock40(stack["posI"])
}

func (c *current) onIfBlock68() (any, error) {
	return pos(c), nil
}

func (p *parser) callonIfBlock68() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock68()
}

func (c *current) onIfBlock62(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonIfBlock62() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock62(stack["identI"], stack["endPosI"])
}

func (c *current) onIfBlock6(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonIfBlock6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock6(stack["identI"])
}

func (c *current) onIfBlock74() (any, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonIfBlock74() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock74()
}

func (c *current) onIfBlock1(nameI, thenI, elseIfsI, elseI any) (any, error) {
	return file.IfBlock{
		Name:     nameI.(file.Ident),
		Then:     thenI.(file.Scope),
		ElseIfs:  typedSlice[file.ElseIfBlock](elseIfsI),
		Else:     ptrOrNil[file.Else](elseI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonIfBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock1(stack["nameI"], stack["thenI"], stack["elseIfsI"], stack["elseI"])
}

func (c *current) onInlineIfBlock15(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonInlineIfBlock15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfBlock15(stack["identI"])
}

func (c *current) onInlineIfBlock34() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineIfBlock34() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfBlock34()
}

func (c *current) onInlineIfBlock21(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonInlineIfBlock21() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfBlock21(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineIfBlock12(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonInlineIfBlock12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfBlock12(stack["identI"])
}

func (c *current) onInlineIfBlock43() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineIfBlock43() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfBlock43()
}

func (c *current) onInlineIfBlock40(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonInlineIfBlock40() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfBlock40(stack["posI"])
}

func (c *current) onInlineIfBlock68() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineIfBlock68() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfBlock68()
}

func (c *current) onInlineIfBlock62(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonInlineIfBlock62() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfBlock62(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineIfBlock6(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonInlineIfBlock6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfBlock6(stack["identI"])
}

func (c *current) onInlineIfBlock74() (any, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonInlineIfBlock74() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfBlock74()
}

func (c *current) onInlineIfBlock1(nameI, thenI any) (any, error) {
	return file.IfBlock{
		Name:     nameI.(file.Ident),
		Then:     file.Scope{thenI.(file.BlockExpansion)},
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineIfBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfBlock1(stack["nameI"], stack["thenI"])
}

func (c *current) onElseIfBlock11() (any, error) {
	return nil, nil
}

func (p *parser) callonElseIfBlock11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock11()
}

func (c *current) onElseIfBlock14() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonElseIfBlock14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock14()
}

func (c *current) onElseIfBlock16() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonElseIfBlock16() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock16()
}

func (c *current) onElseIfBlock18() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0 && len(c.text) > 0, nil

}

func (p *parser) callonElseIfBlock18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock18()
}

func (c *current) onElseIfBlock19() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonElseIfBlock19() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock19()
}

func (c *current) onElseIfBlock21() (bool, error) {
	// this is NOT our first indentation
	return c.state["Indentation.RefLine"].(int) != 0, nil

}

func (p *parser) callonElseIfBlock21() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock21()
}

func (c *current) onElseIfBlock22() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonElseIfBlock22() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock22()
}

func (c *current) onElseIfBlock25() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonElseIfBlock25() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock25()
}

func (c *current) onElseIfBlock26() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonElseIfBlock26() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock26()
}

func (c *current) onElseIfBlock27() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonElseIfBlock27() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock27()
}

func (c *current) onElseIfBlock29() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonElseIfBlock29() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock29()
}

func (c *current) onElseIfBlock30() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	} else if actualCount < expectCount {
		return false, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonElseIfBlock30() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock30()
}

func (c *current) onElseIfBlock32() (any, error) {
	return pos(c), nil
}

func (p *parser) callonElseIfBlock32() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock32()
}

func (c *current) onElseIfBlock50(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonElseIfBlock50() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock50(stack["identI"])
}

func (c *current) onElseIfBlock69() (any, error) {
	return pos(c), nil
}

func (p *parser) callonElseIfBlock69() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock69()
}

func (c *current) onElseIfBlock56(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonElseIfBlock56() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock56(stack["identI"], stack["endPosI"])
}

func (c *current) onElseIfBlock47(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonElseIfBlock47() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock47(stack["identI"])
}

func (c *current) onElseIfBlock78() (any, error) {
	return pos(c), nil
}

func (p *parser) callonElseIfBlock78() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock78()
}

func (c *current) onElseIfBlock75(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonElseIfBlock75() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock75(stack["posI"])
}

func (c *current) onElseIfBlock103() (any, error) {
	return pos(c), nil
}

func (p *parser) callonElseIfBlock103() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock103()
}

func (c *current) onElseIfBlock97(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonElseIfBlock97() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock97(stack["identI"], stack["endPosI"])
}

func (c *current) onElseIfBlock41(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonElseIfBlock41() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock41(stack["identI"])
}

func (c *current) onElseIfBlock109() (any, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonElseIfBlock109() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock109()
}

func (c *current) onElseIfBlock1(posI, nameI, thenI any) (any, error) {
	return file.ElseIfBlock{
		Name:     nameI.(file.Ident),
		Then:     thenI.(file.Scope),
		Position: posI.(file.Position),
	}, nil
}

func (p *parser) callonElseIfBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock1(stack["posI"], stack["nameI"], stack["thenI"])
}

func (c *current) onSwitch1(comparatorI, bodyI any) (any, error) {
	body := bodyI.(file.Switch)

	s := file.Switch{
		Comparator: comparatorI.(*file.Expression),
		Cases:      body.Cases,
		Default:    body.Default,
		Position:   pos(c),
	}

	if len(s.Cases) == 0 {
		return s, &corgierr.Error{
			Message: "switch must have at least one case",
			ErrorAnnotation: anno(c, annotation{
				ContextEndDelta: 1,
				Start:           pos(c),
				ToEOL:           true,
				Annotation:      "expected switch to have at least one non-default case",
			}),
		}
	}

	return s, nil
}

func (p *parser) callonSwitch1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSwitch1(stack["comparatorI"], stack["bodyI"])
}

func (c *current) onswitchComparator2() (any, error) {
	return (*file.Expression)(nil), nil
}

func (p *parser) callonswitchComparator2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchComparator2()
}

func (c *current) onswitchComparator13(compI any) (any, error) {
	comp := compI.(file.Expression)
	return &comp, nil
}

func (p *parser) callonswitchComparator13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchComparator13(stack["compI"])
}

func (c *current) onswitchComparator35() (any, error) {
	return pos(c), nil
}

func (p *parser) callonswitchComparator35() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchComparator35()
}

func (c *current) onswitchComparator28(compI, startPosI any) (any, error) {
	comp := compI.(file.Expression)
	return &comp, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			Annotation: "expression was terminated here, but should span entire line",
		}),
	}
}

func (p *parser) callonswitchComparator28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchComparator28(stack["compI"], stack["startPosI"])
}

func (c *current) onswitchBody3() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonswitchBody3() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody3()
}

func (c *current) onswitchBody15() (any, error) {
	return nil, nil
}

func (p *parser) callonswitchBody15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody15()
}

func (c *current) onswitchBody18() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonswitchBody18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody18()
}

func (c *current) onswitchBody20() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonswitchBody20() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody20()
}

func (c *current) onswitchBody22() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0 && len(c.text) > 0, nil

}

func (p *parser) callonswitchBody22() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody22()
}

func (c *current) onswitchBody23() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonswitchBody23() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody23()
}

func (c *current) onswitchBody25() (bool, error) {
	// this is NOT our first indentation
	return c.state["Indentation.RefLine"].(int) != 0, nil

}

func (p *parser) callonswitchBody25() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody25()
}

func (c *current) onswitchBody26() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonswitchBody26() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody26()
}

func (c *current) onswitchBody29() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonswitchBody29() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody29()
}

func (c *current) onswitchBody30() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonswitchBody30() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody30()
}

func (c *current) onswitchBody31() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonswitchBody31() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody31()
}

func (c *current) onswitchBody33() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonswitchBody33() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody33()
}

func (c *current) onswitchBody34() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	} else if actualCount < expectCount {
		return false, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonswitchBody34() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody34()
}

func (c *current) onswitchBody36(itms any) error {
	lvl := c.state["Indentation.Level"].(int)
	c.state["Indentation.Level"] = lvl - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonswitchBody36() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody36(stack["itms"])
}

func (c *current) onswitchBody1(itms any) (any, error) {
	tupleTuples := islice(itms)

	s := file.Switch{Cases: make([]file.Case, 0, len(tupleTuples))}

	var err error
	for _, tupleTuple := range tupleTuples {
		tuple := getTuple[any](tupleTuple, -1)

		switchCase, ok := getTuple[file.Case](tuple, 0), getTuple[bool](tuple, -1)
		if switchCase.Expression != nil || !ok {
			s.Cases = append(s.Cases, switchCase)
		} else {
			if s.Default != nil {
				err = &corgierr.Error{
					Message: "multiple default cases in switch",
					ErrorAnnotation: anno(c, annotation{
						Start:      switchCase.Position,
						Len:        len("default"),
						Annotation: "second default case",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      s.Default.Position,
							Len:        len("default"),
							Annotation: "first default case",
						}),
					},
				}
			} else {
				s.Default = &switchCase
			}
		}
	}

	return s, err
}

func (p *parser) callonswitchBody1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody1(stack["itms"])
}

func (c *current) onswitchBodyItem2(caseI any) (any, error) {
	return []any{caseI, true}, nil
}

func (p *parser) callonswitchBodyItem2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBodyItem2(stack["caseI"])
}

func (c *current) onswitchBodyItem7(caseI any) (any, error) {
	return []any{caseI, false}, nil
}

func (p *parser) callonswitchBodyItem7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBodyItem7(stack["caseI"])
}

func (c *current) onCase1(condI, thenI any) (any, error) {
	return file.Case{
		Expression: ptrOrNil[file.Expression](condI),
		Then:       castedOrZero[file.Scope](thenI),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonCase1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCase1(stack["condI"], stack["thenI"])
}

func (c *current) onDefault1(thenI any) (any, error) {
	return file.Case{
		Then:     castedOrZero[file.Scope](thenI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonDefault1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDefault1(stack["thenI"])
}

func (c *current) onswitchThen2(scopeI any) (any, error) {
	return scopeI, nil
}

func (p *parser) callonswitchThen2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchThen2(stack["scopeI"])
}

func (c *current) onswitchThen15(beI any) (any, error) {
	return file.Scope{beI.(file.BlockExpansion)}, nil
}

func (p *parser) callonswitchThen15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchThen15(stack["beI"])
}

func (c *current) onBadCase1(bodyI any) (any, error) {
	firstWordLen := strings.IndexByte(string(c.text), ' ')
	if firstWordLen <= 0 {
		firstWordLen = len([]rune(string(c.text)))
	}

	return file.Case{
			Then:     castedOrZero[file.Scope](bodyI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unrecognized directive in switch body",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Len:        firstWordLen,
				Annotation: "expected a case or a default",
			}),
		}
}

func (p *parser) callonBadCase1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBadCase1(stack["bodyI"])
}

func (c *current) onFor1(exprI, bodyI any) (any, error) {
	return file.For{
		Expression: exprI.(*file.Expression),
		Body:       bodyI.(file.Scope),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonFor1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFor1(stack["exprI"], stack["bodyI"])
}

func (c *current) onInlineFor1(exprI, bodyI any) (any, error) {
	return file.For{
		Expression: exprI.(*file.Expression),
		Body:       file.Scope{bodyI.(file.BlockExpansion)},
		Position:   pos(c),
	}, nil
}

func (p *parser) callonInlineFor1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineFor1(stack["exprI"], stack["bodyI"])
}

func (c *current) onCorgiComments1(commentsI any) (any, error) {
	return typedSliceFromTuples[file.CorgiComment](commentsI, -1), nil
}

func (p *parser) callonCorgiComments1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCorgiComments1(stack["commentsI"])
}

func (c *current) onCorgiComment1(linesI any) (any, error) {
	return file.CorgiComment{
		Lines:    linesI.([]file.CorgiCommentLine),
		Position: pos(c),
	}, nil
}

func (p *parser) callonCorgiComment1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCorgiComment1(stack["linesI"])
}

func (c *current) oncorgiCommentLines2(linesI any) (any, error) {
	return linesI, nil
}

func (p *parser) calloncorgiCommentLines2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentLines2(stack["linesI"])
}

func (c *current) oncorgiCommentLines19(commentI any) (any, error) {
	return file.CorgiCommentLine{Comment: concat(commentI), Position: pos(c)}, nil
}

func (p *parser) calloncorgiCommentLines19() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentLines19(stack["commentI"])
}

func (c *current) oncorgiCommentLines17(lineI any) (any, error) {
	return []file.CorgiCommentLine{lineI.(file.CorgiCommentLine)}, nil
}

func (p *parser) calloncorgiCommentLines17() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentLines17(stack["lineI"])
}

func (c *current) oncorgiCommentBlock3() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) calloncorgiCommentBlock3() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentBlock3()
}

func (c *current) oncorgiCommentBlock16(commentI any) (any, error) {
	return file.CorgiCommentLine{Comment: concat(commentI), Position: pos(c)}, nil
}

func (p *parser) calloncorgiCommentBlock16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentBlock16(stack["commentI"])
}

func (c *current) oncorgiCommentBlock30(linesI any) error {
	lvl := c.state["Indentation.Level"].(int)
	c.state["Indentation.Level"] = lvl - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) calloncorgiCommentBlock30() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentBlock30(stack["linesI"])
}

func (c *current) oncorgiCommentBlock1(linesI any) (any, error) {
	return typedSliceFromTuples[file.CorgiCommentLine](linesI, -1), nil
}

func (p *parser) calloncorgiCommentBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentBlock1(stack["linesI"])
}

func (c *current) onHTMLComment8(linesI any) (any, error) {
	return linesI, nil

}

func (p *parser) callonHTMLComment8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLComment8(stack["linesI"])
}

func (c *current) onHTMLComment23(commentI any) (any, error) {
	return file.HTMLCommentLine{Comment: concat(commentI), Position: pos(c)}, nil
}

func (p *parser) callonHTMLComment23() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLComment23(stack["commentI"])
}

func (c *current) onHTMLComment21(lineI any) (any, error) {
	return []file.HTMLCommentLine{lineI.(file.HTMLCommentLine)}, nil

}

func (p *parser) callonHTMLComment21() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLComment21(stack["lineI"])
}

func (c *current) onHTMLComment1(linesI any) (any, error) {
	return file.HTMLComment{
		Lines:    linesI.([]file.HTMLCommentLine),
		Position: pos(c),
	}, nil
}

func (p *parser) callonHTMLComment1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLComment1(stack["linesI"])
}

func (c *current) onhtmlCommentBlock3() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonhtmlCommentBlock3() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onhtmlCommentBlock3()
}

func (c *current) onhtmlCommentBlock16(commentI any) (any, error) {
	return file.HTMLCommentLine{Comment: concat(commentI), Position: pos(c)}, nil
}

func (p *parser) callonhtmlCommentBlock16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onhtmlCommentBlock16(stack["commentI"])
}

func (c *current) onhtmlCommentBlock30(linesI any) error {
	lvl := c.state["Indentation.Level"].(int)
	c.state["Indentation.Level"] = lvl - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonhtmlCommentBlock30() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onhtmlCommentBlock30(stack["linesI"])
}

func (c *current) onhtmlCommentBlock1(linesI any) (any, error) {
	return typedSliceFromTuples[file.HTMLCommentLine](linesI, -1), nil
}

func (p *parser) callonhtmlCommentBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onhtmlCommentBlock1(stack["linesI"])
}

func (c *current) onElement1(nameI, attrsI, voidI, bodyI any) (any, error) {
	return file.Element{
		Name:       concat(nameI),
		Attributes: typedSlice[file.AttributeCollection](attrsI),
		Body:       bodyI.(file.Scope),
		Void:       voidI != nil,
		Position:   pos(c),
	}, nil
}

func (p *parser) callonElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElement1(stack["nameI"], stack["attrsI"], stack["voidI"], stack["bodyI"])
}

func (c *current) onInlineElement1(nameI, attrsI, voidI, bodyI any) (any, error) {
	return file.Element{
		Name:       concat(nameI),
		Attributes: typedSlice[file.AttributeCollection](attrsI),
		Body:       bodyI.(file.Scope),
		Void:       voidI != nil,
		Position:   pos(c),
	}, nil
}

func (p *parser) callonInlineElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineElement1(stack["nameI"], stack["attrsI"], stack["voidI"], stack["bodyI"])
}

func (c *current) onDivShorthand5(nameI any) (any, error) {
	return file.ClassShorthand{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonDivShorthand5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand5(stack["nameI"])
}

func (c *current) onDivShorthand15() (any, error) {
	return pos(c), nil
}

func (p *parser) callonDivShorthand15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand15()
}

func (c *current) onDivShorthand11(posI any) (any, error) {
	return file.ClassShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "class shorthand: missing class name",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected a class name here",
		}),
	}
}

func (p *parser) callonDivShorthand11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand11(stack["posI"])
}

func (c *current) onDivShorthand21(idI any) (any, error) {
	return file.IDShorthand{
		ID:       concat(idI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonDivShorthand21() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand21(stack["idI"])
}

func (c *current) onDivShorthand31() (any, error) {
	return pos(c), nil
}

func (p *parser) callonDivShorthand31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand31()
}

func (c *current) onDivShorthand27(posI any) (any, error) {
	return file.IDShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "id shorthand: missing id",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an id here",
		}),
	}
}

func (p *parser) callonDivShorthand27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand27(stack["posI"])
}

func (c *current) onDivShorthand1(firstAttrI, moreAttrsI, bodyI any) (any, error) {
	return file.DivShorthand{
		Attributes: append([]file.AttributeCollection{firstAttrI.(file.AttributeCollection)}, typedSlice[file.AttributeCollection](moreAttrsI)...),
		Body:       bodyI.(file.Scope),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonDivShorthand1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand1(stack["firstAttrI"], stack["moreAttrsI"], stack["bodyI"])
}

func (c *current) onInlineDivShorthand5(nameI any) (any, error) {
	return file.ClassShorthand{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineDivShorthand5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand5(stack["nameI"])
}

func (c *current) onInlineDivShorthand15() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineDivShorthand15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand15()
}

func (c *current) onInlineDivShorthand11(posI any) (any, error) {
	return file.ClassShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "class shorthand: missing class name",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected a class name here",
		}),
	}
}

func (p *parser) callonInlineDivShorthand11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand11(stack["posI"])
}

func (c *current) onInlineDivShorthand21(idI any) (any, error) {
	return file.IDShorthand{
		ID:       concat(idI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineDivShorthand21() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand21(stack["idI"])
}

func (c *current) onInlineDivShorthand31() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineDivShorthand31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand31()
}

func (c *current) onInlineDivShorthand27(posI any) (any, error) {
	return file.IDShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "id shorthand: missing id",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an id here",
		}),
	}
}

func (p *parser) callonInlineDivShorthand27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand27(stack["posI"])
}

func (c *current) onInlineDivShorthand1(firstAttrI, moreAttrsI, bodyI any) (any, error) {
	return file.DivShorthand{
		Attributes: append([]file.AttributeCollection{firstAttrI.(file.AttributeCollection)}, typedSlice[file.AttributeCollection](moreAttrsI)...),
		Body:       bodyI.(file.Scope),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonInlineDivShorthand1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand1(stack["firstAttrI"], stack["moreAttrsI"], stack["bodyI"])
}

func (c *current) onAnd2(collsI any) (any, error) {
	return file.And{
		Attributes: typedSlice[file.AttributeCollection](collsI),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonAnd2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd2(stack["collsI"])
}

func (c *current) onAnd21() (any, error) {
	return pos(c), nil
}

func (p *parser) callonAnd21() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd21()
}

func (c *current) onAnd17(posI any) (any, error) {
	return file.And{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "`&` with no attributes",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an attribute here",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "write a class shorthand", Example: "`&.woof`"},
				{Suggestion: "write an id shorthand", Example: "`&#bark`"},
				{Suggestion: "write an attribute list", Example: "`&(src=\"bark/woof\", title=\"howl\")`"},
			},
		}
}

func (p *parser) callonAnd17() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd17(stack["posI"])
}

func (c *current) onAnd43() (any, error) {
	return pos(c), nil
}

func (p *parser) callonAnd43() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd43()
}

func (c *current) onAnd36(collsI, posI any) (any, error) {
	return file.And{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "bad attribute syntax",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "this is not a valid attribute (list)",
			}),
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "if there is, remove any whitespace between class/id shorthands and attribute lists",
					Example:    "`&#bark .woof (title=\"howl\")`",
					ShouldBe:   "`&#bark.woof(title=\"howl\")`",
				},
				{Suggestion: "write a class shorthand", Example: "`&.woof`"},
				{Suggestion: "write an id shorthand", Example: "`&#bark`"},
				{Suggestion: "write an attribute list", Example: "`&(src=\"bark/woof\", title=\"howl\")`"},
			},
		}
}

func (p *parser) callonAnd36() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd36(stack["collsI"], stack["posI"])
}

func (c *current) onInlineAnd2(collsI any) (any, error) {
	return file.And{
		Attributes: typedSlice[file.AttributeCollection](collsI),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonInlineAnd2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineAnd2(stack["collsI"])
}

func (c *current) onInlineAnd21() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineAnd21() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineAnd21()
}

func (c *current) onInlineAnd17(posI any) (any, error) {
	return file.And{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "`&` with no attributes",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an attribute here",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "write a class shorthand", Example: "`&.woof`"},
				{Suggestion: "write an id shorthand", Example: "`&#bark`"},
				{Suggestion: "write an attribute list", Example: "`&(src=\"bark/woof\", title=\"howl\")`"},
			},
		}
}

func (p *parser) callonInlineAnd17() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineAnd17(stack["posI"])
}

func (c *current) onInlineAnd43() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineAnd43() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineAnd43()
}

func (c *current) onInlineAnd36(collsI, posI any) (any, error) {
	return file.And{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "bad attribute syntax",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "this is not a valid attribute (list)",
			}),
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "if there is, remove any whitespace between class/id shorthands and attribute lists",
					Example:    "`&#bark .woof (title=\"howl\")`",
					ShouldBe:   "`&#bark.woof(title=\"howl\")`",
				},
				{Suggestion: "write a class shorthand", Example: "`&.woof`"},
				{Suggestion: "write an id shorthand", Example: "`&#bark`"},
				{Suggestion: "write an attribute list", Example: "`&(src=\"bark/woof\", title=\"howl\")`"},
			},
		}
}

func (p *parser) callonInlineAnd36() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineAnd36(stack["collsI"], stack["posI"])
}

func (c *current) onAttributeCollection2(idI any) (any, error) {
	return file.IDShorthand{
		ID:       concat(idI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonAttributeCollection2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection2(stack["idI"])
}

func (c *current) onAttributeCollection12() (any, error) {
	return pos(c), nil
}

func (p *parser) callonAttributeCollection12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection12()
}

func (c *current) onAttributeCollection8(posI any) (any, error) {
	return file.IDShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "id shorthand: missing id",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an id here",
		}),
	}
}

func (p *parser) callonAttributeCollection8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection8(stack["posI"])
}

func (c *current) onAttributeCollection18(nameI any) (any, error) {
	return file.ClassShorthand{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonAttributeCollection18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection18(stack["nameI"])
}

func (c *current) onAttributeCollection28() (any, error) {
	return pos(c), nil
}

func (p *parser) callonAttributeCollection28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection28()
}

func (c *current) onAttributeCollection24(posI any) (any, error) {
	return file.ClassShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "class shorthand: missing class name",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected a class name here",
		}),
	}
}

func (p *parser) callonAttributeCollection24() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection24(stack["posI"])
}

func (c *current) onSingleLineAttributeCollection2(idI any) (any, error) {
	return file.IDShorthand{
		ID:       concat(idI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSingleLineAttributeCollection2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection2(stack["idI"])
}

func (c *current) onSingleLineAttributeCollection12() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineAttributeCollection12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection12()
}

func (c *current) onSingleLineAttributeCollection8(posI any) (any, error) {
	return file.IDShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "id shorthand: missing id",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an id here",
		}),
	}
}

func (p *parser) callonSingleLineAttributeCollection8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection8(stack["posI"])
}

func (c *current) onSingleLineAttributeCollection18(nameI any) (any, error) {
	return file.ClassShorthand{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSingleLineAttributeCollection18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection18(stack["nameI"])
}

func (c *current) onSingleLineAttributeCollection28() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineAttributeCollection28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection28()
}

func (c *current) onSingleLineAttributeCollection24(posI any) (any, error) {
	return file.ClassShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "class shorthand: missing class name",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected a class name here",
		}),
	}
}

func (p *parser) callonSingleLineAttributeCollection24() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection24(stack["posI"])
}

func (c *current) onAttributeList28() (any, error) {
	return pos(c), nil
}

func (p *parser) callonAttributeList28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList28()
}

func (c *current) onAttributeList2(attributesI, rParenPosI any) (any, error) {
	return file.AttributeList{
		LParenPos:  pos(c),
		Attributes: castedOrZero[[]file.Attribute](attributesI),
		RParenPos:  rParenPosI.(file.Position),
	}, nil
}

func (p *parser) callonAttributeList2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList2(stack["attributesI"], stack["rParenPosI"])
}

func (c *current) onAttributeList49() (any, error) {
	return pos(c), nil
}

func (p *parser) callonAttributeList49() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList49()
}

func (c *current) onAttributeList30(attributesI, posI any) (any, error) {
	return file.AttributeList{
			LParenPos:  pos(c),
			Attributes: castedOrZero[[]file.Attribute](attributesI),
		}, &corgierr.Error{
			Message: "attribute list: unclosed `(` or missing `,`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)` or `,`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonAttributeList30() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList30(stack["attributesI"], stack["posI"])
}

func (c *current) onattributes1(firstI, restI any) (any, error) {
	restIs := islice(restI)
	attributes := make([]file.Attribute, 1+len(restIs))
	attributes[0] = firstI.(file.Attribute)
	for i, ai := range restIs {
		attributes[i+1] = getTuple[file.Attribute](ai, -1)
	}

	return attributes, nil
}

func (p *parser) callonattributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onattributes1(stack["firstI"], stack["restI"])
}

func (c *current) onSingleLineAttributeList18() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineAttributeList18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeList18()
}

func (c *current) onSingleLineAttributeList2(attributesI, rParenPosI any) (any, error) {
	return file.AttributeList{
		LParenPos:  pos(c),
		Attributes: castedOrZero[[]file.Attribute](attributesI),
		RParenPos:  rParenPosI.(file.Position),
	}, nil
}

func (p *parser) callonSingleLineAttributeList2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeList2(stack["attributesI"], stack["rParenPosI"])
}

func (c *current) onSingleLineAttributeList34() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineAttributeList34() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeList34()
}

func (c *current) onSingleLineAttributeList20(attributesI, posI any) (any, error) {
	return file.AttributeList{
			LParenPos:  pos(c),
			Attributes: castedOrZero[[]file.Attribute](attributesI),
		}, &corgierr.Error{
			Message: "attribute list: unclosed `(` or missing `,`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)` or `,`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonSingleLineAttributeList20() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeList20(stack["attributesI"], stack["posI"])
}

func (c *current) onsingleLineAttributes1(firstI, restI any) (any, error) {
	restIs := islice(restI)
	attributes := make([]file.Attribute, 1+len(restIs))
	attributes[0] = firstI.(file.Attribute)
	for i, ai := range restIs {
		attributes[i+1] = getTuple[file.Attribute](ai, -1)
	}

	return attributes, nil
}

func (p *parser) callonsingleLineAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineAttributes1(stack["firstI"], stack["restI"])
}

func (c *current) onAttribute3() (any, error) {
	return file.AndPlaceholder{Position: pos(c)}, nil
}

func (p *parser) callonAttribute3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttribute3()
}

func (c *current) onSingleLineAttribute3() (any, error) {
	return file.AndPlaceholder{Position: pos(c)}, nil
}

func (p *parser) callonSingleLineAttribute3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttribute3()
}

func (c *current) onSimpleAttribute3(nameI any) (any, error) {
	return file.SimpleAttribute{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSimpleAttribute3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleAttribute3(stack["nameI"])
}

func (c *current) onSingleLineSimpleAttribute3(nameI any) (any, error) {
	return file.SimpleAttribute{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSingleLineSimpleAttribute3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineSimpleAttribute3(stack["nameI"])
}

func (c *current) onsimpleValueAttribute15() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsimpleValueAttribute15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute15()
}

func (c *current) onsimpleValueAttribute30() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsimpleValueAttribute30() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute30()
}

func (c *current) onsimpleValueAttribute2(nameI, assignPosI, posI, exprI any) (any, error) {
	return file.SimpleAttribute{
		Name:      concat(nameI),
		AssignPos: ptr(assignPosI.(file.Position)),
		Value:     ptrOrNil[file.Expression](exprI),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonsimpleValueAttribute2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute2(stack["nameI"], stack["assignPosI"], stack["posI"], stack["exprI"])
}

func (c *current) onsimpleValueAttribute51() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsimpleValueAttribute51() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute51()
}

func (c *current) onsimpleValueAttribute59() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsimpleValueAttribute59() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute59()
}

func (c *current) onsimpleValueAttribute38(nameI, assignPosI, posI any) (any, error) {
	return file.SimpleAttribute{
			Name:      concat(nameI),
			AssignPos: ptrOrNil[file.Position](assignPosI),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "attribute: missing value expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an expression here",
			}),
		}
}

func (p *parser) callonsimpleValueAttribute38() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute38(stack["nameI"], stack["assignPosI"], stack["posI"])
}

func (c *current) onsingleLineSimpleValueAttribute15() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineSimpleValueAttribute15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute15()
}

func (c *current) onsingleLineSimpleValueAttribute2(nameI, assignPosI, exprI any) (any, error) {
	return file.SimpleAttribute{
		Name:      concat(nameI),
		AssignPos: ptrOrNil[file.Position](assignPosI),
		Value:     ptrOrNil[file.Expression](exprI),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonsingleLineSimpleValueAttribute2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute2(stack["nameI"], stack["assignPosI"], stack["exprI"])
}

func (c *current) onsingleLineSimpleValueAttribute39() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineSimpleValueAttribute39() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute39()
}

func (c *current) onsingleLineSimpleValueAttribute47() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineSimpleValueAttribute47() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute47()
}

func (c *current) onsingleLineSimpleValueAttribute26(nameI, assignPosI, posI any) (any, error) {
	return file.SimpleAttribute{
			Name:      concat(nameI),
			AssignPos: ptrOrNil[file.Position](assignPosI),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "attribute: missing value expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an expression or a mixin call here",
			}),
		}
}

func (p *parser) callonsingleLineSimpleValueAttribute26() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute26(stack["nameI"], stack["assignPosI"], stack["posI"])
}

func (c *current) onMixinCallAttribute14() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallAttribute14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallAttribute14()
}

func (c *current) onMixinCallAttribute1(nameI, assignPosI, callI any) (any, error) {
	call := callI.(file.MixinCallAttribute)
	return file.MixinCallAttribute{
		Name:      concat(nameI),
		AssignPos: assignPosI.(file.Position),
		MixinCall: call.MixinCall,
		Value:     call.Value,
		Position:  pos(c),
	}, nil
}

func (p *parser) callonMixinCallAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallAttribute1(stack["nameI"], stack["assignPosI"], stack["callI"])
}

func (c *current) onSingleLineMixinCallAttribute14() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineMixinCallAttribute14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineMixinCallAttribute14()
}

func (c *current) onSingleLineMixinCallAttribute1(nameI, assignPosI, callI any) (any, error) {
	call := callI.(file.MixinCallAttribute)
	return file.MixinCallAttribute{
		Name:      concat(nameI),
		AssignPos: assignPosI.(file.Position),
		MixinCall: call.MixinCall,
		Value:     call.Value,
		Position:  pos(c),
	}, nil
}

func (p *parser) callonSingleLineMixinCallAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineMixinCallAttribute1(stack["nameI"], stack["assignPosI"], stack["callI"])
}

func (c *current) onmixinCallAttributeCall8(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonmixinCallAttributeCall8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall8(stack["identI"])
}

func (c *current) onmixinCallAttributeCall27() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeCall27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall27()
}

func (c *current) onmixinCallAttributeCall14(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonmixinCallAttributeCall14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall14(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinCallAttributeCall39(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonmixinCallAttributeCall39() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall39(stack["identI"])
}

func (c *current) onmixinCallAttributeCall58() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeCall58() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall58()
}

func (c *current) onmixinCallAttributeCall45(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonmixinCallAttributeCall45() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall45(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinCallAttributeCall36(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonmixinCallAttributeCall36() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall36(stack["identI"])
}

func (c *current) onmixinCallAttributeCall67() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeCall67() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall67()
}

func (c *current) onmixinCallAttributeCall64(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinCallAttributeCall64() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall64(stack["posI"])
}

func (c *current) onmixinCallAttributeCall92() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeCall92() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall92()
}

func (c *current) onmixinCallAttributeCall86(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinCallAttributeCall86() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall86(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinCallAttributeCall1(namespaceI, nameI, argsI, valueI any) (any, error) {
	args := castedOrZero[file.MixinCall](argsI)

	var namespace *file.Ident
	if namespaceI != nil {
		namespace = ptr(getTuple[file.Ident](namespaceI, 0))
	}

	return file.MixinCallAttribute{
		MixinCall: file.MixinCall{
			Namespace: namespace,
			Name:      nameI.(file.Ident),
			LParenPos: args.LParenPos,
			Args:      args.Args,
			RParenPos: args.RParenPos,
			Position:  pos(c),
		},
		Value: castedOrZero[file.InterpolationValue](valueI),
	}, nil
}

func (p *parser) callonmixinCallAttributeCall1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["valueI"])
}

func (c *current) onsingleLineMixinCallAttributeCall8(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall8(stack["identI"])
}

func (c *current) onsingleLineMixinCallAttributeCall27() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall27()
}

func (c *current) onsingleLineMixinCallAttributeCall14(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonsingleLineMixinCallAttributeCall14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall14(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinCallAttributeCall39(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall39() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall39(stack["identI"])
}

func (c *current) onsingleLineMixinCallAttributeCall58() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall58() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall58()
}

func (c *current) onsingleLineMixinCallAttributeCall45(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonsingleLineMixinCallAttributeCall45() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall45(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinCallAttributeCall36(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall36() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall36(stack["identI"])
}

func (c *current) onsingleLineMixinCallAttributeCall67() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall67() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall67()
}

func (c *current) onsingleLineMixinCallAttributeCall64(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonsingleLineMixinCallAttributeCall64() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall64(stack["posI"])
}

func (c *current) onsingleLineMixinCallAttributeCall92() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall92() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall92()
}

func (c *current) onsingleLineMixinCallAttributeCall86(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonsingleLineMixinCallAttributeCall86() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall86(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinCallAttributeCall1(namespaceI, nameI, argsI, valueI any) (any, error) {
	args := castedOrZero[file.MixinCall](argsI)

	var namespace *file.Ident
	if namespaceI != nil {
		namespace = ptr(getTuple[file.Ident](namespaceI, 0))
	}

	return file.MixinCallAttribute{
		MixinCall: file.MixinCall{
			Namespace: namespace,
			Name:      nameI.(file.Ident),
			LParenPos: args.LParenPos,
			Args:      args.Args,
			RParenPos: args.RParenPos,
			Position:  pos(c),
		},
		Value: castedOrZero[file.InterpolationValue](valueI),
	}, nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["valueI"])
}

func (c *current) onmixinCallAttributeValue5() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeValue5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeValue5()
}

func (c *current) onmixinCallAttributeValue11() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeValue11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeValue11()
}

func (c *current) onmixinCallAttributeValue2(lBracketPosI, textI, rBracketPosI any) (any, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
		RBracketPos: rBracketPosI.(file.Position),
	}, nil
}

func (p *parser) callonmixinCallAttributeValue2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeValue2(stack["lBracketPosI"], stack["textI"], stack["rBracketPosI"])
}

func (c *current) onmixinCallAttributeValue16() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeValue16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeValue16()
}

func (c *current) onmixinCallAttributeValue13(lBracketPosI, textI any) (any, error) {
	return file.TextInterpolationValue{
			LBracketPos: lBracketPosI.(file.Position),
			Text:        concat(textI),
		}, &corgierr.Error{
			Message: "unclosed text interpolation",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "`[` opened here, but never closeed",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:       pos(c),
					StartOffset: 1,
					EOLDelta:    1,
					Annotation:  "expected a `]` somewhere here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
			},
		}
}

func (p *parser) callonmixinCallAttributeValue13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeValue13(stack["lBracketPosI"], stack["textI"])
}

func (c *current) onExpression2(cExprI any) (any, error) {
	return file.Expression{Expressions: []file.ExpressionItem{cExprI.(file.ChainExpression)}}, nil
}

func (p *parser) callonExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExpression2(stack["cExprI"])
}

func (c *current) onSingleLineExpression2(cExprI any) (any, error) {
	return file.Expression{Expressions: []file.ExpressionItem{cExprI.(file.ChainExpression)}}, nil
}

func (p *parser) callonSingleLineExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineExpression2(stack["cExprI"])
}

func (c *current) onGoExpression11() (any, error) {
	return pos(c), nil
}

func (p *parser) callonGoExpression11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression11()
}

func (c *current) onGoExpression27() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonGoExpression27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression27()
}

func (c *current) onGoExpression48() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonGoExpression48() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression48()
}

func (c *current) onGoExpression80() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonGoExpression80() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression80()
}

func (c *current) onGoExpression87() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression87() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression87()
}

func (c *current) onGoExpression98() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression98() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression98()
}

func (c *current) onGoExpression105() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression105() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression105()
}

func (c *current) onGoExpression110() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonGoExpression110() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression110()
}

func (c *current) onGoExpression128() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonGoExpression128() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression128()
}

func (c *current) onGoExpression149() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonGoExpression149() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression149()
}

func (c *current) onGoExpression181() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonGoExpression181() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression181()
}

func (c *current) onGoExpression188() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression188() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression188()
}

func (c *current) onGoExpression199() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression199() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression199()
}

func (c *current) onGoExpression206() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression206() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression206()
}

func (c *current) onGoExpression211() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonGoExpression211() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression211()
}

func (c *current) onGoExpression218() (any, error) {
	return pos(c), nil
}

func (p *parser) callonGoExpression218() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression218()
}

func (c *current) onGoExpression116(valsI, endPosI any) (any, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonGoExpression116() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression116(stack["valsI"], stack["endPosI"])
}

func (c *current) onGoExpression8(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil
}

func (p *parser) callonGoExpression8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression8(stack["posI"])
}

func (c *current) onGoExpression227() (any, error) {
	return pos(c), nil
}

func (p *parser) callonGoExpression227() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression227()
}

func (c *current) onGoExpression224(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonGoExpression224() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression224(stack["posI"])
}

func (c *current) onGoExpression1(exprsI any) (any, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonGoExpression1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression1(stack["exprsI"])
}

func (c *current) ongoParenExpr9() (any, error) {
	return pos(c), nil
}

func (p *parser) callongoParenExpr9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoParenExpr9()
}

func (c *current) ongoParenExpr20() (any, error) {
	return pos(c), nil
}

func (p *parser) callongoParenExpr20() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoParenExpr20()
}

func (c *current) ongoParenExpr31() (any, error) {
	return pos(c), nil
}

func (p *parser) callongoParenExpr31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoParenExpr31()
}

func (c *current) ongoParenExpr2(exprI any) (any, error) {
	exprIs := islice(exprI)
	if exprIs[1] == nil {
		return file.GoExpression{
			Expression: concat(exprIs[0]) + concat(exprIs[3]),
			Position:   pos(c),
		}, nil
	}

	expr := exprIs[1].(file.Expression)

	exprs := make([]file.ExpressionItem, len(expr.Expressions)+ /* open/closing paren */ 2)
	copy(exprs[1:], expr.Expressions)
	exprs[0] = file.GoExpression{
		Expression: concat(exprIs[0]), // opening paren
		Position:   pos(c),
	}
	exprs[len(exprs)-1] = file.GoExpression{
		Expression: concat(exprIs[3]), // closing paren
		Position:   exprIs[2].(file.Position),
	}

	return exprs, nil
}

func (p *parser) callongoParenExpr2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoParenExpr2(stack["exprI"])
}

func (c *current) ongoParenExpr43() (any, error) {
	return pos(c), nil
}

func (p *parser) callongoParenExpr43() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoParenExpr43()
}

func (c *current) ongoParenExpr38(parenI, startPosI, exprI any) (any, error) {
	openParen := string(char(parenI))

	closeParen := ")"
	if openParen == "[" {
		closeParen = "]"
	} else if openParen == "{" {
		closeParen = "}"
	}

	exprs := append([]file.ExpressionItem{file.GoExpression{
		Expression: openParen,
		Position:   pos(c),
	}}, castedOrZero[file.Expression](exprI).Expressions...)

	return exprs, &corgierr.Error{
		Message: "unclosed `" + openParen + "` in expression",
		ErrorAnnotation: anno(c, annotation{
			ContextLen: 3,
			Start:      startPosI.(file.Position),
			EOLDelta:   1,
			Annotation: "expected a `" + closeParen + "` somewhere here or on a line below",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      pos(c),
				Annotation: "for the `" + openParen + "` you opened here",
			}),
		},
	}
}

func (p *parser) callongoParenExpr38() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoParenExpr38(stack["parenI"], stack["startPosI"], stack["exprI"])
}

func (c *current) ongoSubExpression11() (any, error) {
	return pos(c), nil
}

func (p *parser) callongoSubExpression11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression11()
}

func (c *current) ongoSubExpression27() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoSubExpression27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression27()
}

func (c *current) ongoSubExpression48() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoSubExpression48() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression48()
}

func (c *current) ongoSubExpression80() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callongoSubExpression80() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression80()
}

func (c *current) ongoSubExpression87() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression87() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression87()
}

func (c *current) ongoSubExpression98() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression98() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression98()
}

func (c *current) ongoSubExpression105() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression105() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression105()
}

func (c *current) ongoSubExpression110() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callongoSubExpression110() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression110()
}

func (c *current) ongoSubExpression128() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoSubExpression128() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression128()
}

func (c *current) ongoSubExpression149() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoSubExpression149() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression149()
}

func (c *current) ongoSubExpression181() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callongoSubExpression181() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression181()
}

func (c *current) ongoSubExpression188() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression188() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression188()
}

func (c *current) ongoSubExpression199() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression199() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression199()
}

func (c *current) ongoSubExpression206() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression206() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression206()
}

func (c *current) ongoSubExpression211() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callongoSubExpression211() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression211()
}

func (c *current) ongoSubExpression218() (any, error) {
	return pos(c), nil
}

func (p *parser) callongoSubExpression218() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression218()
}

func (c *current) ongoSubExpression116(valsI, endPosI any) (any, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callongoSubExpression116() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression116(stack["valsI"], stack["endPosI"])
}

func (c *current) ongoSubExpression8(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil
}

func (p *parser) callongoSubExpression8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression8(stack["posI"])
}

func (c *current) ongoSubExpression227() (any, error) {
	return pos(c), nil
}

func (p *parser) callongoSubExpression227() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression227()
}

func (c *current) ongoSubExpression224(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callongoSubExpression224() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression224(stack["posI"])
}

func (c *current) ongoSubExpression1(exprsI any) (any, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callongoSubExpression1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression1(stack["exprsI"])
}

func (c *current) onmultiLineGoExpression11() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmultiLineGoExpression11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression11()
}

func (c *current) onmultiLineGoExpression27() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonmultiLineGoExpression27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression27()
}

func (c *current) onmultiLineGoExpression48() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonmultiLineGoExpression48() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression48()
}

func (c *current) onmultiLineGoExpression80() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonmultiLineGoExpression80() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression80()
}

func (c *current) onmultiLineGoExpression87() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression87() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression87()
}

func (c *current) onmultiLineGoExpression98() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression98() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression98()
}

func (c *current) onmultiLineGoExpression105() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression105() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression105()
}

func (c *current) onmultiLineGoExpression110() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression110() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression110()
}

func (c *current) onmultiLineGoExpression128() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonmultiLineGoExpression128() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression128()
}

func (c *current) onmultiLineGoExpression149() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonmultiLineGoExpression149() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression149()
}

func (c *current) onmultiLineGoExpression181() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonmultiLineGoExpression181() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression181()
}

func (c *current) onmultiLineGoExpression188() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression188() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression188()
}

func (c *current) onmultiLineGoExpression199() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression199() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression199()
}

func (c *current) onmultiLineGoExpression206() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression206() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression206()
}

func (c *current) onmultiLineGoExpression211() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression211() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression211()
}

func (c *current) onmultiLineGoExpression218() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmultiLineGoExpression218() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression218()
}

func (c *current) onmultiLineGoExpression116(valsI, endPosI any) (any, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonmultiLineGoExpression116() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression116(stack["valsI"], stack["endPosI"])
}

func (c *current) onmultiLineGoExpression8(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil
}

func (p *parser) callonmultiLineGoExpression8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression8(stack["posI"])
}

func (c *current) onmultiLineGoExpression227() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmultiLineGoExpression227() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression227()
}

func (c *current) onmultiLineGoExpression224(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonmultiLineGoExpression224() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression224(stack["posI"])
}

func (c *current) onmultiLineGoExpression1(exprsI any) (any, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonmultiLineGoExpression1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression1(stack["exprsI"])
}

func (c *current) onSingleLineGoExpression11() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineGoExpression11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression11()
}

func (c *current) onSingleLineGoExpression27() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineGoExpression27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression27()
}

func (c *current) onSingleLineGoExpression48() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineGoExpression48() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression48()
}

func (c *current) onSingleLineGoExpression80() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonSingleLineGoExpression80() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression80()
}

func (c *current) onSingleLineGoExpression87() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression87() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression87()
}

func (c *current) onSingleLineGoExpression98() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression98() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression98()
}

func (c *current) onSingleLineGoExpression105() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression105() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression105()
}

func (c *current) onSingleLineGoExpression110() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression110() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression110()
}

func (c *current) onSingleLineGoExpression128() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineGoExpression128() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression128()
}

func (c *current) onSingleLineGoExpression149() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineGoExpression149() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression149()
}

func (c *current) onSingleLineGoExpression181() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonSingleLineGoExpression181() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression181()
}

func (c *current) onSingleLineGoExpression188() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression188() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression188()
}

func (c *current) onSingleLineGoExpression199() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression199() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression199()
}

func (c *current) onSingleLineGoExpression206() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression206() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression206()
}

func (c *current) onSingleLineGoExpression211() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression211() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression211()
}

func (c *current) onSingleLineGoExpression218() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineGoExpression218() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression218()
}

func (c *current) onSingleLineGoExpression116(valsI, endPosI any) (any, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonSingleLineGoExpression116() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression116(stack["valsI"], stack["endPosI"])
}

func (c *current) onSingleLineGoExpression8(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil
}

func (p *parser) callonSingleLineGoExpression8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression8(stack["posI"])
}

func (c *current) onSingleLineGoExpression227() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineGoExpression227() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression227()
}

func (c *current) onSingleLineGoExpression224(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonSingleLineGoExpression224() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression224(stack["posI"])
}

func (c *current) onSingleLineGoExpression1(exprsI any) (any, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonSingleLineGoExpression1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression1(stack["exprsI"])
}

func (c *current) onsingleLineGoParenExpr9() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoParenExpr9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoParenExpr9()
}

func (c *current) onsingleLineGoParenExpr20() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoParenExpr20() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoParenExpr20()
}

func (c *current) onsingleLineGoParenExpr31() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoParenExpr31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoParenExpr31()
}

func (c *current) onsingleLineGoParenExpr2(exprI any) (any, error) {
	exprIs := islice(exprI)
	if exprIs[1] == nil {
		return file.GoExpression{
			Expression: concat(exprIs[0]) + concat(exprIs[3]),
			Position:   pos(c),
		}, nil
	}

	expr := exprIs[1].(file.Expression)

	exprs := make([]file.ExpressionItem, len(expr.Expressions)+ /* open/closing paren */ 2)
	copy(exprs[1:], expr.Expressions)
	exprs[0] = file.GoExpression{
		Expression: concat(exprIs[0]),
		Position:   pos(c),
	}
	exprs[len(exprs)-1] = file.GoExpression{
		Expression: concat(exprIs[3]),
		Position:   exprIs[2].(file.Position),
	}

	return exprs, nil
}

func (p *parser) callonsingleLineGoParenExpr2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoParenExpr2(stack["exprI"])
}

func (c *current) onsingleLineGoParenExpr43() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoParenExpr43() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoParenExpr43()
}

func (c *current) onsingleLineGoParenExpr38(parenI, startPosI, exprI any) (any, error) {
	openParen := string(char(parenI))

	closeParen := ")"
	if openParen == "[" {
		closeParen = "]"
	} else if openParen == "{" {
		closeParen = "}"
	}

	exprs := append([]file.ExpressionItem{file.GoExpression{
		Expression: openParen,
		Position:   pos(c),
	}}, castedOrZero[file.Expression](exprI).Expressions...)

	return exprs, &corgierr.Error{
		Message: "unclosed `" + openParen + "` in expression",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			EOLDelta:   1,
			Annotation: "expected a `" + closeParen + "` somewhere here",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      pos(c),
				Annotation: "for the `" + openParen + "` you opened here",
			}),
		},
	}
}

func (p *parser) callonsingleLineGoParenExpr38() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoParenExpr38(stack["parenI"], stack["startPosI"], stack["exprI"])
}

func (c *current) onsingleLineGoSubExpression11() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoSubExpression11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression11()
}

func (c *current) onsingleLineGoSubExpression27() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineGoSubExpression27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression27()
}

func (c *current) onsingleLineGoSubExpression48() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineGoSubExpression48() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression48()
}

func (c *current) onsingleLineGoSubExpression80() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonsingleLineGoSubExpression80() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression80()
}

func (c *current) onsingleLineGoSubExpression87() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression87() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression87()
}

func (c *current) onsingleLineGoSubExpression98() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression98() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression98()
}

func (c *current) onsingleLineGoSubExpression105() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression105() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression105()
}

func (c *current) onsingleLineGoSubExpression110() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression110() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression110()
}

func (c *current) onsingleLineGoSubExpression128() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineGoSubExpression128() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression128()
}

func (c *current) onsingleLineGoSubExpression149() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineGoSubExpression149() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression149()
}

func (c *current) onsingleLineGoSubExpression181() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonsingleLineGoSubExpression181() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression181()
}

func (c *current) onsingleLineGoSubExpression188() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression188() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression188()
}

func (c *current) onsingleLineGoSubExpression199() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression199() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression199()
}

func (c *current) onsingleLineGoSubExpression206() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression206() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression206()
}

func (c *current) onsingleLineGoSubExpression211() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression211() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression211()
}

func (c *current) onsingleLineGoSubExpression218() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoSubExpression218() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression218()
}

func (c *current) onsingleLineGoSubExpression116(valsI, endPosI any) (any, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonsingleLineGoSubExpression116() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression116(stack["valsI"], stack["endPosI"])
}

func (c *current) onsingleLineGoSubExpression8(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil
}

func (p *parser) callonsingleLineGoSubExpression8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression8(stack["posI"])
}

func (c *current) onsingleLineGoSubExpression227() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoSubExpression227() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression227()
}

func (c *current) onsingleLineGoSubExpression224(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonsingleLineGoSubExpression224() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression224(stack["posI"])
}

func (c *current) onsingleLineGoSubExpression1(exprsI any) (any, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonsingleLineGoSubExpression1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression1(stack["exprsI"])
}

func (c *current) onIfExpression2(cExprI any) (any, error) {
	cExpr := cExprI.(file.ChainExpression)
	expr := file.Expression{Expressions: []file.ExpressionItem{cExpr}}
	if cExpr.Default != nil {
		return expr, &corgierr.Error{
			Message: "chain expression with default as conditional",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "here", // todo: span the entire len of the expression
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remove the default"},
			},
		}
	}

	return expr, nil
}

func (p *parser) callonIfExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression2(stack["cExprI"])
}

func (c *current) onIfExpression15() (any, error) {
	return pos(c), nil
}

func (p *parser) callonIfExpression15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression15()
}

func (c *current) onIfExpression31() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonIfExpression31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression31()
}

func (c *current) onIfExpression52() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonIfExpression52() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression52()
}

func (c *current) onIfExpression84() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonIfExpression84() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression84()
}

func (c *current) onIfExpression91() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression91() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression91()
}

func (c *current) onIfExpression102() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression102() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression102()
}

func (c *current) onIfExpression109() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression109() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression109()
}

func (c *current) onIfExpression114() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonIfExpression114() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression114()
}

func (c *current) onIfExpression132() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonIfExpression132() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression132()
}

func (c *current) onIfExpression153() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonIfExpression153() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression153()
}

func (c *current) onIfExpression185() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonIfExpression185() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression185()
}

func (c *current) onIfExpression192() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression192() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression192()
}

func (c *current) onIfExpression203() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression203() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression203()
}

func (c *current) onIfExpression210() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression210() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression210()
}

func (c *current) onIfExpression215() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonIfExpression215() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression215()
}

func (c *current) onIfExpression222() (any, error) {
	return pos(c), nil
}

func (p *parser) callonIfExpression222() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression222()
}

func (c *current) onIfExpression120(valsI, endPosI any) (any, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonIfExpression120() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression120(stack["valsI"], stack["endPosI"])
}

func (c *current) onIfExpression12(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil
}

func (p *parser) callonIfExpression12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression12(stack["posI"])
}

func (c *current) onIfExpression231() (any, error) {
	return pos(c), nil
}

func (p *parser) callonIfExpression231() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression231()
}

func (c *current) onIfExpression228(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonIfExpression228() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression228(stack["posI"])
}

func (c *current) onIfExpression5(exprsI any) (any, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonIfExpression5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression5(stack["exprsI"])
}

func (c *current) onSingleLineIfExpression2(cExprI any) (any, error) {
	cExpr := cExprI.(file.ChainExpression)
	expr := file.Expression{Expressions: []file.ExpressionItem{cExpr}}
	if cExpr.Default != nil {
		return expr, &corgierr.Error{
			Message: "chain expression with default as conditional",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "here", // todo: span the entire len of the expression
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remove the default"},
			},
		}
	}

	return expr, nil
}

func (p *parser) callonSingleLineIfExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression2(stack["cExprI"])
}

func (c *current) onSingleLineIfExpression15() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineIfExpression15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression15()
}

func (c *current) onSingleLineIfExpression31() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineIfExpression31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression31()
}

func (c *current) onSingleLineIfExpression52() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineIfExpression52() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression52()
}

func (c *current) onSingleLineIfExpression84() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonSingleLineIfExpression84() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression84()
}

func (c *current) onSingleLineIfExpression91() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineIfExpression91() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression91()
}

func (c *current) onSingleLineIfExpression102() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineIfExpression102() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression102()
}

func (c *current) onSingleLineIfExpression109() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineIfExpression109() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression109()
}

func (c *current) onSingleLineIfExpression114() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonSingleLineIfExpression114() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression114()
}

func (c *current) onSingleLineIfExpression132() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineIfExpression132() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression132()
}

func (c *current) onSingleLineIfExpression153() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineIfExpression153() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression153()
}

func (c *current) onSingleLineIfExpression185() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonSingleLineIfExpression185() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression185()
}

func (c *current) onSingleLineIfExpression192() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineIfExpression192() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression192()
}

func (c *current) onSingleLineIfExpression203() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineIfExpression203() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression203()
}

func (c *current) onSingleLineIfExpression210() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineIfExpression210() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression210()
}

func (c *current) onSingleLineIfExpression215() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonSingleLineIfExpression215() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression215()
}

func (c *current) onSingleLineIfExpression222() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineIfExpression222() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression222()
}

func (c *current) onSingleLineIfExpression120(valsI, endPosI any) (any, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonSingleLineIfExpression120() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression120(stack["valsI"], stack["endPosI"])
}

func (c *current) onSingleLineIfExpression12(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil
}

func (p *parser) callonSingleLineIfExpression12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression12(stack["posI"])
}

func (c *current) onSingleLineIfExpression231() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineIfExpression231() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression231()
}

func (c *current) onSingleLineIfExpression228(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonSingleLineIfExpression228() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression228(stack["posI"])
}

func (c *current) onSingleLineIfExpression5(exprsI any) (any, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonSingleLineIfExpression5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIfExpression5(stack["exprsI"])
}

func (c *current) onForExpression2(rExprI any) (any, error) {
	return &file.Expression{Expressions: []file.ExpressionItem{rExprI.(file.RangeExpression)}}, nil
}

func (p *parser) callonForExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onForExpression2(stack["rExprI"])
}

func (c *current) onForExpression8(exprI any) (any, error) {
	return ptr(exprI.(file.Expression)), nil
}

func (p *parser) callonForExpression8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onForExpression8(stack["exprI"])
}

func (c *current) onForExpression14() (any, error) {
	return (*file.Expression)(nil), nil
}

func (p *parser) callonForExpression14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onForExpression14()
}

func (c *current) onSingleLineForExpression2(rExprI any) (any, error) {
	return &file.Expression{Expressions: []file.ExpressionItem{rExprI.(file.RangeExpression)}}, nil
}

func (p *parser) callonSingleLineForExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineForExpression2(stack["rExprI"])
}

func (c *current) onSingleLineForExpression8(exprI any) (any, error) {
	return ptr(exprI.(file.Expression)), nil
}

func (p *parser) callonSingleLineForExpression8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineForExpression8(stack["exprI"])
}

func (c *current) onSingleLineForExpression14() (any, error) {
	return (*file.Expression)(nil), nil
}

func (p *parser) callonSingleLineForExpression14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineForExpression14()
}

func (c *current) onRangeExpression8(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonRangeExpression8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRangeExpression8(stack["ident"])
}

func (c *current) onRangeExpression22(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonRangeExpression22() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRangeExpression22(stack["ident"])
}

func (c *current) onRangeExpression31() (any, error) {
	return pos(c), nil
}

func (p *parser) callonRangeExpression31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRangeExpression31()
}

func (c *current) onRangeExpression5(var1I, var2I, eqPosI, declaresI any) (any, error) {
	var1 := var1I.(file.GoIdent)

	var var2 *file.GoIdent
	if var2I != nil {
		var2Val := getTuple[file.GoIdent](var2I, -1)
		var2 = &var2Val
	}

	return file.RangeExpression{
		Var1:     &var1,
		Var2:     var2,
		EqPos:    eqPosI.(file.Position),
		Declares: declaresI != nil,
	}, nil
}

func (p *parser) callonRangeExpression5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRangeExpression5(stack["var1I"], stack["var2I"], stack["eqPosI"], stack["declaresI"])
}

func (c *current) onRangeExpression1(varsI, orderedI, exprI any) (any, error) {
	re := file.RangeExpression{
		Ordered:         orderedI != nil,
		Position:        pos(c),
		RangeExpression: exprI.(file.Expression),
	}

	if partRE, ok := varsI.(file.RangeExpression); ok {
		re.Var1 = partRE.Var1
		re.Var2 = partRE.Var2
		re.EqPos = partRE.EqPos
		re.Declares = partRE.Declares
	}

	return re, nil
}

func (p *parser) callonRangeExpression1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRangeExpression1(stack["varsI"], stack["orderedI"], stack["exprI"])
}

func (c *current) onSingleLineRangeExpression8(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonSingleLineRangeExpression8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineRangeExpression8(stack["ident"])
}

func (c *current) onSingleLineRangeExpression22(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonSingleLineRangeExpression22() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineRangeExpression22(stack["ident"])
}

func (c *current) onSingleLineRangeExpression31() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineRangeExpression31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineRangeExpression31()
}

func (c *current) onSingleLineRangeExpression5(var1I, var2I, eqPosI, declaresI any) (any, error) {
	var1 := var1I.(file.GoIdent)

	var var2 *file.GoIdent
	if var2I != nil {
		var2Val := getTuple[file.GoIdent](var2I, -1)
		var2 = &var2Val
	}

	return file.RangeExpression{
		Var1:     &var1,
		Var2:     var2,
		EqPos:    eqPosI.(file.Position),
		Declares: declaresI != nil,
	}, nil
}

func (p *parser) callonSingleLineRangeExpression5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineRangeExpression5(stack["var1I"], stack["var2I"], stack["eqPosI"], stack["declaresI"])
}

func (c *current) onSingleLineRangeExpression1(varsI, orderedI, exprI any) (any, error) {
	re := file.RangeExpression{
		Ordered:         orderedI != nil,
		Position:        pos(c),
		RangeExpression: exprI.(file.Expression),
	}

	if partRE, ok := varsI.(file.RangeExpression); ok {
		re.Var1 = partRE.Var1
		re.Var2 = partRE.Var2
		re.EqPos = partRE.EqPos
		re.Declares = partRE.Declares
	}

	return re, nil
}

func (p *parser) callonSingleLineRangeExpression1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineRangeExpression1(stack["varsI"], stack["orderedI"], stack["exprI"])
}

func (c *current) onInterpretedStringExpression2(contentsI any) (any, error) {
	return file.StringExpression{
		Quote:    '"',
		Contents: typedSlice[file.StringExpressionItem](contentsI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInterpretedStringExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpression2(stack["contentsI"])
}

func (c *current) onInterpretedStringExpression13() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInterpretedStringExpression13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpression13()
}

func (c *current) onInterpretedStringExpression9(startPosI, contentsI any) (any, error) {
	return file.StringExpression{
			Quote:    '"',
			Contents: typedSlice[file.StringExpressionItem](contentsI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				ToEOL:      true,
				Annotation: "expected a `\"` somewhere here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the string literal started here",
				}),
			},
		}
}

func (p *parser) callonInterpretedStringExpression9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpression9(stack["startPosI"], stack["contentsI"])
}

func (c *current) onRawStringExpression2(contentsI any) (any, error) {
	return file.StringExpression{
		Quote:    '`',
		Contents: typedSlice[file.StringExpressionItem](contentsI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonRawStringExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawStringExpression2(stack["contentsI"])
}

func (c *current) onRawStringExpression13() (any, error) {
	return pos(c), nil
}

func (p *parser) callonRawStringExpression13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawStringExpression13()
}

func (c *current) onRawStringExpression9(startPosI, contentsI any) (any, error) {
	return file.StringExpression{
			Quote:    '`',
			Contents: typedSlice[file.StringExpressionItem](contentsI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				ToEOL:      true,
				Annotation: "expected a ``` somewhere here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the string literal started here",
				}),
			},
		}
}

func (p *parser) callonRawStringExpression9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawStringExpression9(stack["startPosI"], stack["contentsI"])
}

func (c *current) onInterpretedStringExpressionItem16() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonInterpretedStringExpressionItem16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem16()
}

func (c *current) onInterpretedStringExpressionItem37() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonInterpretedStringExpressionItem37() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem37()
}

func (c *current) onInterpretedStringExpressionItem69() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonInterpretedStringExpressionItem69() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem69()
}

func (c *current) onInterpretedStringExpressionItem76() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonInterpretedStringExpressionItem76() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem76()
}

func (c *current) onInterpretedStringExpressionItem87() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonInterpretedStringExpressionItem87() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem87()
}

func (c *current) onInterpretedStringExpressionItem94() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonInterpretedStringExpressionItem94() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem94()
}

func (c *current) onInterpretedStringExpressionItem99() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonInterpretedStringExpressionItem99() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem99()
}

func (c *current) onInterpretedStringExpressionItem2() (any, error) {
	return file.StringExpressionText{
		Text:     string(c.text),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInterpretedStringExpressionItem2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem2()
}

func (c *current) onRawStringExpressionItem2() (any, error) {
	return file.StringExpressionText{
		Text:     string(c.text),
		Position: pos(c),
	}, nil
}

func (p *parser) callonRawStringExpressionItem2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawStringExpressionItem2()
}

func (c *current) onStringExpressionInterpolation25() (any, error) {
	return []byte(nil), &corgierr.Error{
		Message: "missing format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected a formatting verb here",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation25() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation25()
}

func (c *current) onStringExpressionInterpolation28() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "this is not a valid verb",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation28()
}

func (c *current) onStringExpressionInterpolation8() (any, error) {
	return string(c.text[1:]), nil
}

func (p *parser) callonStringExpressionInterpolation8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation8()
}

func (c *current) onStringExpressionInterpolation36() (any, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation36() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation36()
}

func (c *current) onStringExpressionInterpolation30(endPosI any) (any, error) {
	return string(c.text[1:]), &corgierr.Error{
		Message: "invalid format directive",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "invalid formatter",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on how to write a formatting placeholder"},
			{Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation30() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation30(stack["endPosI"])
}

func (c *current) onStringExpressionInterpolation43() (any, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation43() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation43()
}

func (c *current) onStringExpressionInterpolation48() (any, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation48() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation48()
}

func (c *current) onStringExpressionInterpolation2(fmtDirectiveI, lBracePosI, exprI, rBracePosI any) (any, error) {
	return file.StringExpressionInterpolation{
		FormatDirective: castedOrZero[string](fmtDirectiveI),
		Expression:      exprI.(file.Expression),
		LBracePos:       lBracePosI.(file.Position),
		RBracePos:       rBracePosI.(file.Position),
		Position:        pos(c),
	}, nil
}

func (p *parser) callonStringExpressionInterpolation2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation2(stack["fmtDirectiveI"], stack["lBracePosI"], stack["exprI"], stack["rBracePosI"])
}

func (c *current) onStringExpressionInterpolation73() (any, error) {
	return []byte(nil), &corgierr.Error{
		Message: "missing format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected a formatting verb here",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation73() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation73()
}

func (c *current) onStringExpressionInterpolation76() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "this is not a valid verb",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation76() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation76()
}

func (c *current) onStringExpressionInterpolation56() (any, error) {
	return string(c.text[1:]), nil
}

func (p *parser) callonStringExpressionInterpolation56() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation56()
}

func (c *current) onStringExpressionInterpolation84() (any, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation84() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation84()
}

func (c *current) onStringExpressionInterpolation78(endPosI any) (any, error) {
	return string(c.text[1:]), &corgierr.Error{
		Message: "invalid format directive",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "invalid formatter",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on how to write a formatting placeholder"},
			{Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation78() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation78(stack["endPosI"])
}

func (c *current) onStringExpressionInterpolation91() (any, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation91() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation91()
}

func (c *current) onStringExpressionInterpolation50(fmtDirectiveI, parenPosI any) (any, error) {
	return file.StringExpressionInterpolation{
			FormatDirective: castedOrZero[string](fmtDirectiveI),
			Position:        pos(c),
		}, &corgierr.Error{
			Message: "string interpolation is missing an expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      parenPosI.(file.Position),
				Annotation: "expected a `{` here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the interpolation started here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "add an expression enclosed in braces",
					Code:       "`" + string(c.text) + "{1+1}`",
				},
				{
					Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation",
					Code:       "`#" + string(c.text) + "`",
				},
			},
		}
}

func (p *parser) callonStringExpressionInterpolation50() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation50(stack["fmtDirectiveI"], stack["parenPosI"])
}

func (c *current) onStringExpressionInterpolation120() (any, error) {
	return []byte(nil), &corgierr.Error{
		Message: "missing format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected a formatting verb here",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation120() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation120()
}

func (c *current) onStringExpressionInterpolation123() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "this is not a valid verb",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation123() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation123()
}

func (c *current) onStringExpressionInterpolation103() (any, error) {
	return string(c.text[1:]), nil
}

func (p *parser) callonStringExpressionInterpolation103() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation103()
}

func (c *current) onStringExpressionInterpolation131() (any, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation131() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation131()
}

func (c *current) onStringExpressionInterpolation125(endPosI any) (any, error) {
	return string(c.text[1:]), &corgierr.Error{
		Message: "invalid format directive",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "invalid formatter",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on how to write a formatting placeholder"},
			{Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation125() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation125(stack["endPosI"])
}

func (c *current) onStringExpressionInterpolation138() (any, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation138() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation138()
}

func (c *current) onStringExpressionInterpolation145() (any, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation145() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation145()
}

func (c *current) onStringExpressionInterpolation148() (any, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation148() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation148()
}

func (c *current) onStringExpressionInterpolation97(fmtDirectiveI, parenPosI, lBracePosI, startPosI, exprI any) (any, error) {
	return file.StringExpressionInterpolation{
			FormatDirective: castedOrZero[string](fmtDirectiveI),
			Expression:      exprI.(file.Expression),
			LBracePos:       lBracePosI.(file.Position),
			Position:        pos(c),
		}, &corgierr.Error{
			Message: "unclosed string interpolation",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				EOLDelta:   1,
				Annotation: "expected a `}` somewhere here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					End:        startPosI.(file.Position),
					Annotation: "for the interpolation started here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "add the missing `}`"},
				{
					Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation",
					Code:       "`#" + string(c.text) + "`",
				},
			},
		}
}

func (p *parser) callonStringExpressionInterpolation97() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation97(stack["fmtDirectiveI"], stack["parenPosI"], stack["lBracePosI"], stack["startPosI"], stack["exprI"])
}

func (c *current) onTernaryExpression51() (any, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression51() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression51()
}

func (c *current) onTernaryExpression2(conditionI, ifTrueI, ifFalseI, rParenPosI any) (any, error) {
	return file.TernaryExpression{
		Condition: conditionI.(file.Expression),
		IfTrue:    ifTrueI.(file.Expression),
		IfFalse:   ifFalseI.(file.Expression),
		RParenPos: rParenPosI.(file.Position),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonTernaryExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression2(stack["conditionI"], stack["ifTrueI"], stack["ifFalseI"], stack["rParenPosI"])
}

func (c *current) onTernaryExpression57() (any, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression57() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression57()
}

func (c *current) onTernaryExpression71() (any, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression71() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression71()
}

func (c *current) onTernaryExpression53(startPosI, rParenPosI any) (any, error) {
	return file.TernaryExpression{
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected a condition, an if-true value, and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonTernaryExpression53() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression53(stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onTernaryExpression93() (any, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression93() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression93()
}

func (c *current) onTernaryExpression87(posI any) (any, error) {
	return posI, nil
}

func (p *parser) callonTernaryExpression87() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression87(stack["posI"])
}

func (c *current) onTernaryExpression109() (any, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression109() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression109()
}

func (c *current) onTernaryExpression106(posI any) (any, error) {
	return posI, nil
}

func (p *parser) callonTernaryExpression106() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression106(stack["posI"])
}

func (c *current) onTernaryExpression118() (any, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression118() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression118()
}

func (c *current) onTernaryExpression73(conditionI, startPosI, rParenPosI any) (any, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-true value and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonTernaryExpression73() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression73(stack["conditionI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onTernaryExpression152() (any, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression152() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression152()
}

func (c *current) onTernaryExpression146(posI any) (any, error) {
	return posI, nil
}

func (p *parser) callonTernaryExpression146() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression146(stack["posI"])
}

func (c *current) onTernaryExpression168() (any, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression168() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression168()
}

func (c *current) onTernaryExpression165(posI any) (any, error) {
	return posI, nil
}

func (p *parser) callonTernaryExpression165() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression165(stack["posI"])
}

func (c *current) onTernaryExpression177() (any, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression177() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression177()
}

func (c *current) onTernaryExpression120(conditionI, ifTrueI, startPosI, rParenPosI any) (any, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			IfTrue:    ifTrueI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonTernaryExpression120() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression120(stack["conditionI"], stack["ifTrueI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression31() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression31()
}

func (c *current) onSingleLineTernaryExpression2(conditionI, ifTrueI, ifFalseI, rParenPosI any) (any, error) {
	return file.TernaryExpression{
		Condition: conditionI.(file.Expression),
		IfTrue:    ifTrueI.(file.Expression),
		IfFalse:   ifFalseI.(file.Expression),
		RParenPos: rParenPosI.(file.Position),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonSingleLineTernaryExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression2(stack["conditionI"], stack["ifTrueI"], stack["ifFalseI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression37() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression37() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression37()
}

func (c *current) onSingleLineTernaryExpression46() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression46() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression46()
}

func (c *current) onSingleLineTernaryExpression33(startPosI, rParenPosI any) (any, error) {
	return file.TernaryExpression{
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected a condition, an if-true value, and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonSingleLineTernaryExpression33() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression33(stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression63() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression63() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression63()
}

func (c *current) onSingleLineTernaryExpression57(posI any) (any, error) {
	return posI, nil
}

func (p *parser) callonSingleLineTernaryExpression57() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression57(stack["posI"])
}

func (c *current) onSingleLineTernaryExpression79() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression79() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression79()
}

func (c *current) onSingleLineTernaryExpression76(posI any) (any, error) {
	return posI, nil
}

func (p *parser) callonSingleLineTernaryExpression76() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression76(stack["posI"])
}

func (c *current) onSingleLineTernaryExpression88() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression88() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression88()
}

func (c *current) onSingleLineTernaryExpression48(conditionI, startPosI, rParenPosI any) (any, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-true value and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonSingleLineTernaryExpression48() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression48(stack["conditionI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression112() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression112() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression112()
}

func (c *current) onSingleLineTernaryExpression106(posI any) (any, error) {
	return posI, nil
}

func (p *parser) callonSingleLineTernaryExpression106() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression106(stack["posI"])
}

func (c *current) onSingleLineTernaryExpression128() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression128() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression128()
}

func (c *current) onSingleLineTernaryExpression125(posI any) (any, error) {
	return posI, nil
}

func (p *parser) callonSingleLineTernaryExpression125() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression125(stack["posI"])
}

func (c *current) onSingleLineTernaryExpression137() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression137() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression137()
}

func (c *current) onSingleLineTernaryExpression90(conditionI, ifTrueI, startPosI, rParenPosI any) (any, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			IfTrue:    ifTrueI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonSingleLineTernaryExpression90() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression90(stack["conditionI"], stack["ifTrueI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onChainExpression21() (any, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression21() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression21()
}

func (c *current) onChainExpression37() (any, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression37() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression37()
}

func (c *current) onChainExpression64(derefsI, rootI, checkRootI, chainI, defaultI, endPosI any) (bool, error) {
	return checkRootI != nil || chainExprItmsCheck(typedSlice[file.ChainExpressionItem](chainI)) || defaultI != nil, nil
}

func (p *parser) callonChainExpression64() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression64(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onChainExpression2(derefsI, rootI, checkRootI, chainI, defaultI, endPosI any) (any, error) {
	expr := file.ChainExpression{
		Root:       rootI.(file.GoExpression),
		CheckRoot:  checkRootI != nil,
		Chain:      typedSlice[file.ChainExpressionItem](chainI),
		DerefCount: len(islice(derefsI)),
		Position:   pos(c),
	}
	if defaultI != nil {
		defaultOpPos := getTuple[file.Position](defaultI, 1)
		expr.DefaultOpPos = &defaultOpPos
		defaultVal := getTuple[file.Expression](defaultI, -1)
		expr.Default = &defaultVal
	}

	return expr, nil
}

func (p *parser) callonChainExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression2(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onChainExpression68() (any, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression68() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression68()
}

func (c *current) onChainExpression86() (any, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression86() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression86()
}

func (c *current) onChainExpression92(startPosI, derefsI, rootI, checkRootI, chainI, endPosI any) (bool, error) {
	return checkRootI != nil || chainExprItmsCheck(typedSlice[file.ChainExpressionItem](chainI)), nil
}

func (p *parser) callonChainExpression92() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression92(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"])
}

func (c *current) onChainExpression94() (any, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression94() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression94()
}

func (c *current) onChainExpression102() (any, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression102() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression102()
}

func (c *current) onChainExpression65(startPosI, derefsI, rootI, checkRootI, chainI, endPosI, malStartPosI, malEndPosI any) (any, error) {
	expr := file.ChainExpression{
		Root:       rootI.(file.GoExpression),
		CheckRoot:  checkRootI != nil,
		Chain:      typedSlice[file.ChainExpressionItem](chainI),
		DerefCount: len(islice(derefsI)),
		Position:   pos(c),
	}

	var multiline string
	if malEndPosI.(file.Position).Line > malStartPosI.(file.Position).Line {
		multiline += " and the lines below"
	}

	return expr, &corgierr.Error{
		Message: "malformed chain expression",
		ErrorAnnotation: anno(c, annotation{
			Start:      malStartPosI.(file.Position),
			End:        malEndPosI.(file.Position),
			Annotation: "unable to parse this" + multiline + " part",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        malStartPosI.(file.Position),
				Annotation: "this is valid",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "did you mean to put a default here? default values start with the `~` operator",
				Example:    "`woof?.bark[12?] ~ someDefault`",
			},
			{
				Suggestion: "remember that chain expressions cannot be embedded in Go expressions;\n" +
					"you can either write a chain expression or a Go expression",
			},
		},
	}
}

func (p *parser) callonChainExpression65() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression65(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"], stack["malStartPosI"], stack["malEndPosI"])
}

func (c *current) onchainExpressionRoot2() (any, error) {
	return file.GoExpression{
		Expression: string(c.text),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonchainExpressionRoot2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onchainExpressionRoot2()
}

func (c *current) onchainExpressionRoot10(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonchainExpressionRoot10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onchainExpressionRoot10(stack["ident"])
}

func (c *current) onchainExpressionRoot8(identI any) (any, error) {
	ident := identI.(file.GoIdent)
	return file.GoExpression{
		Expression: ident.Ident,
		Position:   ident.Position,
	}, nil
}

func (p *parser) callonchainExpressionRoot8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onchainExpressionRoot8(stack["identI"])
}

func (c *current) onSingleLineChainExpression21() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression21() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression21()
}

func (c *current) onSingleLineChainExpression32() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression32() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression32()
}

func (c *current) onSingleLineChainExpression55(derefsI, rootI, checkRootI, chainI, defaultI, endPosI any) (bool, error) {
	return checkRootI != nil || chainExprItmsCheck(typedSlice[file.ChainExpressionItem](chainI)) || defaultI != nil, nil
}

func (p *parser) callonSingleLineChainExpression55() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression55(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpression2(derefsI, rootI, checkRootI, chainI, defaultI, endPosI any) (any, error) {
	expr := file.ChainExpression{
		Root:       rootI.(file.GoExpression),
		CheckRoot:  checkRootI != nil,
		Chain:      typedSlice[file.ChainExpressionItem](chainI),
		DerefCount: len(islice(derefsI)),
		Position:   pos(c),
	}
	if defaultI != nil {
		defaultOpPos := getTuple[file.Position](defaultI, 1)
		expr.DefaultOpPos = &defaultOpPos
		defaultVal := getTuple[file.Expression](defaultI, -1)
		expr.Default = &defaultVal
	}

	return expr, nil
}

func (p *parser) callonSingleLineChainExpression2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression2(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpression58() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression58() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression58()
}

func (c *current) onSingleLineChainExpression76() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression76() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression76()
}

func (c *current) onSingleLineChainExpression82(startPosI, derefsI, rootI, checkRootI, chainI, endPosI any) (bool, error) {
	return checkRootI != nil || len(islice(chainI)) > 0, nil
}

func (p *parser) callonSingleLineChainExpression82() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression82(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpression84() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression84() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression84()
}

func (c *current) onSingleLineChainExpression92() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression92() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression92()
}

func (c *current) onSingleLineChainExpression98(startPosI, derefsI, rootI, checkRootI, chainI, endPosI, malStartPosI, malEndPosI any) (bool, error) {
	return false, &corgierr.Error{
		Message: "malformed chain expression",
		ErrorAnnotation: anno(c, annotation{
			Start:      malStartPosI.(file.Position),
			End:        malEndPosI.(file.Position),
			Annotation: "unable to parse this part",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        malStartPosI.(file.Position),
				Annotation: "this is valid",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "did you mean to put a default here? default values start with the `~` operator",
				Example:    "`woof?.bark[12?] ~ someDefault`",
			},
			{
				Suggestion: "remember that chain expressions cannot be embedded in Go expressions;\n" +
					"you can either write a chain expression or a Go expression",
			},
		},
	}
}

func (p *parser) callonSingleLineChainExpression98() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression98(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"], stack["malStartPosI"], stack["malEndPosI"])
}

func (c *current) onChainExpressionItem14(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonChainExpressionItem14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem14(stack["ident"])
}

func (c *current) onChainExpressionItem3(identI, checkI any) (any, error) {
	return file.DotIdentExpression{
		Ident:    identI.(file.GoIdent),
		Check:    checkI != nil,
		Position: pos(c),
	}, nil
}

func (p *parser) callonChainExpressionItem3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem3(stack["identI"], stack["checkI"])
}

func (c *current) onChainExpressionItem37(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonChainExpressionItem37() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem37(stack["ident"])
}

func (c *current) onChainExpressionItem47(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonChainExpressionItem47() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem47(stack["ident"])
}

func (c *current) onChainExpressionItem56() (any, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpressionItem56() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem56()
}

func (c *current) onChainExpressionItem24(ptrsI, packageI, typeI, rParenPosI, checkI any) (any, error) {
	var packageIdent *file.GoIdent
	if packageI != nil {
		packageIdentVal := getTuple[file.GoIdent](packageI, 0)
		packageIdent = &packageIdentVal
	}

	return file.TypeAssertionExpression{
		PointerCount: len(islice(ptrsI)),
		Package:      packageIdent,
		Type:         typeI.(file.GoIdent),
		RParenPos:    rParenPosI.(file.Position),
		Check:        checkI != nil,
	}, nil
}

func (p *parser) callonChainExpressionItem24() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem24(stack["ptrsI"], stack["packageI"], stack["typeI"], stack["rParenPosI"], stack["checkI"])
}

func (c *current) onSingleLineChainExpressionItem9(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonSingleLineChainExpressionItem9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem9(stack["ident"])
}

func (c *current) onSingleLineChainExpressionItem3(identI, checkI any) (any, error) {
	return file.DotIdentExpression{
		Ident:    identI.(file.GoIdent),
		Check:    checkI != nil,
		Position: pos(c),
	}, nil
}

func (p *parser) callonSingleLineChainExpressionItem3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem3(stack["identI"], stack["checkI"])
}

func (c *current) onSingleLineChainExpressionItem32(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonSingleLineChainExpressionItem32() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem32(stack["ident"])
}

func (c *current) onSingleLineChainExpressionItem42(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonSingleLineChainExpressionItem42() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem42(stack["ident"])
}

func (c *current) onSingleLineChainExpressionItem51() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpressionItem51() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem51()
}

func (c *current) onSingleLineChainExpressionItem19(ptrsI, packageI, typeI, rParenPosI, checkI any) (any, error) {
	var packageIdent *file.GoIdent
	if packageI != nil {
		packageIdentVal := getTuple[file.GoIdent](packageI, 0)
		packageIdent = &packageIdentVal
	}

	return file.TypeAssertionExpression{
		PointerCount: len(islice(ptrsI)),
		Package:      packageIdent,
		Type:         typeI.(file.GoIdent),
		RParenPos:    rParenPosI.(file.Position),
		Check:        checkI != nil,
	}, nil
}

func (p *parser) callonSingleLineChainExpressionItem19() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem19(stack["ptrsI"], stack["packageI"], stack["typeI"], stack["rParenPosI"], stack["checkI"])
}

func (c *current) onIndexExpression3() (any, error) {
	return pos(c), nil
}

func (p *parser) callonIndexExpression3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIndexExpression3()
}

func (c *current) onIndexExpression30() (any, error) {
	return pos(c), nil
}

func (p *parser) callonIndexExpression30() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIndexExpression30()
}

func (c *current) onIndexExpression1(exprI, checkIndexI, rBracePosI, checkValueI any) (any, error) {
	return file.IndexExpression{
		LBracePos:  pos(c),
		Index:      exprI.(file.Expression),
		RBracePos:  rBracePosI.(file.Position),
		CheckIndex: checkIndexI != nil,
		CheckValue: checkValueI != nil,
	}, nil
}

func (p *parser) callonIndexExpression1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIndexExpression1(stack["exprI"], stack["checkIndexI"], stack["rBracePosI"], stack["checkValueI"])
}

func (c *current) onindexExpressionIndex11() (any, error) {
	return pos(c), nil
}

func (p *parser) callonindexExpressionIndex11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex11()
}

func (c *current) onindexExpressionIndex27() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonindexExpressionIndex27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex27()
}

func (c *current) onindexExpressionIndex48() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonindexExpressionIndex48() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex48()
}

func (c *current) onindexExpressionIndex80() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonindexExpressionIndex80() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex80()
}

func (c *current) onindexExpressionIndex87() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonindexExpressionIndex87() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex87()
}

func (c *current) onindexExpressionIndex98() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonindexExpressionIndex98() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex98()
}

func (c *current) onindexExpressionIndex105() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonindexExpressionIndex105() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex105()
}

func (c *current) onindexExpressionIndex110() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonindexExpressionIndex110() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex110()
}

func (c *current) onindexExpressionIndex128() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonindexExpressionIndex128() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex128()
}

func (c *current) onindexExpressionIndex149() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonindexExpressionIndex149() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex149()
}

func (c *current) onindexExpressionIndex181() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonindexExpressionIndex181() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex181()
}

func (c *current) onindexExpressionIndex188() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonindexExpressionIndex188() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex188()
}

func (c *current) onindexExpressionIndex199() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonindexExpressionIndex199() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex199()
}

func (c *current) onindexExpressionIndex206() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonindexExpressionIndex206() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex206()
}

func (c *current) onindexExpressionIndex211() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonindexExpressionIndex211() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex211()
}

func (c *current) onindexExpressionIndex218() (any, error) {
	return pos(c), nil
}

func (p *parser) callonindexExpressionIndex218() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex218()
}

func (c *current) onindexExpressionIndex116(valsI, endPosI any) (any, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonindexExpressionIndex116() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex116(stack["valsI"], stack["endPosI"])
}

func (c *current) onindexExpressionIndex8(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil
}

func (p *parser) callonindexExpressionIndex8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex8(stack["posI"])
}

func (c *current) onindexExpressionIndex227() (any, error) {
	return pos(c), nil
}

func (p *parser) callonindexExpressionIndex227() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex227()
}

func (c *current) onindexExpressionIndex224(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonindexExpressionIndex224() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex224(stack["posI"])
}

func (c *current) onindexExpressionIndex1(exprsI any) (any, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonindexExpressionIndex1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onindexExpressionIndex1(stack["exprsI"])
}

func (c *current) onSingleLineIndexExpression3() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineIndexExpression3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIndexExpression3()
}

func (c *current) onSingleLineIndexExpression25() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineIndexExpression25() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIndexExpression25()
}

func (c *current) onSingleLineIndexExpression1(exprI, checkIndexI, rBracePosI, checkValueI any) (any, error) {
	return file.IndexExpression{
		LBracePos:  pos(c),
		Index:      exprI.(file.Expression),
		RBracePos:  rBracePosI.(file.Position),
		CheckIndex: checkIndexI != nil,
		CheckValue: checkValueI != nil,
	}, nil
}

func (p *parser) callonSingleLineIndexExpression1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIndexExpression1(stack["exprI"], stack["checkIndexI"], stack["rBracePosI"], stack["checkValueI"])
}

func (c *current) onsingleLineIndexExpressionIndex11() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineIndexExpressionIndex11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex11()
}

func (c *current) onsingleLineIndexExpressionIndex27() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineIndexExpressionIndex27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex27()
}

func (c *current) onsingleLineIndexExpressionIndex48() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineIndexExpressionIndex48() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex48()
}

func (c *current) onsingleLineIndexExpressionIndex80() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonsingleLineIndexExpressionIndex80() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex80()
}

func (c *current) onsingleLineIndexExpressionIndex87() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineIndexExpressionIndex87() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex87()
}

func (c *current) onsingleLineIndexExpressionIndex98() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineIndexExpressionIndex98() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex98()
}

func (c *current) onsingleLineIndexExpressionIndex105() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineIndexExpressionIndex105() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex105()
}

func (c *current) onsingleLineIndexExpressionIndex110() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonsingleLineIndexExpressionIndex110() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex110()
}

func (c *current) onsingleLineIndexExpressionIndex128() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineIndexExpressionIndex128() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex128()
}

func (c *current) onsingleLineIndexExpressionIndex149() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineIndexExpressionIndex149() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex149()
}

func (c *current) onsingleLineIndexExpressionIndex181() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonsingleLineIndexExpressionIndex181() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex181()
}

func (c *current) onsingleLineIndexExpressionIndex188() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineIndexExpressionIndex188() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex188()
}

func (c *current) onsingleLineIndexExpressionIndex199() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineIndexExpressionIndex199() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex199()
}

func (c *current) onsingleLineIndexExpressionIndex206() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineIndexExpressionIndex206() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex206()
}

func (c *current) onsingleLineIndexExpressionIndex211() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonsingleLineIndexExpressionIndex211() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex211()
}

func (c *current) onsingleLineIndexExpressionIndex218() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineIndexExpressionIndex218() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex218()
}

func (c *current) onsingleLineIndexExpressionIndex116(valsI, endPosI any) (any, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonsingleLineIndexExpressionIndex116() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex116(stack["valsI"], stack["endPosI"])
}

func (c *current) onsingleLineIndexExpressionIndex8(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil
}

func (p *parser) callonsingleLineIndexExpressionIndex8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex8(stack["posI"])
}

func (c *current) onsingleLineIndexExpressionIndex227() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineIndexExpressionIndex227() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex227()
}

func (c *current) onsingleLineIndexExpressionIndex224(posI any) (any, error) {
	return file.GoExpression{Expression: string(c.text), Position: posI.(file.Position)}, nil

}

func (p *parser) callonsingleLineIndexExpressionIndex224() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex224(stack["posI"])
}

func (c *current) onsingleLineIndexExpressionIndex1(exprsI any) (any, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonsingleLineIndexExpressionIndex1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineIndexExpressionIndex1(stack["exprsI"])
}

func (c *current) onParenExpression3() (any, error) {
	return pos(c), nil
}

func (p *parser) callonParenExpression3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onParenExpression3()
}

func (c *current) onParenExpression23() (any, error) {
	return pos(c), nil
}

func (p *parser) callonParenExpression23() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onParenExpression23()
}

func (c *current) onParenExpression1(argsI, rParenPosI, checkI any) (any, error) {
	return file.ParenExpression{
		LParenPos: pos(c),
		Args:      castedOrZero[[]file.Expression](argsI),
		RParenPos: pos(c),
		Check:     checkI != nil,
	}, nil
}

func (p *parser) callonParenExpression1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onParenExpression1(stack["argsI"], stack["rParenPosI"], stack["checkI"])
}

func (c *current) onparenExpressionArgs1(firstI, restI any) (any, error) {
	restTuples := islice(restI)

	args := make([]file.Expression, 1+len(restTuples))
	args[0] = firstI.(file.Expression)
	for i, at := range restTuples {
		args[i+1] = getTuple[file.Expression](at, -1)
	}

	return args, nil
}

func (p *parser) callonparenExpressionArgs1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onparenExpressionArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onSingleLineParenExpression3() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineParenExpression3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineParenExpression3()
}

func (c *current) onSingleLineParenExpression18() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineParenExpression18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineParenExpression18()
}

func (c *current) onSingleLineParenExpression1(argsI, rParenPosI, checkI any) (any, error) {
	return file.ParenExpression{
		LParenPos: pos(c),
		Args:      castedOrZero[[]file.Expression](argsI),
		RParenPos: pos(c),
		Check:     checkI != nil,
	}, nil
}

func (p *parser) callonSingleLineParenExpression1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineParenExpression1(stack["argsI"], stack["rParenPosI"], stack["checkI"])
}

func (c *current) onsingleLinearenExpressionArgs1(firstI, restI any) (any, error) {
	restTuples := islice(restI)

	args := make([]file.Expression, 1+len(restTuples))
	args[0] = firstI.(file.Expression)
	for i, at := range restTuples {
		args[i+1] = getTuple[file.Expression](at, -1)
	}

	return args, nil
}

func (p *parser) callonsingleLinearenExpressionArgs1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLinearenExpressionArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onRawFilter10() (any, error) {
	return file.RawFilterType(string(c.text)), nil
}

func (p *parser) callonRawFilter10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawFilter10()
}

func (c *current) onRawFilter16() (any, error) {
	return file.RawFilterType(string(c.text)), &corgierr.Error{
		Message: "invalid raw filter type",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "expected either `html`, `svg`, `js`, or `css`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "remove the type entirely, or replace it with one of the above",
			},
		},
	}
}

func (p *parser) callonRawFilter16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawFilter16()
}

func (c *current) onRawFilter1(typI, bodyI any) (any, error) {
	var typ file.RawFilterType
	if typI != nil {
		typ = getTuple[file.RawFilterType](typI, -1)
	}

	return file.RawFilter{
		Type:     typ,
		Body:     castedOrZero[[]file.FilterLine](bodyI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonRawFilter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawFilter1(stack["typI"], stack["bodyI"])
}

func (c *current) onCommandFilter16(strI any) (any, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonCommandFilter16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter16(stack["strI"])
}

func (c *current) onCommandFilter23(strI any) (any, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonCommandFilter23() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter23(stack["strI"])
}

func (c *current) onCommandFilter55() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonCommandFilter55() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter55()
}

func (c *current) onCommandFilter68() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonCommandFilter68() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter68()
}

func (c *current) onCommandFilter89() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonCommandFilter89() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter89()
}

func (c *current) onCommandFilter112() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonCommandFilter112() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter112()
}

func (c *current) onCommandFilter123() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonCommandFilter123() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter123()
}

func (c *current) onCommandFilter130() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonCommandFilter130() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter130()
}

func (c *current) onCommandFilter135() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonCommandFilter135() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter135()
}

func (c *current) onCommandFilter40(strI any) (any, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonCommandFilter40() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter40(stack["strI"])
}

func (c *current) onCommandFilter156() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonCommandFilter156() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter156()
}

func (c *current) onCommandFilter169() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonCommandFilter169() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter169()
}

func (c *current) onCommandFilter190() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonCommandFilter190() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter190()
}

func (c *current) onCommandFilter213() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonCommandFilter213() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter213()
}

func (c *current) onCommandFilter224() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonCommandFilter224() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter224()
}

func (c *current) onCommandFilter231() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonCommandFilter231() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter231()
}

func (c *current) onCommandFilter236() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonCommandFilter236() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter236()
}

func (c *current) onCommandFilter242() (any, error) {
	return pos(c), nil
}

func (p *parser) callonCommandFilter242() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter242()
}

func (c *current) onCommandFilter141(strI, endPosI any) (any, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonCommandFilter141() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter141(stack["strI"], stack["endPosI"])
}

func (c *current) onCommandFilter267() (any, error) {
	return pos(c), nil
}

func (p *parser) callonCommandFilter267() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter267()
}

func (c *current) onCommandFilter259(strI, endPosI any) (any, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonCommandFilter259() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter259(stack["strI"], stack["endPosI"])
}

func (c *current) onCommandFilter13(stringI any) (any, error) {
	return file.StringCommandFilterArg(stringI.(file.String)), nil
}

func (p *parser) callonCommandFilter13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter13(stack["stringI"])
}

func (c *current) onCommandFilter273(argI any) (any, error) {
	return file.RawCommandFilterArg{Value: concat(argI), Position: pos(c)}, nil
}

func (p *parser) callonCommandFilter273() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter273(stack["argI"])
}

func (c *current) onCommandFilter1(nameI, argsI, bodyI any) (any, error) {
	return file.CommandFilter{
		Name:     concat(nameI),
		Args:     typedSliceFromTuples[file.CommandFilterArg](argsI, -1),
		Body:     castedOrZero[[]file.FilterLine](bodyI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonCommandFilter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCommandFilter1(stack["nameI"], stack["argsI"], stack["bodyI"])
}

func (c *current) onBadFilter1(bodyI any) (any, error) {
	return file.CommandFilter{
			Position: pos(c),
			Body:     castedOrZero[[]file.FilterLine](bodyI),
		}, &corgierr.Error{
			Message: "bad filter",
			ErrorAnnotation: anno(c, annotation{
				Start:       pos(c),
				StartOffset: 1,
				Annotation:  "expected `raw` or a command name",
			}),
		}
}

func (p *parser) callonBadFilter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBadFilter1(stack["bodyI"])
}

func (c *current) onfilterBody3() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonfilterBody3() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfilterBody3()
}

func (c *current) onfilterBody16(linesI any) error {
	lvl := c.state["Indentation.Level"].(int)
	c.state["Indentation.Level"] = lvl - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonfilterBody16() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfilterBody16(stack["linesI"])
}

func (c *current) onfilterBody1(linesI any) (any, error) {
	return typedSliceFromTuples[file.FilterLine](linesI, -1), nil
}

func (p *parser) callonfilterBody1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfilterBody1(stack["linesI"])
}

func (c *current) onfilterLine5() (any, error) {
	return pos(c), nil
}

func (p *parser) callonfilterLine5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfilterLine5()
}

func (c *current) onfilterLine1(posI, lineI any) (any, error) {
	return file.FilterLine{
		Line:     concat(lineI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonfilterLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfilterLine1(stack["posI"], stack["lineI"])
}

func (c *current) onGoType1(goTypeI any) (any, error) {
	return file.GoType{Type: concat(goTypeI), Position: pos(c)}, nil
}

func (p *parser) callonGoType1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoType1(stack["goTypeI"])
}

func (c *current) ongoFieldDecl33() (any, error) {
	return c.text, &corgierr.Error{
		Message: "unclosed string literal",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			EOLDelta:   1,
			Annotation: "expected a ``` somewhere here",
		}),
	}
}

func (p *parser) callongoFieldDecl33() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl33()
}

func (c *current) ongoFieldDecl57() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoFieldDecl57() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl57()
}

func (c *current) ongoFieldDecl78() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoFieldDecl78() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl78()
}

func (c *current) ongoFieldDecl110() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callongoFieldDecl110() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl110()
}

func (c *current) ongoFieldDecl117() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl117() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl117()
}

func (c *current) ongoFieldDecl128() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl128() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl128()
}

func (c *current) ongoFieldDecl135() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl135() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl135()
}

func (c *current) ongoFieldDecl140() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl140() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl140()
}

func (c *current) ongoFieldDecl157() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoFieldDecl157() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl157()
}

func (c *current) ongoFieldDecl178() (any, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoFieldDecl178() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl178()
}

func (c *current) ongoFieldDecl210() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callongoFieldDecl210() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl210()
}

func (c *current) ongoFieldDecl217() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl217() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl217()
}

func (c *current) ongoFieldDecl228() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl228() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl228()
}

func (c *current) ongoFieldDecl235() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl235() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl235()
}

func (c *current) ongoFieldDecl240() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl240() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl240()
}

func (c *current) ongoFieldDecl146() (any, error) {
	return c.text, &corgierr.Error{
		Message: "unclosed string literal",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			EOLDelta:   1,
			Annotation: "expected a `\"` somewhere here",
		}),
	}

}

func (p *parser) callongoFieldDecl146() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl146()
}

func (c *current) onMixin12(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonMixin12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin12(stack["identI"])
}

func (c *current) onMixin31() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixin31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin31()
}

func (c *current) onMixin18(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonMixin18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin18(stack["identI"], stack["endPosI"])
}

func (c *current) onMixin9(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonMixin9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin9(stack["identI"])
}

func (c *current) onMixin40() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixin40() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin40()
}

func (c *current) onMixin37(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixin37() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin37(stack["posI"])
}

func (c *current) onMixin65() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixin65() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin65()
}

func (c *current) onMixin59(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixin59() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin59(stack["identI"], stack["endPosI"])
}

func (c *current) onMixin2(nameI, paramsI, bodyI any) (any, error) {
	params := castedOrZero[file.Mixin](paramsI)
	return file.Mixin{
		Name:      nameI.(file.Ident),
		LParenPos: params.LParenPos,
		Params:    params.Params,
		RParenPos: params.RParenPos,
		Body:      bodyI.(file.Scope),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonMixin2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin2(stack["nameI"], stack["paramsI"], stack["bodyI"])
}

func (c *current) onMixin80() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixin80() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin80()
}

func (c *current) onMixin76(posI, bodyI any) (any, error) {
	return file.Mixin{
			Body:     bodyI.(file.Scope),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "mixin: missing name",
			ErrorAnnotation: anno(c, annotation{
				Start:       posI.(file.Position),
				StartOffset: 1,
				Annotation:  "expected the name of the mixin here",
			}),
			Example: "`mixin woof\n" +
				"  > bark`",
		}
}

func (p *parser) callonMixin76() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin76(stack["posI"], stack["bodyI"])
}

func (c *current) onmixinParamList28() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParamList28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamList28()
}

func (c *current) onmixinParamList2(paramsI, rParenPosI any) (any, error) {
	return file.Mixin{
		LParenPos: ptr(pos(c)),
		Params:    castedOrZero[[]file.MixinParam](paramsI),
		RParenPos: ptr(rParenPosI.(file.Position)),
	}, nil
}

func (p *parser) callonmixinParamList2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamList2(stack["paramsI"], stack["rParenPosI"])
}

func (c *current) onmixinParamList49() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParamList49() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamList49()
}

func (c *current) onmixinParamList30(paramsI, posI any) (any, error) {
	return file.Mixin{
			LParenPos: ptr(pos(c)),
			Params:    castedOrZero[[]file.MixinParam](paramsI),
		}, &corgierr.Error{
			Message: "mixin parameters: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonmixinParamList30() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamList30(stack["paramsI"], stack["posI"])
}

func (c *current) onmixinParams1(firstI, restI any) (any, error) {
	restIs := islice(restI)
	mixinParams := make([]file.MixinParam, 1+len(restIs))
	mixinParams[0] = firstI.(file.MixinParam)
	for i, ai := range restIs {
		mixinParams[i+1] = getTuple[file.MixinParam](ai, -1)
	}

	return mixinParams, nil
}

func (p *parser) callonmixinParams1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParams1(stack["firstI"], stack["restI"])
}

func (c *current) onmixinParam8(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonmixinParam8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam8(stack["identI"])
}

func (c *current) onmixinParam27() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParam27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam27()
}

func (c *current) onmixinParam14(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonmixinParam14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam14(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinParam5(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonmixinParam5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam5(stack["identI"])
}

func (c *current) onmixinParam39() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParam39() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam39()
}

func (c *current) onmixinParam33(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinParam33() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam33(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinParam46() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParam46() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam46()
}

func (c *current) onmixinParam1(nameI, posI, typeI, defaultI any) (any, error) {
	defaultTuple := islice(defaultI)
	var paramDefault file.MixinParam
	if len(defaultTuple) == 2 {
		paramDefault = defaultTuple[1].(file.MixinParam)
	}

	typeTuple := islice(typeI)
	var paramType *file.GoType
	if len(typeTuple) == 2 {
		paramType = ptr(typeTuple[1].(file.GoType))
	}

	p := file.MixinParam{
		Name:      nameI.(file.Ident),
		Type:      paramType,
		AssignPos: paramDefault.AssignPos,
		Default:   paramDefault.Default,
		Position:  pos(c),
	}
	if p.Type == nil && p.Default == nil {
		return p, &corgierr.Error{
			Message: "mixin param: need either a type or a default",
			ErrorAnnotation: anno(c, annotation{
				Start:       posI.(file.Position),
				StartOffset: 1,
				Annotation:  "expected either a type or a default here",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "give this param a type", Code: "`" + p.Name.Ident + " string`"},
				{Suggestion: "give this param a default with an inferrable type", Code: "`" + p.Name.Ident + "=\"woof\"`"},
			},
		}
	}

	return p, nil
}

func (p *parser) callonmixinParam1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam1(stack["nameI"], stack["posI"], stack["typeI"], stack["defaultI"])
}

func (c *current) onmixinParamDefault2(exprI any) (any, error) {
	return file.MixinParam{
		AssignPos: ptr(pos(c)),
		Default:   ptrOrNil[file.Expression](exprI),
	}, nil
}

func (p *parser) callonmixinParamDefault2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamDefault2(stack["exprI"])
}

func (c *current) onmixinParamDefault13() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParamDefault13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamDefault13()
}

func (c *current) onmixinParamDefault9(posI any) (any, error) {
	return file.MixinParam{
			AssignPos: ptr(pos(c)),
		}, &corgierr.Error{
			Message: "mixin param: missing default",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "because of this `=`",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remove the `=`, if you didn't mean to define a default"},
			},
		}
}

func (p *parser) callonmixinParamDefault9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamDefault9(stack["posI"])
}

func (c *current) onReturn8() (any, error) {
	return c.text, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "here",
		}),
	}
}

func (p *parser) callonReturn8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onReturn8()
}

func (c *current) onReturn1(errExprI any) (any, error) {
	return file.Return{
		Err:      ptrOrNil[file.Expression](errExprI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonReturn1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onReturn1(stack["errExprI"])
}

func (c *current) onMixinCall8(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonMixinCall8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall8(stack["identI"])
}

func (c *current) onMixinCall27() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCall27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall27()
}

func (c *current) onMixinCall14(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonMixinCall14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall14(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCall39(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonMixinCall39() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall39(stack["identI"])
}

func (c *current) onMixinCall58() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCall58() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall58()
}

func (c *current) onMixinCall45(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonMixinCall45() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall45(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCall36(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonMixinCall36() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall36(stack["identI"])
}

func (c *current) onMixinCall67() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCall67() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall67()
}

func (c *current) onMixinCall64(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixinCall64() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall64(stack["posI"])
}

func (c *current) onMixinCall92() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCall92() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall92()
}

func (c *current) onMixinCall86(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixinCall86() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall86(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCall1(namespaceI, nameI, argsI, bodyI any) (any, error) {
	args := castedOrZero[file.MixinCall](argsI)

	var namespace *file.Ident
	if namespaceI != nil {
		namespace = ptr(getTuple[file.Ident](namespaceI, 0))
	}

	return file.MixinCall{
		Namespace: namespace,
		Name:      nameI.(file.Ident),
		LParenPos: args.LParenPos,
		Args:      args.Args,
		RParenPos: args.RParenPos,
		Body:      bodyI.(file.Scope),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonMixinCall1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["bodyI"])
}

func (c *current) onInlineMixinCall8(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonInlineMixinCall8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall8(stack["identI"])
}

func (c *current) onInlineMixinCall27() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineMixinCall27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall27()
}

func (c *current) onInlineMixinCall14(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonInlineMixinCall14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall14(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineMixinCall39(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonInlineMixinCall39() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall39(stack["identI"])
}

func (c *current) onInlineMixinCall58() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineMixinCall58() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall58()
}

func (c *current) onInlineMixinCall45(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonInlineMixinCall45() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall45(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineMixinCall36(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonInlineMixinCall36() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall36(stack["identI"])
}

func (c *current) onInlineMixinCall67() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineMixinCall67() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall67()
}

func (c *current) onInlineMixinCall64(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonInlineMixinCall64() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall64(stack["posI"])
}

func (c *current) onInlineMixinCall92() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineMixinCall92() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall92()
}

func (c *current) onInlineMixinCall86(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonInlineMixinCall86() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall86(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineMixinCall1(namespaceI, nameI, argsI, bodyI any) (any, error) {
	args := castedOrZero[file.MixinCall](argsI)

	var namespace *file.Ident
	if namespaceI != nil {
		namespace = ptr(getTuple[file.Ident](namespaceI, 0))
	}

	return file.MixinCall{
		Namespace: namespace,
		Name:      nameI.(file.Ident),
		LParenPos: args.LParenPos,
		Args:      args.Args,
		RParenPos: args.RParenPos,
		Body:      bodyI.(file.Scope),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonInlineMixinCall1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["bodyI"])
}

func (c *current) onmixinArgList28() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArgList28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgList28()
}

func (c *current) onmixinArgList2(argsI, rParenPosI any) (any, error) {
	return file.MixinCall{
		LParenPos: ptr(pos(c)),
		Args:      castedOrZero[[]file.MixinArg](argsI),
		RParenPos: ptr(rParenPosI.(file.Position)),
	}, nil
}

func (p *parser) callonmixinArgList2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgList2(stack["argsI"], stack["rParenPosI"])
}

func (c *current) onmixinArgList49() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArgList49() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgList49()
}

func (c *current) onmixinArgList30(argsI, posI any) (any, error) {
	return file.MixinCall{
			LParenPos: ptr(pos(c)),
			Args:      castedOrZero[[]file.MixinArg](argsI),
		}, &corgierr.Error{
			Message: "mixin args: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonmixinArgList30() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgList30(stack["argsI"], stack["posI"])
}

func (c *current) onsingleLineMixinArgList18() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArgList18() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgList18()
}

func (c *current) onsingleLineMixinArgList2(argsI, rParenPosI any) (any, error) {
	return file.MixinCall{
		LParenPos: ptr(pos(c)),
		Args:      castedOrZero[[]file.MixinArg](argsI),
		RParenPos: ptr(rParenPosI.(file.Position)),
	}, nil
}

func (p *parser) callonsingleLineMixinArgList2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgList2(stack["argsI"], stack["rParenPosI"])
}

func (c *current) onsingleLineMixinArgList34() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArgList34() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgList34()
}

func (c *current) onsingleLineMixinArgList20(argsI, posI any) (any, error) {
	return file.MixinCall{
			LParenPos: ptr(pos(c)),
			Args:      castedOrZero[[]file.MixinArg](argsI),
		}, &corgierr.Error{
			Message: "mixin args: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonsingleLineMixinArgList20() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgList20(stack["argsI"], stack["posI"])
}

func (c *current) onmixinArgs1(firstI, restI any) (any, error) {
	restIs := islice(restI)
	mixinArgs := make([]file.MixinArg, 1+len(restIs))
	mixinArgs[0] = firstI.(file.MixinArg)
	for i, ai := range restIs {
		mixinArgs[i+1] = getTuple[file.MixinArg](ai, -1)
	}

	return mixinArgs, nil
}

func (p *parser) callonmixinArgs1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onsingleLineMixinArgs1(firstI, restI any) (any, error) {
	restIs := islice(restI)
	mixinArgs := make([]file.MixinArg, 1+len(restIs))
	mixinArgs[0] = firstI.(file.MixinArg)
	for i, ai := range restIs {
		mixinArgs[i+1] = getTuple[file.MixinArg](ai, -1)
	}

	return mixinArgs, nil
}

func (p *parser) callonsingleLineMixinArgs1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onmixinArg9(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonmixinArg9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg9(stack["identI"])
}

func (c *current) onmixinArg28() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg28()
}

func (c *current) onmixinArg15(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonmixinArg15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg15(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinArg6(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonmixinArg6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg6(stack["identI"])
}

func (c *current) onmixinArg40() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg40() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg40()
}

func (c *current) onmixinArg34(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinArg34() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg34(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinArg2(nameI, valI any) (any, error) {
	return file.MixinArg{
		Name:  nameI.(file.Ident),
		Value: valI.(file.Expression),
	}, nil
}

func (p *parser) callonmixinArg2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg2(stack["nameI"], stack["valI"])
}

func (c *current) onmixinArg60(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonmixinArg60() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg60(stack["identI"])
}

func (c *current) onmixinArg79() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg79() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg79()
}

func (c *current) onmixinArg66(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonmixinArg66() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg66(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinArg57(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonmixinArg57() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg57(stack["identI"])
}

func (c *current) onmixinArg91() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg91() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg91()
}

func (c *current) onmixinArg85(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinArg85() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg85(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinArg103() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg103() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg103()
}

func (c *current) onmixinArg53(nameI, posI any) (any, error) {
	return file.MixinArg{
			Name: nameI.(file.Ident),
		}, &corgierr.Error{
			Message: "missing mixin argument value",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a value here",
			}),
			Example: "`argName=123`",
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remember that you always need to write the name of the arg before it's value"},
			},
		}
}

func (p *parser) callonmixinArg53() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg53(stack["nameI"], stack["posI"])
}

func (c *current) onsingleLineMixinArg9(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonsingleLineMixinArg9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg9(stack["identI"])
}

func (c *current) onsingleLineMixinArg28() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg28()
}

func (c *current) onsingleLineMixinArg15(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonsingleLineMixinArg15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg15(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinArg6(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonsingleLineMixinArg6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg6(stack["identI"])
}

func (c *current) onsingleLineMixinArg40() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg40() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg40()
}

func (c *current) onsingleLineMixinArg34(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonsingleLineMixinArg34() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg34(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinArg2(nameI, valI any) (any, error) {
	return file.MixinArg{
		Name:  nameI.(file.Ident),
		Value: valI.(file.Expression),
	}, nil
}

func (p *parser) callonsingleLineMixinArg2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg2(stack["nameI"], stack["valI"])
}

func (c *current) onsingleLineMixinArg60(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonsingleLineMixinArg60() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg60(stack["identI"])
}

func (c *current) onsingleLineMixinArg79() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg79() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg79()
}

func (c *current) onsingleLineMixinArg66(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonsingleLineMixinArg66() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg66(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinArg57(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonsingleLineMixinArg57() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg57(stack["identI"])
}

func (c *current) onsingleLineMixinArg91() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg91() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg91()
}

func (c *current) onsingleLineMixinArg85(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonsingleLineMixinArg85() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg85(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinArg103() (any, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg103() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg103()
}

func (c *current) onsingleLineMixinArg53(nameI, posI any) (any, error) {
	return file.MixinArg{
			Name: nameI.(file.Ident),
		}, &corgierr.Error{
			Message: "missing mixin argument value",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a value here",
			}),
			Example: "`argName=123`",
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remember that you always need to write the name of the arg before it's value"},
			},
		}
}

func (p *parser) callonsingleLineMixinArg53() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg53(stack["nameI"], stack["posI"])
}

func (c *current) onmixinCallBody2(shI any) (any, error) {
	return file.Scope{shI.(file.MixinMainBlockShorthand)}, nil
}

func (p *parser) callonmixinCallBody2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallBody2(stack["shI"])
}

func (c *current) onMixinMainBlockShorthand6() (any, error) {
	return c.text, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "here",
		}),
	}
}

func (p *parser) callonMixinMainBlockShorthand6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand6()
}

func (c *current) onMixinMainBlockShorthand2(bodyI any) (any, error) {
	return file.MixinMainBlockShorthand{
		Body:     bodyI.(file.Scope),
		Position: pos(c),
	}, nil
}

func (p *parser) callonMixinMainBlockShorthand2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand2(stack["bodyI"])
}

func (c *current) onMixinMainBlockShorthand24() (any, error) {
	return c.text, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "here",
		}),
	}
}

func (p *parser) callonMixinMainBlockShorthand24() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand24()
}

func (c *current) onMixinMainBlockShorthand28() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixinMainBlockShorthand28() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand28()
}

func (c *current) onMixinMainBlockShorthand20(posI any) (any, error) {
	return file.MixinMainBlockShorthand{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing body",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an indented body",
			}),
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "if you want the `_` block to write nothing,\n" +
						"use a block directive inside the body of the mixin call",
					Example: "`+woof\n" +
						"  block _`",
				},
			},
		}
}

func (p *parser) callonMixinMainBlockShorthand20() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand20(stack["posI"])
}

func (c *current) onFunc8(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonFunc8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc8(stack["ident"])
}

func (c *current) onFunc19() (any, error) {
	return pos(c), nil
}

func (p *parser) callonFunc19() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc19()
}

func (c *current) onFunc23(paramsI any) (any, error) {
	return castedOrZero[[]file.FuncParam](paramsI), nil

}

func (p *parser) callonFunc23() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc23(stack["paramsI"])
}

func (c *current) onFunc52() (any, error) {
	return pos(c), nil
}

func (p *parser) callonFunc52() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc52()
}

func (c *current) onFunc47(endPosI any) (any, error) {
	return ([]file.FuncParam)(nil), &corgierr.Error{
		Message: "invalid parameter list",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "this is not correct, maybe a missing comma?",
		}),
	}

}

func (p *parser) callonFunc47() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc47(stack["endPosI"])
}

func (c *current) onFunc59() (any, error) {
	return pos(c), nil
}

func (p *parser) callonFunc59() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc59()
}

func (c *current) onFunc16(lParenPosI, paramsI, rParenPosI any) (any, error) {
	return file.Func{
		LParenPos: lParenPosI.(file.Position),
		Params:    paramsI.([]file.FuncParam),
		RParenPos: rParenPosI.(file.Position),
	}, nil

}

func (p *parser) callonFunc16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc16(stack["lParenPosI"], stack["paramsI"], stack["rParenPosI"])
}

func (c *current) onFunc61() (any, error) {
	return file.Func{}, &corgierr.Error{
		Message: "missing `(` or `)` or invalid param list",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "here",
		}),
	}

}

func (p *parser) callonFunc61() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc61()
}

func (c *current) onFunc2(nameI, paramsI any) (any, error) {
	params := paramsI.(file.Func)
	return file.Func{
		Name:      nameI.(file.GoIdent),
		LParenPos: params.LParenPos,
		Params:    params.Params,
		RParenPos: params.RParenPos,
		Position:  pos(c),
	}, nil
}

func (p *parser) callonFunc2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc2(stack["nameI"], stack["paramsI"])
}

func (c *current) onFunc77() (any, error) {
	return pos(c), nil
}

func (p *parser) callonFunc77() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc77()
}

func (c *current) onFunc73(posI any) (any, error) {
	return file.Func{Position: pos(c)}, &corgierr.Error{
		Message: "missing func name",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected an identifier followed by a parameter list",
		}),
	}
}

func (p *parser) callonFunc73() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc73(stack["posI"])
}

func (c *current) onfuncOnlyVariadicParamList1(variadicI any) (any, error) {
	return []file.FuncParam{variadicI.(file.FuncParam)}, nil
}

func (p *parser) callonfuncOnlyVariadicParamList1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncOnlyVariadicParamList1(stack["variadicI"])
}

func (c *current) onfuncOtherParamList1(firstI, restI, variadicI any) (any, error) {
	restTuples := islice(restI)

	n := 1 + len(restTuples)
	if variadicI != nil {
		n++
	}
	params := make([]file.FuncParam, 1, n)
	params[0] = firstI.(file.FuncParam)

	for _, t := range restTuples {
		params = append(params, getTuple[file.FuncParam](t, -1))
	}

	if variadicI != nil {
		params = append(params, getTuple[file.FuncParam](variadicI, -1))
	}

	return params, nil
}

func (p *parser) callonfuncOtherParamList1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncOtherParamList1(stack["firstI"], stack["restI"], stack["variadicI"])
}

func (c *current) onfuncParam8(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonfuncParam8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam8(stack["ident"])
}

func (c *current) onfuncParam27(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonfuncParam27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam27(stack["ident"])
}

func (c *current) onfuncParam5(firstI, restI any) (any, error) {
	restTuples := islice(restI)
	idents := make([]file.GoIdent, 1, 1+len(restTuples))
	idents[0] = firstI.(file.GoIdent)

	for _, t := range restTuples {
		idents = append(idents, getTuple[file.GoIdent](t, -1))
	}

	return idents, nil
}

func (p *parser) callonfuncParam5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam5(stack["firstI"], stack["restI"])
}

func (c *current) onfuncParam2(namesI, typeI any) (any, error) {
	return file.FuncParam{
		Names: namesI.([]file.GoIdent),
		Type:  typeI.(file.GoType),
	}, nil
}

func (p *parser) callonfuncParam2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam2(stack["namesI"], stack["typeI"])
}

func (c *current) onfuncParam37(typeI any) (any, error) {
	return file.FuncParam{
		Type: typeI.(file.GoType),
	}, nil
}

func (p *parser) callonfuncParam37() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam37(stack["typeI"])
}

func (c *current) onfuncVariadicParam6(ident any) (any, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonfuncVariadicParam6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncVariadicParam6(stack["ident"])
}

func (c *current) onfuncVariadicParam1(nameI, typeI any) (any, error) {
	var names []file.GoIdent
	if nameI != nil {
		names = []file.GoIdent{getTuple[file.GoIdent](nameI, 0)}
	}

	return file.FuncParam{
		Names:    names,
		Variadic: true,
		Type:     typeI.(file.GoType),
	}, nil
}

func (p *parser) callonfuncVariadicParam1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncVariadicParam1(stack["nameI"], stack["typeI"])
}

func (c *current) onfuncType9() (any, error) {
	return pos(c), nil
}

func (p *parser) callonfuncType9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncType9()
}

func (c *current) onfuncType3(typeI, endPosI any) (any, error) {
	return file.GoType{
			Type:     concat(typeI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid type",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "not a valid Go type",
			}),
		}
}

func (p *parser) callonfuncType3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncType3(stack["typeI"], stack["endPosI"])
}

func (c *current) onInlineText1(lineI any) (any, error) {
	return file.InlineText{
		Text:     lineI.(file.TextLine),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineText1(stack["lineI"])
}

func (c *current) onArrowBlock2(firstLineI, additionalLinesI any) (any, error) {
	firstLine, firstLineOk := firstLineI.(file.TextLine)
	additionalLineTuples := islice(additionalLinesI)

	n := len(additionalLineTuples)
	if firstLineOk {
		n++
	}

	lines := make([]file.TextLine, 0, n)
	if firstLineOk {
		lines = append(lines, firstLine)
	}
	for _, lt := range additionalLineTuples {
		lines = append(lines, getTuple[file.TextLine](lt, -1))
	}

	return file.ArrowBlock{
		Lines:    lines,
		Position: pos(c),
	}, nil
}

func (p *parser) callonArrowBlock2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onArrowBlock2(stack["firstLineI"], stack["additionalLinesI"])
}

func (c *current) onArrowBlock31() (any, error) {
	return file.ArrowBlock{Position: pos(c)}, nil
}

func (p *parser) callonArrowBlock31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onArrowBlock31()
}

func (c *current) onInlineArrowBlock2(lineI any) (any, error) {
	return file.ArrowBlock{
		Lines:    []file.TextLine{lineI.(file.TextLine)},
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineArrowBlock2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineArrowBlock2(stack["lineI"])
}

func (c *current) onInlineArrowBlock11() (any, error) {
	return pos(c), nil
}

func (p *parser) callonInlineArrowBlock11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineArrowBlock11()
}

func (c *current) onInlineArrowBlock7(posI, lineI any) (any, error) {
	return file.ArrowBlock{
			Lines:    []file.TextLine{lineI.(file.TextLine)},
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing space",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a space here, separating the `>` from the text",
			}),
			Example: "`> woof`",
		}
}

func (p *parser) callonInlineArrowBlock7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineArrowBlock7(stack["posI"], stack["lineI"])
}

func (c *current) onTextLine1(itemsI any) (any, error) {
	return file.TextLine(typedSlice[file.TextItem](itemsI)), nil
}

func (p *parser) callonTextLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTextLine1(stack["itemsI"])
}

func (c *current) onTextItem2(textI any) (any, error) {
	return file.Text{
		Text:     concat(textI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonTextItem2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTextItem2(stack["textI"])
}

func (c *current) onInterpolation5() (any, error) {
	return nil, &corgierr.Error{
		Message: "bad interpolation",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "start of interpolation",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:       pos(c),
				StartOffset: 1,
				Annotation:  "expected a `#`, `[`, `{`, a mixin call, or an element name here",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
		},
	}
}

func (p *parser) callonInterpolation5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpolation5()
}

func (c *current) onSimpleInterpolation13() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSimpleInterpolation13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation13()
}

func (c *current) onSimpleInterpolation19() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSimpleInterpolation19() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation19()
}

func (c *current) onSimpleInterpolation10(lBracketPosI, textI, rBracketPosI any) (any, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
		RBracketPos: rBracketPosI.(file.Position),
	}, nil
}

func (p *parser) callonSimpleInterpolation10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation10(stack["lBracketPosI"], stack["textI"], stack["rBracketPosI"])
}

func (c *current) onSimpleInterpolation24() (any, error) {
	return pos(c), nil
}

func (p *parser) callonSimpleInterpolation24() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation24()
}

func (c *current) onSimpleInterpolation21(lBracketPosI, textI any) (any, error) {
	return file.TextInterpolationValue{
			LBracketPos: lBracketPosI.(file.Position),
			Text:        concat(textI),
		}, &corgierr.Error{
			Message: "unclosed text interpolation",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "`[` opened here, but never closeed",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:       pos(c),
					StartOffset: 1,
					EOLDelta:    1,
					Annotation:  "expected a `]` somewhere here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
			},
		}
}

func (p *parser) callonSimpleInterpolation21() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation21(stack["lBracketPosI"], stack["textI"])
}

func (c *current) onSimpleInterpolation2(noEscapeI, valueI any) (any, error) {
	return file.SimpleInterpolation{
		NoEscape: noEscapeI != nil,
		Value:    valueI.(file.InterpolationValue),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSimpleInterpolation2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation2(stack["noEscapeI"], stack["valueI"])
}

func (c *current) onSimpleInterpolation38(valueI any) (any, error) {
	return file.SimpleInterpolation{
		Value:    valueI.(file.InterpolationValue),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSimpleInterpolation38() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation38(stack["valueI"])
}

func (c *current) onElementInterpolation5() (any, error) {
	return pos(c), nil
}

func (p *parser) callonElementInterpolation5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElementInterpolation5()
}

func (c *current) onElementInterpolation1(elPosI, nameI, attrsI, valueI any) (any, error) {
	return file.ElementInterpolation{
		Element: file.Element{
			Name:       concat(nameI),
			Attributes: typedSlice[file.AttributeCollection](attrsI),
			Void:       castedOrZero[bool](valueI),
			Position:   elPosI.(file.Position),
		},
		Value:    castedOrZero[file.InterpolationValue](valueI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonElementInterpolation1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElementInterpolation1(stack["elPosI"], stack["nameI"], stack["attrsI"], stack["valueI"])
}

func (c *current) onelementInterpolationValue5() (any, error) {
	return pos(c), nil
}

func (p *parser) callonelementInterpolationValue5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue5()
}

func (c *current) onelementInterpolationValue11() (any, error) {
	return pos(c), nil
}

func (p *parser) callonelementInterpolationValue11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue11()
}

func (c *current) onelementInterpolationValue2(lBracketPosI, textI, rBracketPosI any) (any, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
		RBracketPos: rBracketPosI.(file.Position),
	}, nil
}

func (p *parser) callonelementInterpolationValue2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue2(stack["lBracketPosI"], stack["textI"], stack["rBracketPosI"])
}

func (c *current) onelementInterpolationValue16() (any, error) {
	return pos(c), nil
}

func (p *parser) callonelementInterpolationValue16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue16()
}

func (c *current) onelementInterpolationValue13(lBracketPosI, textI any) (any, error) {
	return file.TextInterpolationValue{
			LBracketPos: lBracketPosI.(file.Position),
			Text:        concat(textI),
		}, &corgierr.Error{
			Message: "unclosed text interpolation",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "`[` opened here, but never closeed",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:       pos(c),
					StartOffset: 1,
					EOLDelta:    1,
					Annotation:  "expected a `]` somewhere here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
			},
		}
}

func (p *parser) callonelementInterpolationValue13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue13(stack["lBracketPosI"], stack["textI"])
}

func (c *current) onelementInterpolationValue31() (any, error) {
	return true, nil // hacky, but whatev
}

func (p *parser) callonelementInterpolationValue31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue31()
}

func (c *current) onelementInterpolationValue33() (any, error) {
	return nil, &corgierr.Error{
		Message: "invalid interpolation value",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected either an `{` expression `}`, `[` text `]`, or a `/` void indicator",
		}),
	}
}

func (p *parser) callonelementInterpolationValue33() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue33()
}

func (c *current) onMixinCallInterpolation5() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallInterpolation5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation5()
}

func (c *current) onMixinCallInterpolation16(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonMixinCallInterpolation16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation16(stack["identI"])
}

func (c *current) onMixinCallInterpolation35() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallInterpolation35() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation35()
}

func (c *current) onMixinCallInterpolation22(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonMixinCallInterpolation22() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation22(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCallInterpolation47(identI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonMixinCallInterpolation47() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation47(stack["identI"])
}

func (c *current) onMixinCallInterpolation66() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallInterpolation66() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation66()
}

func (c *current) onMixinCallInterpolation53(identI, endPosI any) (any, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonMixinCallInterpolation53() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation53(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCallInterpolation44(identI any) (any, error) {
	return identI, nil
}

func (p *parser) callonMixinCallInterpolation44() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation44(stack["identI"])
}

func (c *current) onMixinCallInterpolation75() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallInterpolation75() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation75()
}

func (c *current) onMixinCallInterpolation72(posI any) (any, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixinCallInterpolation72() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation72(stack["posI"])
}

func (c *current) onMixinCallInterpolation100() (any, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallInterpolation100() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation100()
}

func (c *current) onMixinCallInterpolation94(identI, endPosI any) (any, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixinCallInterpolation94() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation94(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCallInterpolation1(mcPosI, namespaceI, nameI, argsI, valueI any) (any, error) {
	args := castedOrZero[file.MixinCall](argsI)

	var namespace *file.Ident
	if namespaceI != nil {
		namespace = ptr(getTuple[file.Ident](namespaceI, 0))
	}

	return file.MixinCallInterpolation{
		MixinCall: file.MixinCall{
			Namespace: namespace,
			Name:      nameI.(file.Ident),
			LParenPos: args.LParenPos,
			Args:      args.Args,
			RParenPos: args.RParenPos,
			Position:  mcPosI.(file.Position),
		},
		Value:    castedOrZero[file.InterpolationValue](valueI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonMixinCallInterpolation1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation1(stack["mcPosI"], stack["namespaceI"], stack["nameI"], stack["argsI"], stack["valueI"])
}

func (c *current) onmixinCallInterpolationValue5() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallInterpolationValue5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallInterpolationValue5()
}

func (c *current) onmixinCallInterpolationValue11() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallInterpolationValue11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallInterpolationValue11()
}

func (c *current) onmixinCallInterpolationValue2(lBracketPosI, textI, rBracketPosI any) (any, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
		RBracketPos: rBracketPosI.(file.Position),
	}, nil
}

func (p *parser) callonmixinCallInterpolationValue2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallInterpolationValue2(stack["lBracketPosI"], stack["textI"], stack["rBracketPosI"])
}

func (c *current) onmixinCallInterpolationValue16() (any, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallInterpolationValue16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallInterpolationValue16()
}

func (c *current) onmixinCallInterpolationValue13(lBracketPosI, textI any) (any, error) {
	return file.TextInterpolationValue{
			LBracketPos: lBracketPosI.(file.Position),
			Text:        concat(textI),
		}, &corgierr.Error{
			Message: "unclosed text interpolation",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "`[` opened here, but never closeed",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:       pos(c),
					StartOffset: 1,
					EOLDelta:    1,
					Annotation:  "expected a `]` somewhere here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
			},
		}
}

func (p *parser) callonmixinCallInterpolationValue13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallInterpolationValue13(stack["lBracketPosI"], stack["textI"])
}

func (c *current) onexpressionInterpolationValue5() (any, error) {
	return pos(c), nil
}

func (p *parser) callonexpressionInterpolationValue5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue5()
}

func (c *current) onexpressionInterpolationValue10() (any, error) {
	return pos(c), nil
}

func (p *parser) callonexpressionInterpolationValue10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue10()
}

func (c *current) onexpressionInterpolationValue2(lBracePosI, exprI, rBracePosI any) (any, error) {
	return file.ExpressionInterpolationValue{
		LBracePos:  lBracePosI.(file.Position),
		Expression: exprI.(file.Expression),
		RBracePos:  rBracePosI.(file.Position),
	}, nil
}

func (p *parser) callonexpressionInterpolationValue2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue2(stack["lBracePosI"], stack["exprI"], stack["rBracePosI"])
}

func (c *current) onexpressionInterpolationValue15() (any, error) {
	return pos(c), nil
}

func (p *parser) callonexpressionInterpolationValue15() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue15()
}

func (c *current) onexpressionInterpolationValue12(lBracePosI, exprI any) (any, error) {
	return file.ExpressionInterpolationValue{
			LBracePos:  lBracePosI.(file.Position),
			Expression: exprI.(file.Expression),
		}, &corgierr.Error{
			Message: "unclosed expression interpolation",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "`{` opened here, but never closeed",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:       pos(c),
					StartOffset: 1,
					EOLDelta:    1,
					Annotation:  "expected a `}` somewhere here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
			},
		}
}

func (p *parser) callonexpressionInterpolationValue12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue12(stack["lBracePosI"], stack["exprI"])
}

func (c *current) onfmtExpressionInterpolationValue22() (any, error) {
	return []byte(nil), &corgierr.Error{
		Message: "missing format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected a formatting verb here",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonfmtExpressionInterpolationValue22() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfmtExpressionInterpolationValue22()
}

func (c *current) onfmtExpressionInterpolationValue25() (any, error) {
	return c.text, &corgierr.Error{
		Message: "invalid format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "this is not a valid verb",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonfmtExpressionInterpolationValue25() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfmtExpressionInterpolationValue25()
}

func (c *current) onfmtExpressionInterpolationValue5() (any, error) {
	return string(c.text[1:]), nil
}

func (p *parser) callonfmtExpressionInterpolationValue5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfmtExpressionInterpolationValue5()
}

func (c *current) onfmtExpressionInterpolationValue33() (any, error) {
	return pos(c), nil
}

func (p *parser) callonfmtExpressionInterpolationValue33() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfmtExpressionInterpolationValue33()
}

func (c *current) onfmtExpressionInterpolationValue27(endPosI any) (any, error) {
	return string(c.text[1:]), &corgierr.Error{
		Message: "invalid format directive",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "invalid formatter",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on how to write a formatting placeholder"},
			{Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation"},
		},
	}
}

func (p *parser) callonfmtExpressionInterpolationValue27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfmtExpressionInterpolationValue27(stack["endPosI"])
}

func (c *current) onfmtExpressionInterpolationValue1(fmtDirectiveI, eivI any) (any, error) {
	eiv := eivI.(file.ExpressionInterpolationValue)
	eiv.FormatDirective = fmtDirectiveI.(string)
	return eiv, nil
}

func (p *parser) callonfmtExpressionInterpolationValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfmtExpressionInterpolationValue1(stack["fmtDirectiveI"], stack["eivI"])
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL3() (bool, error) {
	// this is our first ever indentation, INDENTATION will handle it
	return c.state["Indentation.Repetitions"].(int) == 0, nil
}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL3() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL3()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL4() (any, error) {
	return nil, nil
}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL4()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL7() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL7()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL9() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL9() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL9()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL11() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0 && len(c.text) > 0, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL11() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL11()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL12() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL12() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL12()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL14() (bool, error) {
	// this is NOT our first indentation
	return c.state["Indentation.RefLine"].(int) != 0, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL14()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL15() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL15() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL15()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL18() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL18()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL19() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL19() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL19()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL20() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL20() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL20()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL22() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL22() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL22()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL23() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	} else if actualCount < expectCount {
		return false, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL23() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL23()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL25() (bool, error) {
	return c.state["Indentation.Repetitions"].(int) > 0, nil
}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL25() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL25()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL5() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL5() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL5()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL10() (bool, error) {
	refReps := c.state["Indentation.Repetitions"].(int)
	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	want := totalReps + refReps
	have := c.state["Indentation.CharCount"].(int)
	if want == have {
		return true, nil
	}

	return false, nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL10() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL10()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL14() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	have := c.state["Indentation.CharCount"].(int)
	want := totalReps + refReps
	if have == want {
		return true, nil
	} else if have <= totalReps {
		return false, nil
	}

	if indentChar == ' ' {
		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               have - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d spaces", have-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two spaces for a single indentation, use four for a two-level indentation",
				},
			},
		}
	}

	return true, &corgierr.Error{
		Message: "inconsistent indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
			Len:               have - totalReps,
			Annotation:        fmt.Sprintf("however, here you used %d tabs", have-totalReps),
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: refLine, Col: 1},
				Len:               refReps,
				Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "be consistent in your indentation:\n" +
					"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
			},
		},
	}

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL14()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL15() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	have := c.state["Indentation.CharCount"].(int)

	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(have - totalReps)
	c.state["Indentation.TotalRepetitions"] = have
	return nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL15() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL15()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL17() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL17() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL17()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL18() (bool, error) {
	want := c.state["Indentation.TotalRepetitions"].(int)
	have := c.state["Indentation.CharCount"].(int)
	return want == have, nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL18()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL19() error {
	c.state["Indentation.CharCount"] = 0
	return nil

}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL19() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL19()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL22() (any, error) {
	return c.text, nil
}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL22() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL22()
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL24(spaceI any) (bool, error) {
	space := byte(char(spaceI))

	indentChar := c.state["Indentation.Char"].(byte)
	if indentChar != space {
		refLine := c.state["Indentation.RefLine"].(int)
		reps := c.state["Indentation.Repetitions"].(int)

		if indentChar == ' ' {
			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      pos(c),
					Annotation: "this is a tab",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               reps,
						Annotation:        "these are spaces",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}

		panic(&corgierr.Error{
			Message: "mix of tabs and spaces for indentation",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "this is a space",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               reps,
					Annotation:        "these are tabs",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "use only tabs OR spaces for indentation, but not both"},
			},
		})
	}

	return true, nil
}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL24() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL24(stack["spaceI"])
}

func (c *current) on_INDENTATION_IGNORE_ADDITIONAL25(spaceI any) error {
	c.state["Indentation.CharCount"] = c.state["Indentation.CharCount"].(int) + 1
	return nil
}

func (p *parser) callon_INDENTATION_IGNORE_ADDITIONAL25() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_INDENTATION_IGNORE_ADDITIONAL25(stack["spaceI"])
}

func (c *current) onINDENTATION23() (bool, error) {
	return c.state["Indentation.Level"].(int) == 0, nil
}

func (p *parser) callonINDENTATION23() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION23()
}

var (
	// errNoRule is returned when the grammar to parse has no rule.
	errNoRule = errors.New("grammar has no rule")

	// errInvalidEntrypoint is returned when the specified entrypoint rule
	// does not exit.
	errInvalidEntrypoint = errors.New("invalid entrypoint")

	// errInvalidEncoding is returned when the source is not properly
	// utf8-encoded.
	errInvalidEncoding = errors.New("invalid encoding")

	// errMaxExprCnt is used to signal that the maximum number of
	// expressions have been parsed.
	errMaxExprCnt = errors.New("max number of expresssions parsed")
)

// Option is a function that can set an option on the parser. It returns
// the previous setting as an Option.
type Option func(*parser) Option

// MaxExpressions creates an Option to stop parsing after the provided
// number of expressions have been parsed, if the value is 0 then the parser will
// parse for as many steps as needed (possibly an infinite number).
//
// The default for maxExprCnt is 0.
func MaxExpressions(maxExprCnt uint64) Option {
	return func(p *parser) Option {
		oldMaxExprCnt := p.maxExprCnt
		p.maxExprCnt = maxExprCnt
		return MaxExpressions(oldMaxExprCnt)
	}
}

// Entrypoint creates an Option to set the rule name to use as entrypoint.
// The rule name must have been specified in the -alternate-entrypoints
// if generating the parser with the -optimize-grammar flag, otherwise
// it may have been optimized out. Passing an empty string sets the
// entrypoint to the first rule in the grammar.
//
// The default is to start parsing at the first rule in the grammar.
func Entrypoint(ruleName string) Option {
	return func(p *parser) Option {
		oldEntrypoint := p.entrypoint
		p.entrypoint = ruleName
		if ruleName == "" {
			p.entrypoint = g.rules[0].name
		}
		return Entrypoint(oldEntrypoint)
	}
}

// AllowInvalidUTF8 creates an Option to allow invalid UTF-8 bytes.
// Every invalid UTF-8 byte is treated as a utf8.RuneError (U+FFFD)
// by character class matchers and is matched by the any matcher.
// The returned matched value, c.text and c.offset are NOT affected.
//
// The default is false.
func AllowInvalidUTF8(b bool) Option {
	return func(p *parser) Option {
		old := p.allowInvalidUTF8
		p.allowInvalidUTF8 = b
		return AllowInvalidUTF8(old)
	}
}

// Recover creates an Option to set the recover flag to b. When set to
// true, this causes the parser to recover from panics and convert it
// to an error. Setting it to false can be useful while debugging to
// access the full stack trace.
//
// The default is true.
func Recover(b bool) Option {
	return func(p *parser) Option {
		old := p.recover
		p.recover = b
		return Recover(old)
	}
}

// GlobalStore creates an Option to set a key to a certain value in
// the globalStore.
func GlobalStore(key string, value any) Option {
	return func(p *parser) Option {
		old := p.cur.globalStore[key]
		p.cur.globalStore[key] = value
		return GlobalStore(key, old)
	}
}

// InitState creates an Option to set a key to a certain value in
// the global "state" store.
func InitState(key string, value any) Option {
	return func(p *parser) Option {
		old := p.cur.state[key]
		p.cur.state[key] = value
		return InitState(key, old)
	}
}

// ParseFile parses the file identified by filename.
func ParseFile(filename string, opts ...Option) (i any, err error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer func() {
		if closeErr := f.Close(); closeErr != nil {
			err = closeErr
		}
	}()
	return ParseReader(filename, f, opts...)
}

// ParseReader parses the data from r using filename as information in the
// error messages.
func ParseReader(filename string, r io.Reader, opts ...Option) (any, error) {
	b, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}

	return Parse(filename, b, opts...)
}

// Parse parses the data from b using filename as information in the
// error messages.
func Parse(filename string, b []byte, opts ...Option) (any, error) {
	return newParser(filename, b, opts...).parse(g)
}

// position records a position in the text.
type position struct {
	line, col, offset int
}

func (p position) String() string {
	return strconv.Itoa(p.line) + ":" + strconv.Itoa(p.col) + " [" + strconv.Itoa(p.offset) + "]"
}

// savepoint stores all state required to go back to this point in the
// parser.
type savepoint struct {
	position
	rn rune
	w  int
}

type current struct {
	pos  position // start position of the match
	text []byte   // raw text of the match

	// state is a store for arbitrary key,value pairs that the user wants to be
	// tied to the backtracking of the parser.
	// This is always rolled back if a parsing rule fails.
	state storeDict

	// globalStore is a general store for the user to store arbitrary key-value
	// pairs that they need to manage and that they do not want tied to the
	// backtracking of the parser. This is only modified by the user and never
	// rolled back by the parser. It is always up to the user to keep this in a
	// consistent state.
	globalStore storeDict
}

type storeDict map[string]any

// the AST types...

type grammar struct {
	pos   position
	rules []*rule
}

type rule struct {
	pos         position
	name        string
	displayName string
	expr        any
}

type choiceExpr struct {
	pos          position
	alternatives []any
}

type actionExpr struct {
	pos  position
	expr any
	run  func(*parser) (any, error)
}

type recoveryExpr struct {
	pos          position
	expr         any
	recoverExpr  any
	failureLabel []string
}

type seqExpr struct {
	pos   position
	exprs []any
}

type throwExpr struct {
	pos   position
	label string
}

type labeledExpr struct {
	pos   position
	label string
	expr  any
}

type expr struct {
	pos  position
	expr any
}

type (
	andExpr        expr
	notExpr        expr
	zeroOrOneExpr  expr
	zeroOrMoreExpr expr
	oneOrMoreExpr  expr
)

type ruleRefExpr struct {
	pos  position
	name string
}

type stateCodeExpr struct {
	pos position
	run func(*parser) error
}

type andCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type notCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type litMatcher struct {
	pos        position
	val        string
	ignoreCase bool
	want       string
}

type charClassMatcher struct {
	pos             position
	val             string
	basicLatinChars [128]bool
	chars           []rune
	ranges          []rune
	classes         []*unicode.RangeTable
	ignoreCase      bool
	inverted        bool
}

type anyMatcher position

// errList cumulates the errors found by the parser.
type errList []error

func (e *errList) add(err error) {
	*e = append(*e, err)
}

func (e errList) err() error {
	if len(e) == 0 {
		return nil
	}
	e.dedupe()
	return e
}

func (e *errList) dedupe() {
	var cleaned []error
	set := make(map[string]bool)
	for _, err := range *e {
		if msg := err.Error(); !set[msg] {
			set[msg] = true
			cleaned = append(cleaned, err)
		}
	}
	*e = cleaned
}

func (e errList) Error() string {
	switch len(e) {
	case 0:
		return ""
	case 1:
		return e[0].Error()
	default:
		var buf bytes.Buffer

		for i, err := range e {
			if i > 0 {
				buf.WriteRune('\n')
			}
			buf.WriteString(err.Error())
		}
		return buf.String()
	}
}

// parserError wraps an error with a prefix indicating the rule in which
// the error occurred. The original error is stored in the Inner field.
type parserError struct {
	Inner    error
	pos      position
	prefix   string
	expected []string
}

// Error returns the error message.
func (p *parserError) Error() string {
	return p.prefix + ": " + p.Inner.Error()
}

// newParser creates a parser with the specified input source and options.
func newParser(filename string, b []byte, opts ...Option) *parser {
	stats := Stats{
		ChoiceAltCnt: make(map[string]map[string]int),
	}

	p := &parser{
		filename: filename,
		errs:     new(errList),
		data:     b,
		pt:       savepoint{position: position{line: 1}},
		recover:  true,
		cur: current{
			state:       make(storeDict),
			globalStore: make(storeDict),
		},
		maxFailPos:      position{col: 1, line: 1},
		maxFailExpected: make([]string, 0, 20),
		Stats:           &stats,
		// start rule is rule [0] unless an alternate entrypoint is specified
		entrypoint: g.rules[0].name,
	}
	p.setOptions(opts)

	if p.maxExprCnt == 0 {
		p.maxExprCnt = math.MaxUint64
	}

	return p
}

// setOptions applies the options to the parser.
func (p *parser) setOptions(opts []Option) {
	for _, opt := range opts {
		opt(p)
	}
}

type resultTuple struct {
	v   any
	b   bool
	end savepoint
}

const choiceNoMatch = -1

// Stats stores some statistics, gathered during parsing
type Stats struct {
	// ExprCnt counts the number of expressions processed during parsing
	// This value is compared to the maximum number of expressions allowed
	// (set by the MaxExpressions option).
	ExprCnt uint64

	// ChoiceAltCnt is used to count for each ordered choice expression,
	// which alternative is used how may times.
	// These numbers allow to optimize the order of the ordered choice expression
	// to increase the performance of the parser
	//
	// The outer key of ChoiceAltCnt is composed of the name of the rule as well
	// as the line and the column of the ordered choice.
	// The inner key of ChoiceAltCnt is the number (one-based) of the matching alternative.
	// For each alternative the number of matches are counted. If an ordered choice does not
	// match, a special counter is incremented. The name of this counter is set with
	// the parser option Statistics.
	// For an alternative to be included in ChoiceAltCnt, it has to match at least once.
	ChoiceAltCnt map[string]map[string]int
}

type parser struct {
	filename string
	pt       savepoint
	cur      current

	data []byte
	errs *errList

	depth   int
	recover bool

	// rules table, maps the rule identifier to the rule node
	rules map[string]*rule
	// variables stack, map of label to value
	vstack []map[string]any
	// rule stack, allows identification of the current rule in errors
	rstack []*rule

	// parse fail
	maxFailPos            position
	maxFailExpected       []string
	maxFailInvertExpected bool

	// max number of expressions to be parsed
	maxExprCnt uint64
	// entrypoint for the parser
	entrypoint string

	allowInvalidUTF8 bool

	*Stats

	choiceNoMatch string
	// recovery expression stack, keeps track of the currently available recovery expression, these are traversed in reverse
	recoveryStack []map[string]any
}

// push a variable set on the vstack.
func (p *parser) pushV() {
	if cap(p.vstack) == len(p.vstack) {
		// create new empty slot in the stack
		p.vstack = append(p.vstack, nil)
	} else {
		// slice to 1 more
		p.vstack = p.vstack[:len(p.vstack)+1]
	}

	// get the last args set
	m := p.vstack[len(p.vstack)-1]
	if m != nil && len(m) == 0 {
		// empty map, all good
		return
	}

	m = make(map[string]any)
	p.vstack[len(p.vstack)-1] = m
}

// pop a variable set from the vstack.
func (p *parser) popV() {
	// if the map is not empty, clear it
	m := p.vstack[len(p.vstack)-1]
	if len(m) > 0 {
		// GC that map
		p.vstack[len(p.vstack)-1] = nil
	}
	p.vstack = p.vstack[:len(p.vstack)-1]
}

// push a recovery expression with its labels to the recoveryStack
func (p *parser) pushRecovery(labels []string, expr any) {
	if cap(p.recoveryStack) == len(p.recoveryStack) {
		// create new empty slot in the stack
		p.recoveryStack = append(p.recoveryStack, nil)
	} else {
		// slice to 1 more
		p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)+1]
	}

	m := make(map[string]any, len(labels))
	for _, fl := range labels {
		m[fl] = expr
	}
	p.recoveryStack[len(p.recoveryStack)-1] = m
}

// pop a recovery expression from the recoveryStack
func (p *parser) popRecovery() {
	// GC that map
	p.recoveryStack[len(p.recoveryStack)-1] = nil

	p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)-1]
}

func (p *parser) addErr(err error) {
	p.addErrAt(err, p.pt.position, []string{})
}

func (p *parser) addErrAt(err error, pos position, expected []string) {
	var buf bytes.Buffer
	if p.filename != "" {
		buf.WriteString(p.filename)
	}
	if buf.Len() > 0 {
		buf.WriteString(":")
	}
	buf.WriteString(fmt.Sprintf("%d:%d (%d)", pos.line, pos.col, pos.offset))
	if len(p.rstack) > 0 {
		if buf.Len() > 0 {
			buf.WriteString(": ")
		}
		rule := p.rstack[len(p.rstack)-1]
		if rule.displayName != "" {
			buf.WriteString("rule " + rule.displayName)
		} else {
			buf.WriteString("rule " + rule.name)
		}
	}
	pe := &parserError{Inner: err, pos: pos, prefix: buf.String(), expected: expected}
	p.errs.add(pe)
}

func (p *parser) failAt(fail bool, pos position, want string) {
	// process fail if parsing fails and not inverted or parsing succeeds and invert is set
	if fail == p.maxFailInvertExpected {
		if pos.offset < p.maxFailPos.offset {
			return
		}

		if pos.offset > p.maxFailPos.offset {
			p.maxFailPos = pos
			p.maxFailExpected = p.maxFailExpected[:0]
		}

		if p.maxFailInvertExpected {
			want = "!" + want
		}
		p.maxFailExpected = append(p.maxFailExpected, want)
	}
}

// read advances the parser to the next rune.
func (p *parser) read() {
	p.pt.offset += p.pt.w
	rn, n := utf8.DecodeRune(p.data[p.pt.offset:])
	p.pt.rn = rn
	p.pt.w = n
	p.pt.col++
	if rn == '\n' {
		p.pt.line++
		p.pt.col = 0
	}

	if rn == utf8.RuneError && n == 1 { // see utf8.DecodeRune
		if !p.allowInvalidUTF8 {
			p.addErr(errInvalidEncoding)
		}
	}
}

// restore parser position to the savepoint pt.
func (p *parser) restore(pt savepoint) {
	if pt.offset == p.pt.offset {
		return
	}
	p.pt = pt
}

// Cloner is implemented by any value that has a Clone method, which returns a
// copy of the value. This is mainly used for types which are not passed by
// value (e.g map, slice, chan) or structs that contain such types.
//
// This is used in conjunction with the global state feature to create proper
// copies of the state to allow the parser to properly restore the state in
// the case of backtracking.
type Cloner interface {
	Clone() any
}

var statePool = &sync.Pool{
	New: func() any { return make(storeDict) },
}

func (sd storeDict) Discard() {
	for k := range sd {
		delete(sd, k)
	}
	statePool.Put(sd)
}

// clone and return parser current state.
func (p *parser) cloneState() storeDict {

	state := statePool.Get().(storeDict)
	for k, v := range p.cur.state {
		if c, ok := v.(Cloner); ok {
			state[k] = c.Clone()
		} else {
			state[k] = v
		}
	}
	return state
}

// restore parser current state to the state storeDict.
// every restoreState should applied only one time for every cloned state
func (p *parser) restoreState(state storeDict) {
	p.cur.state.Discard()
	p.cur.state = state
}

// get the slice of bytes from the savepoint start to the current position.
func (p *parser) sliceFrom(start savepoint) []byte {
	return p.data[start.position.offset:p.pt.position.offset]
}

func (p *parser) buildRulesTable(g *grammar) {
	p.rules = make(map[string]*rule, len(g.rules))
	for _, r := range g.rules {
		p.rules[r.name] = r
	}
}

func (p *parser) parse(g *grammar) (val any, err error) {
	if len(g.rules) == 0 {
		p.addErr(errNoRule)
		return nil, p.errs.err()
	}

	// TODO : not super critical but this could be generated
	p.buildRulesTable(g)

	if p.recover {
		// panic can be used in action code to stop parsing immediately
		// and return the panic as an error.
		defer func() {
			if e := recover(); e != nil {
				val = nil
				switch e := e.(type) {
				case error:
					p.addErr(e)
				default:
					p.addErr(fmt.Errorf("%v", e))
				}
				err = p.errs.err()
			}
		}()
	}

	startRule, ok := p.rules[p.entrypoint]
	if !ok {
		p.addErr(errInvalidEntrypoint)
		return nil, p.errs.err()
	}

	p.read() // advance to first rune
	val, ok = p.parseRuleWrap(startRule)
	if !ok {
		if len(*p.errs) == 0 {
			// If parsing fails, but no errors have been recorded, the expected values
			// for the farthest parser position are returned as error.
			maxFailExpectedMap := make(map[string]struct{}, len(p.maxFailExpected))
			for _, v := range p.maxFailExpected {
				maxFailExpectedMap[v] = struct{}{}
			}
			expected := make([]string, 0, len(maxFailExpectedMap))
			eof := false
			if _, ok := maxFailExpectedMap["!."]; ok {
				delete(maxFailExpectedMap, "!.")
				eof = true
			}
			for k := range maxFailExpectedMap {
				expected = append(expected, k)
			}
			sort.Strings(expected)
			if eof {
				expected = append(expected, "EOF")
			}
			p.addErrAt(errors.New("no match found, expected: "+listJoin(expected, ", ", "or")), p.maxFailPos, expected)
		}

		return nil, p.errs.err()
	}
	return val, p.errs.err()
}

func listJoin(list []string, sep string, lastSep string) string {
	switch len(list) {
	case 0:
		return ""
	case 1:
		return list[0]
	default:
		return strings.Join(list[:len(list)-1], sep) + " " + lastSep + " " + list[len(list)-1]
	}
}

func (p *parser) parseRuleWrap(rule *rule) (any, bool) {
	var (
		val any
		ok  bool
	)

	val, ok = p.parseRule(rule)

	return val, ok
}

func (p *parser) parseRule(rule *rule) (any, bool) {
	p.rstack = append(p.rstack, rule)
	p.pushV()
	val, ok := p.parseExprWrap(rule.expr)
	p.popV()
	p.rstack = p.rstack[:len(p.rstack)-1]
	return val, ok
}

func (p *parser) parseExprWrap(expr any) (any, bool) {
	val, ok := p.parseExpr(expr)

	return val, ok
}

func (p *parser) parseExpr(expr any) (any, bool) {
	p.ExprCnt++
	if p.ExprCnt > p.maxExprCnt {
		panic(errMaxExprCnt)
	}

	var val any
	var ok bool
	switch expr := expr.(type) {
	case *actionExpr:
		val, ok = p.parseActionExpr(expr)
	case *andCodeExpr:
		val, ok = p.parseAndCodeExpr(expr)
	case *andExpr:
		val, ok = p.parseAndExpr(expr)
	case *anyMatcher:
		val, ok = p.parseAnyMatcher(expr)
	case *charClassMatcher:
		val, ok = p.parseCharClassMatcher(expr)
	case *choiceExpr:
		val, ok = p.parseChoiceExpr(expr)
	case *labeledExpr:
		val, ok = p.parseLabeledExpr(expr)
	case *litMatcher:
		val, ok = p.parseLitMatcher(expr)
	case *notCodeExpr:
		val, ok = p.parseNotCodeExpr(expr)
	case *notExpr:
		val, ok = p.parseNotExpr(expr)
	case *oneOrMoreExpr:
		val, ok = p.parseOneOrMoreExpr(expr)
	case *recoveryExpr:
		val, ok = p.parseRecoveryExpr(expr)
	case *ruleRefExpr:
		val, ok = p.parseRuleRefExpr(expr)
	case *seqExpr:
		val, ok = p.parseSeqExpr(expr)
	case *stateCodeExpr:
		val, ok = p.parseStateCodeExpr(expr)
	case *throwExpr:
		val, ok = p.parseThrowExpr(expr)
	case *zeroOrMoreExpr:
		val, ok = p.parseZeroOrMoreExpr(expr)
	case *zeroOrOneExpr:
		val, ok = p.parseZeroOrOneExpr(expr)
	default:
		panic(fmt.Sprintf("unknown expression type %T", expr))
	}
	return val, ok
}

func (p *parser) parseActionExpr(act *actionExpr) (any, bool) {
	start := p.pt
	val, ok := p.parseExprWrap(act.expr)
	if ok {
		p.cur.pos = start.position
		p.cur.text = p.sliceFrom(start)
		state := p.cloneState()
		actVal, err := act.run(p)
		if err != nil {
			p.addErrAt(err, start.position, []string{})
		}
		p.restoreState(state)

		val = actVal
	}
	return val, ok
}

func (p *parser) parseAndCodeExpr(and *andCodeExpr) (any, bool) {
	state := p.cloneState()

	ok, err := and.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, ok
}

func (p *parser) parseAndExpr(and *andExpr) (any, bool) {
	pt := p.pt
	state := p.cloneState()
	p.pushV()
	_, ok := p.parseExprWrap(and.expr)
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, ok
}

func (p *parser) parseAnyMatcher(any *anyMatcher) (any, bool) {
	if p.pt.rn == utf8.RuneError && p.pt.w == 0 {
		// EOF - see utf8.DecodeRune
		p.failAt(false, p.pt.position, ".")
		return nil, false
	}
	start := p.pt
	p.read()
	p.failAt(true, start.position, ".")
	return p.sliceFrom(start), true
}

func (p *parser) parseCharClassMatcher(chr *charClassMatcher) (any, bool) {
	cur := p.pt.rn
	start := p.pt

	// can't match EOF
	if cur == utf8.RuneError && p.pt.w == 0 { // see utf8.DecodeRune
		p.failAt(false, start.position, chr.val)
		return nil, false
	}

	if chr.ignoreCase {
		cur = unicode.ToLower(cur)
	}

	// try to match in the list of available chars
	for _, rn := range chr.chars {
		if rn == cur {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of ranges
	for i := 0; i < len(chr.ranges); i += 2 {
		if cur >= chr.ranges[i] && cur <= chr.ranges[i+1] {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of Unicode classes
	for _, cl := range chr.classes {
		if unicode.Is(cl, cur) {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	if chr.inverted {
		p.read()
		p.failAt(true, start.position, chr.val)
		return p.sliceFrom(start), true
	}
	p.failAt(false, start.position, chr.val)
	return nil, false
}

func (p *parser) parseChoiceExpr(ch *choiceExpr) (any, bool) {

	for altI, alt := range ch.alternatives {
		// dummy assignment to prevent compile error if optimized
		_ = altI

		state := p.cloneState()

		p.pushV()
		val, ok := p.parseExprWrap(alt)
		p.popV()
		if ok {
			return val, ok
		}
		p.restoreState(state)
	}
	return nil, false
}

func (p *parser) parseLabeledExpr(lab *labeledExpr) (any, bool) {
	p.pushV()
	val, ok := p.parseExprWrap(lab.expr)
	p.popV()
	if ok && lab.label != "" {
		m := p.vstack[len(p.vstack)-1]
		m[lab.label] = val
	}
	return val, ok
}

func (p *parser) parseLitMatcher(lit *litMatcher) (any, bool) {
	start := p.pt
	for _, want := range lit.val {
		cur := p.pt.rn
		if lit.ignoreCase {
			cur = unicode.ToLower(cur)
		}
		if cur != want {
			p.failAt(false, start.position, lit.want)
			p.restore(start)
			return nil, false
		}
		p.read()
	}
	p.failAt(true, start.position, lit.want)
	return p.sliceFrom(start), true
}

func (p *parser) parseNotCodeExpr(not *notCodeExpr) (any, bool) {
	state := p.cloneState()

	ok, err := not.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, !ok
}

func (p *parser) parseNotExpr(not *notExpr) (any, bool) {
	pt := p.pt
	state := p.cloneState()
	p.pushV()
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	_, ok := p.parseExprWrap(not.expr)
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, !ok
}

func (p *parser) parseOneOrMoreExpr(expr *oneOrMoreExpr) (any, bool) {
	var vals []any

	for {
		p.pushV()
		val, ok := p.parseExprWrap(expr.expr)
		p.popV()
		if !ok {
			if len(vals) == 0 {
				// did not match once, no match
				return nil, false
			}
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseRecoveryExpr(recover *recoveryExpr) (any, bool) {

	p.pushRecovery(recover.failureLabel, recover.recoverExpr)
	val, ok := p.parseExprWrap(recover.expr)
	p.popRecovery()

	return val, ok
}

func (p *parser) parseRuleRefExpr(ref *ruleRefExpr) (any, bool) {
	if ref.name == "" {
		panic(fmt.Sprintf("%s: invalid rule: missing name", ref.pos))
	}

	rule := p.rules[ref.name]
	if rule == nil {
		p.addErr(fmt.Errorf("undefined rule: %s", ref.name))
		return nil, false
	}
	return p.parseRuleWrap(rule)
}

func (p *parser) parseSeqExpr(seq *seqExpr) (any, bool) {
	vals := make([]any, 0, len(seq.exprs))

	pt := p.pt
	state := p.cloneState()
	for _, expr := range seq.exprs {
		val, ok := p.parseExprWrap(expr)
		if !ok {
			p.restoreState(state)
			p.restore(pt)
			return nil, false
		}
		vals = append(vals, val)
	}
	return vals, true
}

func (p *parser) parseStateCodeExpr(state *stateCodeExpr) (any, bool) {
	err := state.run(p)
	if err != nil {
		p.addErr(err)
	}
	return nil, true
}

func (p *parser) parseThrowExpr(expr *throwExpr) (any, bool) {

	for i := len(p.recoveryStack) - 1; i >= 0; i-- {
		if recoverExpr, ok := p.recoveryStack[i][expr.label]; ok {
			if val, ok := p.parseExprWrap(recoverExpr); ok {
				return val, ok
			}
		}
	}

	return nil, false
}

func (p *parser) parseZeroOrMoreExpr(expr *zeroOrMoreExpr) (any, bool) {
	var vals []any

	for {
		p.pushV()
		val, ok := p.parseExprWrap(expr.expr)
		p.popV()
		if !ok {
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseZeroOrOneExpr(expr *zeroOrOneExpr) (any, bool) {
	p.pushV()
	val, _ := p.parseExprWrap(expr.expr)
	p.popV()
	// whether it matched or not, consider it a match
	return val, true
}

func rangeTable(class string) *unicode.RangeTable {
	if rt, ok := unicode.Categories[class]; ok {
		return rt
	}
	if rt, ok := unicode.Properties[class]; ok {
		return rt
	}
	if rt, ok := unicode.Scripts[class]; ok {
		return rt
	}

	// cannot happen
	panic(fmt.Sprintf("invalid Unicode class: %s", class))
}
