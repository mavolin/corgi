// Code generated by pigeon; DO NOT EDIT.

package internal

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"

	"github.com/mavolin/corgi/corgierr"
	"github.com/mavolin/corgi/file"
	"github.com/mavolin/corgi/internal/stack"
)

// todo: rm these as soon as pigeon#115 is fixed
const lbrace = "{"
const rbrace = "}"

type ErrList = errList
type ParserError = parserError

var g = &grammar{
	rules: []*rule{
		{
			name: "File",
			pos:  position{line: 12, col: 1, offset: 189},
			expr: &actionExpr{
				pos: position{line: 13, col: 5, offset: 201},
				run: (*parser).callonFile1,
				expr: &seqExpr{
					pos: position{line: 13, col: 5, offset: 201},
					exprs: []interface{}{
						&stateCodeExpr{
							pos: position{line: 128, col: 9, offset: 3669},
							run: (*parser).callonFile3,
						},
						&zeroOrOneExpr{
							pos: position{line: 14, col: 5, offset: 210},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 15, col: 5, offset: 223},
							label: "extendComments",
							expr: &zeroOrOneExpr{
								pos: position{line: 15, col: 20, offset: 238},
								expr: &ruleRefExpr{
									pos:  position{line: 15, col: 20, offset: 238},
									name: "CorgiComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 15, col: 35, offset: 253},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 16, col: 5, offset: 266},
							label: "extendI",
							expr: &zeroOrOneExpr{
								pos: position{line: 16, col: 13, offset: 274},
								expr: &actionExpr{
									pos: position{line: 3194, col: 11, offset: 110867},
									run: (*parser).callonFile25,
									expr: &seqExpr{
										pos: position{line: 3194, col: 11, offset: 110867},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 3194, col: 11, offset: 110867},
												val:        "extend",
												ignoreCase: false,
												want:       "\"extend\"",
											},
											&labeledExpr{
												pos:   position{line: 3194, col: 20, offset: 110876},
												label: "extendI",
												expr: &choiceExpr{
													pos: position{line: 3166, col: 18, offset: 109929},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 3166, col: 18, offset: 109929},
															exprs: []interface{}{
																&oneOrMoreExpr{
																	pos: position{line: 3166, col: 18, offset: 109929},
																	expr: &litMatcher{
																		pos:        position{line: 3166, col: 18, offset: 109929},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&choiceExpr{
																	pos: position{line: 743, col: 11, offset: 22871},
																	alternatives: []interface{}{
																		&actionExpr{
																			pos: position{line: 749, col: 14, offset: 22958},
																			run: (*parser).callonFile34,
																			expr: &seqExpr{
																				pos: position{line: 749, col: 14, offset: 22958},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 749, col: 14, offset: 22958},
																						val:        "`",
																						ignoreCase: false,
																						want:       "\"`\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 749, col: 18, offset: 22962},
																						label: "strI",
																						expr: &zeroOrMoreExpr{
																							pos: position{line: 749, col: 23, offset: 22967},
																							expr: &charClassMatcher{
																								pos:        position{line: 2704, col: 27, offset: 94307},
																								val:        "[^\\n`]",
																								chars:      []rune{'\n', '`'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 749, col: 47, offset: 22991},
																						val:        "`",
																						ignoreCase: false,
																						want:       "\"`\"",
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 751, col: 5, offset: 23083},
																			run: (*parser).callonFile41,
																			expr: &seqExpr{
																				pos: position{line: 751, col: 5, offset: 23083},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 751, col: 5, offset: 23083},
																						val:        "`",
																						ignoreCase: false,
																						want:       "\"`\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 751, col: 9, offset: 23087},
																						label: "strI",
																						expr: &zeroOrMoreExpr{
																							pos: position{line: 751, col: 14, offset: 23092},
																							expr: &charClassMatcher{
																								pos:        position{line: 2704, col: 27, offset: 94307},
																								val:        "[^\\n`]",
																								chars:      []rune{'\n', '`'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																					&andExpr{
																						pos: position{line: 751, col: 38, offset: 23116},
																						expr: &seqExpr{
																							pos: position{line: 3734, col: 12, offset: 128237},
																							exprs: []interface{}{
																								&zeroOrMoreExpr{
																									pos: position{line: 3734, col: 12, offset: 128237},
																									expr: &charClassMatcher{
																										pos:        position{line: 3746, col: 36, offset: 128584},
																										val:        "[ \\t]",
																										chars:      []rune{' ', '\t'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&choiceExpr{
																									pos: position{line: 3734, col: 16, offset: 128241},
																									alternatives: []interface{}{
																										&seqExpr{
																											pos: position{line: 3734, col: 16, offset: 128241},
																											exprs: []interface{}{
																												&zeroOrOneExpr{
																													pos: position{line: 3734, col: 16, offset: 128241},
																													expr: &litMatcher{
																														pos:        position{line: 3734, col: 16, offset: 128241},
																														val:        "\r",
																														ignoreCase: false,
																														want:       "\"\\r\"",
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 3734, col: 22, offset: 128247},
																													val:        "\n",
																													ignoreCase: false,
																													want:       "\"\\n\"",
																												},
																											},
																										},
																										&notExpr{
																											pos: position{line: 3733, col: 12, offset: 128223},
																											expr: &anyMatcher{
																												line: 3733, col: 13, offset: 128224,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 770, col: 22, offset: 23520},
																			run: (*parser).callonFile58,
																			expr: &seqExpr{
																				pos: position{line: 770, col: 22, offset: 23520},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 770, col: 22, offset: 23520},
																						val:        "\"",
																						ignoreCase: false,
																						want:       "\"\\\"\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 770, col: 26, offset: 23524},
																						label: "strI",
																						expr: &zeroOrMoreExpr{
																							pos: position{line: 770, col: 31, offset: 23529},
																							expr: &choiceExpr{
																								pos: position{line: 770, col: 32, offset: 23530},
																								alternatives: []interface{}{
																									&seqExpr{
																										pos: position{line: 2443, col: 24, offset: 83970},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2443, col: 24, offset: 83970},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2444, col: 24, offset: 84037},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2444, col: 24, offset: 84037},
																												val:        "\\x",
																												ignoreCase: false,
																												want:       "\"\\\\x\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2445, col: 5, offset: 84074},
																										run: (*parser).callonFile73,
																										expr: &seqExpr{
																											pos: position{line: 2445, col: 5, offset: 84074},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2445, col: 5, offset: 84074},
																													val:        "\\x",
																													ignoreCase: false,
																													want:       "\"\\\\x\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2445, col: 14, offset: 84083},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2445, col: 26, offset: 84095},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2462, col: 19, offset: 84712},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2462, col: 19, offset: 84712},
																												val:        "\\u",
																												ignoreCase: false,
																												want:       "\"\\\\u\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2463, col: 5, offset: 84771},
																										run: (*parser).callonFile86,
																										expr: &seqExpr{
																											pos: position{line: 2463, col: 5, offset: 84771},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2463, col: 5, offset: 84771},
																													val:        "\\u",
																													ignoreCase: false,
																													want:       "\"\\\\u\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 14, offset: 84780},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 26, offset: 84792},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 38, offset: 84804},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 50, offset: 84816},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2492, col: 16, offset: 85952},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2492, col: 16, offset: 85952},
																												val:        "\\U",
																												ignoreCase: false,
																												want:       "\"\\\\U\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2493, col: 5, offset: 86055},
																										run: (*parser).callonFile107,
																										expr: &seqExpr{
																											pos: position{line: 2493, col: 5, offset: 86055},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2493, col: 5, offset: 86055},
																													val:        "\\U",
																													ignoreCase: false,
																													want:       "\"\\\\U\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 14, offset: 86064},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 26, offset: 86076},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 38, offset: 86088},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 50, offset: 86100},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 62, offset: 86112},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 74, offset: 86124},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 86, offset: 86136},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 98, offset: 86148},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2720, col: 36, offset: 95085},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2720, col: 36, offset: 95085},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2720, col: 41, offset: 95090},
																												val:        "[abfnrtv\\\\\"]",
																												chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 2718, col: 38, offset: 94977},
																										val:        "[^\"\\\\\\n]",
																										chars:      []rune{'"', '\\', '\n'},
																										ignoreCase: false,
																										inverted:   true,
																									},
																									&actionExpr{
																										pos: position{line: 2607, col: 37, offset: 90735},
																										run: (*parser).callonFile130,
																										expr: &seqExpr{
																											pos: position{line: 2607, col: 37, offset: 90735},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2607, col: 37, offset: 90735},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2631, col: 5, offset: 91752},
																										run: (*parser).callonFile141,
																										expr: &seqExpr{
																											pos: position{line: 2631, col: 5, offset: 91752},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2631, col: 5, offset: 91752},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2652, col: 5, offset: 92594},
																										run: (*parser).callonFile148,
																										expr: &seqExpr{
																											pos: position{line: 2652, col: 5, offset: 92594},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2652, col: 5, offset: 92594},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2670, col: 5, offset: 93280},
																										run: (*parser).callonFile153,
																										expr: &seqExpr{
																											pos: position{line: 2670, col: 5, offset: 93280},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2670, col: 5, offset: 93280},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2670, col: 10, offset: 93285},
																													expr: &charClassMatcher{
																														pos:        position{line: 3735, col: 12, offset: 128270},
																														val:        "[^\\r\\n]",
																														chars:      []rune{'\r', '\n'},
																														ignoreCase: false,
																														inverted:   true,
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 770, col: 115, offset: 23613},
																						val:        "\"",
																						ignoreCase: false,
																						want:       "\"\\\"\"",
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 772, col: 5, offset: 23705},
																			run: (*parser).callonFile159,
																			expr: &seqExpr{
																				pos: position{line: 772, col: 5, offset: 23705},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 772, col: 5, offset: 23705},
																						val:        "\"",
																						ignoreCase: false,
																						want:       "\"\\\"\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 772, col: 9, offset: 23709},
																						label: "strI",
																						expr: &zeroOrMoreExpr{
																							pos: position{line: 772, col: 14, offset: 23714},
																							expr: &choiceExpr{
																								pos: position{line: 772, col: 15, offset: 23715},
																								alternatives: []interface{}{
																									&seqExpr{
																										pos: position{line: 2443, col: 24, offset: 83970},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2443, col: 24, offset: 83970},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2444, col: 24, offset: 84037},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2444, col: 24, offset: 84037},
																												val:        "\\x",
																												ignoreCase: false,
																												want:       "\"\\\\x\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2445, col: 5, offset: 84074},
																										run: (*parser).callonFile174,
																										expr: &seqExpr{
																											pos: position{line: 2445, col: 5, offset: 84074},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2445, col: 5, offset: 84074},
																													val:        "\\x",
																													ignoreCase: false,
																													want:       "\"\\\\x\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2445, col: 14, offset: 84083},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2445, col: 26, offset: 84095},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2462, col: 19, offset: 84712},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2462, col: 19, offset: 84712},
																												val:        "\\u",
																												ignoreCase: false,
																												want:       "\"\\\\u\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2463, col: 5, offset: 84771},
																										run: (*parser).callonFile187,
																										expr: &seqExpr{
																											pos: position{line: 2463, col: 5, offset: 84771},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2463, col: 5, offset: 84771},
																													val:        "\\u",
																													ignoreCase: false,
																													want:       "\"\\\\u\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 14, offset: 84780},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 26, offset: 84792},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 38, offset: 84804},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 50, offset: 84816},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2492, col: 16, offset: 85952},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2492, col: 16, offset: 85952},
																												val:        "\\U",
																												ignoreCase: false,
																												want:       "\"\\\\U\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2493, col: 5, offset: 86055},
																										run: (*parser).callonFile208,
																										expr: &seqExpr{
																											pos: position{line: 2493, col: 5, offset: 86055},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2493, col: 5, offset: 86055},
																													val:        "\\U",
																													ignoreCase: false,
																													want:       "\"\\\\U\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 14, offset: 86064},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 26, offset: 86076},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 38, offset: 86088},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 50, offset: 86100},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 62, offset: 86112},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 74, offset: 86124},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 86, offset: 86136},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 98, offset: 86148},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2720, col: 36, offset: 95085},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2720, col: 36, offset: 95085},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2720, col: 41, offset: 95090},
																												val:        "[abfnrtv\\\\\"]",
																												chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 2718, col: 38, offset: 94977},
																										val:        "[^\"\\\\\\n]",
																										chars:      []rune{'"', '\\', '\n'},
																										ignoreCase: false,
																										inverted:   true,
																									},
																									&actionExpr{
																										pos: position{line: 2607, col: 37, offset: 90735},
																										run: (*parser).callonFile231,
																										expr: &seqExpr{
																											pos: position{line: 2607, col: 37, offset: 90735},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2607, col: 37, offset: 90735},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2631, col: 5, offset: 91752},
																										run: (*parser).callonFile242,
																										expr: &seqExpr{
																											pos: position{line: 2631, col: 5, offset: 91752},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2631, col: 5, offset: 91752},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2652, col: 5, offset: 92594},
																										run: (*parser).callonFile249,
																										expr: &seqExpr{
																											pos: position{line: 2652, col: 5, offset: 92594},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2652, col: 5, offset: 92594},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2670, col: 5, offset: 93280},
																										run: (*parser).callonFile254,
																										expr: &seqExpr{
																											pos: position{line: 2670, col: 5, offset: 93280},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2670, col: 5, offset: 93280},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2670, col: 10, offset: 93285},
																													expr: &charClassMatcher{
																														pos:        position{line: 3735, col: 12, offset: 128270},
																														val:        "[^\\r\\n]",
																														chars:      []rune{'\r', '\n'},
																														ignoreCase: false,
																														inverted:   true,
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																					&labeledExpr{
																						pos:   position{line: 772, col: 98, offset: 23798},
																						label: "endPosI",
																						expr: &actionExpr{
																							pos: position{line: 3737, col: 8, offset: 128286},
																							run: (*parser).callonFile260,
																							expr: &choiceExpr{
																								pos: position{line: 3737, col: 9, offset: 128287},
																								alternatives: []interface{}{
																									&andExpr{
																										pos: position{line: 3737, col: 9, offset: 128287},
																										expr: &anyMatcher{
																											line: 3737, col: 10, offset: 128288,
																										},
																									},
																									&notExpr{
																										pos: position{line: 3737, col: 14, offset: 128292},
																										expr: &anyMatcher{
																											line: 3737, col: 15, offset: 128293,
																										},
																									},
																								},
																							},
																						},
																					},
																					&andExpr{
																						pos: position{line: 772, col: 110, offset: 23810},
																						expr: &seqExpr{
																							pos: position{line: 3734, col: 12, offset: 128237},
																							exprs: []interface{}{
																								&zeroOrMoreExpr{
																									pos: position{line: 3734, col: 12, offset: 128237},
																									expr: &charClassMatcher{
																										pos:        position{line: 3746, col: 36, offset: 128584},
																										val:        "[ \\t]",
																										chars:      []rune{' ', '\t'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&choiceExpr{
																									pos: position{line: 3734, col: 16, offset: 128241},
																									alternatives: []interface{}{
																										&seqExpr{
																											pos: position{line: 3734, col: 16, offset: 128241},
																											exprs: []interface{}{
																												&zeroOrOneExpr{
																													pos: position{line: 3734, col: 16, offset: 128241},
																													expr: &litMatcher{
																														pos:        position{line: 3734, col: 16, offset: 128241},
																														val:        "\r",
																														ignoreCase: false,
																														want:       "\"\\r\"",
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 3734, col: 22, offset: 128247},
																													val:        "\n",
																													ignoreCase: false,
																													want:       "\"\\n\"",
																												},
																											},
																										},
																										&notExpr{
																											pos: position{line: 3733, col: 12, offset: 128223},
																											expr: &anyMatcher{
																												line: 3733, col: 13, offset: 128224,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 791, col: 22, offset: 24216},
																			run: (*parser).callonFile277,
																			expr: &seqExpr{
																				pos: position{line: 791, col: 22, offset: 24216},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 791, col: 22, offset: 24216},
																						val:        "'",
																						ignoreCase: false,
																						want:       "\"'\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 791, col: 27, offset: 24221},
																						label: "strI",
																						expr: &zeroOrMoreExpr{
																							pos: position{line: 791, col: 32, offset: 24226},
																							expr: &charClassMatcher{
																								pos:        position{line: 791, col: 32, offset: 24226},
																								val:        "[^\\\\r\\n]",
																								chars:      []rune{'\'', '\r', '\n'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 791, col: 42, offset: 24236},
																						val:        "'",
																						ignoreCase: false,
																						want:       "\"'\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 791, col: 47, offset: 24241},
																						label: "endPosI",
																						expr: &actionExpr{
																							pos: position{line: 3737, col: 8, offset: 128286},
																							run: (*parser).callonFile285,
																							expr: &choiceExpr{
																								pos: position{line: 3737, col: 9, offset: 128287},
																								alternatives: []interface{}{
																									&andExpr{
																										pos: position{line: 3737, col: 9, offset: 128287},
																										expr: &anyMatcher{
																											line: 3737, col: 10, offset: 128288,
																										},
																									},
																									&notExpr{
																										pos: position{line: 3737, col: 14, offset: 128292},
																										expr: &anyMatcher{
																											line: 3737, col: 15, offset: 128293,
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 3166, col: 32, offset: 109943},
															run: (*parser).callonFile291,
															expr: &labeledExpr{
																pos:   position{line: 3166, col: 32, offset: 109943},
																label: "pathI",
																expr: &zeroOrMoreExpr{
																	pos: position{line: 3166, col: 38, offset: 109949},
																	expr: &charClassMatcher{
																		pos:        position{line: 3735, col: 12, offset: 128270},
																		val:        "[^\\r\\n]",
																		chars:      []rune{'\r', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																},
															},
														},
													},
												},
											},
											&zeroOrMoreExpr{
												pos: position{line: 3734, col: 12, offset: 128237},
												expr: &charClassMatcher{
													pos:        position{line: 3746, col: 36, offset: 128584},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&choiceExpr{
												pos: position{line: 3734, col: 16, offset: 128241},
												alternatives: []interface{}{
													&seqExpr{
														pos: position{line: 3734, col: 16, offset: 128241},
														exprs: []interface{}{
															&zeroOrOneExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																expr: &litMatcher{
																	pos:        position{line: 3734, col: 16, offset: 128241},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3734, col: 22, offset: 128247},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
													&notExpr{
														pos: position{line: 3733, col: 12, offset: 128223},
														expr: &anyMatcher{
															line: 3733, col: 13, offset: 128224,
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 16, col: 21, offset: 282},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 17, col: 5, offset: 295},
							label: "importsAndCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 17, col: 25, offset: 315},
								expr: &ruleRefExpr{
									pos:  position{line: 17, col: 25, offset: 315},
									name: "importsAndComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 17, col: 45, offset: 335},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 18, col: 5, offset: 348},
							label: "usesAndCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 18, col: 22, offset: 365},
								expr: &ruleRefExpr{
									pos:  position{line: 18, col: 22, offset: 365},
									name: "usesAndComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 18, col: 39, offset: 382},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 19, col: 5, offset: 395},
							label: "globalCodeAndFuncI",
							expr: &zeroOrOneExpr{
								pos: position{line: 19, col: 24, offset: 414},
								expr: &ruleRefExpr{
									pos:  position{line: 19, col: 24, offset: 414},
									name: "globalCodeAndFunc",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 19, col: 43, offset: 433},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 20, col: 5, offset: 446},
							label: "doctypeCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 20, col: 22, offset: 463},
								expr: &ruleRefExpr{
									pos:  position{line: 20, col: 22, offset: 463},
									name: "CorgiComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 20, col: 37, offset: 478},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 21, col: 5, offset: 491},
							label: "doctypeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 21, col: 14, offset: 500},
								expr: &choiceExpr{
									pos: position{line: 852, col: 12, offset: 26297},
									alternatives: []interface{}{
										&actionExpr{
											pos: position{line: 852, col: 12, offset: 26297},
											run: (*parser).callonFile359,
											expr: &seqExpr{
												pos: position{line: 852, col: 12, offset: 26297},
												exprs: []interface{}{
													&litMatcher{
														pos:        position{line: 852, col: 12, offset: 26297},
														val:        "doctype",
														ignoreCase: false,
														want:       "\"doctype\"",
													},
													&choiceExpr{
														pos: position{line: 865, col: 18, offset: 26720},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 865, col: 18, offset: 26720},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 865, col: 18, offset: 26720},
																		val:        " html",
																		ignoreCase: false,
																		want:       "\" html\"",
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 866, col: 5, offset: 26738},
																run: (*parser).callonFile374,
																expr: &seqExpr{
																	pos: position{line: 866, col: 5, offset: 26738},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 866, col: 5, offset: 26738},
																			val:        " ",
																			ignoreCase: false,
																			want:       "\" \"",
																		},
																		&labeledExpr{
																			pos:   position{line: 866, col: 9, offset: 26742},
																			label: "startPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonFile378,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 866, col: 23, offset: 26756},
																			expr: &charClassMatcher{
																				pos:        position{line: 3735, col: 12, offset: 128270},
																				val:        "[^\\r\\n]",
																				chars:      []rune{'\r', '\n'},
																				ignoreCase: false,
																				inverted:   true,
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 3734, col: 12, offset: 128237},
																			expr: &charClassMatcher{
																				pos:        position{line: 3746, col: 36, offset: 128584},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																		&choiceExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					exprs: []interface{}{
																						&zeroOrOneExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							expr: &litMatcher{
																								pos:        position{line: 3734, col: 16, offset: 128241},
																								val:        "\r",
																								ignoreCase: false,
																								want:       "\"\\r\"",
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 3734, col: 22, offset: 128247},
																							val:        "\n",
																							ignoreCase: false,
																							want:       "\"\\n\"",
																						},
																					},
																				},
																				&notExpr{
																					pos: position{line: 3733, col: 12, offset: 128223},
																					expr: &anyMatcher{
																						line: 3733, col: 13, offset: 128224,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 876, col: 9, offset: 27137},
																run: (*parser).callonFile395,
																expr: &seqExpr{
																	pos: position{line: 876, col: 9, offset: 27137},
																	exprs: []interface{}{
																		&zeroOrMoreExpr{
																			pos: position{line: 876, col: 9, offset: 27137},
																			expr: &litMatcher{
																				pos:        position{line: 876, col: 9, offset: 27137},
																				val:        " ",
																				ignoreCase: false,
																				want:       "\" \"",
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 876, col: 14, offset: 27142},
																			expr: &charClassMatcher{
																				pos:        position{line: 3735, col: 12, offset: 128270},
																				val:        "[^\\r\\n]",
																				chars:      []rune{'\r', '\n'},
																				ignoreCase: false,
																				inverted:   true,
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 3734, col: 12, offset: 128237},
																			expr: &charClassMatcher{
																				pos:        position{line: 3746, col: 36, offset: 128584},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																		&choiceExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					exprs: []interface{}{
																						&zeroOrOneExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							expr: &litMatcher{
																								pos:        position{line: 3734, col: 16, offset: 128241},
																								val:        "\r",
																								ignoreCase: false,
																								want:       "\"\\r\"",
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 3734, col: 22, offset: 128247},
																							val:        "\n",
																							ignoreCase: false,
																							want:       "\"\\n\"",
																						},
																					},
																				},
																				&notExpr{
																					pos: position{line: 3733, col: 12, offset: 128223},
																					expr: &anyMatcher{
																						line: 3733, col: 13, offset: 128224,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&actionExpr{
											pos: position{line: 854, col: 5, offset: 26374},
											run: (*parser).callonFile410,
											expr: &seqExpr{
												pos: position{line: 854, col: 5, offset: 26374},
												exprs: []interface{}{
													&litMatcher{
														pos:        position{line: 854, col: 5, offset: 26374},
														val:        "!doctype",
														ignoreCase: false,
														want:       "\"!doctype\"",
													},
													&choiceExpr{
														pos: position{line: 865, col: 18, offset: 26720},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 865, col: 18, offset: 26720},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 865, col: 18, offset: 26720},
																		val:        " html",
																		ignoreCase: false,
																		want:       "\" html\"",
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 866, col: 5, offset: 26738},
																run: (*parser).callonFile425,
																expr: &seqExpr{
																	pos: position{line: 866, col: 5, offset: 26738},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 866, col: 5, offset: 26738},
																			val:        " ",
																			ignoreCase: false,
																			want:       "\" \"",
																		},
																		&labeledExpr{
																			pos:   position{line: 866, col: 9, offset: 26742},
																			label: "startPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonFile429,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 866, col: 23, offset: 26756},
																			expr: &charClassMatcher{
																				pos:        position{line: 3735, col: 12, offset: 128270},
																				val:        "[^\\r\\n]",
																				chars:      []rune{'\r', '\n'},
																				ignoreCase: false,
																				inverted:   true,
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 3734, col: 12, offset: 128237},
																			expr: &charClassMatcher{
																				pos:        position{line: 3746, col: 36, offset: 128584},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																		&choiceExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					exprs: []interface{}{
																						&zeroOrOneExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							expr: &litMatcher{
																								pos:        position{line: 3734, col: 16, offset: 128241},
																								val:        "\r",
																								ignoreCase: false,
																								want:       "\"\\r\"",
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 3734, col: 22, offset: 128247},
																							val:        "\n",
																							ignoreCase: false,
																							want:       "\"\\n\"",
																						},
																					},
																				},
																				&notExpr{
																					pos: position{line: 3733, col: 12, offset: 128223},
																					expr: &anyMatcher{
																						line: 3733, col: 13, offset: 128224,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 876, col: 9, offset: 27137},
																run: (*parser).callonFile446,
																expr: &seqExpr{
																	pos: position{line: 876, col: 9, offset: 27137},
																	exprs: []interface{}{
																		&zeroOrMoreExpr{
																			pos: position{line: 876, col: 9, offset: 27137},
																			expr: &litMatcher{
																				pos:        position{line: 876, col: 9, offset: 27137},
																				val:        " ",
																				ignoreCase: false,
																				want:       "\" \"",
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 876, col: 14, offset: 27142},
																			expr: &charClassMatcher{
																				pos:        position{line: 3735, col: 12, offset: 128270},
																				val:        "[^\\r\\n]",
																				chars:      []rune{'\r', '\n'},
																				ignoreCase: false,
																				inverted:   true,
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 3734, col: 12, offset: 128237},
																			expr: &charClassMatcher{
																				pos:        position{line: 3746, col: 36, offset: 128584},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																		&choiceExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					exprs: []interface{}{
																						&zeroOrOneExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							expr: &litMatcher{
																								pos:        position{line: 3734, col: 16, offset: 128241},
																								val:        "\r",
																								ignoreCase: false,
																								want:       "\"\\r\"",
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 3734, col: 22, offset: 128247},
																							val:        "\n",
																							ignoreCase: false,
																							want:       "\"\\n\"",
																						},
																					},
																				},
																				&notExpr{
																					pos: position{line: 3733, col: 12, offset: 128223},
																					expr: &anyMatcher{
																						line: 3733, col: 13, offset: 128224,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 21, col: 23, offset: 509},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 22, col: 5, offset: 522},
							label: "scopeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 22, col: 12, offset: 529},
								expr: &ruleRefExpr{
									pos:  position{line: 22, col: 12, offset: 529},
									name: "Scope",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 22, col: 19, offset: 536},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&notExpr{
							pos: position{line: 3733, col: 12, offset: 128223},
							expr: &anyMatcher{
								line: 3733, col: 13, offset: 128224,
							},
						},
					},
				},
			},
		},
		{
			name: "importsAndComments",
			pos:  position{line: 68, col: 1, offset: 1902},
			expr: &actionExpr{
				pos: position{line: 68, col: 23, offset: 1924},
				run: (*parser).callonimportsAndComments1,
				expr: &labeledExpr{
					pos:   position{line: 68, col: 23, offset: 1924},
					label: "valsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 68, col: 29, offset: 1930},
						expr: &seqExpr{
							pos: position{line: 68, col: 30, offset: 1931},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 68, col: 30, offset: 1931},
									expr: &ruleRefExpr{
										pos:  position{line: 68, col: 30, offset: 1931},
										name: "CorgiComments",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 68, col: 45, offset: 1946},
									expr: &oneOrMoreExpr{
										pos: position{line: 3748, col: 36, offset: 128671},
										expr: &seqExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 3748, col: 37, offset: 128672},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3747, col: 36, offset: 128625},
													expr: &litMatcher{
														pos:        position{line: 3747, col: 36, offset: 128625},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3747, col: 42, offset: 128631},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 3202, col: 12, offset: 111174},
									run: (*parser).callonimportsAndComments15,
									expr: &labeledExpr{
										pos:   position{line: 3202, col: 12, offset: 111174},
										label: "importsI",
										expr: &oneOrMoreExpr{
											pos: position{line: 3202, col: 21, offset: 111183},
											expr: &seqExpr{
												pos: position{line: 3202, col: 22, offset: 111184},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3202, col: 22, offset: 111184},
														expr: &oneOrMoreExpr{
															pos: position{line: 3748, col: 36, offset: 128671},
															expr: &seqExpr{
																pos: position{line: 3748, col: 37, offset: 128672},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3748, col: 37, offset: 128672},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 3747, col: 36, offset: 128625},
																		expr: &litMatcher{
																			pos:        position{line: 3747, col: 36, offset: 128625},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3747, col: 42, offset: 128631},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
														},
													},
													&choiceExpr{
														pos: position{line: 3216, col: 11, offset: 111483},
														alternatives: []interface{}{
															&actionExpr{
																pos: position{line: 3216, col: 11, offset: 111483},
																run: (*parser).callonimportsAndComments28,
																expr: &seqExpr{
																	pos: position{line: 3216, col: 11, offset: 111483},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 3216, col: 11, offset: 111483},
																			val:        "import",
																			ignoreCase: false,
																			want:       "\"import\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 3216, col: 21, offset: 111493},
																			label: "specsI",
																			expr: &actionExpr{
																				pos: position{line: 3237, col: 16, offset: 112147},
																				run: (*parser).callonimportsAndComments32,
																				expr: &seqExpr{
																					pos: position{line: 3237, col: 16, offset: 112147},
																					exprs: []interface{}{
																						&stateCodeExpr{
																							pos: position{line: 4214, col: 11, offset: 148867},
																							run: (*parser).callonimportsAndComments34,
																						},
																						&labeledExpr{
																							pos:   position{line: 3237, col: 23, offset: 112154},
																							label: "importsI",
																							expr: &zeroOrMoreExpr{
																								pos: position{line: 3237, col: 32, offset: 112163},
																								expr: &seqExpr{
																									pos: position{line: 3237, col: 33, offset: 112164},
																									exprs: []interface{}{
																										&zeroOrOneExpr{
																											pos: position{line: 3237, col: 33, offset: 112164},
																											expr: &oneOrMoreExpr{
																												pos: position{line: 3748, col: 36, offset: 128671},
																												expr: &seqExpr{
																													pos: position{line: 3748, col: 37, offset: 128672},
																													exprs: []interface{}{
																														&zeroOrMoreExpr{
																															pos: position{line: 3748, col: 37, offset: 128672},
																															expr: &charClassMatcher{
																																pos:        position{line: 3746, col: 36, offset: 128584},
																																val:        "[ \\t]",
																																chars:      []rune{' ', '\t'},
																																ignoreCase: false,
																																inverted:   false,
																															},
																														},
																														&zeroOrOneExpr{
																															pos: position{line: 3747, col: 36, offset: 128625},
																															expr: &litMatcher{
																																pos:        position{line: 3747, col: 36, offset: 128625},
																																val:        "\r",
																																ignoreCase: false,
																																want:       "\"\\r\"",
																															},
																														},
																														&litMatcher{
																															pos:        position{line: 3747, col: 42, offset: 128631},
																															val:        "\n",
																															ignoreCase: false,
																															want:       "\"\\n\"",
																														},
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 3835, col: 17, offset: 132478},
																											run: (*parser).callonimportsAndComments46,
																											expr: &zeroOrMoreExpr{
																												pos: position{line: 3835, col: 17, offset: 132478},
																												expr: &charClassMatcher{
																													pos:        position{line: 3746, col: 36, offset: 128584},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&andCodeExpr{
																											pos: position{line: 3835, col: 41, offset: 132502},
																											run: (*parser).callonimportsAndComments49,
																										},
																										&choiceExpr{
																											pos: position{line: 3887, col: 5, offset: 134412},
																											alternatives: []interface{}{
																												&andCodeExpr{
																													pos: position{line: 3887, col: 5, offset: 134412},
																													run: (*parser).callonimportsAndComments51,
																												},
																												&seqExpr{
																													pos: position{line: 3889, col: 9, offset: 134495},
																													exprs: []interface{}{
																														&andCodeExpr{
																															pos: position{line: 3889, col: 9, offset: 134495},
																															run: (*parser).callonimportsAndComments53,
																														},
																														&stateCodeExpr{
																															pos: position{line: 3891, col: 7, offset: 134599},
																															run: (*parser).callonimportsAndComments54,
																														},
																													},
																												},
																												&seqExpr{
																													pos: position{line: 3898, col: 9, offset: 134935},
																													exprs: []interface{}{
																														&andCodeExpr{
																															pos: position{line: 3898, col: 9, offset: 134935},
																															run: (*parser).callonimportsAndComments56,
																														},
																														&choiceExpr{
																															pos: position{line: 3951, col: 9, offset: 137270},
																															alternatives: []interface{}{
																																&seqExpr{
																																	pos: position{line: 3951, col: 9, offset: 137270},
																																	exprs: []interface{}{
																																		&andCodeExpr{
																																			pos: position{line: 3951, col: 9, offset: 137270},
																																			run: (*parser).callonimportsAndComments59,
																																		},
																																		&andCodeExpr{
																																			pos: position{line: 3955, col: 11, offset: 137520},
																																			run: (*parser).callonimportsAndComments60,
																																		},
																																		&stateCodeExpr{
																																			pos: position{line: 4021, col: 11, offset: 140726},
																																			run: (*parser).callonimportsAndComments61,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 4029, col: 13, offset: 141079},
																																	exprs: []interface{}{
																																		&andCodeExpr{
																																			pos: position{line: 4029, col: 13, offset: 141079},
																																			run: (*parser).callonimportsAndComments63,
																																		},
																																		&andCodeExpr{
																																			pos: position{line: 4033, col: 11, offset: 141334},
																																			run: (*parser).callonimportsAndComments64,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 3241, col: 15, offset: 112292},
																											run: (*parser).callonimportsAndComments65,
																											expr: &seqExpr{
																												pos: position{line: 3241, col: 15, offset: 112292},
																												exprs: []interface{}{
																													&labeledExpr{
																														pos:   position{line: 3241, col: 15, offset: 112292},
																														label: "aliasI",
																														expr: &zeroOrOneExpr{
																															pos: position{line: 3241, col: 22, offset: 112299},
																															expr: &seqExpr{
																																pos: position{line: 3241, col: 23, offset: 112300},
																																exprs: []interface{}{
																																	&choiceExpr{
																																		pos: position{line: 3254, col: 16, offset: 112580},
																																		alternatives: []interface{}{
																																			&actionExpr{
																																				pos: position{line: 3254, col: 16, offset: 112580},
																																				run: (*parser).callonimportsAndComments71,
																																				expr: &litMatcher{
																																					pos:        position{line: 3254, col: 16, offset: 112580},
																																					val:        ".",
																																					ignoreCase: false,
																																					want:       "\".\"",
																																				},
																																			},
																																			&actionExpr{
																																				pos: position{line: 2319, col: 12, offset: 79887},
																																				run: (*parser).callonimportsAndComments73,
																																				expr: &labeledExpr{
																																					pos:   position{line: 2319, col: 12, offset: 79887},
																																					label: "ident",
																																					expr: &seqExpr{
																																						pos: position{line: 2367, col: 17, offset: 81233},
																																						exprs: []interface{}{
																																							&charClassMatcher{
																																								pos:        position{line: 2350, col: 20, offset: 80988},
																																								val:        "[_\\pL]",
																																								chars:      []rune{'_'},
																																								classes:    []*unicode.RangeTable{rangeTable("L")},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																							&zeroOrMoreExpr{
																																								pos: position{line: 2367, col: 26, offset: 81242},
																																								expr: &charClassMatcher{
																																									pos:        position{line: 2350, col: 20, offset: 80988},
																																									val:        "[_\\pL\\pNd]",
																																									chars:      []rune{'_'},
																																									classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																																									ignoreCase: false,
																																									inverted:   false,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&actionExpr{
																																				pos: position{line: 2321, col: 5, offset: 79981},
																																				run: (*parser).callonimportsAndComments79,
																																				expr: &seqExpr{
																																					pos: position{line: 2321, col: 5, offset: 79981},
																																					exprs: []interface{}{
																																						&labeledExpr{
																																							pos:   position{line: 2321, col: 5, offset: 79981},
																																							label: "identI",
																																							expr: &seqExpr{
																																								pos: position{line: 2321, col: 13, offset: 79989},
																																								exprs: []interface{}{
																																									&zeroOrOneExpr{
																																										pos: position{line: 2321, col: 13, offset: 79989},
																																										expr: &litMatcher{
																																											pos:        position{line: 2321, col: 13, offset: 79989},
																																											val:        "$",
																																											ignoreCase: false,
																																											want:       "\"$\"",
																																										},
																																									},
																																									&oneOrMoreExpr{
																																										pos: position{line: 2321, col: 18, offset: 79994},
																																										expr: &choiceExpr{
																																											pos: position{line: 2321, col: 19, offset: 79995},
																																											alternatives: []interface{}{
																																												&seqExpr{
																																													pos: position{line: 2321, col: 19, offset: 79995},
																																													exprs: []interface{}{
																																														&charClassMatcher{
																																															pos:        position{line: 2321, col: 19, offset: 79995},
																																															val:        "[\\pNd]",
																																															classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																															ignoreCase: false,
																																															inverted:   false,
																																														},
																																														&charClassMatcher{
																																															pos:        position{line: 2321, col: 28, offset: 80004},
																																															val:        "[_-\\pL]",
																																															chars:      []rune{'_', '-'},
																																															classes:    []*unicode.RangeTable{rangeTable("L")},
																																															ignoreCase: false,
																																															inverted:   false,
																																														},
																																													},
																																												},
																																												&charClassMatcher{
																																													pos:        position{line: 2321, col: 38, offset: 80014},
																																													val:        "[_-\\pL]",
																																													chars:      []rune{'_', '-'},
																																													classes:    []*unicode.RangeTable{rangeTable("L")},
																																													ignoreCase: false,
																																													inverted:   false,
																																												},
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																						&labeledExpr{
																																							pos:   position{line: 2321, col: 49, offset: 80025},
																																							label: "endPosI",
																																							expr: &actionExpr{
																																								pos: position{line: 3737, col: 8, offset: 128286},
																																								run: (*parser).callonimportsAndComments92,
																																								expr: &choiceExpr{
																																									pos: position{line: 3737, col: 9, offset: 128287},
																																									alternatives: []interface{}{
																																										&andExpr{
																																											pos: position{line: 3737, col: 9, offset: 128287},
																																											expr: &anyMatcher{
																																												line: 3737, col: 10, offset: 128288,
																																											},
																																										},
																																										&notExpr{
																																											pos: position{line: 3737, col: 14, offset: 128292},
																																											expr: &anyMatcher{
																																												line: 3737, col: 15, offset: 128293,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&actionExpr{
																																				pos: position{line: 3256, col: 15, offset: 112659},
																																				run: (*parser).callonimportsAndComments98,
																																				expr: &seqExpr{
																																					pos: position{line: 3256, col: 15, offset: 112659},
																																					exprs: []interface{}{
																																						&oneOrMoreExpr{
																																							pos: position{line: 3256, col: 15, offset: 112659},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3256, col: 15, offset: 112659},
																																								val:        "[^\"`\\ ]",
																																								chars:      []rune{'"', '`', '\'', ' '},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																						},
																																						&labeledExpr{
																																							pos:   position{line: 3256, col: 24, offset: 112668},
																																							label: "endPosI",
																																							expr: &actionExpr{
																																								pos: position{line: 3737, col: 8, offset: 128286},
																																								run: (*parser).callonimportsAndComments103,
																																								expr: &choiceExpr{
																																									pos: position{line: 3737, col: 9, offset: 128287},
																																									alternatives: []interface{}{
																																										&andExpr{
																																											pos: position{line: 3737, col: 9, offset: 128287},
																																											expr: &anyMatcher{
																																												line: 3737, col: 10, offset: 128288,
																																											},
																																										},
																																										&notExpr{
																																											pos: position{line: 3737, col: 14, offset: 128292},
																																											expr: &anyMatcher{
																																												line: 3737, col: 15, offset: 128293,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																	&oneOrMoreExpr{
																																		pos: position{line: 3241, col: 35, offset: 112312},
																																		expr: &litMatcher{
																																			pos:        position{line: 3241, col: 35, offset: 112312},
																																			val:        " ",
																																			ignoreCase: false,
																																			want:       "\" \"",
																																		},
																																	},
																																},
																															},
																														},
																													},
																													&labeledExpr{
																														pos:   position{line: 3241, col: 42, offset: 112319},
																														label: "pathI",
																														expr: &choiceExpr{
																															pos: position{line: 3178, col: 12, offset: 110324},
																															alternatives: []interface{}{
																																&actionExpr{
																																	pos: position{line: 749, col: 14, offset: 22958},
																																	run: (*parser).callonimportsAndComments113,
																																	expr: &seqExpr{
																																		pos: position{line: 749, col: 14, offset: 22958},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 749, col: 14, offset: 22958},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 749, col: 18, offset: 22962},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 749, col: 23, offset: 22967},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 2704, col: 27, offset: 94307},
																																						val:        "[^\\n`]",
																																						chars:      []rune{'\n', '`'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 749, col: 47, offset: 22991},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 751, col: 5, offset: 23083},
																																	run: (*parser).callonimportsAndComments120,
																																	expr: &seqExpr{
																																		pos: position{line: 751, col: 5, offset: 23083},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 751, col: 5, offset: 23083},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 751, col: 9, offset: 23087},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 751, col: 14, offset: 23092},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 2704, col: 27, offset: 94307},
																																						val:        "[^\\n`]",
																																						chars:      []rune{'\n', '`'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&andExpr{
																																				pos: position{line: 751, col: 38, offset: 23116},
																																				expr: &seqExpr{
																																					pos: position{line: 3734, col: 12, offset: 128237},
																																					exprs: []interface{}{
																																						&zeroOrMoreExpr{
																																							pos: position{line: 3734, col: 12, offset: 128237},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3746, col: 36, offset: 128584},
																																								val:        "[ \\t]",
																																								chars:      []rune{' ', '\t'},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																						},
																																						&choiceExpr{
																																							pos: position{line: 3734, col: 16, offset: 128241},
																																							alternatives: []interface{}{
																																								&seqExpr{
																																									pos: position{line: 3734, col: 16, offset: 128241},
																																									exprs: []interface{}{
																																										&zeroOrOneExpr{
																																											pos: position{line: 3734, col: 16, offset: 128241},
																																											expr: &litMatcher{
																																												pos:        position{line: 3734, col: 16, offset: 128241},
																																												val:        "\r",
																																												ignoreCase: false,
																																												want:       "\"\\r\"",
																																											},
																																										},
																																										&litMatcher{
																																											pos:        position{line: 3734, col: 22, offset: 128247},
																																											val:        "\n",
																																											ignoreCase: false,
																																											want:       "\"\\n\"",
																																										},
																																									},
																																								},
																																								&notExpr{
																																									pos: position{line: 3733, col: 12, offset: 128223},
																																									expr: &anyMatcher{
																																										line: 3733, col: 13, offset: 128224,
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 770, col: 22, offset: 23520},
																																	run: (*parser).callonimportsAndComments137,
																																	expr: &seqExpr{
																																		pos: position{line: 770, col: 22, offset: 23520},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 770, col: 22, offset: 23520},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 770, col: 26, offset: 23524},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 770, col: 31, offset: 23529},
																																					expr: &choiceExpr{
																																						pos: position{line: 770, col: 32, offset: 23530},
																																						alternatives: []interface{}{
																																							&seqExpr{
																																								pos: position{line: 2443, col: 24, offset: 83970},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2443, col: 24, offset: 83970},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2444, col: 24, offset: 84037},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2444, col: 24, offset: 84037},
																																										val:        "\\x",
																																										ignoreCase: false,
																																										want:       "\"\\\\x\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2445, col: 5, offset: 84074},
																																								run: (*parser).callonimportsAndComments152,
																																								expr: &seqExpr{
																																									pos: position{line: 2445, col: 5, offset: 84074},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2445, col: 5, offset: 84074},
																																											val:        "\\x",
																																											ignoreCase: false,
																																											want:       "\"\\\\x\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2445, col: 14, offset: 84083},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2445, col: 26, offset: 84095},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2462, col: 19, offset: 84712},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2462, col: 19, offset: 84712},
																																										val:        "\\u",
																																										ignoreCase: false,
																																										want:       "\"\\\\u\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2463, col: 5, offset: 84771},
																																								run: (*parser).callonimportsAndComments165,
																																								expr: &seqExpr{
																																									pos: position{line: 2463, col: 5, offset: 84771},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2463, col: 5, offset: 84771},
																																											val:        "\\u",
																																											ignoreCase: false,
																																											want:       "\"\\\\u\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 14, offset: 84780},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 26, offset: 84792},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 38, offset: 84804},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 50, offset: 84816},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2492, col: 16, offset: 85952},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2492, col: 16, offset: 85952},
																																										val:        "\\U",
																																										ignoreCase: false,
																																										want:       "\"\\\\U\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2493, col: 5, offset: 86055},
																																								run: (*parser).callonimportsAndComments186,
																																								expr: &seqExpr{
																																									pos: position{line: 2493, col: 5, offset: 86055},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2493, col: 5, offset: 86055},
																																											val:        "\\U",
																																											ignoreCase: false,
																																											want:       "\"\\\\U\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 14, offset: 86064},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 26, offset: 86076},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 38, offset: 86088},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 50, offset: 86100},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 62, offset: 86112},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 74, offset: 86124},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 86, offset: 86136},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 98, offset: 86148},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2720, col: 36, offset: 95085},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2720, col: 36, offset: 95085},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2720, col: 41, offset: 95090},
																																										val:        "[abfnrtv\\\\\"]",
																																										chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&charClassMatcher{
																																								pos:        position{line: 2718, col: 38, offset: 94977},
																																								val:        "[^\"\\\\\\n]",
																																								chars:      []rune{'"', '\\', '\n'},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																							&actionExpr{
																																								pos: position{line: 2607, col: 37, offset: 90735},
																																								run: (*parser).callonimportsAndComments209,
																																								expr: &seqExpr{
																																									pos: position{line: 2607, col: 37, offset: 90735},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2607, col: 37, offset: 90735},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2631, col: 5, offset: 91752},
																																								run: (*parser).callonimportsAndComments220,
																																								expr: &seqExpr{
																																									pos: position{line: 2631, col: 5, offset: 91752},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2631, col: 5, offset: 91752},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2652, col: 5, offset: 92594},
																																								run: (*parser).callonimportsAndComments227,
																																								expr: &seqExpr{
																																									pos: position{line: 2652, col: 5, offset: 92594},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2652, col: 5, offset: 92594},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2670, col: 5, offset: 93280},
																																								run: (*parser).callonimportsAndComments232,
																																								expr: &seqExpr{
																																									pos: position{line: 2670, col: 5, offset: 93280},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2670, col: 5, offset: 93280},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2670, col: 10, offset: 93285},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 3735, col: 12, offset: 128270},
																																												val:        "[^\\r\\n]",
																																												chars:      []rune{'\r', '\n'},
																																												ignoreCase: false,
																																												inverted:   true,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 770, col: 115, offset: 23613},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 772, col: 5, offset: 23705},
																																	run: (*parser).callonimportsAndComments238,
																																	expr: &seqExpr{
																																		pos: position{line: 772, col: 5, offset: 23705},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 772, col: 5, offset: 23705},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 772, col: 9, offset: 23709},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 772, col: 14, offset: 23714},
																																					expr: &choiceExpr{
																																						pos: position{line: 772, col: 15, offset: 23715},
																																						alternatives: []interface{}{
																																							&seqExpr{
																																								pos: position{line: 2443, col: 24, offset: 83970},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2443, col: 24, offset: 83970},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2444, col: 24, offset: 84037},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2444, col: 24, offset: 84037},
																																										val:        "\\x",
																																										ignoreCase: false,
																																										want:       "\"\\\\x\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2445, col: 5, offset: 84074},
																																								run: (*parser).callonimportsAndComments253,
																																								expr: &seqExpr{
																																									pos: position{line: 2445, col: 5, offset: 84074},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2445, col: 5, offset: 84074},
																																											val:        "\\x",
																																											ignoreCase: false,
																																											want:       "\"\\\\x\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2445, col: 14, offset: 84083},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2445, col: 26, offset: 84095},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2462, col: 19, offset: 84712},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2462, col: 19, offset: 84712},
																																										val:        "\\u",
																																										ignoreCase: false,
																																										want:       "\"\\\\u\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2463, col: 5, offset: 84771},
																																								run: (*parser).callonimportsAndComments266,
																																								expr: &seqExpr{
																																									pos: position{line: 2463, col: 5, offset: 84771},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2463, col: 5, offset: 84771},
																																											val:        "\\u",
																																											ignoreCase: false,
																																											want:       "\"\\\\u\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 14, offset: 84780},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 26, offset: 84792},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 38, offset: 84804},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 50, offset: 84816},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2492, col: 16, offset: 85952},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2492, col: 16, offset: 85952},
																																										val:        "\\U",
																																										ignoreCase: false,
																																										want:       "\"\\\\U\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2493, col: 5, offset: 86055},
																																								run: (*parser).callonimportsAndComments287,
																																								expr: &seqExpr{
																																									pos: position{line: 2493, col: 5, offset: 86055},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2493, col: 5, offset: 86055},
																																											val:        "\\U",
																																											ignoreCase: false,
																																											want:       "\"\\\\U\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 14, offset: 86064},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 26, offset: 86076},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 38, offset: 86088},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 50, offset: 86100},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 62, offset: 86112},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 74, offset: 86124},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 86, offset: 86136},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 98, offset: 86148},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2720, col: 36, offset: 95085},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2720, col: 36, offset: 95085},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2720, col: 41, offset: 95090},
																																										val:        "[abfnrtv\\\\\"]",
																																										chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&charClassMatcher{
																																								pos:        position{line: 2718, col: 38, offset: 94977},
																																								val:        "[^\"\\\\\\n]",
																																								chars:      []rune{'"', '\\', '\n'},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																							&actionExpr{
																																								pos: position{line: 2607, col: 37, offset: 90735},
																																								run: (*parser).callonimportsAndComments310,
																																								expr: &seqExpr{
																																									pos: position{line: 2607, col: 37, offset: 90735},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2607, col: 37, offset: 90735},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2631, col: 5, offset: 91752},
																																								run: (*parser).callonimportsAndComments321,
																																								expr: &seqExpr{
																																									pos: position{line: 2631, col: 5, offset: 91752},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2631, col: 5, offset: 91752},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2652, col: 5, offset: 92594},
																																								run: (*parser).callonimportsAndComments328,
																																								expr: &seqExpr{
																																									pos: position{line: 2652, col: 5, offset: 92594},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2652, col: 5, offset: 92594},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2670, col: 5, offset: 93280},
																																								run: (*parser).callonimportsAndComments333,
																																								expr: &seqExpr{
																																									pos: position{line: 2670, col: 5, offset: 93280},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2670, col: 5, offset: 93280},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2670, col: 10, offset: 93285},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 3735, col: 12, offset: 128270},
																																												val:        "[^\\r\\n]",
																																												chars:      []rune{'\r', '\n'},
																																												ignoreCase: false,
																																												inverted:   true,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 772, col: 98, offset: 23798},
																																				label: "endPosI",
																																				expr: &actionExpr{
																																					pos: position{line: 3737, col: 8, offset: 128286},
																																					run: (*parser).callonimportsAndComments339,
																																					expr: &choiceExpr{
																																						pos: position{line: 3737, col: 9, offset: 128287},
																																						alternatives: []interface{}{
																																							&andExpr{
																																								pos: position{line: 3737, col: 9, offset: 128287},
																																								expr: &anyMatcher{
																																									line: 3737, col: 10, offset: 128288,
																																								},
																																							},
																																							&notExpr{
																																								pos: position{line: 3737, col: 14, offset: 128292},
																																								expr: &anyMatcher{
																																									line: 3737, col: 15, offset: 128293,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&andExpr{
																																				pos: position{line: 772, col: 110, offset: 23810},
																																				expr: &seqExpr{
																																					pos: position{line: 3734, col: 12, offset: 128237},
																																					exprs: []interface{}{
																																						&zeroOrMoreExpr{
																																							pos: position{line: 3734, col: 12, offset: 128237},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3746, col: 36, offset: 128584},
																																								val:        "[ \\t]",
																																								chars:      []rune{' ', '\t'},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																						},
																																						&choiceExpr{
																																							pos: position{line: 3734, col: 16, offset: 128241},
																																							alternatives: []interface{}{
																																								&seqExpr{
																																									pos: position{line: 3734, col: 16, offset: 128241},
																																									exprs: []interface{}{
																																										&zeroOrOneExpr{
																																											pos: position{line: 3734, col: 16, offset: 128241},
																																											expr: &litMatcher{
																																												pos:        position{line: 3734, col: 16, offset: 128241},
																																												val:        "\r",
																																												ignoreCase: false,
																																												want:       "\"\\r\"",
																																											},
																																										},
																																										&litMatcher{
																																											pos:        position{line: 3734, col: 22, offset: 128247},
																																											val:        "\n",
																																											ignoreCase: false,
																																											want:       "\"\\n\"",
																																										},
																																									},
																																								},
																																								&notExpr{
																																									pos: position{line: 3733, col: 12, offset: 128223},
																																									expr: &anyMatcher{
																																										line: 3733, col: 13, offset: 128224,
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 791, col: 22, offset: 24216},
																																	run: (*parser).callonimportsAndComments356,
																																	expr: &seqExpr{
																																		pos: position{line: 791, col: 22, offset: 24216},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 791, col: 22, offset: 24216},
																																				val:        "'",
																																				ignoreCase: false,
																																				want:       "\"'\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 791, col: 27, offset: 24221},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 791, col: 32, offset: 24226},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 791, col: 32, offset: 24226},
																																						val:        "[^\\\\r\\n]",
																																						chars:      []rune{'\'', '\r', '\n'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 791, col: 42, offset: 24236},
																																				val:        "'",
																																				ignoreCase: false,
																																				want:       "\"'\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 791, col: 47, offset: 24241},
																																				label: "endPosI",
																																				expr: &actionExpr{
																																					pos: position{line: 3737, col: 8, offset: 128286},
																																					run: (*parser).callonimportsAndComments364,
																																					expr: &choiceExpr{
																																						pos: position{line: 3737, col: 9, offset: 128287},
																																						alternatives: []interface{}{
																																							&andExpr{
																																								pos: position{line: 3737, col: 9, offset: 128287},
																																								expr: &anyMatcher{
																																									line: 3737, col: 10, offset: 128288,
																																								},
																																							},
																																							&notExpr{
																																								pos: position{line: 3737, col: 14, offset: 128292},
																																								expr: &anyMatcher{
																																									line: 3737, col: 15, offset: 128293,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 3178, col: 21, offset: 110333},
																																	run: (*parser).callonimportsAndComments370,
																																	expr: &labeledExpr{
																																		pos:   position{line: 3178, col: 21, offset: 110333},
																																		label: "pathI",
																																		expr: &zeroOrMoreExpr{
																																			pos: position{line: 3178, col: 27, offset: 110339},
																																			expr: &charClassMatcher{
																																				pos:        position{line: 3735, col: 12, offset: 128270},
																																				val:        "[^\\r\\n]",
																																				chars:      []rune{'\r', '\n'},
																																				ignoreCase: false,
																																				inverted:   true,
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																													&zeroOrMoreExpr{
																														pos: position{line: 3734, col: 12, offset: 128237},
																														expr: &charClassMatcher{
																															pos:        position{line: 3746, col: 36, offset: 128584},
																															val:        "[ \\t]",
																															chars:      []rune{' ', '\t'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&choiceExpr{
																														pos: position{line: 3734, col: 16, offset: 128241},
																														alternatives: []interface{}{
																															&seqExpr{
																																pos: position{line: 3734, col: 16, offset: 128241},
																																exprs: []interface{}{
																																	&zeroOrOneExpr{
																																		pos: position{line: 3734, col: 16, offset: 128241},
																																		expr: &litMatcher{
																																			pos:        position{line: 3734, col: 16, offset: 128241},
																																			val:        "\r",
																																			ignoreCase: false,
																																			want:       "\"\\r\"",
																																		},
																																	},
																																	&litMatcher{
																																		pos:        position{line: 3734, col: 22, offset: 128247},
																																		val:        "\n",
																																		ignoreCase: false,
																																		want:       "\"\\n\"",
																																	},
																																},
																															},
																															&notExpr{
																																pos: position{line: 3733, col: 12, offset: 128223},
																																expr: &anyMatcher{
																																	line: 3733, col: 13, offset: 128224,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&stateCodeExpr{
																							pos: position{line: 4219, col: 11, offset: 148972},
																							run: (*parser).callonimportsAndComments383,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 3221, col: 5, offset: 111624},
																run: (*parser).callonimportsAndComments384,
																expr: &seqExpr{
																	pos: position{line: 3221, col: 5, offset: 111624},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 3221, col: 5, offset: 111624},
																			val:        "import",
																			ignoreCase: false,
																			want:       "\"import\"",
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 3221, col: 14, offset: 111633},
																			expr: &litMatcher{
																				pos:        position{line: 3221, col: 14, offset: 111633},
																				val:        " ",
																				ignoreCase: false,
																				want:       "\" \"",
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 3221, col: 19, offset: 111638},
																			label: "specI",
																			expr: &actionExpr{
																				pos: position{line: 3241, col: 15, offset: 112292},
																				run: (*parser).callonimportsAndComments390,
																				expr: &seqExpr{
																					pos: position{line: 3241, col: 15, offset: 112292},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 3241, col: 15, offset: 112292},
																							label: "aliasI",
																							expr: &zeroOrOneExpr{
																								pos: position{line: 3241, col: 22, offset: 112299},
																								expr: &seqExpr{
																									pos: position{line: 3241, col: 23, offset: 112300},
																									exprs: []interface{}{
																										&choiceExpr{
																											pos: position{line: 3254, col: 16, offset: 112580},
																											alternatives: []interface{}{
																												&actionExpr{
																													pos: position{line: 3254, col: 16, offset: 112580},
																													run: (*parser).callonimportsAndComments396,
																													expr: &litMatcher{
																														pos:        position{line: 3254, col: 16, offset: 112580},
																														val:        ".",
																														ignoreCase: false,
																														want:       "\".\"",
																													},
																												},
																												&actionExpr{
																													pos: position{line: 2319, col: 12, offset: 79887},
																													run: (*parser).callonimportsAndComments398,
																													expr: &labeledExpr{
																														pos:   position{line: 2319, col: 12, offset: 79887},
																														label: "ident",
																														expr: &seqExpr{
																															pos: position{line: 2367, col: 17, offset: 81233},
																															exprs: []interface{}{
																																&charClassMatcher{
																																	pos:        position{line: 2350, col: 20, offset: 80988},
																																	val:        "[_\\pL]",
																																	chars:      []rune{'_'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																																&zeroOrMoreExpr{
																																	pos: position{line: 2367, col: 26, offset: 81242},
																																	expr: &charClassMatcher{
																																		pos:        position{line: 2350, col: 20, offset: 80988},
																																		val:        "[_\\pL\\pNd]",
																																		chars:      []rune{'_'},
																																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																																		ignoreCase: false,
																																		inverted:   false,
																																	},
																																},
																															},
																														},
																													},
																												},
																												&actionExpr{
																													pos: position{line: 2321, col: 5, offset: 79981},
																													run: (*parser).callonimportsAndComments404,
																													expr: &seqExpr{
																														pos: position{line: 2321, col: 5, offset: 79981},
																														exprs: []interface{}{
																															&labeledExpr{
																																pos:   position{line: 2321, col: 5, offset: 79981},
																																label: "identI",
																																expr: &seqExpr{
																																	pos: position{line: 2321, col: 13, offset: 79989},
																																	exprs: []interface{}{
																																		&zeroOrOneExpr{
																																			pos: position{line: 2321, col: 13, offset: 79989},
																																			expr: &litMatcher{
																																				pos:        position{line: 2321, col: 13, offset: 79989},
																																				val:        "$",
																																				ignoreCase: false,
																																				want:       "\"$\"",
																																			},
																																		},
																																		&oneOrMoreExpr{
																																			pos: position{line: 2321, col: 18, offset: 79994},
																																			expr: &choiceExpr{
																																				pos: position{line: 2321, col: 19, offset: 79995},
																																				alternatives: []interface{}{
																																					&seqExpr{
																																						pos: position{line: 2321, col: 19, offset: 79995},
																																						exprs: []interface{}{
																																							&charClassMatcher{
																																								pos:        position{line: 2321, col: 19, offset: 79995},
																																								val:        "[\\pNd]",
																																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																							&charClassMatcher{
																																								pos:        position{line: 2321, col: 28, offset: 80004},
																																								val:        "[_-\\pL]",
																																								chars:      []rune{'_', '-'},
																																								classes:    []*unicode.RangeTable{rangeTable("L")},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																						},
																																					},
																																					&charClassMatcher{
																																						pos:        position{line: 2321, col: 38, offset: 80014},
																																						val:        "[_-\\pL]",
																																						chars:      []rune{'_', '-'},
																																						classes:    []*unicode.RangeTable{rangeTable("L")},
																																						ignoreCase: false,
																																						inverted:   false,
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																															&labeledExpr{
																																pos:   position{line: 2321, col: 49, offset: 80025},
																																label: "endPosI",
																																expr: &actionExpr{
																																	pos: position{line: 3737, col: 8, offset: 128286},
																																	run: (*parser).callonimportsAndComments417,
																																	expr: &choiceExpr{
																																		pos: position{line: 3737, col: 9, offset: 128287},
																																		alternatives: []interface{}{
																																			&andExpr{
																																				pos: position{line: 3737, col: 9, offset: 128287},
																																				expr: &anyMatcher{
																																					line: 3737, col: 10, offset: 128288,
																																				},
																																			},
																																			&notExpr{
																																				pos: position{line: 3737, col: 14, offset: 128292},
																																				expr: &anyMatcher{
																																					line: 3737, col: 15, offset: 128293,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																												&actionExpr{
																													pos: position{line: 3256, col: 15, offset: 112659},
																													run: (*parser).callonimportsAndComments423,
																													expr: &seqExpr{
																														pos: position{line: 3256, col: 15, offset: 112659},
																														exprs: []interface{}{
																															&oneOrMoreExpr{
																																pos: position{line: 3256, col: 15, offset: 112659},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3256, col: 15, offset: 112659},
																																	val:        "[^\"`\\ ]",
																																	chars:      []rune{'"', '`', '\'', ' '},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																															},
																															&labeledExpr{
																																pos:   position{line: 3256, col: 24, offset: 112668},
																																label: "endPosI",
																																expr: &actionExpr{
																																	pos: position{line: 3737, col: 8, offset: 128286},
																																	run: (*parser).callonimportsAndComments428,
																																	expr: &choiceExpr{
																																		pos: position{line: 3737, col: 9, offset: 128287},
																																		alternatives: []interface{}{
																																			&andExpr{
																																				pos: position{line: 3737, col: 9, offset: 128287},
																																				expr: &anyMatcher{
																																					line: 3737, col: 10, offset: 128288,
																																				},
																																			},
																																			&notExpr{
																																				pos: position{line: 3737, col: 14, offset: 128292},
																																				expr: &anyMatcher{
																																					line: 3737, col: 15, offset: 128293,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&oneOrMoreExpr{
																											pos: position{line: 3241, col: 35, offset: 112312},
																											expr: &litMatcher{
																												pos:        position{line: 3241, col: 35, offset: 112312},
																												val:        " ",
																												ignoreCase: false,
																												want:       "\" \"",
																											},
																										},
																									},
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 3241, col: 42, offset: 112319},
																							label: "pathI",
																							expr: &choiceExpr{
																								pos: position{line: 3178, col: 12, offset: 110324},
																								alternatives: []interface{}{
																									&actionExpr{
																										pos: position{line: 749, col: 14, offset: 22958},
																										run: (*parser).callonimportsAndComments438,
																										expr: &seqExpr{
																											pos: position{line: 749, col: 14, offset: 22958},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 749, col: 14, offset: 22958},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 749, col: 18, offset: 22962},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 749, col: 23, offset: 22967},
																														expr: &charClassMatcher{
																															pos:        position{line: 2704, col: 27, offset: 94307},
																															val:        "[^\\n`]",
																															chars:      []rune{'\n', '`'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 749, col: 47, offset: 22991},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 751, col: 5, offset: 23083},
																										run: (*parser).callonimportsAndComments445,
																										expr: &seqExpr{
																											pos: position{line: 751, col: 5, offset: 23083},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 751, col: 5, offset: 23083},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 751, col: 9, offset: 23087},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 751, col: 14, offset: 23092},
																														expr: &charClassMatcher{
																															pos:        position{line: 2704, col: 27, offset: 94307},
																															val:        "[^\\n`]",
																															chars:      []rune{'\n', '`'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&andExpr{
																													pos: position{line: 751, col: 38, offset: 23116},
																													expr: &seqExpr{
																														pos: position{line: 3734, col: 12, offset: 128237},
																														exprs: []interface{}{
																															&zeroOrMoreExpr{
																																pos: position{line: 3734, col: 12, offset: 128237},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3746, col: 36, offset: 128584},
																																	val:        "[ \\t]",
																																	chars:      []rune{' ', '\t'},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																															&choiceExpr{
																																pos: position{line: 3734, col: 16, offset: 128241},
																																alternatives: []interface{}{
																																	&seqExpr{
																																		pos: position{line: 3734, col: 16, offset: 128241},
																																		exprs: []interface{}{
																																			&zeroOrOneExpr{
																																				pos: position{line: 3734, col: 16, offset: 128241},
																																				expr: &litMatcher{
																																					pos:        position{line: 3734, col: 16, offset: 128241},
																																					val:        "\r",
																																					ignoreCase: false,
																																					want:       "\"\\r\"",
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 3734, col: 22, offset: 128247},
																																				val:        "\n",
																																				ignoreCase: false,
																																				want:       "\"\\n\"",
																																			},
																																		},
																																	},
																																	&notExpr{
																																		pos: position{line: 3733, col: 12, offset: 128223},
																																		expr: &anyMatcher{
																																			line: 3733, col: 13, offset: 128224,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 770, col: 22, offset: 23520},
																										run: (*parser).callonimportsAndComments462,
																										expr: &seqExpr{
																											pos: position{line: 770, col: 22, offset: 23520},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 770, col: 22, offset: 23520},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 770, col: 26, offset: 23524},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 770, col: 31, offset: 23529},
																														expr: &choiceExpr{
																															pos: position{line: 770, col: 32, offset: 23530},
																															alternatives: []interface{}{
																																&seqExpr{
																																	pos: position{line: 2443, col: 24, offset: 83970},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2443, col: 24, offset: 83970},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2444, col: 24, offset: 84037},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2444, col: 24, offset: 84037},
																																			val:        "\\x",
																																			ignoreCase: false,
																																			want:       "\"\\\\x\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2445, col: 5, offset: 84074},
																																	run: (*parser).callonimportsAndComments477,
																																	expr: &seqExpr{
																																		pos: position{line: 2445, col: 5, offset: 84074},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2445, col: 5, offset: 84074},
																																				val:        "\\x",
																																				ignoreCase: false,
																																				want:       "\"\\\\x\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2445, col: 14, offset: 84083},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2445, col: 26, offset: 84095},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2462, col: 19, offset: 84712},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2462, col: 19, offset: 84712},
																																			val:        "\\u",
																																			ignoreCase: false,
																																			want:       "\"\\\\u\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2463, col: 5, offset: 84771},
																																	run: (*parser).callonimportsAndComments490,
																																	expr: &seqExpr{
																																		pos: position{line: 2463, col: 5, offset: 84771},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2463, col: 5, offset: 84771},
																																				val:        "\\u",
																																				ignoreCase: false,
																																				want:       "\"\\\\u\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 14, offset: 84780},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 26, offset: 84792},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 38, offset: 84804},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 50, offset: 84816},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2492, col: 16, offset: 85952},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2492, col: 16, offset: 85952},
																																			val:        "\\U",
																																			ignoreCase: false,
																																			want:       "\"\\\\U\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2493, col: 5, offset: 86055},
																																	run: (*parser).callonimportsAndComments511,
																																	expr: &seqExpr{
																																		pos: position{line: 2493, col: 5, offset: 86055},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2493, col: 5, offset: 86055},
																																				val:        "\\U",
																																				ignoreCase: false,
																																				want:       "\"\\\\U\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 14, offset: 86064},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 26, offset: 86076},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 38, offset: 86088},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 50, offset: 86100},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 62, offset: 86112},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 74, offset: 86124},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 86, offset: 86136},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 98, offset: 86148},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2720, col: 36, offset: 95085},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2720, col: 36, offset: 95085},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2720, col: 41, offset: 95090},
																																			val:        "[abfnrtv\\\\\"]",
																																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 2718, col: 38, offset: 94977},
																																	val:        "[^\"\\\\\\n]",
																																	chars:      []rune{'"', '\\', '\n'},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																																&actionExpr{
																																	pos: position{line: 2607, col: 37, offset: 90735},
																																	run: (*parser).callonimportsAndComments534,
																																	expr: &seqExpr{
																																		pos: position{line: 2607, col: 37, offset: 90735},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2607, col: 37, offset: 90735},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2631, col: 5, offset: 91752},
																																	run: (*parser).callonimportsAndComments545,
																																	expr: &seqExpr{
																																		pos: position{line: 2631, col: 5, offset: 91752},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2631, col: 5, offset: 91752},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2652, col: 5, offset: 92594},
																																	run: (*parser).callonimportsAndComments552,
																																	expr: &seqExpr{
																																		pos: position{line: 2652, col: 5, offset: 92594},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2652, col: 5, offset: 92594},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2670, col: 5, offset: 93280},
																																	run: (*parser).callonimportsAndComments557,
																																	expr: &seqExpr{
																																		pos: position{line: 2670, col: 5, offset: 93280},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2670, col: 5, offset: 93280},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2670, col: 10, offset: 93285},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 3735, col: 12, offset: 128270},
																																					val:        "[^\\r\\n]",
																																					chars:      []rune{'\r', '\n'},
																																					ignoreCase: false,
																																					inverted:   true,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 770, col: 115, offset: 23613},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 772, col: 5, offset: 23705},
																										run: (*parser).callonimportsAndComments563,
																										expr: &seqExpr{
																											pos: position{line: 772, col: 5, offset: 23705},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 772, col: 5, offset: 23705},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 772, col: 9, offset: 23709},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 772, col: 14, offset: 23714},
																														expr: &choiceExpr{
																															pos: position{line: 772, col: 15, offset: 23715},
																															alternatives: []interface{}{
																																&seqExpr{
																																	pos: position{line: 2443, col: 24, offset: 83970},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2443, col: 24, offset: 83970},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2444, col: 24, offset: 84037},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2444, col: 24, offset: 84037},
																																			val:        "\\x",
																																			ignoreCase: false,
																																			want:       "\"\\\\x\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2445, col: 5, offset: 84074},
																																	run: (*parser).callonimportsAndComments578,
																																	expr: &seqExpr{
																																		pos: position{line: 2445, col: 5, offset: 84074},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2445, col: 5, offset: 84074},
																																				val:        "\\x",
																																				ignoreCase: false,
																																				want:       "\"\\\\x\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2445, col: 14, offset: 84083},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2445, col: 26, offset: 84095},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2462, col: 19, offset: 84712},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2462, col: 19, offset: 84712},
																																			val:        "\\u",
																																			ignoreCase: false,
																																			want:       "\"\\\\u\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2463, col: 5, offset: 84771},
																																	run: (*parser).callonimportsAndComments591,
																																	expr: &seqExpr{
																																		pos: position{line: 2463, col: 5, offset: 84771},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2463, col: 5, offset: 84771},
																																				val:        "\\u",
																																				ignoreCase: false,
																																				want:       "\"\\\\u\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 14, offset: 84780},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 26, offset: 84792},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 38, offset: 84804},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 50, offset: 84816},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2492, col: 16, offset: 85952},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2492, col: 16, offset: 85952},
																																			val:        "\\U",
																																			ignoreCase: false,
																																			want:       "\"\\\\U\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2493, col: 5, offset: 86055},
																																	run: (*parser).callonimportsAndComments612,
																																	expr: &seqExpr{
																																		pos: position{line: 2493, col: 5, offset: 86055},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2493, col: 5, offset: 86055},
																																				val:        "\\U",
																																				ignoreCase: false,
																																				want:       "\"\\\\U\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 14, offset: 86064},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 26, offset: 86076},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 38, offset: 86088},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 50, offset: 86100},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 62, offset: 86112},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 74, offset: 86124},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 86, offset: 86136},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 98, offset: 86148},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2720, col: 36, offset: 95085},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2720, col: 36, offset: 95085},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2720, col: 41, offset: 95090},
																																			val:        "[abfnrtv\\\\\"]",
																																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 2718, col: 38, offset: 94977},
																																	val:        "[^\"\\\\\\n]",
																																	chars:      []rune{'"', '\\', '\n'},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																																&actionExpr{
																																	pos: position{line: 2607, col: 37, offset: 90735},
																																	run: (*parser).callonimportsAndComments635,
																																	expr: &seqExpr{
																																		pos: position{line: 2607, col: 37, offset: 90735},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2607, col: 37, offset: 90735},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2631, col: 5, offset: 91752},
																																	run: (*parser).callonimportsAndComments646,
																																	expr: &seqExpr{
																																		pos: position{line: 2631, col: 5, offset: 91752},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2631, col: 5, offset: 91752},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2652, col: 5, offset: 92594},
																																	run: (*parser).callonimportsAndComments653,
																																	expr: &seqExpr{
																																		pos: position{line: 2652, col: 5, offset: 92594},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2652, col: 5, offset: 92594},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2670, col: 5, offset: 93280},
																																	run: (*parser).callonimportsAndComments658,
																																	expr: &seqExpr{
																																		pos: position{line: 2670, col: 5, offset: 93280},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2670, col: 5, offset: 93280},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2670, col: 10, offset: 93285},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 3735, col: 12, offset: 128270},
																																					val:        "[^\\r\\n]",
																																					chars:      []rune{'\r', '\n'},
																																					ignoreCase: false,
																																					inverted:   true,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																												&labeledExpr{
																													pos:   position{line: 772, col: 98, offset: 23798},
																													label: "endPosI",
																													expr: &actionExpr{
																														pos: position{line: 3737, col: 8, offset: 128286},
																														run: (*parser).callonimportsAndComments664,
																														expr: &choiceExpr{
																															pos: position{line: 3737, col: 9, offset: 128287},
																															alternatives: []interface{}{
																																&andExpr{
																																	pos: position{line: 3737, col: 9, offset: 128287},
																																	expr: &anyMatcher{
																																		line: 3737, col: 10, offset: 128288,
																																	},
																																},
																																&notExpr{
																																	pos: position{line: 3737, col: 14, offset: 128292},
																																	expr: &anyMatcher{
																																		line: 3737, col: 15, offset: 128293,
																																	},
																																},
																															},
																														},
																													},
																												},
																												&andExpr{
																													pos: position{line: 772, col: 110, offset: 23810},
																													expr: &seqExpr{
																														pos: position{line: 3734, col: 12, offset: 128237},
																														exprs: []interface{}{
																															&zeroOrMoreExpr{
																																pos: position{line: 3734, col: 12, offset: 128237},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3746, col: 36, offset: 128584},
																																	val:        "[ \\t]",
																																	chars:      []rune{' ', '\t'},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																															&choiceExpr{
																																pos: position{line: 3734, col: 16, offset: 128241},
																																alternatives: []interface{}{
																																	&seqExpr{
																																		pos: position{line: 3734, col: 16, offset: 128241},
																																		exprs: []interface{}{
																																			&zeroOrOneExpr{
																																				pos: position{line: 3734, col: 16, offset: 128241},
																																				expr: &litMatcher{
																																					pos:        position{line: 3734, col: 16, offset: 128241},
																																					val:        "\r",
																																					ignoreCase: false,
																																					want:       "\"\\r\"",
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 3734, col: 22, offset: 128247},
																																				val:        "\n",
																																				ignoreCase: false,
																																				want:       "\"\\n\"",
																																			},
																																		},
																																	},
																																	&notExpr{
																																		pos: position{line: 3733, col: 12, offset: 128223},
																																		expr: &anyMatcher{
																																			line: 3733, col: 13, offset: 128224,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 791, col: 22, offset: 24216},
																										run: (*parser).callonimportsAndComments681,
																										expr: &seqExpr{
																											pos: position{line: 791, col: 22, offset: 24216},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 791, col: 22, offset: 24216},
																													val:        "'",
																													ignoreCase: false,
																													want:       "\"'\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 791, col: 27, offset: 24221},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 791, col: 32, offset: 24226},
																														expr: &charClassMatcher{
																															pos:        position{line: 791, col: 32, offset: 24226},
																															val:        "[^\\\\r\\n]",
																															chars:      []rune{'\'', '\r', '\n'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 791, col: 42, offset: 24236},
																													val:        "'",
																													ignoreCase: false,
																													want:       "\"'\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 791, col: 47, offset: 24241},
																													label: "endPosI",
																													expr: &actionExpr{
																														pos: position{line: 3737, col: 8, offset: 128286},
																														run: (*parser).callonimportsAndComments689,
																														expr: &choiceExpr{
																															pos: position{line: 3737, col: 9, offset: 128287},
																															alternatives: []interface{}{
																																&andExpr{
																																	pos: position{line: 3737, col: 9, offset: 128287},
																																	expr: &anyMatcher{
																																		line: 3737, col: 10, offset: 128288,
																																	},
																																},
																																&notExpr{
																																	pos: position{line: 3737, col: 14, offset: 128292},
																																	expr: &anyMatcher{
																																		line: 3737, col: 15, offset: 128293,
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 3178, col: 21, offset: 110333},
																										run: (*parser).callonimportsAndComments695,
																										expr: &labeledExpr{
																											pos:   position{line: 3178, col: 21, offset: 110333},
																											label: "pathI",
																											expr: &zeroOrMoreExpr{
																												pos: position{line: 3178, col: 27, offset: 110339},
																												expr: &charClassMatcher{
																													pos:        position{line: 3735, col: 12, offset: 128270},
																													val:        "[^\\r\\n]",
																													chars:      []rune{'\r', '\n'},
																													ignoreCase: false,
																													inverted:   true,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&zeroOrMoreExpr{
																							pos: position{line: 3734, col: 12, offset: 128237},
																							expr: &charClassMatcher{
																								pos:        position{line: 3746, col: 36, offset: 128584},
																								val:        "[ \\t]",
																								chars:      []rune{' ', '\t'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&choiceExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							alternatives: []interface{}{
																								&seqExpr{
																									pos: position{line: 3734, col: 16, offset: 128241},
																									exprs: []interface{}{
																										&zeroOrOneExpr{
																											pos: position{line: 3734, col: 16, offset: 128241},
																											expr: &litMatcher{
																												pos:        position{line: 3734, col: 16, offset: 128241},
																												val:        "\r",
																												ignoreCase: false,
																												want:       "\"\\r\"",
																											},
																										},
																										&litMatcher{
																											pos:        position{line: 3734, col: 22, offset: 128247},
																											val:        "\n",
																											ignoreCase: false,
																											want:       "\"\\n\"",
																										},
																									},
																								},
																								&notExpr{
																									pos: position{line: 3733, col: 12, offset: 128223},
																									expr: &anyMatcher{
																										line: 3733, col: 13, offset: 128224,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 3226, col: 5, offset: 111783},
																run: (*parser).callonimportsAndComments708,
																expr: &seqExpr{
																	pos: position{line: 3226, col: 5, offset: 111783},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 3226, col: 5, offset: 111783},
																			val:        "import",
																			ignoreCase: false,
																			want:       "\"import\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 3226, col: 14, offset: 111792},
																			label: "posI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonimportsAndComments712,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 3734, col: 12, offset: 128237},
																			expr: &charClassMatcher{
																				pos:        position{line: 3746, col: 36, offset: 128584},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																		&choiceExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					exprs: []interface{}{
																						&zeroOrOneExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							expr: &litMatcher{
																								pos:        position{line: 3734, col: 16, offset: 128241},
																								val:        "\r",
																								ignoreCase: false,
																								want:       "\"\\r\"",
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 3734, col: 22, offset: 128247},
																							val:        "\n",
																							ignoreCase: false,
																							want:       "\"\\n\"",
																						},
																					},
																				},
																				&notExpr{
																					pos: position{line: 3733, col: 12, offset: 128223},
																					expr: &anyMatcher{
																						line: 3733, col: 13, offset: 128224,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "usesAndComments",
			pos:  position{line: 82, col: 1, offset: 2315},
			expr: &actionExpr{
				pos: position{line: 82, col: 20, offset: 2334},
				run: (*parser).callonusesAndComments1,
				expr: &labeledExpr{
					pos:   position{line: 82, col: 20, offset: 2334},
					label: "valsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 82, col: 26, offset: 2340},
						expr: &seqExpr{
							pos: position{line: 82, col: 27, offset: 2341},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 82, col: 27, offset: 2341},
									expr: &ruleRefExpr{
										pos:  position{line: 82, col: 27, offset: 2341},
										name: "CorgiComments",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 82, col: 42, offset: 2356},
									expr: &oneOrMoreExpr{
										pos: position{line: 3748, col: 36, offset: 128671},
										expr: &seqExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 3748, col: 37, offset: 128672},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3747, col: 36, offset: 128625},
													expr: &litMatcher{
														pos:        position{line: 3747, col: 36, offset: 128625},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3747, col: 42, offset: 128631},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 3274, col: 9, offset: 113254},
									run: (*parser).callonusesAndComments15,
									expr: &labeledExpr{
										pos:   position{line: 3274, col: 9, offset: 113254},
										label: "usesI",
										expr: &oneOrMoreExpr{
											pos: position{line: 3274, col: 15, offset: 113260},
											expr: &seqExpr{
												pos: position{line: 3274, col: 16, offset: 113261},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3274, col: 16, offset: 113261},
														expr: &oneOrMoreExpr{
															pos: position{line: 3748, col: 36, offset: 128671},
															expr: &seqExpr{
																pos: position{line: 3748, col: 37, offset: 128672},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3748, col: 37, offset: 128672},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 3747, col: 36, offset: 128625},
																		expr: &litMatcher{
																			pos:        position{line: 3747, col: 36, offset: 128625},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3747, col: 42, offset: 128631},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
														},
													},
													&choiceExpr{
														pos: position{line: 3288, col: 8, offset: 113542},
														alternatives: []interface{}{
															&actionExpr{
																pos: position{line: 3288, col: 8, offset: 113542},
																run: (*parser).callonusesAndComments28,
																expr: &seqExpr{
																	pos: position{line: 3288, col: 8, offset: 113542},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 3288, col: 8, offset: 113542},
																			val:        "use",
																			ignoreCase: false,
																			want:       "\"use\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 3288, col: 15, offset: 113549},
																			label: "specsI",
																			expr: &actionExpr{
																				pos: position{line: 3309, col: 13, offset: 114155},
																				run: (*parser).callonusesAndComments32,
																				expr: &seqExpr{
																					pos: position{line: 3309, col: 13, offset: 114155},
																					exprs: []interface{}{
																						&stateCodeExpr{
																							pos: position{line: 4214, col: 11, offset: 148867},
																							run: (*parser).callonusesAndComments34,
																						},
																						&labeledExpr{
																							pos:   position{line: 3309, col: 20, offset: 114162},
																							label: "usesI",
																							expr: &zeroOrMoreExpr{
																								pos: position{line: 3309, col: 26, offset: 114168},
																								expr: &seqExpr{
																									pos: position{line: 3309, col: 27, offset: 114169},
																									exprs: []interface{}{
																										&zeroOrOneExpr{
																											pos: position{line: 3309, col: 27, offset: 114169},
																											expr: &oneOrMoreExpr{
																												pos: position{line: 3748, col: 36, offset: 128671},
																												expr: &seqExpr{
																													pos: position{line: 3748, col: 37, offset: 128672},
																													exprs: []interface{}{
																														&zeroOrMoreExpr{
																															pos: position{line: 3748, col: 37, offset: 128672},
																															expr: &charClassMatcher{
																																pos:        position{line: 3746, col: 36, offset: 128584},
																																val:        "[ \\t]",
																																chars:      []rune{' ', '\t'},
																																ignoreCase: false,
																																inverted:   false,
																															},
																														},
																														&zeroOrOneExpr{
																															pos: position{line: 3747, col: 36, offset: 128625},
																															expr: &litMatcher{
																																pos:        position{line: 3747, col: 36, offset: 128625},
																																val:        "\r",
																																ignoreCase: false,
																																want:       "\"\\r\"",
																															},
																														},
																														&litMatcher{
																															pos:        position{line: 3747, col: 42, offset: 128631},
																															val:        "\n",
																															ignoreCase: false,
																															want:       "\"\\n\"",
																														},
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 3835, col: 17, offset: 132478},
																											run: (*parser).callonusesAndComments46,
																											expr: &zeroOrMoreExpr{
																												pos: position{line: 3835, col: 17, offset: 132478},
																												expr: &charClassMatcher{
																													pos:        position{line: 3746, col: 36, offset: 128584},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																										&andCodeExpr{
																											pos: position{line: 3835, col: 41, offset: 132502},
																											run: (*parser).callonusesAndComments49,
																										},
																										&choiceExpr{
																											pos: position{line: 3887, col: 5, offset: 134412},
																											alternatives: []interface{}{
																												&andCodeExpr{
																													pos: position{line: 3887, col: 5, offset: 134412},
																													run: (*parser).callonusesAndComments51,
																												},
																												&seqExpr{
																													pos: position{line: 3889, col: 9, offset: 134495},
																													exprs: []interface{}{
																														&andCodeExpr{
																															pos: position{line: 3889, col: 9, offset: 134495},
																															run: (*parser).callonusesAndComments53,
																														},
																														&stateCodeExpr{
																															pos: position{line: 3891, col: 7, offset: 134599},
																															run: (*parser).callonusesAndComments54,
																														},
																													},
																												},
																												&seqExpr{
																													pos: position{line: 3898, col: 9, offset: 134935},
																													exprs: []interface{}{
																														&andCodeExpr{
																															pos: position{line: 3898, col: 9, offset: 134935},
																															run: (*parser).callonusesAndComments56,
																														},
																														&choiceExpr{
																															pos: position{line: 3951, col: 9, offset: 137270},
																															alternatives: []interface{}{
																																&seqExpr{
																																	pos: position{line: 3951, col: 9, offset: 137270},
																																	exprs: []interface{}{
																																		&andCodeExpr{
																																			pos: position{line: 3951, col: 9, offset: 137270},
																																			run: (*parser).callonusesAndComments59,
																																		},
																																		&andCodeExpr{
																																			pos: position{line: 3955, col: 11, offset: 137520},
																																			run: (*parser).callonusesAndComments60,
																																		},
																																		&stateCodeExpr{
																																			pos: position{line: 4021, col: 11, offset: 140726},
																																			run: (*parser).callonusesAndComments61,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 4029, col: 13, offset: 141079},
																																	exprs: []interface{}{
																																		&andCodeExpr{
																																			pos: position{line: 4029, col: 13, offset: 141079},
																																			run: (*parser).callonusesAndComments63,
																																		},
																																		&andCodeExpr{
																																			pos: position{line: 4033, col: 11, offset: 141334},
																																			run: (*parser).callonusesAndComments64,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&actionExpr{
																											pos: position{line: 3313, col: 12, offset: 114285},
																											run: (*parser).callonusesAndComments65,
																											expr: &seqExpr{
																												pos: position{line: 3313, col: 12, offset: 114285},
																												exprs: []interface{}{
																													&labeledExpr{
																														pos:   position{line: 3313, col: 12, offset: 114285},
																														label: "aliasI",
																														expr: &zeroOrOneExpr{
																															pos: position{line: 3313, col: 19, offset: 114292},
																															expr: &seqExpr{
																																pos: position{line: 3313, col: 20, offset: 114293},
																																exprs: []interface{}{
																																	&choiceExpr{
																																		pos: position{line: 3326, col: 13, offset: 114562},
																																		alternatives: []interface{}{
																																			&actionExpr{
																																				pos: position{line: 3326, col: 13, offset: 114562},
																																				run: (*parser).callonusesAndComments71,
																																				expr: &litMatcher{
																																					pos:        position{line: 3326, col: 13, offset: 114562},
																																					val:        ".",
																																					ignoreCase: false,
																																					want:       "\".\"",
																																				},
																																			},
																																			&actionExpr{
																																				pos: position{line: 697, col: 10, offset: 21290},
																																				run: (*parser).callonusesAndComments73,
																																				expr: &labeledExpr{
																																					pos:   position{line: 697, col: 10, offset: 21290},
																																					label: "identI",
																																					expr: &seqExpr{
																																						pos: position{line: 2367, col: 17, offset: 81233},
																																						exprs: []interface{}{
																																							&charClassMatcher{
																																								pos:        position{line: 2350, col: 20, offset: 80988},
																																								val:        "[_\\pL]",
																																								chars:      []rune{'_'},
																																								classes:    []*unicode.RangeTable{rangeTable("L")},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																							&zeroOrMoreExpr{
																																								pos: position{line: 2367, col: 26, offset: 81242},
																																								expr: &charClassMatcher{
																																									pos:        position{line: 2350, col: 20, offset: 80988},
																																									val:        "[_\\pL\\pNd]",
																																									chars:      []rune{'_'},
																																									classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																																									ignoreCase: false,
																																									inverted:   false,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&actionExpr{
																																				pos: position{line: 699, col: 5, offset: 21384},
																																				run: (*parser).callonusesAndComments79,
																																				expr: &seqExpr{
																																					pos: position{line: 699, col: 5, offset: 21384},
																																					exprs: []interface{}{
																																						&labeledExpr{
																																							pos:   position{line: 699, col: 5, offset: 21384},
																																							label: "identI",
																																							expr: &seqExpr{
																																								pos: position{line: 699, col: 13, offset: 21392},
																																								exprs: []interface{}{
																																									&zeroOrOneExpr{
																																										pos: position{line: 699, col: 13, offset: 21392},
																																										expr: &litMatcher{
																																											pos:        position{line: 699, col: 13, offset: 21392},
																																											val:        "$",
																																											ignoreCase: false,
																																											want:       "\"$\"",
																																										},
																																									},
																																									&oneOrMoreExpr{
																																										pos: position{line: 699, col: 18, offset: 21397},
																																										expr: &choiceExpr{
																																											pos: position{line: 699, col: 19, offset: 21398},
																																											alternatives: []interface{}{
																																												&seqExpr{
																																													pos: position{line: 699, col: 19, offset: 21398},
																																													exprs: []interface{}{
																																														&charClassMatcher{
																																															pos:        position{line: 699, col: 19, offset: 21398},
																																															val:        "[\\pNd]",
																																															classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																															ignoreCase: false,
																																															inverted:   false,
																																														},
																																														&charClassMatcher{
																																															pos:        position{line: 699, col: 28, offset: 21407},
																																															val:        "[_-\\pL]",
																																															chars:      []rune{'_', '-'},
																																															classes:    []*unicode.RangeTable{rangeTable("L")},
																																															ignoreCase: false,
																																															inverted:   false,
																																														},
																																													},
																																												},
																																												&charClassMatcher{
																																													pos:        position{line: 699, col: 38, offset: 21417},
																																													val:        "[_-\\pL]",
																																													chars:      []rune{'_', '-'},
																																													classes:    []*unicode.RangeTable{rangeTable("L")},
																																													ignoreCase: false,
																																													inverted:   false,
																																												},
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																						&labeledExpr{
																																							pos:   position{line: 699, col: 49, offset: 21428},
																																							label: "endPosI",
																																							expr: &actionExpr{
																																								pos: position{line: 3737, col: 8, offset: 128286},
																																								run: (*parser).callonusesAndComments92,
																																								expr: &choiceExpr{
																																									pos: position{line: 3737, col: 9, offset: 128287},
																																									alternatives: []interface{}{
																																										&andExpr{
																																											pos: position{line: 3737, col: 9, offset: 128287},
																																											expr: &anyMatcher{
																																												line: 3737, col: 10, offset: 128288,
																																											},
																																										},
																																										&notExpr{
																																											pos: position{line: 3737, col: 14, offset: 128292},
																																											expr: &anyMatcher{
																																												line: 3737, col: 15, offset: 128293,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&actionExpr{
																																				pos: position{line: 3328, col: 13, offset: 114637},
																																				run: (*parser).callonusesAndComments98,
																																				expr: &seqExpr{
																																					pos: position{line: 3328, col: 13, offset: 114637},
																																					exprs: []interface{}{
																																						&oneOrMoreExpr{
																																							pos: position{line: 3328, col: 13, offset: 114637},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3328, col: 13, offset: 114637},
																																								val:        "[^\"`\\ ]",
																																								chars:      []rune{'"', '`', '\'', ' '},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																						},
																																						&labeledExpr{
																																							pos:   position{line: 3328, col: 22, offset: 114646},
																																							label: "endPosI",
																																							expr: &actionExpr{
																																								pos: position{line: 3737, col: 8, offset: 128286},
																																								run: (*parser).callonusesAndComments103,
																																								expr: &choiceExpr{
																																									pos: position{line: 3737, col: 9, offset: 128287},
																																									alternatives: []interface{}{
																																										&andExpr{
																																											pos: position{line: 3737, col: 9, offset: 128287},
																																											expr: &anyMatcher{
																																												line: 3737, col: 10, offset: 128288,
																																											},
																																										},
																																										&notExpr{
																																											pos: position{line: 3737, col: 14, offset: 128292},
																																											expr: &anyMatcher{
																																												line: 3737, col: 15, offset: 128293,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																	&oneOrMoreExpr{
																																		pos: position{line: 3313, col: 29, offset: 114302},
																																		expr: &litMatcher{
																																			pos:        position{line: 3313, col: 29, offset: 114302},
																																			val:        " ",
																																			ignoreCase: false,
																																			want:       "\" \"",
																																		},
																																	},
																																},
																															},
																														},
																													},
																													&labeledExpr{
																														pos:   position{line: 3313, col: 36, offset: 114309},
																														label: "pathI",
																														expr: &choiceExpr{
																															pos: position{line: 3178, col: 12, offset: 110324},
																															alternatives: []interface{}{
																																&actionExpr{
																																	pos: position{line: 749, col: 14, offset: 22958},
																																	run: (*parser).callonusesAndComments113,
																																	expr: &seqExpr{
																																		pos: position{line: 749, col: 14, offset: 22958},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 749, col: 14, offset: 22958},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 749, col: 18, offset: 22962},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 749, col: 23, offset: 22967},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 2704, col: 27, offset: 94307},
																																						val:        "[^\\n`]",
																																						chars:      []rune{'\n', '`'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 749, col: 47, offset: 22991},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 751, col: 5, offset: 23083},
																																	run: (*parser).callonusesAndComments120,
																																	expr: &seqExpr{
																																		pos: position{line: 751, col: 5, offset: 23083},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 751, col: 5, offset: 23083},
																																				val:        "`",
																																				ignoreCase: false,
																																				want:       "\"`\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 751, col: 9, offset: 23087},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 751, col: 14, offset: 23092},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 2704, col: 27, offset: 94307},
																																						val:        "[^\\n`]",
																																						chars:      []rune{'\n', '`'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&andExpr{
																																				pos: position{line: 751, col: 38, offset: 23116},
																																				expr: &seqExpr{
																																					pos: position{line: 3734, col: 12, offset: 128237},
																																					exprs: []interface{}{
																																						&zeroOrMoreExpr{
																																							pos: position{line: 3734, col: 12, offset: 128237},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3746, col: 36, offset: 128584},
																																								val:        "[ \\t]",
																																								chars:      []rune{' ', '\t'},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																						},
																																						&choiceExpr{
																																							pos: position{line: 3734, col: 16, offset: 128241},
																																							alternatives: []interface{}{
																																								&seqExpr{
																																									pos: position{line: 3734, col: 16, offset: 128241},
																																									exprs: []interface{}{
																																										&zeroOrOneExpr{
																																											pos: position{line: 3734, col: 16, offset: 128241},
																																											expr: &litMatcher{
																																												pos:        position{line: 3734, col: 16, offset: 128241},
																																												val:        "\r",
																																												ignoreCase: false,
																																												want:       "\"\\r\"",
																																											},
																																										},
																																										&litMatcher{
																																											pos:        position{line: 3734, col: 22, offset: 128247},
																																											val:        "\n",
																																											ignoreCase: false,
																																											want:       "\"\\n\"",
																																										},
																																									},
																																								},
																																								&notExpr{
																																									pos: position{line: 3733, col: 12, offset: 128223},
																																									expr: &anyMatcher{
																																										line: 3733, col: 13, offset: 128224,
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 770, col: 22, offset: 23520},
																																	run: (*parser).callonusesAndComments137,
																																	expr: &seqExpr{
																																		pos: position{line: 770, col: 22, offset: 23520},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 770, col: 22, offset: 23520},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 770, col: 26, offset: 23524},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 770, col: 31, offset: 23529},
																																					expr: &choiceExpr{
																																						pos: position{line: 770, col: 32, offset: 23530},
																																						alternatives: []interface{}{
																																							&seqExpr{
																																								pos: position{line: 2443, col: 24, offset: 83970},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2443, col: 24, offset: 83970},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2444, col: 24, offset: 84037},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2444, col: 24, offset: 84037},
																																										val:        "\\x",
																																										ignoreCase: false,
																																										want:       "\"\\\\x\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2445, col: 5, offset: 84074},
																																								run: (*parser).callonusesAndComments152,
																																								expr: &seqExpr{
																																									pos: position{line: 2445, col: 5, offset: 84074},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2445, col: 5, offset: 84074},
																																											val:        "\\x",
																																											ignoreCase: false,
																																											want:       "\"\\\\x\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2445, col: 14, offset: 84083},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2445, col: 26, offset: 84095},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2462, col: 19, offset: 84712},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2462, col: 19, offset: 84712},
																																										val:        "\\u",
																																										ignoreCase: false,
																																										want:       "\"\\\\u\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2463, col: 5, offset: 84771},
																																								run: (*parser).callonusesAndComments165,
																																								expr: &seqExpr{
																																									pos: position{line: 2463, col: 5, offset: 84771},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2463, col: 5, offset: 84771},
																																											val:        "\\u",
																																											ignoreCase: false,
																																											want:       "\"\\\\u\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 14, offset: 84780},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 26, offset: 84792},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 38, offset: 84804},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 50, offset: 84816},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2492, col: 16, offset: 85952},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2492, col: 16, offset: 85952},
																																										val:        "\\U",
																																										ignoreCase: false,
																																										want:       "\"\\\\U\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2493, col: 5, offset: 86055},
																																								run: (*parser).callonusesAndComments186,
																																								expr: &seqExpr{
																																									pos: position{line: 2493, col: 5, offset: 86055},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2493, col: 5, offset: 86055},
																																											val:        "\\U",
																																											ignoreCase: false,
																																											want:       "\"\\\\U\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 14, offset: 86064},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 26, offset: 86076},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 38, offset: 86088},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 50, offset: 86100},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 62, offset: 86112},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 74, offset: 86124},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 86, offset: 86136},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 98, offset: 86148},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2720, col: 36, offset: 95085},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2720, col: 36, offset: 95085},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2720, col: 41, offset: 95090},
																																										val:        "[abfnrtv\\\\\"]",
																																										chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&charClassMatcher{
																																								pos:        position{line: 2718, col: 38, offset: 94977},
																																								val:        "[^\"\\\\\\n]",
																																								chars:      []rune{'"', '\\', '\n'},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																							&actionExpr{
																																								pos: position{line: 2607, col: 37, offset: 90735},
																																								run: (*parser).callonusesAndComments209,
																																								expr: &seqExpr{
																																									pos: position{line: 2607, col: 37, offset: 90735},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2607, col: 37, offset: 90735},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2631, col: 5, offset: 91752},
																																								run: (*parser).callonusesAndComments220,
																																								expr: &seqExpr{
																																									pos: position{line: 2631, col: 5, offset: 91752},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2631, col: 5, offset: 91752},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2652, col: 5, offset: 92594},
																																								run: (*parser).callonusesAndComments227,
																																								expr: &seqExpr{
																																									pos: position{line: 2652, col: 5, offset: 92594},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2652, col: 5, offset: 92594},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2670, col: 5, offset: 93280},
																																								run: (*parser).callonusesAndComments232,
																																								expr: &seqExpr{
																																									pos: position{line: 2670, col: 5, offset: 93280},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2670, col: 5, offset: 93280},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2670, col: 10, offset: 93285},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 3735, col: 12, offset: 128270},
																																												val:        "[^\\r\\n]",
																																												chars:      []rune{'\r', '\n'},
																																												ignoreCase: false,
																																												inverted:   true,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 770, col: 115, offset: 23613},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 772, col: 5, offset: 23705},
																																	run: (*parser).callonusesAndComments238,
																																	expr: &seqExpr{
																																		pos: position{line: 772, col: 5, offset: 23705},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 772, col: 5, offset: 23705},
																																				val:        "\"",
																																				ignoreCase: false,
																																				want:       "\"\\\"\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 772, col: 9, offset: 23709},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 772, col: 14, offset: 23714},
																																					expr: &choiceExpr{
																																						pos: position{line: 772, col: 15, offset: 23715},
																																						alternatives: []interface{}{
																																							&seqExpr{
																																								pos: position{line: 2443, col: 24, offset: 83970},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2443, col: 24, offset: 83970},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2360, col: 19, offset: 81158},
																																										val:        "[0-7]",
																																										ranges:     []rune{'0', '7'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2444, col: 24, offset: 84037},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2444, col: 24, offset: 84037},
																																										val:        "\\x",
																																										ignoreCase: false,
																																										want:       "\"\\\\x\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2445, col: 5, offset: 84074},
																																								run: (*parser).callonusesAndComments253,
																																								expr: &seqExpr{
																																									pos: position{line: 2445, col: 5, offset: 84074},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2445, col: 5, offset: 84074},
																																											val:        "\\x",
																																											ignoreCase: false,
																																											want:       "\"\\\\x\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2445, col: 14, offset: 84083},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2445, col: 26, offset: 84095},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2462, col: 19, offset: 84712},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2462, col: 19, offset: 84712},
																																										val:        "\\u",
																																										ignoreCase: false,
																																										want:       "\"\\\\u\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2463, col: 5, offset: 84771},
																																								run: (*parser).callonusesAndComments266,
																																								expr: &seqExpr{
																																									pos: position{line: 2463, col: 5, offset: 84771},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2463, col: 5, offset: 84771},
																																											val:        "\\u",
																																											ignoreCase: false,
																																											want:       "\"\\\\u\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 14, offset: 84780},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 26, offset: 84792},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 38, offset: 84804},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2463, col: 50, offset: 84816},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2492, col: 16, offset: 85952},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2492, col: 16, offset: 85952},
																																										val:        "\\U",
																																										ignoreCase: false,
																																										want:       "\"\\\\U\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2361, col: 19, offset: 81182},
																																										val:        "[0-9A-Fa-f]",
																																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2493, col: 5, offset: 86055},
																																								run: (*parser).callonusesAndComments287,
																																								expr: &seqExpr{
																																									pos: position{line: 2493, col: 5, offset: 86055},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2493, col: 5, offset: 86055},
																																											val:        "\\U",
																																											ignoreCase: false,
																																											want:       "\"\\\\U\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 14, offset: 86064},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 26, offset: 86076},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 38, offset: 86088},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 50, offset: 86100},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 62, offset: 86112},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 74, offset: 86124},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 86, offset: 86136},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2493, col: 98, offset: 86148},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 2361, col: 19, offset: 81182},
																																												val:        "[0-9A-Fa-f]",
																																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																												ignoreCase: false,
																																												inverted:   false,
																																											},
																																										},
																																									},
																																								},
																																							},
																																							&seqExpr{
																																								pos: position{line: 2720, col: 36, offset: 95085},
																																								exprs: []interface{}{
																																									&litMatcher{
																																										pos:        position{line: 2720, col: 36, offset: 95085},
																																										val:        "\\",
																																										ignoreCase: false,
																																										want:       "\"\\\\\"",
																																									},
																																									&charClassMatcher{
																																										pos:        position{line: 2720, col: 41, offset: 95090},
																																										val:        "[abfnrtv\\\\\"]",
																																										chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																										ignoreCase: false,
																																										inverted:   false,
																																									},
																																								},
																																							},
																																							&charClassMatcher{
																																								pos:        position{line: 2718, col: 38, offset: 94977},
																																								val:        "[^\"\\\\\\n]",
																																								chars:      []rune{'"', '\\', '\n'},
																																								ignoreCase: false,
																																								inverted:   true,
																																							},
																																							&actionExpr{
																																								pos: position{line: 2607, col: 37, offset: 90735},
																																								run: (*parser).callonusesAndComments310,
																																								expr: &seqExpr{
																																									pos: position{line: 2607, col: 37, offset: 90735},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2607, col: 37, offset: 90735},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2631, col: 5, offset: 91752},
																																								run: (*parser).callonusesAndComments321,
																																								expr: &seqExpr{
																																									pos: position{line: 2631, col: 5, offset: 91752},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2631, col: 5, offset: 91752},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2652, col: 5, offset: 92594},
																																								run: (*parser).callonusesAndComments328,
																																								expr: &seqExpr{
																																									pos: position{line: 2652, col: 5, offset: 92594},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2652, col: 5, offset: 92594},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																										&charClassMatcher{
																																											pos:        position{line: 2361, col: 19, offset: 81182},
																																											val:        "[0-9A-Fa-f]",
																																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																											ignoreCase: false,
																																											inverted:   false,
																																										},
																																									},
																																								},
																																							},
																																							&actionExpr{
																																								pos: position{line: 2670, col: 5, offset: 93280},
																																								run: (*parser).callonusesAndComments333,
																																								expr: &seqExpr{
																																									pos: position{line: 2670, col: 5, offset: 93280},
																																									exprs: []interface{}{
																																										&litMatcher{
																																											pos:        position{line: 2670, col: 5, offset: 93280},
																																											val:        "\\",
																																											ignoreCase: false,
																																											want:       "\"\\\\\"",
																																										},
																																										&zeroOrOneExpr{
																																											pos: position{line: 2670, col: 10, offset: 93285},
																																											expr: &charClassMatcher{
																																												pos:        position{line: 3735, col: 12, offset: 128270},
																																												val:        "[^\\r\\n]",
																																												chars:      []rune{'\r', '\n'},
																																												ignoreCase: false,
																																												inverted:   true,
																																											},
																																										},
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 772, col: 98, offset: 23798},
																																				label: "endPosI",
																																				expr: &actionExpr{
																																					pos: position{line: 3737, col: 8, offset: 128286},
																																					run: (*parser).callonusesAndComments339,
																																					expr: &choiceExpr{
																																						pos: position{line: 3737, col: 9, offset: 128287},
																																						alternatives: []interface{}{
																																							&andExpr{
																																								pos: position{line: 3737, col: 9, offset: 128287},
																																								expr: &anyMatcher{
																																									line: 3737, col: 10, offset: 128288,
																																								},
																																							},
																																							&notExpr{
																																								pos: position{line: 3737, col: 14, offset: 128292},
																																								expr: &anyMatcher{
																																									line: 3737, col: 15, offset: 128293,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																			&andExpr{
																																				pos: position{line: 772, col: 110, offset: 23810},
																																				expr: &seqExpr{
																																					pos: position{line: 3734, col: 12, offset: 128237},
																																					exprs: []interface{}{
																																						&zeroOrMoreExpr{
																																							pos: position{line: 3734, col: 12, offset: 128237},
																																							expr: &charClassMatcher{
																																								pos:        position{line: 3746, col: 36, offset: 128584},
																																								val:        "[ \\t]",
																																								chars:      []rune{' ', '\t'},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																						},
																																						&choiceExpr{
																																							pos: position{line: 3734, col: 16, offset: 128241},
																																							alternatives: []interface{}{
																																								&seqExpr{
																																									pos: position{line: 3734, col: 16, offset: 128241},
																																									exprs: []interface{}{
																																										&zeroOrOneExpr{
																																											pos: position{line: 3734, col: 16, offset: 128241},
																																											expr: &litMatcher{
																																												pos:        position{line: 3734, col: 16, offset: 128241},
																																												val:        "\r",
																																												ignoreCase: false,
																																												want:       "\"\\r\"",
																																											},
																																										},
																																										&litMatcher{
																																											pos:        position{line: 3734, col: 22, offset: 128247},
																																											val:        "\n",
																																											ignoreCase: false,
																																											want:       "\"\\n\"",
																																										},
																																									},
																																								},
																																								&notExpr{
																																									pos: position{line: 3733, col: 12, offset: 128223},
																																									expr: &anyMatcher{
																																										line: 3733, col: 13, offset: 128224,
																																									},
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 791, col: 22, offset: 24216},
																																	run: (*parser).callonusesAndComments356,
																																	expr: &seqExpr{
																																		pos: position{line: 791, col: 22, offset: 24216},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 791, col: 22, offset: 24216},
																																				val:        "'",
																																				ignoreCase: false,
																																				want:       "\"'\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 791, col: 27, offset: 24221},
																																				label: "strI",
																																				expr: &zeroOrMoreExpr{
																																					pos: position{line: 791, col: 32, offset: 24226},
																																					expr: &charClassMatcher{
																																						pos:        position{line: 791, col: 32, offset: 24226},
																																						val:        "[^\\\\r\\n]",
																																						chars:      []rune{'\'', '\r', '\n'},
																																						ignoreCase: false,
																																						inverted:   true,
																																					},
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 791, col: 42, offset: 24236},
																																				val:        "'",
																																				ignoreCase: false,
																																				want:       "\"'\"",
																																			},
																																			&labeledExpr{
																																				pos:   position{line: 791, col: 47, offset: 24241},
																																				label: "endPosI",
																																				expr: &actionExpr{
																																					pos: position{line: 3737, col: 8, offset: 128286},
																																					run: (*parser).callonusesAndComments364,
																																					expr: &choiceExpr{
																																						pos: position{line: 3737, col: 9, offset: 128287},
																																						alternatives: []interface{}{
																																							&andExpr{
																																								pos: position{line: 3737, col: 9, offset: 128287},
																																								expr: &anyMatcher{
																																									line: 3737, col: 10, offset: 128288,
																																								},
																																							},
																																							&notExpr{
																																								pos: position{line: 3737, col: 14, offset: 128292},
																																								expr: &anyMatcher{
																																									line: 3737, col: 15, offset: 128293,
																																								},
																																							},
																																						},
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 3178, col: 21, offset: 110333},
																																	run: (*parser).callonusesAndComments370,
																																	expr: &labeledExpr{
																																		pos:   position{line: 3178, col: 21, offset: 110333},
																																		label: "pathI",
																																		expr: &zeroOrMoreExpr{
																																			pos: position{line: 3178, col: 27, offset: 110339},
																																			expr: &charClassMatcher{
																																				pos:        position{line: 3735, col: 12, offset: 128270},
																																				val:        "[^\\r\\n]",
																																				chars:      []rune{'\r', '\n'},
																																				ignoreCase: false,
																																				inverted:   true,
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																													&zeroOrMoreExpr{
																														pos: position{line: 3734, col: 12, offset: 128237},
																														expr: &charClassMatcher{
																															pos:        position{line: 3746, col: 36, offset: 128584},
																															val:        "[ \\t]",
																															chars:      []rune{' ', '\t'},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																													&choiceExpr{
																														pos: position{line: 3734, col: 16, offset: 128241},
																														alternatives: []interface{}{
																															&seqExpr{
																																pos: position{line: 3734, col: 16, offset: 128241},
																																exprs: []interface{}{
																																	&zeroOrOneExpr{
																																		pos: position{line: 3734, col: 16, offset: 128241},
																																		expr: &litMatcher{
																																			pos:        position{line: 3734, col: 16, offset: 128241},
																																			val:        "\r",
																																			ignoreCase: false,
																																			want:       "\"\\r\"",
																																		},
																																	},
																																	&litMatcher{
																																		pos:        position{line: 3734, col: 22, offset: 128247},
																																		val:        "\n",
																																		ignoreCase: false,
																																		want:       "\"\\n\"",
																																	},
																																},
																															},
																															&notExpr{
																																pos: position{line: 3733, col: 12, offset: 128223},
																																expr: &anyMatcher{
																																	line: 3733, col: 13, offset: 128224,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&stateCodeExpr{
																							pos: position{line: 4219, col: 11, offset: 148972},
																							run: (*parser).callonusesAndComments383,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 3293, col: 5, offset: 113668},
																run: (*parser).callonusesAndComments384,
																expr: &seqExpr{
																	pos: position{line: 3293, col: 5, offset: 113668},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 3293, col: 5, offset: 113668},
																			val:        "use",
																			ignoreCase: false,
																			want:       "\"use\"",
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 3293, col: 11, offset: 113674},
																			expr: &litMatcher{
																				pos:        position{line: 3293, col: 11, offset: 113674},
																				val:        " ",
																				ignoreCase: false,
																				want:       "\" \"",
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 3293, col: 16, offset: 113679},
																			label: "specI",
																			expr: &actionExpr{
																				pos: position{line: 3313, col: 12, offset: 114285},
																				run: (*parser).callonusesAndComments390,
																				expr: &seqExpr{
																					pos: position{line: 3313, col: 12, offset: 114285},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 3313, col: 12, offset: 114285},
																							label: "aliasI",
																							expr: &zeroOrOneExpr{
																								pos: position{line: 3313, col: 19, offset: 114292},
																								expr: &seqExpr{
																									pos: position{line: 3313, col: 20, offset: 114293},
																									exprs: []interface{}{
																										&choiceExpr{
																											pos: position{line: 3326, col: 13, offset: 114562},
																											alternatives: []interface{}{
																												&actionExpr{
																													pos: position{line: 3326, col: 13, offset: 114562},
																													run: (*parser).callonusesAndComments396,
																													expr: &litMatcher{
																														pos:        position{line: 3326, col: 13, offset: 114562},
																														val:        ".",
																														ignoreCase: false,
																														want:       "\".\"",
																													},
																												},
																												&actionExpr{
																													pos: position{line: 697, col: 10, offset: 21290},
																													run: (*parser).callonusesAndComments398,
																													expr: &labeledExpr{
																														pos:   position{line: 697, col: 10, offset: 21290},
																														label: "identI",
																														expr: &seqExpr{
																															pos: position{line: 2367, col: 17, offset: 81233},
																															exprs: []interface{}{
																																&charClassMatcher{
																																	pos:        position{line: 2350, col: 20, offset: 80988},
																																	val:        "[_\\pL]",
																																	chars:      []rune{'_'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																																&zeroOrMoreExpr{
																																	pos: position{line: 2367, col: 26, offset: 81242},
																																	expr: &charClassMatcher{
																																		pos:        position{line: 2350, col: 20, offset: 80988},
																																		val:        "[_\\pL\\pNd]",
																																		chars:      []rune{'_'},
																																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																																		ignoreCase: false,
																																		inverted:   false,
																																	},
																																},
																															},
																														},
																													},
																												},
																												&actionExpr{
																													pos: position{line: 699, col: 5, offset: 21384},
																													run: (*parser).callonusesAndComments404,
																													expr: &seqExpr{
																														pos: position{line: 699, col: 5, offset: 21384},
																														exprs: []interface{}{
																															&labeledExpr{
																																pos:   position{line: 699, col: 5, offset: 21384},
																																label: "identI",
																																expr: &seqExpr{
																																	pos: position{line: 699, col: 13, offset: 21392},
																																	exprs: []interface{}{
																																		&zeroOrOneExpr{
																																			pos: position{line: 699, col: 13, offset: 21392},
																																			expr: &litMatcher{
																																				pos:        position{line: 699, col: 13, offset: 21392},
																																				val:        "$",
																																				ignoreCase: false,
																																				want:       "\"$\"",
																																			},
																																		},
																																		&oneOrMoreExpr{
																																			pos: position{line: 699, col: 18, offset: 21397},
																																			expr: &choiceExpr{
																																				pos: position{line: 699, col: 19, offset: 21398},
																																				alternatives: []interface{}{
																																					&seqExpr{
																																						pos: position{line: 699, col: 19, offset: 21398},
																																						exprs: []interface{}{
																																							&charClassMatcher{
																																								pos:        position{line: 699, col: 19, offset: 21398},
																																								val:        "[\\pNd]",
																																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																							&charClassMatcher{
																																								pos:        position{line: 699, col: 28, offset: 21407},
																																								val:        "[_-\\pL]",
																																								chars:      []rune{'_', '-'},
																																								classes:    []*unicode.RangeTable{rangeTable("L")},
																																								ignoreCase: false,
																																								inverted:   false,
																																							},
																																						},
																																					},
																																					&charClassMatcher{
																																						pos:        position{line: 699, col: 38, offset: 21417},
																																						val:        "[_-\\pL]",
																																						chars:      []rune{'_', '-'},
																																						classes:    []*unicode.RangeTable{rangeTable("L")},
																																						ignoreCase: false,
																																						inverted:   false,
																																					},
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																															&labeledExpr{
																																pos:   position{line: 699, col: 49, offset: 21428},
																																label: "endPosI",
																																expr: &actionExpr{
																																	pos: position{line: 3737, col: 8, offset: 128286},
																																	run: (*parser).callonusesAndComments417,
																																	expr: &choiceExpr{
																																		pos: position{line: 3737, col: 9, offset: 128287},
																																		alternatives: []interface{}{
																																			&andExpr{
																																				pos: position{line: 3737, col: 9, offset: 128287},
																																				expr: &anyMatcher{
																																					line: 3737, col: 10, offset: 128288,
																																				},
																																			},
																																			&notExpr{
																																				pos: position{line: 3737, col: 14, offset: 128292},
																																				expr: &anyMatcher{
																																					line: 3737, col: 15, offset: 128293,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																												&actionExpr{
																													pos: position{line: 3328, col: 13, offset: 114637},
																													run: (*parser).callonusesAndComments423,
																													expr: &seqExpr{
																														pos: position{line: 3328, col: 13, offset: 114637},
																														exprs: []interface{}{
																															&oneOrMoreExpr{
																																pos: position{line: 3328, col: 13, offset: 114637},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3328, col: 13, offset: 114637},
																																	val:        "[^\"`\\ ]",
																																	chars:      []rune{'"', '`', '\'', ' '},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																															},
																															&labeledExpr{
																																pos:   position{line: 3328, col: 22, offset: 114646},
																																label: "endPosI",
																																expr: &actionExpr{
																																	pos: position{line: 3737, col: 8, offset: 128286},
																																	run: (*parser).callonusesAndComments428,
																																	expr: &choiceExpr{
																																		pos: position{line: 3737, col: 9, offset: 128287},
																																		alternatives: []interface{}{
																																			&andExpr{
																																				pos: position{line: 3737, col: 9, offset: 128287},
																																				expr: &anyMatcher{
																																					line: 3737, col: 10, offset: 128288,
																																				},
																																			},
																																			&notExpr{
																																				pos: position{line: 3737, col: 14, offset: 128292},
																																				expr: &anyMatcher{
																																					line: 3737, col: 15, offset: 128293,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&oneOrMoreExpr{
																											pos: position{line: 3313, col: 29, offset: 114302},
																											expr: &litMatcher{
																												pos:        position{line: 3313, col: 29, offset: 114302},
																												val:        " ",
																												ignoreCase: false,
																												want:       "\" \"",
																											},
																										},
																									},
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 3313, col: 36, offset: 114309},
																							label: "pathI",
																							expr: &choiceExpr{
																								pos: position{line: 3178, col: 12, offset: 110324},
																								alternatives: []interface{}{
																									&actionExpr{
																										pos: position{line: 749, col: 14, offset: 22958},
																										run: (*parser).callonusesAndComments438,
																										expr: &seqExpr{
																											pos: position{line: 749, col: 14, offset: 22958},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 749, col: 14, offset: 22958},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 749, col: 18, offset: 22962},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 749, col: 23, offset: 22967},
																														expr: &charClassMatcher{
																															pos:        position{line: 2704, col: 27, offset: 94307},
																															val:        "[^\\n`]",
																															chars:      []rune{'\n', '`'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 749, col: 47, offset: 22991},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 751, col: 5, offset: 23083},
																										run: (*parser).callonusesAndComments445,
																										expr: &seqExpr{
																											pos: position{line: 751, col: 5, offset: 23083},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 751, col: 5, offset: 23083},
																													val:        "`",
																													ignoreCase: false,
																													want:       "\"`\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 751, col: 9, offset: 23087},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 751, col: 14, offset: 23092},
																														expr: &charClassMatcher{
																															pos:        position{line: 2704, col: 27, offset: 94307},
																															val:        "[^\\n`]",
																															chars:      []rune{'\n', '`'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&andExpr{
																													pos: position{line: 751, col: 38, offset: 23116},
																													expr: &seqExpr{
																														pos: position{line: 3734, col: 12, offset: 128237},
																														exprs: []interface{}{
																															&zeroOrMoreExpr{
																																pos: position{line: 3734, col: 12, offset: 128237},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3746, col: 36, offset: 128584},
																																	val:        "[ \\t]",
																																	chars:      []rune{' ', '\t'},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																															&choiceExpr{
																																pos: position{line: 3734, col: 16, offset: 128241},
																																alternatives: []interface{}{
																																	&seqExpr{
																																		pos: position{line: 3734, col: 16, offset: 128241},
																																		exprs: []interface{}{
																																			&zeroOrOneExpr{
																																				pos: position{line: 3734, col: 16, offset: 128241},
																																				expr: &litMatcher{
																																					pos:        position{line: 3734, col: 16, offset: 128241},
																																					val:        "\r",
																																					ignoreCase: false,
																																					want:       "\"\\r\"",
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 3734, col: 22, offset: 128247},
																																				val:        "\n",
																																				ignoreCase: false,
																																				want:       "\"\\n\"",
																																			},
																																		},
																																	},
																																	&notExpr{
																																		pos: position{line: 3733, col: 12, offset: 128223},
																																		expr: &anyMatcher{
																																			line: 3733, col: 13, offset: 128224,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 770, col: 22, offset: 23520},
																										run: (*parser).callonusesAndComments462,
																										expr: &seqExpr{
																											pos: position{line: 770, col: 22, offset: 23520},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 770, col: 22, offset: 23520},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 770, col: 26, offset: 23524},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 770, col: 31, offset: 23529},
																														expr: &choiceExpr{
																															pos: position{line: 770, col: 32, offset: 23530},
																															alternatives: []interface{}{
																																&seqExpr{
																																	pos: position{line: 2443, col: 24, offset: 83970},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2443, col: 24, offset: 83970},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2444, col: 24, offset: 84037},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2444, col: 24, offset: 84037},
																																			val:        "\\x",
																																			ignoreCase: false,
																																			want:       "\"\\\\x\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2445, col: 5, offset: 84074},
																																	run: (*parser).callonusesAndComments477,
																																	expr: &seqExpr{
																																		pos: position{line: 2445, col: 5, offset: 84074},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2445, col: 5, offset: 84074},
																																				val:        "\\x",
																																				ignoreCase: false,
																																				want:       "\"\\\\x\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2445, col: 14, offset: 84083},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2445, col: 26, offset: 84095},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2462, col: 19, offset: 84712},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2462, col: 19, offset: 84712},
																																			val:        "\\u",
																																			ignoreCase: false,
																																			want:       "\"\\\\u\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2463, col: 5, offset: 84771},
																																	run: (*parser).callonusesAndComments490,
																																	expr: &seqExpr{
																																		pos: position{line: 2463, col: 5, offset: 84771},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2463, col: 5, offset: 84771},
																																				val:        "\\u",
																																				ignoreCase: false,
																																				want:       "\"\\\\u\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 14, offset: 84780},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 26, offset: 84792},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 38, offset: 84804},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 50, offset: 84816},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2492, col: 16, offset: 85952},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2492, col: 16, offset: 85952},
																																			val:        "\\U",
																																			ignoreCase: false,
																																			want:       "\"\\\\U\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2493, col: 5, offset: 86055},
																																	run: (*parser).callonusesAndComments511,
																																	expr: &seqExpr{
																																		pos: position{line: 2493, col: 5, offset: 86055},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2493, col: 5, offset: 86055},
																																				val:        "\\U",
																																				ignoreCase: false,
																																				want:       "\"\\\\U\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 14, offset: 86064},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 26, offset: 86076},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 38, offset: 86088},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 50, offset: 86100},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 62, offset: 86112},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 74, offset: 86124},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 86, offset: 86136},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 98, offset: 86148},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2720, col: 36, offset: 95085},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2720, col: 36, offset: 95085},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2720, col: 41, offset: 95090},
																																			val:        "[abfnrtv\\\\\"]",
																																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 2718, col: 38, offset: 94977},
																																	val:        "[^\"\\\\\\n]",
																																	chars:      []rune{'"', '\\', '\n'},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																																&actionExpr{
																																	pos: position{line: 2607, col: 37, offset: 90735},
																																	run: (*parser).callonusesAndComments534,
																																	expr: &seqExpr{
																																		pos: position{line: 2607, col: 37, offset: 90735},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2607, col: 37, offset: 90735},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2631, col: 5, offset: 91752},
																																	run: (*parser).callonusesAndComments545,
																																	expr: &seqExpr{
																																		pos: position{line: 2631, col: 5, offset: 91752},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2631, col: 5, offset: 91752},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2652, col: 5, offset: 92594},
																																	run: (*parser).callonusesAndComments552,
																																	expr: &seqExpr{
																																		pos: position{line: 2652, col: 5, offset: 92594},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2652, col: 5, offset: 92594},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2670, col: 5, offset: 93280},
																																	run: (*parser).callonusesAndComments557,
																																	expr: &seqExpr{
																																		pos: position{line: 2670, col: 5, offset: 93280},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2670, col: 5, offset: 93280},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2670, col: 10, offset: 93285},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 3735, col: 12, offset: 128270},
																																					val:        "[^\\r\\n]",
																																					chars:      []rune{'\r', '\n'},
																																					ignoreCase: false,
																																					inverted:   true,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 770, col: 115, offset: 23613},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 772, col: 5, offset: 23705},
																										run: (*parser).callonusesAndComments563,
																										expr: &seqExpr{
																											pos: position{line: 772, col: 5, offset: 23705},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 772, col: 5, offset: 23705},
																													val:        "\"",
																													ignoreCase: false,
																													want:       "\"\\\"\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 772, col: 9, offset: 23709},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 772, col: 14, offset: 23714},
																														expr: &choiceExpr{
																															pos: position{line: 772, col: 15, offset: 23715},
																															alternatives: []interface{}{
																																&seqExpr{
																																	pos: position{line: 2443, col: 24, offset: 83970},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2443, col: 24, offset: 83970},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2360, col: 19, offset: 81158},
																																			val:        "[0-7]",
																																			ranges:     []rune{'0', '7'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2444, col: 24, offset: 84037},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2444, col: 24, offset: 84037},
																																			val:        "\\x",
																																			ignoreCase: false,
																																			want:       "\"\\\\x\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2445, col: 5, offset: 84074},
																																	run: (*parser).callonusesAndComments578,
																																	expr: &seqExpr{
																																		pos: position{line: 2445, col: 5, offset: 84074},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2445, col: 5, offset: 84074},
																																				val:        "\\x",
																																				ignoreCase: false,
																																				want:       "\"\\\\x\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2445, col: 14, offset: 84083},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2445, col: 26, offset: 84095},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2462, col: 19, offset: 84712},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2462, col: 19, offset: 84712},
																																			val:        "\\u",
																																			ignoreCase: false,
																																			want:       "\"\\\\u\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2463, col: 5, offset: 84771},
																																	run: (*parser).callonusesAndComments591,
																																	expr: &seqExpr{
																																		pos: position{line: 2463, col: 5, offset: 84771},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2463, col: 5, offset: 84771},
																																				val:        "\\u",
																																				ignoreCase: false,
																																				want:       "\"\\\\u\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 14, offset: 84780},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 26, offset: 84792},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 38, offset: 84804},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2463, col: 50, offset: 84816},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2492, col: 16, offset: 85952},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2492, col: 16, offset: 85952},
																																			val:        "\\U",
																																			ignoreCase: false,
																																			want:       "\"\\\\U\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2361, col: 19, offset: 81182},
																																			val:        "[0-9A-Fa-f]",
																																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2493, col: 5, offset: 86055},
																																	run: (*parser).callonusesAndComments612,
																																	expr: &seqExpr{
																																		pos: position{line: 2493, col: 5, offset: 86055},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2493, col: 5, offset: 86055},
																																				val:        "\\U",
																																				ignoreCase: false,
																																				want:       "\"\\\\U\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 14, offset: 86064},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 26, offset: 86076},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 38, offset: 86088},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 50, offset: 86100},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 62, offset: 86112},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 74, offset: 86124},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 86, offset: 86136},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2493, col: 98, offset: 86148},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 2361, col: 19, offset: 81182},
																																					val:        "[0-9A-Fa-f]",
																																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																					ignoreCase: false,
																																					inverted:   false,
																																				},
																																			},
																																		},
																																	},
																																},
																																&seqExpr{
																																	pos: position{line: 2720, col: 36, offset: 95085},
																																	exprs: []interface{}{
																																		&litMatcher{
																																			pos:        position{line: 2720, col: 36, offset: 95085},
																																			val:        "\\",
																																			ignoreCase: false,
																																			want:       "\"\\\\\"",
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 2720, col: 41, offset: 95090},
																																			val:        "[abfnrtv\\\\\"]",
																																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 2718, col: 38, offset: 94977},
																																	val:        "[^\"\\\\\\n]",
																																	chars:      []rune{'"', '\\', '\n'},
																																	ignoreCase: false,
																																	inverted:   true,
																																},
																																&actionExpr{
																																	pos: position{line: 2607, col: 37, offset: 90735},
																																	run: (*parser).callonusesAndComments635,
																																	expr: &seqExpr{
																																		pos: position{line: 2607, col: 37, offset: 90735},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2607, col: 37, offset: 90735},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2631, col: 5, offset: 91752},
																																	run: (*parser).callonusesAndComments646,
																																	expr: &seqExpr{
																																		pos: position{line: 2631, col: 5, offset: 91752},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2631, col: 5, offset: 91752},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2652, col: 5, offset: 92594},
																																	run: (*parser).callonusesAndComments653,
																																	expr: &seqExpr{
																																		pos: position{line: 2652, col: 5, offset: 92594},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2652, col: 5, offset: 92594},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																			&charClassMatcher{
																																				pos:        position{line: 2361, col: 19, offset: 81182},
																																				val:        "[0-9A-Fa-f]",
																																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																																				ignoreCase: false,
																																				inverted:   false,
																																			},
																																		},
																																	},
																																},
																																&actionExpr{
																																	pos: position{line: 2670, col: 5, offset: 93280},
																																	run: (*parser).callonusesAndComments658,
																																	expr: &seqExpr{
																																		pos: position{line: 2670, col: 5, offset: 93280},
																																		exprs: []interface{}{
																																			&litMatcher{
																																				pos:        position{line: 2670, col: 5, offset: 93280},
																																				val:        "\\",
																																				ignoreCase: false,
																																				want:       "\"\\\\\"",
																																			},
																																			&zeroOrOneExpr{
																																				pos: position{line: 2670, col: 10, offset: 93285},
																																				expr: &charClassMatcher{
																																					pos:        position{line: 3735, col: 12, offset: 128270},
																																					val:        "[^\\r\\n]",
																																					chars:      []rune{'\r', '\n'},
																																					ignoreCase: false,
																																					inverted:   true,
																																				},
																																			},
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																												&labeledExpr{
																													pos:   position{line: 772, col: 98, offset: 23798},
																													label: "endPosI",
																													expr: &actionExpr{
																														pos: position{line: 3737, col: 8, offset: 128286},
																														run: (*parser).callonusesAndComments664,
																														expr: &choiceExpr{
																															pos: position{line: 3737, col: 9, offset: 128287},
																															alternatives: []interface{}{
																																&andExpr{
																																	pos: position{line: 3737, col: 9, offset: 128287},
																																	expr: &anyMatcher{
																																		line: 3737, col: 10, offset: 128288,
																																	},
																																},
																																&notExpr{
																																	pos: position{line: 3737, col: 14, offset: 128292},
																																	expr: &anyMatcher{
																																		line: 3737, col: 15, offset: 128293,
																																	},
																																},
																															},
																														},
																													},
																												},
																												&andExpr{
																													pos: position{line: 772, col: 110, offset: 23810},
																													expr: &seqExpr{
																														pos: position{line: 3734, col: 12, offset: 128237},
																														exprs: []interface{}{
																															&zeroOrMoreExpr{
																																pos: position{line: 3734, col: 12, offset: 128237},
																																expr: &charClassMatcher{
																																	pos:        position{line: 3746, col: 36, offset: 128584},
																																	val:        "[ \\t]",
																																	chars:      []rune{' ', '\t'},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																															&choiceExpr{
																																pos: position{line: 3734, col: 16, offset: 128241},
																																alternatives: []interface{}{
																																	&seqExpr{
																																		pos: position{line: 3734, col: 16, offset: 128241},
																																		exprs: []interface{}{
																																			&zeroOrOneExpr{
																																				pos: position{line: 3734, col: 16, offset: 128241},
																																				expr: &litMatcher{
																																					pos:        position{line: 3734, col: 16, offset: 128241},
																																					val:        "\r",
																																					ignoreCase: false,
																																					want:       "\"\\r\"",
																																				},
																																			},
																																			&litMatcher{
																																				pos:        position{line: 3734, col: 22, offset: 128247},
																																				val:        "\n",
																																				ignoreCase: false,
																																				want:       "\"\\n\"",
																																			},
																																		},
																																	},
																																	&notExpr{
																																		pos: position{line: 3733, col: 12, offset: 128223},
																																		expr: &anyMatcher{
																																			line: 3733, col: 13, offset: 128224,
																																		},
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 791, col: 22, offset: 24216},
																										run: (*parser).callonusesAndComments681,
																										expr: &seqExpr{
																											pos: position{line: 791, col: 22, offset: 24216},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 791, col: 22, offset: 24216},
																													val:        "'",
																													ignoreCase: false,
																													want:       "\"'\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 791, col: 27, offset: 24221},
																													label: "strI",
																													expr: &zeroOrMoreExpr{
																														pos: position{line: 791, col: 32, offset: 24226},
																														expr: &charClassMatcher{
																															pos:        position{line: 791, col: 32, offset: 24226},
																															val:        "[^\\\\r\\n]",
																															chars:      []rune{'\'', '\r', '\n'},
																															ignoreCase: false,
																															inverted:   true,
																														},
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 791, col: 42, offset: 24236},
																													val:        "'",
																													ignoreCase: false,
																													want:       "\"'\"",
																												},
																												&labeledExpr{
																													pos:   position{line: 791, col: 47, offset: 24241},
																													label: "endPosI",
																													expr: &actionExpr{
																														pos: position{line: 3737, col: 8, offset: 128286},
																														run: (*parser).callonusesAndComments689,
																														expr: &choiceExpr{
																															pos: position{line: 3737, col: 9, offset: 128287},
																															alternatives: []interface{}{
																																&andExpr{
																																	pos: position{line: 3737, col: 9, offset: 128287},
																																	expr: &anyMatcher{
																																		line: 3737, col: 10, offset: 128288,
																																	},
																																},
																																&notExpr{
																																	pos: position{line: 3737, col: 14, offset: 128292},
																																	expr: &anyMatcher{
																																		line: 3737, col: 15, offset: 128293,
																																	},
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 3178, col: 21, offset: 110333},
																										run: (*parser).callonusesAndComments695,
																										expr: &labeledExpr{
																											pos:   position{line: 3178, col: 21, offset: 110333},
																											label: "pathI",
																											expr: &zeroOrMoreExpr{
																												pos: position{line: 3178, col: 27, offset: 110339},
																												expr: &charClassMatcher{
																													pos:        position{line: 3735, col: 12, offset: 128270},
																													val:        "[^\\r\\n]",
																													chars:      []rune{'\r', '\n'},
																													ignoreCase: false,
																													inverted:   true,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&zeroOrMoreExpr{
																							pos: position{line: 3734, col: 12, offset: 128237},
																							expr: &charClassMatcher{
																								pos:        position{line: 3746, col: 36, offset: 128584},
																								val:        "[ \\t]",
																								chars:      []rune{' ', '\t'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&choiceExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							alternatives: []interface{}{
																								&seqExpr{
																									pos: position{line: 3734, col: 16, offset: 128241},
																									exprs: []interface{}{
																										&zeroOrOneExpr{
																											pos: position{line: 3734, col: 16, offset: 128241},
																											expr: &litMatcher{
																												pos:        position{line: 3734, col: 16, offset: 128241},
																												val:        "\r",
																												ignoreCase: false,
																												want:       "\"\\r\"",
																											},
																										},
																										&litMatcher{
																											pos:        position{line: 3734, col: 22, offset: 128247},
																											val:        "\n",
																											ignoreCase: false,
																											want:       "\"\\n\"",
																										},
																									},
																								},
																								&notExpr{
																									pos: position{line: 3733, col: 12, offset: 128223},
																									expr: &anyMatcher{
																										line: 3733, col: 13, offset: 128224,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 3298, col: 5, offset: 113809},
																run: (*parser).callonusesAndComments708,
																expr: &seqExpr{
																	pos: position{line: 3298, col: 5, offset: 113809},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 3298, col: 5, offset: 113809},
																			val:        "use",
																			ignoreCase: false,
																			want:       "\"use\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 3298, col: 11, offset: 113815},
																			label: "posI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonusesAndComments712,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 3734, col: 12, offset: 128237},
																			expr: &charClassMatcher{
																				pos:        position{line: 3746, col: 36, offset: 128584},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																		&choiceExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					exprs: []interface{}{
																						&zeroOrOneExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							expr: &litMatcher{
																								pos:        position{line: 3734, col: 16, offset: 128241},
																								val:        "\r",
																								ignoreCase: false,
																								want:       "\"\\r\"",
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 3734, col: 22, offset: 128247},
																							val:        "\n",
																							ignoreCase: false,
																							want:       "\"\\n\"",
																						},
																					},
																				},
																				&notExpr{
																					pos: position{line: 3733, col: 12, offset: 128223},
																					expr: &anyMatcher{
																						line: 3733, col: 13, offset: 128224,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "codesAndComments",
			pos:  position{line: 96, col: 1, offset: 2704},
			expr: &actionExpr{
				pos: position{line: 96, col: 21, offset: 2724},
				run: (*parser).calloncodesAndComments1,
				expr: &labeledExpr{
					pos:   position{line: 96, col: 21, offset: 2724},
					label: "valsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 96, col: 27, offset: 2730},
						expr: &seqExpr{
							pos: position{line: 96, col: 28, offset: 2731},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 96, col: 28, offset: 2731},
									expr: &ruleRefExpr{
										pos:  position{line: 96, col: 28, offset: 2731},
										name: "CorgiComments",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 96, col: 43, offset: 2746},
									expr: &oneOrMoreExpr{
										pos: position{line: 3748, col: 36, offset: 128671},
										expr: &seqExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 3748, col: 37, offset: 128672},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3747, col: 36, offset: 128625},
													expr: &litMatcher{
														pos:        position{line: 3747, col: 36, offset: 128625},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3747, col: 42, offset: 128631},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 96, col: 52, offset: 2755},
									name: "Codes",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "globalCodeAndFunc",
			pos:  position{line: 110, col: 1, offset: 3101},
			expr: &actionExpr{
				pos: position{line: 110, col: 22, offset: 3122},
				run: (*parser).callonglobalCodeAndFunc1,
				expr: &seqExpr{
					pos: position{line: 110, col: 22, offset: 3122},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 110, col: 22, offset: 3122},
							label: "codesAndCommentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 110, col: 40, offset: 3140},
								expr: &ruleRefExpr{
									pos:  position{line: 110, col: 40, offset: 3140},
									name: "codesAndComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 110, col: 58, offset: 3158},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 110, col: 67, offset: 3167},
							label: "commentsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 110, col: 77, offset: 3177},
								expr: &ruleRefExpr{
									pos:  position{line: 110, col: 77, offset: 3177},
									name: "CorgiComments",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 110, col: 92, offset: 3192},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 110, col: 101, offset: 3201},
							label: "funcI",
							expr: &ruleRefExpr{
								pos:  position{line: 110, col: 107, offset: 3207},
								name: "Func",
							},
						},
					},
				},
			},
		},
		{
			name: "Scope",
			pos:  position{line: 148, col: 1, offset: 4584},
			expr: &actionExpr{
				pos: position{line: 148, col: 10, offset: 4593},
				run: (*parser).callonScope1,
				expr: &labeledExpr{
					pos:   position{line: 148, col: 10, offset: 4593},
					label: "itemsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 148, col: 17, offset: 4600},
						expr: &seqExpr{
							pos: position{line: 148, col: 18, offset: 4601},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 148, col: 18, offset: 4601},
									expr: &oneOrMoreExpr{
										pos: position{line: 3748, col: 36, offset: 128671},
										expr: &seqExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 3748, col: 37, offset: 128672},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3747, col: 36, offset: 128625},
													expr: &litMatcher{
														pos:        position{line: 3747, col: 36, offset: 128625},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3747, col: 42, offset: 128631},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 3835, col: 17, offset: 132478},
									run: (*parser).callonScope13,
									expr: &zeroOrMoreExpr{
										pos: position{line: 3835, col: 17, offset: 132478},
										expr: &charClassMatcher{
											pos:        position{line: 3746, col: 36, offset: 128584},
											val:        "[ \\t]",
											chars:      []rune{' ', '\t'},
											ignoreCase: false,
											inverted:   false,
										},
									},
								},
								&andCodeExpr{
									pos: position{line: 3835, col: 41, offset: 132502},
									run: (*parser).callonScope16,
								},
								&choiceExpr{
									pos: position{line: 3887, col: 5, offset: 134412},
									alternatives: []interface{}{
										&andCodeExpr{
											pos: position{line: 3887, col: 5, offset: 134412},
											run: (*parser).callonScope18,
										},
										&seqExpr{
											pos: position{line: 3889, col: 9, offset: 134495},
											exprs: []interface{}{
												&andCodeExpr{
													pos: position{line: 3889, col: 9, offset: 134495},
													run: (*parser).callonScope20,
												},
												&stateCodeExpr{
													pos: position{line: 3891, col: 7, offset: 134599},
													run: (*parser).callonScope21,
												},
											},
										},
										&seqExpr{
											pos: position{line: 3898, col: 9, offset: 134935},
											exprs: []interface{}{
												&andCodeExpr{
													pos: position{line: 3898, col: 9, offset: 134935},
													run: (*parser).callonScope23,
												},
												&choiceExpr{
													pos: position{line: 3951, col: 9, offset: 137270},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 3951, col: 9, offset: 137270},
															exprs: []interface{}{
																&andCodeExpr{
																	pos: position{line: 3951, col: 9, offset: 137270},
																	run: (*parser).callonScope26,
																},
																&andCodeExpr{
																	pos: position{line: 3955, col: 11, offset: 137520},
																	run: (*parser).callonScope27,
																},
																&stateCodeExpr{
																	pos: position{line: 4021, col: 11, offset: 140726},
																	run: (*parser).callonScope28,
																},
															},
														},
														&seqExpr{
															pos: position{line: 4029, col: 13, offset: 141079},
															exprs: []interface{}{
																&andCodeExpr{
																	pos: position{line: 4029, col: 13, offset: 141079},
																	run: (*parser).callonScope30,
																},
																&andCodeExpr{
																	pos: position{line: 4033, col: 11, offset: 141334},
																	run: (*parser).callonScope31,
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 148, col: 39, offset: 4622},
									name: "scopeItem",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "scopeItem",
			pos:  position{line: 161, col: 1, offset: 4894},
			expr: &choiceExpr{
				pos: position{line: 162, col: 5, offset: 4913},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 162, col: 5, offset: 4913},
						name: "Block",
					},
					&ruleRefExpr{
						pos:  position{line: 162, col: 13, offset: 4921},
						name: "Prepend",
					},
					&ruleRefExpr{
						pos:  position{line: 162, col: 23, offset: 4931},
						name: "Append",
					},
					&ruleRefExpr{
						pos:  position{line: 163, col: 5, offset: 4959},
						name: "Code",
					},
					&ruleRefExpr{
						pos:  position{line: 164, col: 5, offset: 5004},
						name: "If",
					},
					&ruleRefExpr{
						pos:  position{line: 164, col: 10, offset: 5009},
						name: "IfBlock",
					},
					&ruleRefExpr{
						pos:  position{line: 164, col: 20, offset: 5019},
						name: "Switch",
					},
					&ruleRefExpr{
						pos:  position{line: 165, col: 5, offset: 5063},
						name: "HTMLComment",
					},
					&ruleRefExpr{
						pos:  position{line: 165, col: 19, offset: 5077},
						name: "And",
					},
					&actionExpr{
						pos: position{line: 2252, col: 14, offset: 77714},
						run: (*parser).callonscopeItem11,
						expr: &seqExpr{
							pos: position{line: 2252, col: 14, offset: 77714},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2252, col: 14, offset: 77714},
									val:        ":raw",
									ignoreCase: false,
									want:       "\":raw\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2252, col: 25, offset: 77725},
									label: "bodyI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2252, col: 31, offset: 77731},
										expr: &actionExpr{
											pos: position{line: 2304, col: 15, offset: 79426},
											run: (*parser).callonscopeItem25,
											expr: &seqExpr{
												pos: position{line: 2304, col: 15, offset: 79426},
												exprs: []interface{}{
													&stateCodeExpr{
														pos: position{line: 4214, col: 11, offset: 148867},
														run: (*parser).callonscopeItem27,
													},
													&labeledExpr{
														pos:   position{line: 2304, col: 22, offset: 79433},
														label: "linesI",
														expr: &oneOrMoreExpr{
															pos: position{line: 2304, col: 29, offset: 79440},
															expr: &seqExpr{
																pos: position{line: 2304, col: 30, offset: 79441},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 2304, col: 30, offset: 79441},
																		expr: &oneOrMoreExpr{
																			pos: position{line: 3748, col: 36, offset: 128671},
																			expr: &seqExpr{
																				pos: position{line: 3748, col: 37, offset: 128672},
																				exprs: []interface{}{
																					&zeroOrMoreExpr{
																						pos: position{line: 3748, col: 37, offset: 128672},
																						expr: &charClassMatcher{
																							pos:        position{line: 3746, col: 36, offset: 128584},
																							val:        "[ \\t]",
																							chars:      []rune{' ', '\t'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 3747, col: 36, offset: 128625},
																						expr: &litMatcher{
																							pos:        position{line: 3747, col: 36, offset: 128625},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3747, col: 42, offset: 128631},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2308, col: 15, offset: 79555},
																		run: (*parser).callonscopeItem39,
																		expr: &seqExpr{
																			pos: position{line: 2308, col: 15, offset: 79555},
																			exprs: []interface{}{
																				&actionExpr{
																					pos: position{line: 3835, col: 17, offset: 132478},
																					run: (*parser).callonscopeItem41,
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 3835, col: 17, offset: 132478},
																						expr: &charClassMatcher{
																							pos:        position{line: 3746, col: 36, offset: 128584},
																							val:        "[ \\t]",
																							chars:      []rune{' ', '\t'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&andCodeExpr{
																					pos: position{line: 3835, col: 41, offset: 132502},
																					run: (*parser).callonscopeItem44,
																				},
																				&choiceExpr{
																					pos: position{line: 3887, col: 5, offset: 134412},
																					alternatives: []interface{}{
																						&andCodeExpr{
																							pos: position{line: 3887, col: 5, offset: 134412},
																							run: (*parser).callonscopeItem46,
																						},
																						&seqExpr{
																							pos: position{line: 3889, col: 9, offset: 134495},
																							exprs: []interface{}{
																								&andCodeExpr{
																									pos: position{line: 3889, col: 9, offset: 134495},
																									run: (*parser).callonscopeItem48,
																								},
																								&stateCodeExpr{
																									pos: position{line: 3891, col: 7, offset: 134599},
																									run: (*parser).callonscopeItem49,
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 3898, col: 9, offset: 134935},
																							exprs: []interface{}{
																								&andCodeExpr{
																									pos: position{line: 3898, col: 9, offset: 134935},
																									run: (*parser).callonscopeItem51,
																								},
																								&choiceExpr{
																									pos: position{line: 3951, col: 9, offset: 137270},
																									alternatives: []interface{}{
																										&seqExpr{
																											pos: position{line: 3951, col: 9, offset: 137270},
																											exprs: []interface{}{
																												&andCodeExpr{
																													pos: position{line: 3951, col: 9, offset: 137270},
																													run: (*parser).callonscopeItem54,
																												},
																												&andCodeExpr{
																													pos: position{line: 3955, col: 11, offset: 137520},
																													run: (*parser).callonscopeItem55,
																												},
																												&stateCodeExpr{
																													pos: position{line: 4021, col: 11, offset: 140726},
																													run: (*parser).callonscopeItem56,
																												},
																											},
																										},
																										&seqExpr{
																											pos: position{line: 4029, col: 13, offset: 141079},
																											exprs: []interface{}{
																												&andCodeExpr{
																													pos: position{line: 4029, col: 13, offset: 141079},
																													run: (*parser).callonscopeItem58,
																												},
																												&andCodeExpr{
																													pos: position{line: 4033, col: 11, offset: 141334},
																													run: (*parser).callonscopeItem59,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 2308, col: 27, offset: 79567},
																					label: "posI",
																					expr: &actionExpr{
																						pos: position{line: 3737, col: 8, offset: 128286},
																						run: (*parser).callonscopeItem61,
																						expr: &choiceExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							alternatives: []interface{}{
																								&andExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									expr: &anyMatcher{
																										line: 3737, col: 10, offset: 128288,
																									},
																								},
																								&notExpr{
																									pos: position{line: 3737, col: 14, offset: 128292},
																									expr: &anyMatcher{
																										line: 3737, col: 15, offset: 128293,
																									},
																								},
																							},
																						},
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 2308, col: 36, offset: 79576},
																					label: "lineI",
																					expr: &oneOrMoreExpr{
																						pos: position{line: 2308, col: 42, offset: 79582},
																						expr: &charClassMatcher{
																							pos:        position{line: 3735, col: 12, offset: 128270},
																							val:        "[^\\r\\n]",
																							chars:      []rune{'\r', '\n'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																					},
																				},
																				&zeroOrMoreExpr{
																					pos: position{line: 3734, col: 12, offset: 128237},
																					expr: &charClassMatcher{
																						pos:        position{line: 3746, col: 36, offset: 128584},
																						val:        "[ \\t]",
																						chars:      []rune{' ', '\t'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&choiceExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					alternatives: []interface{}{
																						&seqExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							exprs: []interface{}{
																								&zeroOrOneExpr{
																									pos: position{line: 3734, col: 16, offset: 128241},
																									expr: &litMatcher{
																										pos:        position{line: 3734, col: 16, offset: 128241},
																										val:        "\r",
																										ignoreCase: false,
																										want:       "\"\\r\"",
																									},
																								},
																								&litMatcher{
																									pos:        position{line: 3734, col: 22, offset: 128247},
																									val:        "\n",
																									ignoreCase: false,
																									want:       "\"\\n\"",
																								},
																							},
																						},
																						&notExpr{
																							pos: position{line: 3733, col: 12, offset: 128223},
																							expr: &anyMatcher{
																								line: 3733, col: 13, offset: 128224,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&stateCodeExpr{
														pos: position{line: 4219, col: 11, offset: 148972},
														run: (*parser).callonscopeItem79,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2263, col: 18, offset: 78072},
						run: (*parser).callonscopeItem80,
						expr: &seqExpr{
							pos: position{line: 2263, col: 18, offset: 78072},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2263, col: 18, offset: 78072},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&labeledExpr{
									pos:   position{line: 2263, col: 22, offset: 78076},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 2263, col: 28, offset: 78082},
										expr: &charClassMatcher{
											pos:        position{line: 2263, col: 28, offset: 78082},
											val:        "[^ \\t\\r\\n]",
											chars:      []rune{' ', '\t', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2263, col: 40, offset: 78094},
									label: "argsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2263, col: 46, offset: 78100},
										expr: &seqExpr{
											pos: position{line: 2263, col: 47, offset: 78101},
											exprs: []interface{}{
												&oneOrMoreExpr{
													pos: position{line: 2263, col: 47, offset: 78101},
													expr: &litMatcher{
														pos:        position{line: 2263, col: 47, offset: 78101},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&choiceExpr{
													pos: position{line: 2272, col: 21, offset: 78393},
													alternatives: []interface{}{
														&actionExpr{
															pos: position{line: 2274, col: 27, offset: 78456},
															run: (*parser).callonscopeItem92,
															expr: &labeledExpr{
																pos:   position{line: 2274, col: 27, offset: 78456},
																label: "stringI",
																expr: &choiceExpr{
																	pos: position{line: 743, col: 11, offset: 22871},
																	alternatives: []interface{}{
																		&actionExpr{
																			pos: position{line: 749, col: 14, offset: 22958},
																			run: (*parser).callonscopeItem95,
																			expr: &seqExpr{
																				pos: position{line: 749, col: 14, offset: 22958},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 749, col: 14, offset: 22958},
																						val:        "`",
																						ignoreCase: false,
																						want:       "\"`\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 749, col: 18, offset: 22962},
																						label: "strI",
																						expr: &zeroOrMoreExpr{
																							pos: position{line: 749, col: 23, offset: 22967},
																							expr: &charClassMatcher{
																								pos:        position{line: 2704, col: 27, offset: 94307},
																								val:        "[^\\n`]",
																								chars:      []rune{'\n', '`'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 749, col: 47, offset: 22991},
																						val:        "`",
																						ignoreCase: false,
																						want:       "\"`\"",
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 751, col: 5, offset: 23083},
																			run: (*parser).callonscopeItem102,
																			expr: &seqExpr{
																				pos: position{line: 751, col: 5, offset: 23083},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 751, col: 5, offset: 23083},
																						val:        "`",
																						ignoreCase: false,
																						want:       "\"`\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 751, col: 9, offset: 23087},
																						label: "strI",
																						expr: &zeroOrMoreExpr{
																							pos: position{line: 751, col: 14, offset: 23092},
																							expr: &charClassMatcher{
																								pos:        position{line: 2704, col: 27, offset: 94307},
																								val:        "[^\\n`]",
																								chars:      []rune{'\n', '`'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																					&andExpr{
																						pos: position{line: 751, col: 38, offset: 23116},
																						expr: &seqExpr{
																							pos: position{line: 3734, col: 12, offset: 128237},
																							exprs: []interface{}{
																								&zeroOrMoreExpr{
																									pos: position{line: 3734, col: 12, offset: 128237},
																									expr: &charClassMatcher{
																										pos:        position{line: 3746, col: 36, offset: 128584},
																										val:        "[ \\t]",
																										chars:      []rune{' ', '\t'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&choiceExpr{
																									pos: position{line: 3734, col: 16, offset: 128241},
																									alternatives: []interface{}{
																										&seqExpr{
																											pos: position{line: 3734, col: 16, offset: 128241},
																											exprs: []interface{}{
																												&zeroOrOneExpr{
																													pos: position{line: 3734, col: 16, offset: 128241},
																													expr: &litMatcher{
																														pos:        position{line: 3734, col: 16, offset: 128241},
																														val:        "\r",
																														ignoreCase: false,
																														want:       "\"\\r\"",
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 3734, col: 22, offset: 128247},
																													val:        "\n",
																													ignoreCase: false,
																													want:       "\"\\n\"",
																												},
																											},
																										},
																										&notExpr{
																											pos: position{line: 3733, col: 12, offset: 128223},
																											expr: &anyMatcher{
																												line: 3733, col: 13, offset: 128224,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 770, col: 22, offset: 23520},
																			run: (*parser).callonscopeItem119,
																			expr: &seqExpr{
																				pos: position{line: 770, col: 22, offset: 23520},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 770, col: 22, offset: 23520},
																						val:        "\"",
																						ignoreCase: false,
																						want:       "\"\\\"\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 770, col: 26, offset: 23524},
																						label: "strI",
																						expr: &zeroOrMoreExpr{
																							pos: position{line: 770, col: 31, offset: 23529},
																							expr: &choiceExpr{
																								pos: position{line: 770, col: 32, offset: 23530},
																								alternatives: []interface{}{
																									&seqExpr{
																										pos: position{line: 2443, col: 24, offset: 83970},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2443, col: 24, offset: 83970},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2444, col: 24, offset: 84037},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2444, col: 24, offset: 84037},
																												val:        "\\x",
																												ignoreCase: false,
																												want:       "\"\\\\x\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2445, col: 5, offset: 84074},
																										run: (*parser).callonscopeItem134,
																										expr: &seqExpr{
																											pos: position{line: 2445, col: 5, offset: 84074},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2445, col: 5, offset: 84074},
																													val:        "\\x",
																													ignoreCase: false,
																													want:       "\"\\\\x\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2445, col: 14, offset: 84083},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2445, col: 26, offset: 84095},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2462, col: 19, offset: 84712},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2462, col: 19, offset: 84712},
																												val:        "\\u",
																												ignoreCase: false,
																												want:       "\"\\\\u\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2463, col: 5, offset: 84771},
																										run: (*parser).callonscopeItem147,
																										expr: &seqExpr{
																											pos: position{line: 2463, col: 5, offset: 84771},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2463, col: 5, offset: 84771},
																													val:        "\\u",
																													ignoreCase: false,
																													want:       "\"\\\\u\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 14, offset: 84780},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 26, offset: 84792},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 38, offset: 84804},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 50, offset: 84816},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2492, col: 16, offset: 85952},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2492, col: 16, offset: 85952},
																												val:        "\\U",
																												ignoreCase: false,
																												want:       "\"\\\\U\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2493, col: 5, offset: 86055},
																										run: (*parser).callonscopeItem168,
																										expr: &seqExpr{
																											pos: position{line: 2493, col: 5, offset: 86055},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2493, col: 5, offset: 86055},
																													val:        "\\U",
																													ignoreCase: false,
																													want:       "\"\\\\U\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 14, offset: 86064},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 26, offset: 86076},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 38, offset: 86088},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 50, offset: 86100},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 62, offset: 86112},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 74, offset: 86124},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 86, offset: 86136},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 98, offset: 86148},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2720, col: 36, offset: 95085},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2720, col: 36, offset: 95085},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2720, col: 41, offset: 95090},
																												val:        "[abfnrtv\\\\\"]",
																												chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 2718, col: 38, offset: 94977},
																										val:        "[^\"\\\\\\n]",
																										chars:      []rune{'"', '\\', '\n'},
																										ignoreCase: false,
																										inverted:   true,
																									},
																									&actionExpr{
																										pos: position{line: 2607, col: 37, offset: 90735},
																										run: (*parser).callonscopeItem191,
																										expr: &seqExpr{
																											pos: position{line: 2607, col: 37, offset: 90735},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2607, col: 37, offset: 90735},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2631, col: 5, offset: 91752},
																										run: (*parser).callonscopeItem202,
																										expr: &seqExpr{
																											pos: position{line: 2631, col: 5, offset: 91752},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2631, col: 5, offset: 91752},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2652, col: 5, offset: 92594},
																										run: (*parser).callonscopeItem209,
																										expr: &seqExpr{
																											pos: position{line: 2652, col: 5, offset: 92594},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2652, col: 5, offset: 92594},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2670, col: 5, offset: 93280},
																										run: (*parser).callonscopeItem214,
																										expr: &seqExpr{
																											pos: position{line: 2670, col: 5, offset: 93280},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2670, col: 5, offset: 93280},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2670, col: 10, offset: 93285},
																													expr: &charClassMatcher{
																														pos:        position{line: 3735, col: 12, offset: 128270},
																														val:        "[^\\r\\n]",
																														chars:      []rune{'\r', '\n'},
																														ignoreCase: false,
																														inverted:   true,
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 770, col: 115, offset: 23613},
																						val:        "\"",
																						ignoreCase: false,
																						want:       "\"\\\"\"",
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 772, col: 5, offset: 23705},
																			run: (*parser).callonscopeItem220,
																			expr: &seqExpr{
																				pos: position{line: 772, col: 5, offset: 23705},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 772, col: 5, offset: 23705},
																						val:        "\"",
																						ignoreCase: false,
																						want:       "\"\\\"\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 772, col: 9, offset: 23709},
																						label: "strI",
																						expr: &zeroOrMoreExpr{
																							pos: position{line: 772, col: 14, offset: 23714},
																							expr: &choiceExpr{
																								pos: position{line: 772, col: 15, offset: 23715},
																								alternatives: []interface{}{
																									&seqExpr{
																										pos: position{line: 2443, col: 24, offset: 83970},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2443, col: 24, offset: 83970},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2360, col: 19, offset: 81158},
																												val:        "[0-7]",
																												ranges:     []rune{'0', '7'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2444, col: 24, offset: 84037},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2444, col: 24, offset: 84037},
																												val:        "\\x",
																												ignoreCase: false,
																												want:       "\"\\\\x\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2445, col: 5, offset: 84074},
																										run: (*parser).callonscopeItem235,
																										expr: &seqExpr{
																											pos: position{line: 2445, col: 5, offset: 84074},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2445, col: 5, offset: 84074},
																													val:        "\\x",
																													ignoreCase: false,
																													want:       "\"\\\\x\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2445, col: 14, offset: 84083},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2445, col: 26, offset: 84095},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2462, col: 19, offset: 84712},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2462, col: 19, offset: 84712},
																												val:        "\\u",
																												ignoreCase: false,
																												want:       "\"\\\\u\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2463, col: 5, offset: 84771},
																										run: (*parser).callonscopeItem248,
																										expr: &seqExpr{
																											pos: position{line: 2463, col: 5, offset: 84771},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2463, col: 5, offset: 84771},
																													val:        "\\u",
																													ignoreCase: false,
																													want:       "\"\\\\u\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 14, offset: 84780},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 26, offset: 84792},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 38, offset: 84804},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2463, col: 50, offset: 84816},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2492, col: 16, offset: 85952},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2492, col: 16, offset: 85952},
																												val:        "\\U",
																												ignoreCase: false,
																												want:       "\"\\\\U\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&charClassMatcher{
																												pos:        position{line: 2361, col: 19, offset: 81182},
																												val:        "[0-9A-Fa-f]",
																												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2493, col: 5, offset: 86055},
																										run: (*parser).callonscopeItem269,
																										expr: &seqExpr{
																											pos: position{line: 2493, col: 5, offset: 86055},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2493, col: 5, offset: 86055},
																													val:        "\\U",
																													ignoreCase: false,
																													want:       "\"\\\\U\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 14, offset: 86064},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 26, offset: 86076},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 38, offset: 86088},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 50, offset: 86100},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 62, offset: 86112},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 74, offset: 86124},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 86, offset: 86136},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2493, col: 98, offset: 86148},
																													expr: &charClassMatcher{
																														pos:        position{line: 2361, col: 19, offset: 81182},
																														val:        "[0-9A-Fa-f]",
																														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																										},
																									},
																									&seqExpr{
																										pos: position{line: 2720, col: 36, offset: 95085},
																										exprs: []interface{}{
																											&litMatcher{
																												pos:        position{line: 2720, col: 36, offset: 95085},
																												val:        "\\",
																												ignoreCase: false,
																												want:       "\"\\\\\"",
																											},
																											&charClassMatcher{
																												pos:        position{line: 2720, col: 41, offset: 95090},
																												val:        "[abfnrtv\\\\\"]",
																												chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 2718, col: 38, offset: 94977},
																										val:        "[^\"\\\\\\n]",
																										chars:      []rune{'"', '\\', '\n'},
																										ignoreCase: false,
																										inverted:   true,
																									},
																									&actionExpr{
																										pos: position{line: 2607, col: 37, offset: 90735},
																										run: (*parser).callonscopeItem292,
																										expr: &seqExpr{
																											pos: position{line: 2607, col: 37, offset: 90735},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2607, col: 37, offset: 90735},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2631, col: 5, offset: 91752},
																										run: (*parser).callonscopeItem303,
																										expr: &seqExpr{
																											pos: position{line: 2631, col: 5, offset: 91752},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2631, col: 5, offset: 91752},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2652, col: 5, offset: 92594},
																										run: (*parser).callonscopeItem310,
																										expr: &seqExpr{
																											pos: position{line: 2652, col: 5, offset: 92594},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2652, col: 5, offset: 92594},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																												&charClassMatcher{
																													pos:        position{line: 2361, col: 19, offset: 81182},
																													val:        "[0-9A-Fa-f]",
																													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																									&actionExpr{
																										pos: position{line: 2670, col: 5, offset: 93280},
																										run: (*parser).callonscopeItem315,
																										expr: &seqExpr{
																											pos: position{line: 2670, col: 5, offset: 93280},
																											exprs: []interface{}{
																												&litMatcher{
																													pos:        position{line: 2670, col: 5, offset: 93280},
																													val:        "\\",
																													ignoreCase: false,
																													want:       "\"\\\\\"",
																												},
																												&zeroOrOneExpr{
																													pos: position{line: 2670, col: 10, offset: 93285},
																													expr: &charClassMatcher{
																														pos:        position{line: 3735, col: 12, offset: 128270},
																														val:        "[^\\r\\n]",
																														chars:      []rune{'\r', '\n'},
																														ignoreCase: false,
																														inverted:   true,
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																					&labeledExpr{
																						pos:   position{line: 772, col: 98, offset: 23798},
																						label: "endPosI",
																						expr: &actionExpr{
																							pos: position{line: 3737, col: 8, offset: 128286},
																							run: (*parser).callonscopeItem321,
																							expr: &choiceExpr{
																								pos: position{line: 3737, col: 9, offset: 128287},
																								alternatives: []interface{}{
																									&andExpr{
																										pos: position{line: 3737, col: 9, offset: 128287},
																										expr: &anyMatcher{
																											line: 3737, col: 10, offset: 128288,
																										},
																									},
																									&notExpr{
																										pos: position{line: 3737, col: 14, offset: 128292},
																										expr: &anyMatcher{
																											line: 3737, col: 15, offset: 128293,
																										},
																									},
																								},
																							},
																						},
																					},
																					&andExpr{
																						pos: position{line: 772, col: 110, offset: 23810},
																						expr: &seqExpr{
																							pos: position{line: 3734, col: 12, offset: 128237},
																							exprs: []interface{}{
																								&zeroOrMoreExpr{
																									pos: position{line: 3734, col: 12, offset: 128237},
																									expr: &charClassMatcher{
																										pos:        position{line: 3746, col: 36, offset: 128584},
																										val:        "[ \\t]",
																										chars:      []rune{' ', '\t'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&choiceExpr{
																									pos: position{line: 3734, col: 16, offset: 128241},
																									alternatives: []interface{}{
																										&seqExpr{
																											pos: position{line: 3734, col: 16, offset: 128241},
																											exprs: []interface{}{
																												&zeroOrOneExpr{
																													pos: position{line: 3734, col: 16, offset: 128241},
																													expr: &litMatcher{
																														pos:        position{line: 3734, col: 16, offset: 128241},
																														val:        "\r",
																														ignoreCase: false,
																														want:       "\"\\r\"",
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 3734, col: 22, offset: 128247},
																													val:        "\n",
																													ignoreCase: false,
																													want:       "\"\\n\"",
																												},
																											},
																										},
																										&notExpr{
																											pos: position{line: 3733, col: 12, offset: 128223},
																											expr: &anyMatcher{
																												line: 3733, col: 13, offset: 128224,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 791, col: 22, offset: 24216},
																			run: (*parser).callonscopeItem338,
																			expr: &seqExpr{
																				pos: position{line: 791, col: 22, offset: 24216},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 791, col: 22, offset: 24216},
																						val:        "'",
																						ignoreCase: false,
																						want:       "\"'\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 791, col: 27, offset: 24221},
																						label: "strI",
																						expr: &zeroOrMoreExpr{
																							pos: position{line: 791, col: 32, offset: 24226},
																							expr: &charClassMatcher{
																								pos:        position{line: 791, col: 32, offset: 24226},
																								val:        "[^\\\\r\\n]",
																								chars:      []rune{'\'', '\r', '\n'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 791, col: 42, offset: 24236},
																						val:        "'",
																						ignoreCase: false,
																						want:       "\"'\"",
																					},
																					&labeledExpr{
																						pos:   position{line: 791, col: 47, offset: 24241},
																						label: "endPosI",
																						expr: &actionExpr{
																							pos: position{line: 3737, col: 8, offset: 128286},
																							run: (*parser).callonscopeItem346,
																							expr: &choiceExpr{
																								pos: position{line: 3737, col: 9, offset: 128287},
																								alternatives: []interface{}{
																									&andExpr{
																										pos: position{line: 3737, col: 9, offset: 128287},
																										expr: &anyMatcher{
																											line: 3737, col: 10, offset: 128288,
																										},
																									},
																									&notExpr{
																										pos: position{line: 3737, col: 14, offset: 128292},
																										expr: &anyMatcher{
																											line: 3737, col: 15, offset: 128293,
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 2278, col: 15, offset: 78557},
															run: (*parser).callonscopeItem352,
															expr: &labeledExpr{
																pos:   position{line: 2278, col: 15, offset: 78557},
																label: "argI",
																expr: &oneOrMoreExpr{
																	pos: position{line: 2278, col: 20, offset: 78562},
																	expr: &charClassMatcher{
																		pos:        position{line: 2278, col: 20, offset: 78562},
																		val:        "[^ \\t\\r\\n]",
																		chars:      []rune{' ', '\t', '\r', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2263, col: 75, offset: 78129},
									label: "bodyI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2263, col: 81, offset: 78135},
										expr: &actionExpr{
											pos: position{line: 2304, col: 15, offset: 79426},
											run: (*parser).callonscopeItem367,
											expr: &seqExpr{
												pos: position{line: 2304, col: 15, offset: 79426},
												exprs: []interface{}{
													&stateCodeExpr{
														pos: position{line: 4214, col: 11, offset: 148867},
														run: (*parser).callonscopeItem369,
													},
													&labeledExpr{
														pos:   position{line: 2304, col: 22, offset: 79433},
														label: "linesI",
														expr: &oneOrMoreExpr{
															pos: position{line: 2304, col: 29, offset: 79440},
															expr: &seqExpr{
																pos: position{line: 2304, col: 30, offset: 79441},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 2304, col: 30, offset: 79441},
																		expr: &oneOrMoreExpr{
																			pos: position{line: 3748, col: 36, offset: 128671},
																			expr: &seqExpr{
																				pos: position{line: 3748, col: 37, offset: 128672},
																				exprs: []interface{}{
																					&zeroOrMoreExpr{
																						pos: position{line: 3748, col: 37, offset: 128672},
																						expr: &charClassMatcher{
																							pos:        position{line: 3746, col: 36, offset: 128584},
																							val:        "[ \\t]",
																							chars:      []rune{' ', '\t'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 3747, col: 36, offset: 128625},
																						expr: &litMatcher{
																							pos:        position{line: 3747, col: 36, offset: 128625},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3747, col: 42, offset: 128631},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2308, col: 15, offset: 79555},
																		run: (*parser).callonscopeItem381,
																		expr: &seqExpr{
																			pos: position{line: 2308, col: 15, offset: 79555},
																			exprs: []interface{}{
																				&actionExpr{
																					pos: position{line: 3835, col: 17, offset: 132478},
																					run: (*parser).callonscopeItem383,
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 3835, col: 17, offset: 132478},
																						expr: &charClassMatcher{
																							pos:        position{line: 3746, col: 36, offset: 128584},
																							val:        "[ \\t]",
																							chars:      []rune{' ', '\t'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&andCodeExpr{
																					pos: position{line: 3835, col: 41, offset: 132502},
																					run: (*parser).callonscopeItem386,
																				},
																				&choiceExpr{
																					pos: position{line: 3887, col: 5, offset: 134412},
																					alternatives: []interface{}{
																						&andCodeExpr{
																							pos: position{line: 3887, col: 5, offset: 134412},
																							run: (*parser).callonscopeItem388,
																						},
																						&seqExpr{
																							pos: position{line: 3889, col: 9, offset: 134495},
																							exprs: []interface{}{
																								&andCodeExpr{
																									pos: position{line: 3889, col: 9, offset: 134495},
																									run: (*parser).callonscopeItem390,
																								},
																								&stateCodeExpr{
																									pos: position{line: 3891, col: 7, offset: 134599},
																									run: (*parser).callonscopeItem391,
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 3898, col: 9, offset: 134935},
																							exprs: []interface{}{
																								&andCodeExpr{
																									pos: position{line: 3898, col: 9, offset: 134935},
																									run: (*parser).callonscopeItem393,
																								},
																								&choiceExpr{
																									pos: position{line: 3951, col: 9, offset: 137270},
																									alternatives: []interface{}{
																										&seqExpr{
																											pos: position{line: 3951, col: 9, offset: 137270},
																											exprs: []interface{}{
																												&andCodeExpr{
																													pos: position{line: 3951, col: 9, offset: 137270},
																													run: (*parser).callonscopeItem396,
																												},
																												&andCodeExpr{
																													pos: position{line: 3955, col: 11, offset: 137520},
																													run: (*parser).callonscopeItem397,
																												},
																												&stateCodeExpr{
																													pos: position{line: 4021, col: 11, offset: 140726},
																													run: (*parser).callonscopeItem398,
																												},
																											},
																										},
																										&seqExpr{
																											pos: position{line: 4029, col: 13, offset: 141079},
																											exprs: []interface{}{
																												&andCodeExpr{
																													pos: position{line: 4029, col: 13, offset: 141079},
																													run: (*parser).callonscopeItem400,
																												},
																												&andCodeExpr{
																													pos: position{line: 4033, col: 11, offset: 141334},
																													run: (*parser).callonscopeItem401,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 2308, col: 27, offset: 79567},
																					label: "posI",
																					expr: &actionExpr{
																						pos: position{line: 3737, col: 8, offset: 128286},
																						run: (*parser).callonscopeItem403,
																						expr: &choiceExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							alternatives: []interface{}{
																								&andExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									expr: &anyMatcher{
																										line: 3737, col: 10, offset: 128288,
																									},
																								},
																								&notExpr{
																									pos: position{line: 3737, col: 14, offset: 128292},
																									expr: &anyMatcher{
																										line: 3737, col: 15, offset: 128293,
																									},
																								},
																							},
																						},
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 2308, col: 36, offset: 79576},
																					label: "lineI",
																					expr: &oneOrMoreExpr{
																						pos: position{line: 2308, col: 42, offset: 79582},
																						expr: &charClassMatcher{
																							pos:        position{line: 3735, col: 12, offset: 128270},
																							val:        "[^\\r\\n]",
																							chars:      []rune{'\r', '\n'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																					},
																				},
																				&zeroOrMoreExpr{
																					pos: position{line: 3734, col: 12, offset: 128237},
																					expr: &charClassMatcher{
																						pos:        position{line: 3746, col: 36, offset: 128584},
																						val:        "[ \\t]",
																						chars:      []rune{' ', '\t'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&choiceExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					alternatives: []interface{}{
																						&seqExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							exprs: []interface{}{
																								&zeroOrOneExpr{
																									pos: position{line: 3734, col: 16, offset: 128241},
																									expr: &litMatcher{
																										pos:        position{line: 3734, col: 16, offset: 128241},
																										val:        "\r",
																										ignoreCase: false,
																										want:       "\"\\r\"",
																									},
																								},
																								&litMatcher{
																									pos:        position{line: 3734, col: 22, offset: 128247},
																									val:        "\n",
																									ignoreCase: false,
																									want:       "\"\\n\"",
																								},
																							},
																						},
																						&notExpr{
																							pos: position{line: 3733, col: 12, offset: 128223},
																							expr: &anyMatcher{
																								line: 3733, col: 13, offset: 128224,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&stateCodeExpr{
														pos: position{line: 4219, col: 11, offset: 148972},
														run: (*parser).callonscopeItem421,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2286, col: 14, offset: 78857},
						run: (*parser).callonscopeItem422,
						expr: &seqExpr{
							pos: position{line: 2286, col: 14, offset: 78857},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2286, col: 14, offset: 78857},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2286, col: 22, offset: 78865},
									label: "bodyI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2286, col: 28, offset: 78871},
										expr: &actionExpr{
											pos: position{line: 2304, col: 15, offset: 79426},
											run: (*parser).callonscopeItem436,
											expr: &seqExpr{
												pos: position{line: 2304, col: 15, offset: 79426},
												exprs: []interface{}{
													&stateCodeExpr{
														pos: position{line: 4214, col: 11, offset: 148867},
														run: (*parser).callonscopeItem438,
													},
													&labeledExpr{
														pos:   position{line: 2304, col: 22, offset: 79433},
														label: "linesI",
														expr: &oneOrMoreExpr{
															pos: position{line: 2304, col: 29, offset: 79440},
															expr: &seqExpr{
																pos: position{line: 2304, col: 30, offset: 79441},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 2304, col: 30, offset: 79441},
																		expr: &oneOrMoreExpr{
																			pos: position{line: 3748, col: 36, offset: 128671},
																			expr: &seqExpr{
																				pos: position{line: 3748, col: 37, offset: 128672},
																				exprs: []interface{}{
																					&zeroOrMoreExpr{
																						pos: position{line: 3748, col: 37, offset: 128672},
																						expr: &charClassMatcher{
																							pos:        position{line: 3746, col: 36, offset: 128584},
																							val:        "[ \\t]",
																							chars:      []rune{' ', '\t'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 3747, col: 36, offset: 128625},
																						expr: &litMatcher{
																							pos:        position{line: 3747, col: 36, offset: 128625},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3747, col: 42, offset: 128631},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 2308, col: 15, offset: 79555},
																		run: (*parser).callonscopeItem450,
																		expr: &seqExpr{
																			pos: position{line: 2308, col: 15, offset: 79555},
																			exprs: []interface{}{
																				&actionExpr{
																					pos: position{line: 3835, col: 17, offset: 132478},
																					run: (*parser).callonscopeItem452,
																					expr: &zeroOrMoreExpr{
																						pos: position{line: 3835, col: 17, offset: 132478},
																						expr: &charClassMatcher{
																							pos:        position{line: 3746, col: 36, offset: 128584},
																							val:        "[ \\t]",
																							chars:      []rune{' ', '\t'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&andCodeExpr{
																					pos: position{line: 3835, col: 41, offset: 132502},
																					run: (*parser).callonscopeItem455,
																				},
																				&choiceExpr{
																					pos: position{line: 3887, col: 5, offset: 134412},
																					alternatives: []interface{}{
																						&andCodeExpr{
																							pos: position{line: 3887, col: 5, offset: 134412},
																							run: (*parser).callonscopeItem457,
																						},
																						&seqExpr{
																							pos: position{line: 3889, col: 9, offset: 134495},
																							exprs: []interface{}{
																								&andCodeExpr{
																									pos: position{line: 3889, col: 9, offset: 134495},
																									run: (*parser).callonscopeItem459,
																								},
																								&stateCodeExpr{
																									pos: position{line: 3891, col: 7, offset: 134599},
																									run: (*parser).callonscopeItem460,
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 3898, col: 9, offset: 134935},
																							exprs: []interface{}{
																								&andCodeExpr{
																									pos: position{line: 3898, col: 9, offset: 134935},
																									run: (*parser).callonscopeItem462,
																								},
																								&choiceExpr{
																									pos: position{line: 3951, col: 9, offset: 137270},
																									alternatives: []interface{}{
																										&seqExpr{
																											pos: position{line: 3951, col: 9, offset: 137270},
																											exprs: []interface{}{
																												&andCodeExpr{
																													pos: position{line: 3951, col: 9, offset: 137270},
																													run: (*parser).callonscopeItem465,
																												},
																												&andCodeExpr{
																													pos: position{line: 3955, col: 11, offset: 137520},
																													run: (*parser).callonscopeItem466,
																												},
																												&stateCodeExpr{
																													pos: position{line: 4021, col: 11, offset: 140726},
																													run: (*parser).callonscopeItem467,
																												},
																											},
																										},
																										&seqExpr{
																											pos: position{line: 4029, col: 13, offset: 141079},
																											exprs: []interface{}{
																												&andCodeExpr{
																													pos: position{line: 4029, col: 13, offset: 141079},
																													run: (*parser).callonscopeItem469,
																												},
																												&andCodeExpr{
																													pos: position{line: 4033, col: 11, offset: 141334},
																													run: (*parser).callonscopeItem470,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 2308, col: 27, offset: 79567},
																					label: "posI",
																					expr: &actionExpr{
																						pos: position{line: 3737, col: 8, offset: 128286},
																						run: (*parser).callonscopeItem472,
																						expr: &choiceExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							alternatives: []interface{}{
																								&andExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									expr: &anyMatcher{
																										line: 3737, col: 10, offset: 128288,
																									},
																								},
																								&notExpr{
																									pos: position{line: 3737, col: 14, offset: 128292},
																									expr: &anyMatcher{
																										line: 3737, col: 15, offset: 128293,
																									},
																								},
																							},
																						},
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 2308, col: 36, offset: 79576},
																					label: "lineI",
																					expr: &oneOrMoreExpr{
																						pos: position{line: 2308, col: 42, offset: 79582},
																						expr: &charClassMatcher{
																							pos:        position{line: 3735, col: 12, offset: 128270},
																							val:        "[^\\r\\n]",
																							chars:      []rune{'\r', '\n'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																					},
																				},
																				&zeroOrMoreExpr{
																					pos: position{line: 3734, col: 12, offset: 128237},
																					expr: &charClassMatcher{
																						pos:        position{line: 3746, col: 36, offset: 128584},
																						val:        "[ \\t]",
																						chars:      []rune{' ', '\t'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																				&choiceExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					alternatives: []interface{}{
																						&seqExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							exprs: []interface{}{
																								&zeroOrOneExpr{
																									pos: position{line: 3734, col: 16, offset: 128241},
																									expr: &litMatcher{
																										pos:        position{line: 3734, col: 16, offset: 128241},
																										val:        "\r",
																										ignoreCase: false,
																										want:       "\"\\r\"",
																									},
																								},
																								&litMatcher{
																									pos:        position{line: 3734, col: 22, offset: 128247},
																									val:        "\n",
																									ignoreCase: false,
																									want:       "\"\\n\"",
																								},
																							},
																						},
																						&notExpr{
																							pos: position{line: 3733, col: 12, offset: 128223},
																							expr: &anyMatcher{
																								line: 3733, col: 13, offset: 128224,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&stateCodeExpr{
														pos: position{line: 4219, col: 11, offset: 148972},
														run: (*parser).callonscopeItem490,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2844, col: 12, offset: 99283},
						run: (*parser).callonscopeItem491,
						expr: &seqExpr{
							pos: position{line: 2844, col: 12, offset: 99283},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2844, col: 12, offset: 99283},
									val:        "include",
									ignoreCase: false,
									want:       "\"include\"",
								},
								&labeledExpr{
									pos:   position{line: 2844, col: 22, offset: 99293},
									label: "pathI",
									expr: &choiceExpr{
										pos: position{line: 3166, col: 18, offset: 109929},
										alternatives: []interface{}{
											&seqExpr{
												pos: position{line: 3166, col: 18, offset: 109929},
												exprs: []interface{}{
													&oneOrMoreExpr{
														pos: position{line: 3166, col: 18, offset: 109929},
														expr: &litMatcher{
															pos:        position{line: 3166, col: 18, offset: 109929},
															val:        " ",
															ignoreCase: false,
															want:       "\" \"",
														},
													},
													&choiceExpr{
														pos: position{line: 743, col: 11, offset: 22871},
														alternatives: []interface{}{
															&actionExpr{
																pos: position{line: 749, col: 14, offset: 22958},
																run: (*parser).callonscopeItem500,
																expr: &seqExpr{
																	pos: position{line: 749, col: 14, offset: 22958},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 749, col: 14, offset: 22958},
																			val:        "`",
																			ignoreCase: false,
																			want:       "\"`\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 749, col: 18, offset: 22962},
																			label: "strI",
																			expr: &zeroOrMoreExpr{
																				pos: position{line: 749, col: 23, offset: 22967},
																				expr: &charClassMatcher{
																					pos:        position{line: 2704, col: 27, offset: 94307},
																					val:        "[^\\n`]",
																					chars:      []rune{'\n', '`'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																		&litMatcher{
																			pos:        position{line: 749, col: 47, offset: 22991},
																			val:        "`",
																			ignoreCase: false,
																			want:       "\"`\"",
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 751, col: 5, offset: 23083},
																run: (*parser).callonscopeItem507,
																expr: &seqExpr{
																	pos: position{line: 751, col: 5, offset: 23083},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 751, col: 5, offset: 23083},
																			val:        "`",
																			ignoreCase: false,
																			want:       "\"`\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 751, col: 9, offset: 23087},
																			label: "strI",
																			expr: &zeroOrMoreExpr{
																				pos: position{line: 751, col: 14, offset: 23092},
																				expr: &charClassMatcher{
																					pos:        position{line: 2704, col: 27, offset: 94307},
																					val:        "[^\\n`]",
																					chars:      []rune{'\n', '`'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																		&andExpr{
																			pos: position{line: 751, col: 38, offset: 23116},
																			expr: &seqExpr{
																				pos: position{line: 3734, col: 12, offset: 128237},
																				exprs: []interface{}{
																					&zeroOrMoreExpr{
																						pos: position{line: 3734, col: 12, offset: 128237},
																						expr: &charClassMatcher{
																							pos:        position{line: 3746, col: 36, offset: 128584},
																							val:        "[ \\t]",
																							chars:      []rune{' ', '\t'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&choiceExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						alternatives: []interface{}{
																							&seqExpr{
																								pos: position{line: 3734, col: 16, offset: 128241},
																								exprs: []interface{}{
																									&zeroOrOneExpr{
																										pos: position{line: 3734, col: 16, offset: 128241},
																										expr: &litMatcher{
																											pos:        position{line: 3734, col: 16, offset: 128241},
																											val:        "\r",
																											ignoreCase: false,
																											want:       "\"\\r\"",
																										},
																									},
																									&litMatcher{
																										pos:        position{line: 3734, col: 22, offset: 128247},
																										val:        "\n",
																										ignoreCase: false,
																										want:       "\"\\n\"",
																									},
																								},
																							},
																							&notExpr{
																								pos: position{line: 3733, col: 12, offset: 128223},
																								expr: &anyMatcher{
																									line: 3733, col: 13, offset: 128224,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 770, col: 22, offset: 23520},
																run: (*parser).callonscopeItem524,
																expr: &seqExpr{
																	pos: position{line: 770, col: 22, offset: 23520},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 770, col: 22, offset: 23520},
																			val:        "\"",
																			ignoreCase: false,
																			want:       "\"\\\"\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 770, col: 26, offset: 23524},
																			label: "strI",
																			expr: &zeroOrMoreExpr{
																				pos: position{line: 770, col: 31, offset: 23529},
																				expr: &choiceExpr{
																					pos: position{line: 770, col: 32, offset: 23530},
																					alternatives: []interface{}{
																						&seqExpr{
																							pos: position{line: 2443, col: 24, offset: 83970},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2443, col: 24, offset: 83970},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2360, col: 19, offset: 81158},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2360, col: 19, offset: 81158},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2360, col: 19, offset: 81158},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2444, col: 24, offset: 84037},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2444, col: 24, offset: 84037},
																									val:        "\\x",
																									ignoreCase: false,
																									want:       "\"\\\\x\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2445, col: 5, offset: 84074},
																							run: (*parser).callonscopeItem539,
																							expr: &seqExpr{
																								pos: position{line: 2445, col: 5, offset: 84074},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2445, col: 5, offset: 84074},
																										val:        "\\x",
																										ignoreCase: false,
																										want:       "\"\\\\x\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2445, col: 14, offset: 84083},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2445, col: 26, offset: 84095},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2462, col: 19, offset: 84712},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2462, col: 19, offset: 84712},
																									val:        "\\u",
																									ignoreCase: false,
																									want:       "\"\\\\u\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2463, col: 5, offset: 84771},
																							run: (*parser).callonscopeItem552,
																							expr: &seqExpr{
																								pos: position{line: 2463, col: 5, offset: 84771},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2463, col: 5, offset: 84771},
																										val:        "\\u",
																										ignoreCase: false,
																										want:       "\"\\\\u\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2463, col: 14, offset: 84780},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2463, col: 26, offset: 84792},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2463, col: 38, offset: 84804},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2463, col: 50, offset: 84816},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2492, col: 16, offset: 85952},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2492, col: 16, offset: 85952},
																									val:        "\\U",
																									ignoreCase: false,
																									want:       "\"\\\\U\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2493, col: 5, offset: 86055},
																							run: (*parser).callonscopeItem573,
																							expr: &seqExpr{
																								pos: position{line: 2493, col: 5, offset: 86055},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2493, col: 5, offset: 86055},
																										val:        "\\U",
																										ignoreCase: false,
																										want:       "\"\\\\U\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 14, offset: 86064},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 26, offset: 86076},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 38, offset: 86088},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 50, offset: 86100},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 62, offset: 86112},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 74, offset: 86124},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 86, offset: 86136},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 98, offset: 86148},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2720, col: 36, offset: 95085},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2720, col: 36, offset: 95085},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2720, col: 41, offset: 95090},
																									val:        "[abfnrtv\\\\\"]",
																									chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 2718, col: 38, offset: 94977},
																							val:        "[^\"\\\\\\n]",
																							chars:      []rune{'"', '\\', '\n'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																						&actionExpr{
																							pos: position{line: 2607, col: 37, offset: 90735},
																							run: (*parser).callonscopeItem596,
																							expr: &seqExpr{
																								pos: position{line: 2607, col: 37, offset: 90735},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2607, col: 37, offset: 90735},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2631, col: 5, offset: 91752},
																							run: (*parser).callonscopeItem607,
																							expr: &seqExpr{
																								pos: position{line: 2631, col: 5, offset: 91752},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2631, col: 5, offset: 91752},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2652, col: 5, offset: 92594},
																							run: (*parser).callonscopeItem614,
																							expr: &seqExpr{
																								pos: position{line: 2652, col: 5, offset: 92594},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2652, col: 5, offset: 92594},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2670, col: 5, offset: 93280},
																							run: (*parser).callonscopeItem619,
																							expr: &seqExpr{
																								pos: position{line: 2670, col: 5, offset: 93280},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2670, col: 5, offset: 93280},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2670, col: 10, offset: 93285},
																										expr: &charClassMatcher{
																											pos:        position{line: 3735, col: 12, offset: 128270},
																											val:        "[^\\r\\n]",
																											chars:      []rune{'\r', '\n'},
																											ignoreCase: false,
																											inverted:   true,
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&litMatcher{
																			pos:        position{line: 770, col: 115, offset: 23613},
																			val:        "\"",
																			ignoreCase: false,
																			want:       "\"\\\"\"",
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 772, col: 5, offset: 23705},
																run: (*parser).callonscopeItem625,
																expr: &seqExpr{
																	pos: position{line: 772, col: 5, offset: 23705},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 772, col: 5, offset: 23705},
																			val:        "\"",
																			ignoreCase: false,
																			want:       "\"\\\"\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 772, col: 9, offset: 23709},
																			label: "strI",
																			expr: &zeroOrMoreExpr{
																				pos: position{line: 772, col: 14, offset: 23714},
																				expr: &choiceExpr{
																					pos: position{line: 772, col: 15, offset: 23715},
																					alternatives: []interface{}{
																						&seqExpr{
																							pos: position{line: 2443, col: 24, offset: 83970},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2443, col: 24, offset: 83970},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2360, col: 19, offset: 81158},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2360, col: 19, offset: 81158},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2360, col: 19, offset: 81158},
																									val:        "[0-7]",
																									ranges:     []rune{'0', '7'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2444, col: 24, offset: 84037},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2444, col: 24, offset: 84037},
																									val:        "\\x",
																									ignoreCase: false,
																									want:       "\"\\\\x\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2445, col: 5, offset: 84074},
																							run: (*parser).callonscopeItem640,
																							expr: &seqExpr{
																								pos: position{line: 2445, col: 5, offset: 84074},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2445, col: 5, offset: 84074},
																										val:        "\\x",
																										ignoreCase: false,
																										want:       "\"\\\\x\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2445, col: 14, offset: 84083},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2445, col: 26, offset: 84095},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2462, col: 19, offset: 84712},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2462, col: 19, offset: 84712},
																									val:        "\\u",
																									ignoreCase: false,
																									want:       "\"\\\\u\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2463, col: 5, offset: 84771},
																							run: (*parser).callonscopeItem653,
																							expr: &seqExpr{
																								pos: position{line: 2463, col: 5, offset: 84771},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2463, col: 5, offset: 84771},
																										val:        "\\u",
																										ignoreCase: false,
																										want:       "\"\\\\u\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2463, col: 14, offset: 84780},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2463, col: 26, offset: 84792},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2463, col: 38, offset: 84804},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2463, col: 50, offset: 84816},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2492, col: 16, offset: 85952},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2492, col: 16, offset: 85952},
																									val:        "\\U",
																									ignoreCase: false,
																									want:       "\"\\\\U\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2493, col: 5, offset: 86055},
																							run: (*parser).callonscopeItem674,
																							expr: &seqExpr{
																								pos: position{line: 2493, col: 5, offset: 86055},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2493, col: 5, offset: 86055},
																										val:        "\\U",
																										ignoreCase: false,
																										want:       "\"\\\\U\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 14, offset: 86064},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 26, offset: 86076},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 38, offset: 86088},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 50, offset: 86100},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 62, offset: 86112},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 74, offset: 86124},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 86, offset: 86136},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2493, col: 98, offset: 86148},
																										expr: &charClassMatcher{
																											pos:        position{line: 2361, col: 19, offset: 81182},
																											val:        "[0-9A-Fa-f]",
																											ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																							},
																						},
																						&seqExpr{
																							pos: position{line: 2720, col: 36, offset: 95085},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2720, col: 36, offset: 95085},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2720, col: 41, offset: 95090},
																									val:        "[abfnrtv\\\\\"]",
																									chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 2718, col: 38, offset: 94977},
																							val:        "[^\"\\\\\\n]",
																							chars:      []rune{'"', '\\', '\n'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																						&actionExpr{
																							pos: position{line: 2607, col: 37, offset: 90735},
																							run: (*parser).callonscopeItem697,
																							expr: &seqExpr{
																								pos: position{line: 2607, col: 37, offset: 90735},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2607, col: 37, offset: 90735},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2631, col: 5, offset: 91752},
																							run: (*parser).callonscopeItem708,
																							expr: &seqExpr{
																								pos: position{line: 2631, col: 5, offset: 91752},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2631, col: 5, offset: 91752},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2652, col: 5, offset: 92594},
																							run: (*parser).callonscopeItem715,
																							expr: &seqExpr{
																								pos: position{line: 2652, col: 5, offset: 92594},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2652, col: 5, offset: 92594},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																						&actionExpr{
																							pos: position{line: 2670, col: 5, offset: 93280},
																							run: (*parser).callonscopeItem720,
																							expr: &seqExpr{
																								pos: position{line: 2670, col: 5, offset: 93280},
																								exprs: []interface{}{
																									&litMatcher{
																										pos:        position{line: 2670, col: 5, offset: 93280},
																										val:        "\\",
																										ignoreCase: false,
																										want:       "\"\\\\\"",
																									},
																									&zeroOrOneExpr{
																										pos: position{line: 2670, col: 10, offset: 93285},
																										expr: &charClassMatcher{
																											pos:        position{line: 3735, col: 12, offset: 128270},
																											val:        "[^\\r\\n]",
																											chars:      []rune{'\r', '\n'},
																											ignoreCase: false,
																											inverted:   true,
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 772, col: 98, offset: 23798},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonscopeItem726,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																		&andExpr{
																			pos: position{line: 772, col: 110, offset: 23810},
																			expr: &seqExpr{
																				pos: position{line: 3734, col: 12, offset: 128237},
																				exprs: []interface{}{
																					&zeroOrMoreExpr{
																						pos: position{line: 3734, col: 12, offset: 128237},
																						expr: &charClassMatcher{
																							pos:        position{line: 3746, col: 36, offset: 128584},
																							val:        "[ \\t]",
																							chars:      []rune{' ', '\t'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&choiceExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						alternatives: []interface{}{
																							&seqExpr{
																								pos: position{line: 3734, col: 16, offset: 128241},
																								exprs: []interface{}{
																									&zeroOrOneExpr{
																										pos: position{line: 3734, col: 16, offset: 128241},
																										expr: &litMatcher{
																											pos:        position{line: 3734, col: 16, offset: 128241},
																											val:        "\r",
																											ignoreCase: false,
																											want:       "\"\\r\"",
																										},
																									},
																									&litMatcher{
																										pos:        position{line: 3734, col: 22, offset: 128247},
																										val:        "\n",
																										ignoreCase: false,
																										want:       "\"\\n\"",
																									},
																								},
																							},
																							&notExpr{
																								pos: position{line: 3733, col: 12, offset: 128223},
																								expr: &anyMatcher{
																									line: 3733, col: 13, offset: 128224,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 791, col: 22, offset: 24216},
																run: (*parser).callonscopeItem743,
																expr: &seqExpr{
																	pos: position{line: 791, col: 22, offset: 24216},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 791, col: 22, offset: 24216},
																			val:        "'",
																			ignoreCase: false,
																			want:       "\"'\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 791, col: 27, offset: 24221},
																			label: "strI",
																			expr: &zeroOrMoreExpr{
																				pos: position{line: 791, col: 32, offset: 24226},
																				expr: &charClassMatcher{
																					pos:        position{line: 791, col: 32, offset: 24226},
																					val:        "[^\\\\r\\n]",
																					chars:      []rune{'\'', '\r', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																		&litMatcher{
																			pos:        position{line: 791, col: 42, offset: 24236},
																			val:        "'",
																			ignoreCase: false,
																			want:       "\"'\"",
																		},
																		&labeledExpr{
																			pos:   position{line: 791, col: 47, offset: 24241},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonscopeItem751,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 3166, col: 32, offset: 109943},
												run: (*parser).callonscopeItem757,
												expr: &labeledExpr{
													pos:   position{line: 3166, col: 32, offset: 109943},
													label: "pathI",
													expr: &zeroOrMoreExpr{
														pos: position{line: 3166, col: 38, offset: 109949},
														expr: &charClassMatcher{
															pos:        position{line: 3735, col: 12, offset: 128270},
															val:        "[^\\r\\n]",
															chars:      []rune{'\r', '\n'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 168, col: 5, offset: 5236},
						name: "Mixin",
					},
					&ruleRefExpr{
						pos:  position{line: 168, col: 13, offset: 5244},
						name: "Return",
					},
					&ruleRefExpr{
						pos:  position{line: 168, col: 22, offset: 5253},
						name: "MixinCall",
					},
					&ruleRefExpr{
						pos:  position{line: 169, col: 5, offset: 5284},
						name: "Assign",
					},
					&ruleRefExpr{
						pos:  position{line: 169, col: 14, offset: 5293},
						name: "ArrowBlock",
					},
					&actionExpr{
						pos: position{line: 176, col: 17, offset: 5431},
						run: (*parser).callonscopeItem766,
						expr: &labeledExpr{
							pos:   position{line: 176, col: 17, offset: 5431},
							label: "doctypeI",
							expr: &choiceExpr{
								pos: position{line: 852, col: 12, offset: 26297},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 852, col: 12, offset: 26297},
										run: (*parser).callonscopeItem769,
										expr: &seqExpr{
											pos: position{line: 852, col: 12, offset: 26297},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 852, col: 12, offset: 26297},
													val:        "doctype",
													ignoreCase: false,
													want:       "\"doctype\"",
												},
												&choiceExpr{
													pos: position{line: 865, col: 18, offset: 26720},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 865, col: 18, offset: 26720},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 865, col: 18, offset: 26720},
																	val:        " html",
																	ignoreCase: false,
																	want:       "\" html\"",
																},
																&zeroOrMoreExpr{
																	pos: position{line: 3734, col: 12, offset: 128237},
																	expr: &charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&choiceExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	alternatives: []interface{}{
																		&seqExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			exprs: []interface{}{
																				&zeroOrOneExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					expr: &litMatcher{
																						pos:        position{line: 3734, col: 16, offset: 128241},
																						val:        "\r",
																						ignoreCase: false,
																						want:       "\"\\r\"",
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 3734, col: 22, offset: 128247},
																					val:        "\n",
																					ignoreCase: false,
																					want:       "\"\\n\"",
																				},
																			},
																		},
																		&notExpr{
																			pos: position{line: 3733, col: 12, offset: 128223},
																			expr: &anyMatcher{
																				line: 3733, col: 13, offset: 128224,
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 866, col: 5, offset: 26738},
															run: (*parser).callonscopeItem784,
															expr: &seqExpr{
																pos: position{line: 866, col: 5, offset: 26738},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 866, col: 5, offset: 26738},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																	&labeledExpr{
																		pos:   position{line: 866, col: 9, offset: 26742},
																		label: "startPosI",
																		expr: &actionExpr{
																			pos: position{line: 3737, col: 8, offset: 128286},
																			run: (*parser).callonscopeItem788,
																			expr: &choiceExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				alternatives: []interface{}{
																					&andExpr{
																						pos: position{line: 3737, col: 9, offset: 128287},
																						expr: &anyMatcher{
																							line: 3737, col: 10, offset: 128288,
																						},
																					},
																					&notExpr{
																						pos: position{line: 3737, col: 14, offset: 128292},
																						expr: &anyMatcher{
																							line: 3737, col: 15, offset: 128293,
																						},
																					},
																				},
																			},
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 866, col: 23, offset: 26756},
																		expr: &charClassMatcher{
																			pos:        position{line: 3735, col: 12, offset: 128270},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 876, col: 9, offset: 27137},
															run: (*parser).callonscopeItem805,
															expr: &seqExpr{
																pos: position{line: 876, col: 9, offset: 27137},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 876, col: 9, offset: 27137},
																		expr: &litMatcher{
																			pos:        position{line: 876, col: 9, offset: 27137},
																			val:        " ",
																			ignoreCase: false,
																			want:       "\" \"",
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 876, col: 14, offset: 27142},
																		expr: &charClassMatcher{
																			pos:        position{line: 3735, col: 12, offset: 128270},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 854, col: 5, offset: 26374},
										run: (*parser).callonscopeItem820,
										expr: &seqExpr{
											pos: position{line: 854, col: 5, offset: 26374},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 854, col: 5, offset: 26374},
													val:        "!doctype",
													ignoreCase: false,
													want:       "\"!doctype\"",
												},
												&choiceExpr{
													pos: position{line: 865, col: 18, offset: 26720},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 865, col: 18, offset: 26720},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 865, col: 18, offset: 26720},
																	val:        " html",
																	ignoreCase: false,
																	want:       "\" html\"",
																},
																&zeroOrMoreExpr{
																	pos: position{line: 3734, col: 12, offset: 128237},
																	expr: &charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&choiceExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	alternatives: []interface{}{
																		&seqExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			exprs: []interface{}{
																				&zeroOrOneExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					expr: &litMatcher{
																						pos:        position{line: 3734, col: 16, offset: 128241},
																						val:        "\r",
																						ignoreCase: false,
																						want:       "\"\\r\"",
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 3734, col: 22, offset: 128247},
																					val:        "\n",
																					ignoreCase: false,
																					want:       "\"\\n\"",
																				},
																			},
																		},
																		&notExpr{
																			pos: position{line: 3733, col: 12, offset: 128223},
																			expr: &anyMatcher{
																				line: 3733, col: 13, offset: 128224,
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 866, col: 5, offset: 26738},
															run: (*parser).callonscopeItem835,
															expr: &seqExpr{
																pos: position{line: 866, col: 5, offset: 26738},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 866, col: 5, offset: 26738},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																	&labeledExpr{
																		pos:   position{line: 866, col: 9, offset: 26742},
																		label: "startPosI",
																		expr: &actionExpr{
																			pos: position{line: 3737, col: 8, offset: 128286},
																			run: (*parser).callonscopeItem839,
																			expr: &choiceExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				alternatives: []interface{}{
																					&andExpr{
																						pos: position{line: 3737, col: 9, offset: 128287},
																						expr: &anyMatcher{
																							line: 3737, col: 10, offset: 128288,
																						},
																					},
																					&notExpr{
																						pos: position{line: 3737, col: 14, offset: 128292},
																						expr: &anyMatcher{
																							line: 3737, col: 15, offset: 128293,
																						},
																					},
																				},
																			},
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 866, col: 23, offset: 26756},
																		expr: &charClassMatcher{
																			pos:        position{line: 3735, col: 12, offset: 128270},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 876, col: 9, offset: 27137},
															run: (*parser).callonscopeItem856,
															expr: &seqExpr{
																pos: position{line: 876, col: 9, offset: 27137},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 876, col: 9, offset: 27137},
																		expr: &litMatcher{
																			pos:        position{line: 876, col: 9, offset: 27137},
																			val:        " ",
																			ignoreCase: false,
																			want:       "\" \"",
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 876, col: 14, offset: 27142},
																		expr: &charClassMatcher{
																			pos:        position{line: 3735, col: 12, offset: 128270},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 172, col: 5, offset: 5349},
						name: "DivShorthand",
					},
					&ruleRefExpr{
						pos:  position{line: 172, col: 20, offset: 5364},
						name: "Element",
					},
					&ruleRefExpr{
						pos:  position{line: 173, col: 5, offset: 5404},
						name: "BadItem",
					},
				},
			},
		},
		{
			name: "Body",
			pos:  position{line: 198, col: 1, offset: 6259},
			expr: &actionExpr{
				pos: position{line: 198, col: 9, offset: 6267},
				run: (*parser).callonBody1,
				expr: &seqExpr{
					pos: position{line: 198, col: 9, offset: 6267},
					exprs: []interface{}{
						&stateCodeExpr{
							pos: position{line: 4214, col: 11, offset: 148867},
							run: (*parser).callonBody3,
						},
						&labeledExpr{
							pos:   position{line: 198, col: 16, offset: 6274},
							label: "scopeI",
							expr: &ruleRefExpr{
								pos:  position{line: 198, col: 23, offset: 6281},
								name: "Scope",
							},
						},
						&stateCodeExpr{
							pos: position{line: 4219, col: 11, offset: 148972},
							run: (*parser).callonBody6,
						},
					},
				},
			},
		},
		{
			name: "Beaitb",
			pos:  position{line: 202, col: 1, offset: 6322},
			expr: &actionExpr{
				pos: position{line: 202, col: 11, offset: 6332},
				run: (*parser).callonBeaitb1,
				expr: &seqExpr{
					pos: position{line: 202, col: 11, offset: 6332},
					exprs: []interface{}{
						&zeroOrOneExpr{
							pos: position{line: 202, col: 11, offset: 6332},
							expr: &actionExpr{
								pos: position{line: 203, col: 5, offset: 6338},
								run: (*parser).callonBeaitb4,
								expr: &seqExpr{
									pos: position{line: 203, col: 5, offset: 6338},
									exprs: []interface{}{
										&oneOrMoreExpr{
											pos: position{line: 203, col: 5, offset: 6338},
											expr: &charClassMatcher{
												pos:        position{line: 203, col: 5, offset: 6338},
												val:        "[^:!= \\r\\n]",
												chars:      []rune{':', '!', '=', ' ', '\r', '\n'},
												ignoreCase: false,
												inverted:   true,
											},
										},
										&labeledExpr{
											pos:   position{line: 203, col: 18, offset: 6351},
											label: "endPosI",
											expr: &actionExpr{
												pos: position{line: 3737, col: 8, offset: 128286},
												run: (*parser).callonBeaitb9,
												expr: &choiceExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													alternatives: []interface{}{
														&andExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															expr: &anyMatcher{
																line: 3737, col: 10, offset: 128288,
															},
														},
														&notExpr{
															pos: position{line: 3737, col: 14, offset: 128292},
															expr: &anyMatcher{
																line: 3737, col: 15, offset: 128293,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 214, col: 4, offset: 6763},
							label: "scopeI",
							expr: &choiceExpr{
								pos: position{line: 215, col: 5, offset: 6776},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 215, col: 5, offset: 6776},
										run: (*parser).callonBeaitb17,
										expr: &labeledExpr{
											pos:   position{line: 215, col: 5, offset: 6776},
											label: "scopeItemI",
											expr: &choiceExpr{
												pos: position{line: 215, col: 17, offset: 6788},
												alternatives: []interface{}{
													&ruleRefExpr{
														pos:  position{line: 215, col: 17, offset: 6788},
														name: "BlockExpansion",
													},
													&ruleRefExpr{
														pos:  position{line: 215, col: 34, offset: 6805},
														name: "Assign",
													},
													&ruleRefExpr{
														pos:  position{line: 215, col: 43, offset: 6814},
														name: "InlineText",
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 217, col: 9, offset: 6896},
										run: (*parser).callonBeaitb23,
										expr: &seqExpr{
											pos: position{line: 217, col: 9, offset: 6896},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 3734, col: 12, offset: 128237},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&choiceExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 3734, col: 16, offset: 128241},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	expr: &litMatcher{
																		pos:        position{line: 3734, col: 16, offset: 128241},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3734, col: 22, offset: 128247},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
														&notExpr{
															pos: position{line: 3733, col: 12, offset: 128223},
															expr: &anyMatcher{
																line: 3733, col: 13, offset: 128224,
															},
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 217, col: 13, offset: 6900},
													label: "bodyI",
													expr: &ruleRefExpr{
														pos:  position{line: 217, col: 19, offset: 6906},
														name: "Body",
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 219, col: 9, offset: 6947},
										run: (*parser).callonBeaitb36,
										expr: &seqExpr{
											pos: position{line: 3734, col: 12, offset: 128237},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 3734, col: 12, offset: 128237},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&choiceExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 3734, col: 16, offset: 128241},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	expr: &litMatcher{
																		pos:        position{line: 3734, col: 16, offset: 128241},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3734, col: 22, offset: 128247},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
														&notExpr{
															pos: position{line: 3733, col: 12, offset: 128223},
															expr: &anyMatcher{
																line: 3733, col: 13, offset: 128224,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Beait",
			pos:  position{line: 226, col: 1, offset: 7025},
			expr: &actionExpr{
				pos: position{line: 226, col: 10, offset: 7034},
				run: (*parser).callonBeait1,
				expr: &seqExpr{
					pos: position{line: 226, col: 10, offset: 7034},
					exprs: []interface{}{
						&zeroOrOneExpr{
							pos: position{line: 226, col: 10, offset: 7034},
							expr: &actionExpr{
								pos: position{line: 227, col: 5, offset: 7040},
								run: (*parser).callonBeait4,
								expr: &seqExpr{
									pos: position{line: 227, col: 5, offset: 7040},
									exprs: []interface{}{
										&oneOrMoreExpr{
											pos: position{line: 227, col: 5, offset: 7040},
											expr: &charClassMatcher{
												pos:        position{line: 227, col: 5, offset: 7040},
												val:        "[^:= \\r\\n]",
												chars:      []rune{':', '=', ' ', '\r', '\n'},
												ignoreCase: false,
												inverted:   true,
											},
										},
										&labeledExpr{
											pos:   position{line: 227, col: 17, offset: 7052},
											label: "endPosI",
											expr: &actionExpr{
												pos: position{line: 3737, col: 8, offset: 128286},
												run: (*parser).callonBeait9,
												expr: &choiceExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													alternatives: []interface{}{
														&andExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															expr: &anyMatcher{
																line: 3737, col: 10, offset: 128288,
															},
														},
														&notExpr{
															pos: position{line: 3737, col: 14, offset: 128292},
															expr: &anyMatcher{
																line: 3737, col: 15, offset: 128293,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 237, col: 4, offset: 7420},
							label: "scopeI",
							expr: &choiceExpr{
								pos: position{line: 238, col: 5, offset: 7433},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 238, col: 5, offset: 7433},
										run: (*parser).callonBeait17,
										expr: &labeledExpr{
											pos:   position{line: 238, col: 5, offset: 7433},
											label: "scopeItemI",
											expr: &choiceExpr{
												pos: position{line: 238, col: 17, offset: 7445},
												alternatives: []interface{}{
													&ruleRefExpr{
														pos:  position{line: 238, col: 17, offset: 7445},
														name: "BlockExpansion",
													},
													&ruleRefExpr{
														pos:  position{line: 238, col: 34, offset: 7462},
														name: "Assign",
													},
													&ruleRefExpr{
														pos:  position{line: 238, col: 43, offset: 7471},
														name: "InlineText",
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 240, col: 9, offset: 7553},
										run: (*parser).callonBeait23,
										expr: &seqExpr{
											pos: position{line: 3734, col: 12, offset: 128237},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 3734, col: 12, offset: 128237},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&choiceExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 3734, col: 16, offset: 128241},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	expr: &litMatcher{
																		pos:        position{line: 3734, col: 16, offset: 128241},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3734, col: 22, offset: 128247},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
														&notExpr{
															pos: position{line: 3733, col: 12, offset: 128223},
															expr: &anyMatcher{
																line: 3733, col: 13, offset: 128224,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BadItem",
			pos:  position{line: 246, col: 1, offset: 7630},
			expr: &actionExpr{
				pos: position{line: 246, col: 12, offset: 7641},
				run: (*parser).callonBadItem1,
				expr: &seqExpr{
					pos: position{line: 246, col: 12, offset: 7641},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 246, col: 12, offset: 7641},
							label: "lineI",
							expr: &oneOrMoreExpr{
								pos: position{line: 246, col: 18, offset: 7647},
								expr: &charClassMatcher{
									pos:        position{line: 3735, col: 12, offset: 128270},
									val:        "[^\\r\\n]",
									chars:      []rune{'\r', '\n'},
									ignoreCase: false,
									inverted:   true,
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3734, col: 12, offset: 128237},
							expr: &charClassMatcher{
								pos:        position{line: 3746, col: 36, offset: 128584},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3734, col: 16, offset: 128241},
							alternatives: []interface{}{
								&seqExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											expr: &litMatcher{
												pos:        position{line: 3734, col: 16, offset: 128241},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3734, col: 22, offset: 128247},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3733, col: 12, offset: 128223},
									expr: &anyMatcher{
										line: 3733, col: 13, offset: 128224,
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 246, col: 31, offset: 7660},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 246, col: 37, offset: 7666},
								expr: &ruleRefExpr{
									pos:  position{line: 246, col: 37, offset: 7666},
									name: "Body",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Block",
			pos:  position{line: 281, col: 1, offset: 9107},
			expr: &actionExpr{
				pos: position{line: 281, col: 10, offset: 9116},
				run: (*parser).callonBlock1,
				expr: &seqExpr{
					pos: position{line: 281, col: 10, offset: 9116},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 281, col: 10, offset: 9116},
							label: "blockI",
							expr: &actionExpr{
								pos: position{line: 302, col: 19, offset: 9712},
								run: (*parser).callonBlock4,
								expr: &seqExpr{
									pos: position{line: 302, col: 19, offset: 9712},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 302, col: 19, offset: 9712},
											val:        "block",
											ignoreCase: false,
											want:       "\"block\"",
										},
										&labeledExpr{
											pos:   position{line: 302, col: 27, offset: 9720},
											label: "nameI",
											expr: &choiceExpr{
												pos: position{line: 327, col: 14, offset: 10293},
												alternatives: []interface{}{
													&actionExpr{
														pos: position{line: 327, col: 14, offset: 10293},
														run: (*parser).callonBlock9,
														expr: &seqExpr{
															pos: position{line: 327, col: 14, offset: 10293},
															exprs: []interface{}{
																&oneOrMoreExpr{
																	pos: position{line: 327, col: 14, offset: 10293},
																	expr: &litMatcher{
																		pos:        position{line: 327, col: 14, offset: 10293},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&labeledExpr{
																	pos:   position{line: 327, col: 19, offset: 10298},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 711, col: 14, offset: 21845},
																		alternatives: []interface{}{
																			&actionExpr{
																				pos: position{line: 711, col: 14, offset: 21845},
																				run: (*parser).callonBlock15,
																				expr: &labeledExpr{
																					pos:   position{line: 711, col: 14, offset: 21845},
																					label: "identI",
																					expr: &choiceExpr{
																						pos: position{line: 697, col: 10, offset: 21290},
																						alternatives: []interface{}{
																							&actionExpr{
																								pos: position{line: 697, col: 10, offset: 21290},
																								run: (*parser).callonBlock18,
																								expr: &labeledExpr{
																									pos:   position{line: 697, col: 10, offset: 21290},
																									label: "identI",
																									expr: &seqExpr{
																										pos: position{line: 2367, col: 17, offset: 81233},
																										exprs: []interface{}{
																											&charClassMatcher{
																												pos:        position{line: 2350, col: 20, offset: 80988},
																												val:        "[_\\pL]",
																												chars:      []rune{'_'},
																												classes:    []*unicode.RangeTable{rangeTable("L")},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&zeroOrMoreExpr{
																												pos: position{line: 2367, col: 26, offset: 81242},
																												expr: &charClassMatcher{
																													pos:        position{line: 2350, col: 20, offset: 80988},
																													val:        "[_\\pL\\pNd]",
																													chars:      []rune{'_'},
																													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 699, col: 5, offset: 21384},
																								run: (*parser).callonBlock24,
																								expr: &seqExpr{
																									pos: position{line: 699, col: 5, offset: 21384},
																									exprs: []interface{}{
																										&labeledExpr{
																											pos:   position{line: 699, col: 5, offset: 21384},
																											label: "identI",
																											expr: &seqExpr{
																												pos: position{line: 699, col: 13, offset: 21392},
																												exprs: []interface{}{
																													&zeroOrOneExpr{
																														pos: position{line: 699, col: 13, offset: 21392},
																														expr: &litMatcher{
																															pos:        position{line: 699, col: 13, offset: 21392},
																															val:        "$",
																															ignoreCase: false,
																															want:       "\"$\"",
																														},
																													},
																													&oneOrMoreExpr{
																														pos: position{line: 699, col: 18, offset: 21397},
																														expr: &choiceExpr{
																															pos: position{line: 699, col: 19, offset: 21398},
																															alternatives: []interface{}{
																																&seqExpr{
																																	pos: position{line: 699, col: 19, offset: 21398},
																																	exprs: []interface{}{
																																		&charClassMatcher{
																																			pos:        position{line: 699, col: 19, offset: 21398},
																																			val:        "[\\pNd]",
																																			classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 699, col: 28, offset: 21407},
																																			val:        "[_-\\pL]",
																																			chars:      []rune{'_', '-'},
																																			classes:    []*unicode.RangeTable{rangeTable("L")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 699, col: 38, offset: 21417},
																																	val:        "[_-\\pL]",
																																	chars:      []rune{'_', '-'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&labeledExpr{
																											pos:   position{line: 699, col: 49, offset: 21428},
																											label: "endPosI",
																											expr: &actionExpr{
																												pos: position{line: 3737, col: 8, offset: 128286},
																												run: (*parser).callonBlock37,
																												expr: &choiceExpr{
																													pos: position{line: 3737, col: 9, offset: 128287},
																													alternatives: []interface{}{
																														&andExpr{
																															pos: position{line: 3737, col: 9, offset: 128287},
																															expr: &anyMatcher{
																																line: 3737, col: 10, offset: 128288,
																															},
																														},
																														&notExpr{
																															pos: position{line: 3737, col: 14, offset: 128292},
																															expr: &anyMatcher{
																																line: 3737, col: 15, offset: 128293,
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 713, col: 5, offset: 21887},
																				run: (*parser).callonBlock43,
																				expr: &seqExpr{
																					pos: position{line: 713, col: 5, offset: 21887},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 713, col: 5, offset: 21887},
																							label: "posI",
																							expr: &actionExpr{
																								pos: position{line: 3737, col: 8, offset: 128286},
																								run: (*parser).callonBlock46,
																								expr: &choiceExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									alternatives: []interface{}{
																										&andExpr{
																											pos: position{line: 3737, col: 9, offset: 128287},
																											expr: &anyMatcher{
																												line: 3737, col: 10, offset: 128288,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3737, col: 14, offset: 128292},
																											expr: &anyMatcher{
																												line: 3737, col: 15, offset: 128293,
																											},
																										},
																									},
																								},
																							},
																						},
																						&andExpr{
																							pos: position{line: 713, col: 14, offset: 21896},
																							expr: &choiceExpr{
																								pos: position{line: 713, col: 16, offset: 21898},
																								alternatives: []interface{}{
																									&seqExpr{
																										pos: position{line: 3734, col: 12, offset: 128237},
																										exprs: []interface{}{
																											&zeroOrMoreExpr{
																												pos: position{line: 3734, col: 12, offset: 128237},
																												expr: &charClassMatcher{
																													pos:        position{line: 3746, col: 36, offset: 128584},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&choiceExpr{
																												pos: position{line: 3734, col: 16, offset: 128241},
																												alternatives: []interface{}{
																													&seqExpr{
																														pos: position{line: 3734, col: 16, offset: 128241},
																														exprs: []interface{}{
																															&zeroOrOneExpr{
																																pos: position{line: 3734, col: 16, offset: 128241},
																																expr: &litMatcher{
																																	pos:        position{line: 3734, col: 16, offset: 128241},
																																	val:        "\r",
																																	ignoreCase: false,
																																	want:       "\"\\r\"",
																																},
																															},
																															&litMatcher{
																																pos:        position{line: 3734, col: 22, offset: 128247},
																																val:        "\n",
																																ignoreCase: false,
																																want:       "\"\\n\"",
																															},
																														},
																													},
																													&notExpr{
																														pos: position{line: 3733, col: 12, offset: 128223},
																														expr: &anyMatcher{
																															line: 3733, col: 13, offset: 128224,
																														},
																													},
																												},
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 713, col: 22, offset: 21904},
																										val:        "[:!=(]",
																										chars:      []rune{':', '!', '=', '('},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 724, col: 5, offset: 22230},
																				run: (*parser).callonBlock65,
																				expr: &seqExpr{
																					pos: position{line: 724, col: 5, offset: 22230},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 724, col: 5, offset: 22230},
																							label: "identI",
																							expr: &oneOrMoreExpr{
																								pos: position{line: 724, col: 12, offset: 22237},
																								expr: &charClassMatcher{
																									pos:        position{line: 724, col: 12, offset: 22237},
																									val:        "[^ \\t\\r\\n:!=(]",
																									chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 724, col: 28, offset: 22253},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3737, col: 8, offset: 128286},
																								run: (*parser).callonBlock71,
																								expr: &choiceExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									alternatives: []interface{}{
																										&andExpr{
																											pos: position{line: 3737, col: 9, offset: 128287},
																											expr: &anyMatcher{
																												line: 3737, col: 10, offset: 128288,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3737, col: 14, offset: 128292},
																											expr: &anyMatcher{
																												line: 3737, col: 15, offset: 128293,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 329, col: 5, offset: 10344},
														run: (*parser).callonBlock77,
														expr: &andExpr{
															pos: position{line: 329, col: 5, offset: 10344},
															expr: &seqExpr{
																pos: position{line: 3734, col: 12, offset: 128237},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 281, col: 32, offset: 9138},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 281, col: 38, offset: 9144},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineBlock",
			pos:  position{line: 286, col: 1, offset: 9246},
			expr: &actionExpr{
				pos: position{line: 286, col: 16, offset: 9261},
				run: (*parser).callonInlineBlock1,
				expr: &seqExpr{
					pos: position{line: 286, col: 16, offset: 9261},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 286, col: 16, offset: 9261},
							label: "blockI",
							expr: &actionExpr{
								pos: position{line: 302, col: 19, offset: 9712},
								run: (*parser).callonInlineBlock4,
								expr: &seqExpr{
									pos: position{line: 302, col: 19, offset: 9712},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 302, col: 19, offset: 9712},
											val:        "block",
											ignoreCase: false,
											want:       "\"block\"",
										},
										&labeledExpr{
											pos:   position{line: 302, col: 27, offset: 9720},
											label: "nameI",
											expr: &choiceExpr{
												pos: position{line: 327, col: 14, offset: 10293},
												alternatives: []interface{}{
													&actionExpr{
														pos: position{line: 327, col: 14, offset: 10293},
														run: (*parser).callonInlineBlock9,
														expr: &seqExpr{
															pos: position{line: 327, col: 14, offset: 10293},
															exprs: []interface{}{
																&oneOrMoreExpr{
																	pos: position{line: 327, col: 14, offset: 10293},
																	expr: &litMatcher{
																		pos:        position{line: 327, col: 14, offset: 10293},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&labeledExpr{
																	pos:   position{line: 327, col: 19, offset: 10298},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 711, col: 14, offset: 21845},
																		alternatives: []interface{}{
																			&actionExpr{
																				pos: position{line: 711, col: 14, offset: 21845},
																				run: (*parser).callonInlineBlock15,
																				expr: &labeledExpr{
																					pos:   position{line: 711, col: 14, offset: 21845},
																					label: "identI",
																					expr: &choiceExpr{
																						pos: position{line: 697, col: 10, offset: 21290},
																						alternatives: []interface{}{
																							&actionExpr{
																								pos: position{line: 697, col: 10, offset: 21290},
																								run: (*parser).callonInlineBlock18,
																								expr: &labeledExpr{
																									pos:   position{line: 697, col: 10, offset: 21290},
																									label: "identI",
																									expr: &seqExpr{
																										pos: position{line: 2367, col: 17, offset: 81233},
																										exprs: []interface{}{
																											&charClassMatcher{
																												pos:        position{line: 2350, col: 20, offset: 80988},
																												val:        "[_\\pL]",
																												chars:      []rune{'_'},
																												classes:    []*unicode.RangeTable{rangeTable("L")},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&zeroOrMoreExpr{
																												pos: position{line: 2367, col: 26, offset: 81242},
																												expr: &charClassMatcher{
																													pos:        position{line: 2350, col: 20, offset: 80988},
																													val:        "[_\\pL\\pNd]",
																													chars:      []rune{'_'},
																													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 699, col: 5, offset: 21384},
																								run: (*parser).callonInlineBlock24,
																								expr: &seqExpr{
																									pos: position{line: 699, col: 5, offset: 21384},
																									exprs: []interface{}{
																										&labeledExpr{
																											pos:   position{line: 699, col: 5, offset: 21384},
																											label: "identI",
																											expr: &seqExpr{
																												pos: position{line: 699, col: 13, offset: 21392},
																												exprs: []interface{}{
																													&zeroOrOneExpr{
																														pos: position{line: 699, col: 13, offset: 21392},
																														expr: &litMatcher{
																															pos:        position{line: 699, col: 13, offset: 21392},
																															val:        "$",
																															ignoreCase: false,
																															want:       "\"$\"",
																														},
																													},
																													&oneOrMoreExpr{
																														pos: position{line: 699, col: 18, offset: 21397},
																														expr: &choiceExpr{
																															pos: position{line: 699, col: 19, offset: 21398},
																															alternatives: []interface{}{
																																&seqExpr{
																																	pos: position{line: 699, col: 19, offset: 21398},
																																	exprs: []interface{}{
																																		&charClassMatcher{
																																			pos:        position{line: 699, col: 19, offset: 21398},
																																			val:        "[\\pNd]",
																																			classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 699, col: 28, offset: 21407},
																																			val:        "[_-\\pL]",
																																			chars:      []rune{'_', '-'},
																																			classes:    []*unicode.RangeTable{rangeTable("L")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 699, col: 38, offset: 21417},
																																	val:        "[_-\\pL]",
																																	chars:      []rune{'_', '-'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&labeledExpr{
																											pos:   position{line: 699, col: 49, offset: 21428},
																											label: "endPosI",
																											expr: &actionExpr{
																												pos: position{line: 3737, col: 8, offset: 128286},
																												run: (*parser).callonInlineBlock37,
																												expr: &choiceExpr{
																													pos: position{line: 3737, col: 9, offset: 128287},
																													alternatives: []interface{}{
																														&andExpr{
																															pos: position{line: 3737, col: 9, offset: 128287},
																															expr: &anyMatcher{
																																line: 3737, col: 10, offset: 128288,
																															},
																														},
																														&notExpr{
																															pos: position{line: 3737, col: 14, offset: 128292},
																															expr: &anyMatcher{
																																line: 3737, col: 15, offset: 128293,
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 713, col: 5, offset: 21887},
																				run: (*parser).callonInlineBlock43,
																				expr: &seqExpr{
																					pos: position{line: 713, col: 5, offset: 21887},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 713, col: 5, offset: 21887},
																							label: "posI",
																							expr: &actionExpr{
																								pos: position{line: 3737, col: 8, offset: 128286},
																								run: (*parser).callonInlineBlock46,
																								expr: &choiceExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									alternatives: []interface{}{
																										&andExpr{
																											pos: position{line: 3737, col: 9, offset: 128287},
																											expr: &anyMatcher{
																												line: 3737, col: 10, offset: 128288,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3737, col: 14, offset: 128292},
																											expr: &anyMatcher{
																												line: 3737, col: 15, offset: 128293,
																											},
																										},
																									},
																								},
																							},
																						},
																						&andExpr{
																							pos: position{line: 713, col: 14, offset: 21896},
																							expr: &choiceExpr{
																								pos: position{line: 713, col: 16, offset: 21898},
																								alternatives: []interface{}{
																									&seqExpr{
																										pos: position{line: 3734, col: 12, offset: 128237},
																										exprs: []interface{}{
																											&zeroOrMoreExpr{
																												pos: position{line: 3734, col: 12, offset: 128237},
																												expr: &charClassMatcher{
																													pos:        position{line: 3746, col: 36, offset: 128584},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&choiceExpr{
																												pos: position{line: 3734, col: 16, offset: 128241},
																												alternatives: []interface{}{
																													&seqExpr{
																														pos: position{line: 3734, col: 16, offset: 128241},
																														exprs: []interface{}{
																															&zeroOrOneExpr{
																																pos: position{line: 3734, col: 16, offset: 128241},
																																expr: &litMatcher{
																																	pos:        position{line: 3734, col: 16, offset: 128241},
																																	val:        "\r",
																																	ignoreCase: false,
																																	want:       "\"\\r\"",
																																},
																															},
																															&litMatcher{
																																pos:        position{line: 3734, col: 22, offset: 128247},
																																val:        "\n",
																																ignoreCase: false,
																																want:       "\"\\n\"",
																															},
																														},
																													},
																													&notExpr{
																														pos: position{line: 3733, col: 12, offset: 128223},
																														expr: &anyMatcher{
																															line: 3733, col: 13, offset: 128224,
																														},
																													},
																												},
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 713, col: 22, offset: 21904},
																										val:        "[:!=(]",
																										chars:      []rune{':', '!', '=', '('},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 724, col: 5, offset: 22230},
																				run: (*parser).callonInlineBlock65,
																				expr: &seqExpr{
																					pos: position{line: 724, col: 5, offset: 22230},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 724, col: 5, offset: 22230},
																							label: "identI",
																							expr: &oneOrMoreExpr{
																								pos: position{line: 724, col: 12, offset: 22237},
																								expr: &charClassMatcher{
																									pos:        position{line: 724, col: 12, offset: 22237},
																									val:        "[^ \\t\\r\\n:!=(]",
																									chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 724, col: 28, offset: 22253},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3737, col: 8, offset: 128286},
																								run: (*parser).callonInlineBlock71,
																								expr: &choiceExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									alternatives: []interface{}{
																										&andExpr{
																											pos: position{line: 3737, col: 9, offset: 128287},
																											expr: &anyMatcher{
																												line: 3737, col: 10, offset: 128288,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3737, col: 14, offset: 128292},
																											expr: &anyMatcher{
																												line: 3737, col: 15, offset: 128293,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 329, col: 5, offset: 10344},
														run: (*parser).callonInlineBlock77,
														expr: &andExpr{
															pos: position{line: 329, col: 5, offset: 10344},
															expr: &seqExpr{
																pos: position{line: 3734, col: 12, offset: 128237},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 286, col: 38, offset: 9283},
							label: "scopeI",
							expr: &ruleRefExpr{
								pos:  position{line: 286, col: 45, offset: 9290},
								name: "Beait",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3734, col: 12, offset: 128237},
							expr: &charClassMatcher{
								pos:        position{line: 3746, col: 36, offset: 128584},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3734, col: 16, offset: 128241},
							alternatives: []interface{}{
								&seqExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											expr: &litMatcher{
												pos:        position{line: 3734, col: 16, offset: 128241},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3734, col: 22, offset: 128247},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3733, col: 12, offset: 128223},
									expr: &anyMatcher{
										line: 3733, col: 13, offset: 128224,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Prepend",
			pos:  position{line: 291, col: 1, offset: 9409},
			expr: &actionExpr{
				pos: position{line: 291, col: 12, offset: 9420},
				run: (*parser).callonPrepend1,
				expr: &seqExpr{
					pos: position{line: 291, col: 12, offset: 9420},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 291, col: 12, offset: 9420},
							label: "blockI",
							expr: &actionExpr{
								pos: position{line: 310, col: 21, offset: 9906},
								run: (*parser).callonPrepend4,
								expr: &seqExpr{
									pos: position{line: 310, col: 21, offset: 9906},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 310, col: 21, offset: 9906},
											val:        "prepend",
											ignoreCase: false,
											want:       "\"prepend\"",
										},
										&labeledExpr{
											pos:   position{line: 310, col: 31, offset: 9916},
											label: "nameI",
											expr: &choiceExpr{
												pos: position{line: 327, col: 14, offset: 10293},
												alternatives: []interface{}{
													&actionExpr{
														pos: position{line: 327, col: 14, offset: 10293},
														run: (*parser).callonPrepend9,
														expr: &seqExpr{
															pos: position{line: 327, col: 14, offset: 10293},
															exprs: []interface{}{
																&oneOrMoreExpr{
																	pos: position{line: 327, col: 14, offset: 10293},
																	expr: &litMatcher{
																		pos:        position{line: 327, col: 14, offset: 10293},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&labeledExpr{
																	pos:   position{line: 327, col: 19, offset: 10298},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 711, col: 14, offset: 21845},
																		alternatives: []interface{}{
																			&actionExpr{
																				pos: position{line: 711, col: 14, offset: 21845},
																				run: (*parser).callonPrepend15,
																				expr: &labeledExpr{
																					pos:   position{line: 711, col: 14, offset: 21845},
																					label: "identI",
																					expr: &choiceExpr{
																						pos: position{line: 697, col: 10, offset: 21290},
																						alternatives: []interface{}{
																							&actionExpr{
																								pos: position{line: 697, col: 10, offset: 21290},
																								run: (*parser).callonPrepend18,
																								expr: &labeledExpr{
																									pos:   position{line: 697, col: 10, offset: 21290},
																									label: "identI",
																									expr: &seqExpr{
																										pos: position{line: 2367, col: 17, offset: 81233},
																										exprs: []interface{}{
																											&charClassMatcher{
																												pos:        position{line: 2350, col: 20, offset: 80988},
																												val:        "[_\\pL]",
																												chars:      []rune{'_'},
																												classes:    []*unicode.RangeTable{rangeTable("L")},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&zeroOrMoreExpr{
																												pos: position{line: 2367, col: 26, offset: 81242},
																												expr: &charClassMatcher{
																													pos:        position{line: 2350, col: 20, offset: 80988},
																													val:        "[_\\pL\\pNd]",
																													chars:      []rune{'_'},
																													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 699, col: 5, offset: 21384},
																								run: (*parser).callonPrepend24,
																								expr: &seqExpr{
																									pos: position{line: 699, col: 5, offset: 21384},
																									exprs: []interface{}{
																										&labeledExpr{
																											pos:   position{line: 699, col: 5, offset: 21384},
																											label: "identI",
																											expr: &seqExpr{
																												pos: position{line: 699, col: 13, offset: 21392},
																												exprs: []interface{}{
																													&zeroOrOneExpr{
																														pos: position{line: 699, col: 13, offset: 21392},
																														expr: &litMatcher{
																															pos:        position{line: 699, col: 13, offset: 21392},
																															val:        "$",
																															ignoreCase: false,
																															want:       "\"$\"",
																														},
																													},
																													&oneOrMoreExpr{
																														pos: position{line: 699, col: 18, offset: 21397},
																														expr: &choiceExpr{
																															pos: position{line: 699, col: 19, offset: 21398},
																															alternatives: []interface{}{
																																&seqExpr{
																																	pos: position{line: 699, col: 19, offset: 21398},
																																	exprs: []interface{}{
																																		&charClassMatcher{
																																			pos:        position{line: 699, col: 19, offset: 21398},
																																			val:        "[\\pNd]",
																																			classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 699, col: 28, offset: 21407},
																																			val:        "[_-\\pL]",
																																			chars:      []rune{'_', '-'},
																																			classes:    []*unicode.RangeTable{rangeTable("L")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 699, col: 38, offset: 21417},
																																	val:        "[_-\\pL]",
																																	chars:      []rune{'_', '-'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&labeledExpr{
																											pos:   position{line: 699, col: 49, offset: 21428},
																											label: "endPosI",
																											expr: &actionExpr{
																												pos: position{line: 3737, col: 8, offset: 128286},
																												run: (*parser).callonPrepend37,
																												expr: &choiceExpr{
																													pos: position{line: 3737, col: 9, offset: 128287},
																													alternatives: []interface{}{
																														&andExpr{
																															pos: position{line: 3737, col: 9, offset: 128287},
																															expr: &anyMatcher{
																																line: 3737, col: 10, offset: 128288,
																															},
																														},
																														&notExpr{
																															pos: position{line: 3737, col: 14, offset: 128292},
																															expr: &anyMatcher{
																																line: 3737, col: 15, offset: 128293,
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 713, col: 5, offset: 21887},
																				run: (*parser).callonPrepend43,
																				expr: &seqExpr{
																					pos: position{line: 713, col: 5, offset: 21887},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 713, col: 5, offset: 21887},
																							label: "posI",
																							expr: &actionExpr{
																								pos: position{line: 3737, col: 8, offset: 128286},
																								run: (*parser).callonPrepend46,
																								expr: &choiceExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									alternatives: []interface{}{
																										&andExpr{
																											pos: position{line: 3737, col: 9, offset: 128287},
																											expr: &anyMatcher{
																												line: 3737, col: 10, offset: 128288,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3737, col: 14, offset: 128292},
																											expr: &anyMatcher{
																												line: 3737, col: 15, offset: 128293,
																											},
																										},
																									},
																								},
																							},
																						},
																						&andExpr{
																							pos: position{line: 713, col: 14, offset: 21896},
																							expr: &choiceExpr{
																								pos: position{line: 713, col: 16, offset: 21898},
																								alternatives: []interface{}{
																									&seqExpr{
																										pos: position{line: 3734, col: 12, offset: 128237},
																										exprs: []interface{}{
																											&zeroOrMoreExpr{
																												pos: position{line: 3734, col: 12, offset: 128237},
																												expr: &charClassMatcher{
																													pos:        position{line: 3746, col: 36, offset: 128584},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&choiceExpr{
																												pos: position{line: 3734, col: 16, offset: 128241},
																												alternatives: []interface{}{
																													&seqExpr{
																														pos: position{line: 3734, col: 16, offset: 128241},
																														exprs: []interface{}{
																															&zeroOrOneExpr{
																																pos: position{line: 3734, col: 16, offset: 128241},
																																expr: &litMatcher{
																																	pos:        position{line: 3734, col: 16, offset: 128241},
																																	val:        "\r",
																																	ignoreCase: false,
																																	want:       "\"\\r\"",
																																},
																															},
																															&litMatcher{
																																pos:        position{line: 3734, col: 22, offset: 128247},
																																val:        "\n",
																																ignoreCase: false,
																																want:       "\"\\n\"",
																															},
																														},
																													},
																													&notExpr{
																														pos: position{line: 3733, col: 12, offset: 128223},
																														expr: &anyMatcher{
																															line: 3733, col: 13, offset: 128224,
																														},
																													},
																												},
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 713, col: 22, offset: 21904},
																										val:        "[:!=(]",
																										chars:      []rune{':', '!', '=', '('},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 724, col: 5, offset: 22230},
																				run: (*parser).callonPrepend65,
																				expr: &seqExpr{
																					pos: position{line: 724, col: 5, offset: 22230},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 724, col: 5, offset: 22230},
																							label: "identI",
																							expr: &oneOrMoreExpr{
																								pos: position{line: 724, col: 12, offset: 22237},
																								expr: &charClassMatcher{
																									pos:        position{line: 724, col: 12, offset: 22237},
																									val:        "[^ \\t\\r\\n:!=(]",
																									chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 724, col: 28, offset: 22253},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3737, col: 8, offset: 128286},
																								run: (*parser).callonPrepend71,
																								expr: &choiceExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									alternatives: []interface{}{
																										&andExpr{
																											pos: position{line: 3737, col: 9, offset: 128287},
																											expr: &anyMatcher{
																												line: 3737, col: 10, offset: 128288,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3737, col: 14, offset: 128292},
																											expr: &anyMatcher{
																												line: 3737, col: 15, offset: 128293,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 329, col: 5, offset: 10344},
														run: (*parser).callonPrepend77,
														expr: &andExpr{
															pos: position{line: 329, col: 5, offset: 10344},
															expr: &seqExpr{
																pos: position{line: 3734, col: 12, offset: 128237},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 291, col: 36, offset: 9444},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 291, col: 42, offset: 9450},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "Append",
			pos:  position{line: 296, col: 1, offset: 9552},
			expr: &actionExpr{
				pos: position{line: 296, col: 11, offset: 9562},
				run: (*parser).callonAppend1,
				expr: &seqExpr{
					pos: position{line: 296, col: 11, offset: 9562},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 296, col: 11, offset: 9562},
							label: "blockI",
							expr: &actionExpr{
								pos: position{line: 318, col: 20, offset: 10103},
								run: (*parser).callonAppend4,
								expr: &seqExpr{
									pos: position{line: 318, col: 20, offset: 10103},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 318, col: 20, offset: 10103},
											val:        "append",
											ignoreCase: false,
											want:       "\"append\"",
										},
										&labeledExpr{
											pos:   position{line: 318, col: 29, offset: 10112},
											label: "nameI",
											expr: &choiceExpr{
												pos: position{line: 327, col: 14, offset: 10293},
												alternatives: []interface{}{
													&actionExpr{
														pos: position{line: 327, col: 14, offset: 10293},
														run: (*parser).callonAppend9,
														expr: &seqExpr{
															pos: position{line: 327, col: 14, offset: 10293},
															exprs: []interface{}{
																&oneOrMoreExpr{
																	pos: position{line: 327, col: 14, offset: 10293},
																	expr: &litMatcher{
																		pos:        position{line: 327, col: 14, offset: 10293},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&labeledExpr{
																	pos:   position{line: 327, col: 19, offset: 10298},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 711, col: 14, offset: 21845},
																		alternatives: []interface{}{
																			&actionExpr{
																				pos: position{line: 711, col: 14, offset: 21845},
																				run: (*parser).callonAppend15,
																				expr: &labeledExpr{
																					pos:   position{line: 711, col: 14, offset: 21845},
																					label: "identI",
																					expr: &choiceExpr{
																						pos: position{line: 697, col: 10, offset: 21290},
																						alternatives: []interface{}{
																							&actionExpr{
																								pos: position{line: 697, col: 10, offset: 21290},
																								run: (*parser).callonAppend18,
																								expr: &labeledExpr{
																									pos:   position{line: 697, col: 10, offset: 21290},
																									label: "identI",
																									expr: &seqExpr{
																										pos: position{line: 2367, col: 17, offset: 81233},
																										exprs: []interface{}{
																											&charClassMatcher{
																												pos:        position{line: 2350, col: 20, offset: 80988},
																												val:        "[_\\pL]",
																												chars:      []rune{'_'},
																												classes:    []*unicode.RangeTable{rangeTable("L")},
																												ignoreCase: false,
																												inverted:   false,
																											},
																											&zeroOrMoreExpr{
																												pos: position{line: 2367, col: 26, offset: 81242},
																												expr: &charClassMatcher{
																													pos:        position{line: 2350, col: 20, offset: 80988},
																													val:        "[_\\pL\\pNd]",
																													chars:      []rune{'_'},
																													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																							&actionExpr{
																								pos: position{line: 699, col: 5, offset: 21384},
																								run: (*parser).callonAppend24,
																								expr: &seqExpr{
																									pos: position{line: 699, col: 5, offset: 21384},
																									exprs: []interface{}{
																										&labeledExpr{
																											pos:   position{line: 699, col: 5, offset: 21384},
																											label: "identI",
																											expr: &seqExpr{
																												pos: position{line: 699, col: 13, offset: 21392},
																												exprs: []interface{}{
																													&zeroOrOneExpr{
																														pos: position{line: 699, col: 13, offset: 21392},
																														expr: &litMatcher{
																															pos:        position{line: 699, col: 13, offset: 21392},
																															val:        "$",
																															ignoreCase: false,
																															want:       "\"$\"",
																														},
																													},
																													&oneOrMoreExpr{
																														pos: position{line: 699, col: 18, offset: 21397},
																														expr: &choiceExpr{
																															pos: position{line: 699, col: 19, offset: 21398},
																															alternatives: []interface{}{
																																&seqExpr{
																																	pos: position{line: 699, col: 19, offset: 21398},
																																	exprs: []interface{}{
																																		&charClassMatcher{
																																			pos:        position{line: 699, col: 19, offset: 21398},
																																			val:        "[\\pNd]",
																																			classes:    []*unicode.RangeTable{rangeTable("Nd")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																		&charClassMatcher{
																																			pos:        position{line: 699, col: 28, offset: 21407},
																																			val:        "[_-\\pL]",
																																			chars:      []rune{'_', '-'},
																																			classes:    []*unicode.RangeTable{rangeTable("L")},
																																			ignoreCase: false,
																																			inverted:   false,
																																		},
																																	},
																																},
																																&charClassMatcher{
																																	pos:        position{line: 699, col: 38, offset: 21417},
																																	val:        "[_-\\pL]",
																																	chars:      []rune{'_', '-'},
																																	classes:    []*unicode.RangeTable{rangeTable("L")},
																																	ignoreCase: false,
																																	inverted:   false,
																																},
																															},
																														},
																													},
																												},
																											},
																										},
																										&labeledExpr{
																											pos:   position{line: 699, col: 49, offset: 21428},
																											label: "endPosI",
																											expr: &actionExpr{
																												pos: position{line: 3737, col: 8, offset: 128286},
																												run: (*parser).callonAppend37,
																												expr: &choiceExpr{
																													pos: position{line: 3737, col: 9, offset: 128287},
																													alternatives: []interface{}{
																														&andExpr{
																															pos: position{line: 3737, col: 9, offset: 128287},
																															expr: &anyMatcher{
																																line: 3737, col: 10, offset: 128288,
																															},
																														},
																														&notExpr{
																															pos: position{line: 3737, col: 14, offset: 128292},
																															expr: &anyMatcher{
																																line: 3737, col: 15, offset: 128293,
																															},
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 713, col: 5, offset: 21887},
																				run: (*parser).callonAppend43,
																				expr: &seqExpr{
																					pos: position{line: 713, col: 5, offset: 21887},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 713, col: 5, offset: 21887},
																							label: "posI",
																							expr: &actionExpr{
																								pos: position{line: 3737, col: 8, offset: 128286},
																								run: (*parser).callonAppend46,
																								expr: &choiceExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									alternatives: []interface{}{
																										&andExpr{
																											pos: position{line: 3737, col: 9, offset: 128287},
																											expr: &anyMatcher{
																												line: 3737, col: 10, offset: 128288,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3737, col: 14, offset: 128292},
																											expr: &anyMatcher{
																												line: 3737, col: 15, offset: 128293,
																											},
																										},
																									},
																								},
																							},
																						},
																						&andExpr{
																							pos: position{line: 713, col: 14, offset: 21896},
																							expr: &choiceExpr{
																								pos: position{line: 713, col: 16, offset: 21898},
																								alternatives: []interface{}{
																									&seqExpr{
																										pos: position{line: 3734, col: 12, offset: 128237},
																										exprs: []interface{}{
																											&zeroOrMoreExpr{
																												pos: position{line: 3734, col: 12, offset: 128237},
																												expr: &charClassMatcher{
																													pos:        position{line: 3746, col: 36, offset: 128584},
																													val:        "[ \\t]",
																													chars:      []rune{' ', '\t'},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																											&choiceExpr{
																												pos: position{line: 3734, col: 16, offset: 128241},
																												alternatives: []interface{}{
																													&seqExpr{
																														pos: position{line: 3734, col: 16, offset: 128241},
																														exprs: []interface{}{
																															&zeroOrOneExpr{
																																pos: position{line: 3734, col: 16, offset: 128241},
																																expr: &litMatcher{
																																	pos:        position{line: 3734, col: 16, offset: 128241},
																																	val:        "\r",
																																	ignoreCase: false,
																																	want:       "\"\\r\"",
																																},
																															},
																															&litMatcher{
																																pos:        position{line: 3734, col: 22, offset: 128247},
																																val:        "\n",
																																ignoreCase: false,
																																want:       "\"\\n\"",
																															},
																														},
																													},
																													&notExpr{
																														pos: position{line: 3733, col: 12, offset: 128223},
																														expr: &anyMatcher{
																															line: 3733, col: 13, offset: 128224,
																														},
																													},
																												},
																											},
																										},
																									},
																									&charClassMatcher{
																										pos:        position{line: 713, col: 22, offset: 21904},
																										val:        "[:!=(]",
																										chars:      []rune{':', '!', '=', '('},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 724, col: 5, offset: 22230},
																				run: (*parser).callonAppend65,
																				expr: &seqExpr{
																					pos: position{line: 724, col: 5, offset: 22230},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 724, col: 5, offset: 22230},
																							label: "identI",
																							expr: &oneOrMoreExpr{
																								pos: position{line: 724, col: 12, offset: 22237},
																								expr: &charClassMatcher{
																									pos:        position{line: 724, col: 12, offset: 22237},
																									val:        "[^ \\t\\r\\n:!=(]",
																									chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
																									ignoreCase: false,
																									inverted:   true,
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 724, col: 28, offset: 22253},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3737, col: 8, offset: 128286},
																								run: (*parser).callonAppend71,
																								expr: &choiceExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									alternatives: []interface{}{
																										&andExpr{
																											pos: position{line: 3737, col: 9, offset: 128287},
																											expr: &anyMatcher{
																												line: 3737, col: 10, offset: 128288,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3737, col: 14, offset: 128292},
																											expr: &anyMatcher{
																												line: 3737, col: 15, offset: 128293,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 329, col: 5, offset: 10344},
														run: (*parser).callonAppend77,
														expr: &andExpr{
															pos: position{line: 329, col: 5, offset: 10344},
															expr: &seqExpr{
																pos: position{line: 3734, col: 12, offset: 128237},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 296, col: 34, offset: 9585},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 296, col: 40, offset: 9591},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "BlockExpansion",
			pos:  position{line: 344, col: 1, offset: 10791},
			expr: &choiceExpr{
				pos: position{line: 344, col: 19, offset: 10809},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 344, col: 19, offset: 10809},
						run: (*parser).callonBlockExpansion2,
						expr: &seqExpr{
							pos: position{line: 344, col: 19, offset: 10809},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 344, col: 19, offset: 10809},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&labeledExpr{
									pos:   position{line: 344, col: 23, offset: 10813},
									label: "abI",
									expr: &ruleRefExpr{
										pos:  position{line: 344, col: 27, offset: 10817},
										name: "InlineArrowBlock",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 349, col: 5, offset: 10946},
						run: (*parser).callonBlockExpansion7,
						expr: &seqExpr{
							pos: position{line: 349, col: 5, offset: 10946},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 349, col: 5, offset: 10946},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 349, col: 9, offset: 10950},
									expr: &litMatcher{
										pos:        position{line: 349, col: 9, offset: 10950},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 349, col: 14, offset: 10955},
									label: "sI",
									expr: &ruleRefExpr{
										pos:  position{line: 349, col: 17, offset: 10958},
										name: "blockExpansionItem",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 354, col: 5, offset: 11087},
						run: (*parser).callonBlockExpansion14,
						expr: &seqExpr{
							pos: position{line: 354, col: 5, offset: 11087},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 354, col: 5, offset: 11087},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 365, col: 5, offset: 11460},
						run: (*parser).callonBlockExpansion26,
						expr: &seqExpr{
							pos: position{line: 365, col: 5, offset: 11460},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 365, col: 5, offset: 11460},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&labeledExpr{
									pos:   position{line: 365, col: 9, offset: 11464},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonBlockExpansion30,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 365, col: 18, offset: 11473},
									label: "sI",
									expr: &ruleRefExpr{
										pos:  position{line: 365, col: 21, offset: 11476},
										name: "blockExpansionItem",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "blockExpansionItem",
			pos:  position{line: 392, col: 1, offset: 12156},
			expr: &choiceExpr{
				pos: position{line: 392, col: 23, offset: 12178},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 392, col: 23, offset: 12178},
						name: "InlineBlock",
					},
					&ruleRefExpr{
						pos:  position{line: 392, col: 37, offset: 12192},
						name: "InlineElement",
					},
					&ruleRefExpr{
						pos:  position{line: 392, col: 53, offset: 12208},
						name: "InlineDivShorthand",
					},
					&ruleRefExpr{
						pos:  position{line: 392, col: 74, offset: 12229},
						name: "InlineMixinCall",
					},
					&actionExpr{
						pos: position{line: 394, col: 22, offset: 12287},
						run: (*parser).callonblockExpansionItem6,
						expr: &seqExpr{
							pos: position{line: 394, col: 22, offset: 12287},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 394, col: 22, offset: 12287},
									label: "lineI",
									expr: &oneOrMoreExpr{
										pos: position{line: 394, col: 28, offset: 12293},
										expr: &charClassMatcher{
											pos:        position{line: 3735, col: 12, offset: 128270},
											val:        "[^\\r\\n]",
											chars:      []rune{'\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Codes",
			pos:  position{line: 416, col: 1, offset: 13005},
			expr: &actionExpr{
				pos: position{line: 416, col: 10, offset: 13014},
				run: (*parser).callonCodes1,
				expr: &labeledExpr{
					pos:   position{line: 416, col: 10, offset: 13014},
					label: "codesI",
					expr: &oneOrMoreExpr{
						pos: position{line: 416, col: 17, offset: 13021},
						expr: &seqExpr{
							pos: position{line: 416, col: 18, offset: 13022},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 416, col: 18, offset: 13022},
									expr: &oneOrMoreExpr{
										pos: position{line: 3748, col: 36, offset: 128671},
										expr: &seqExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 3748, col: 37, offset: 128672},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3747, col: 36, offset: 128625},
													expr: &litMatcher{
														pos:        position{line: 3747, col: 36, offset: 128625},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3747, col: 42, offset: 128631},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 416, col: 27, offset: 13031},
									name: "Code",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Code",
			pos:  position{line: 420, col: 1, offset: 13102},
			expr: &choiceExpr{
				pos: position{line: 420, col: 9, offset: 13110},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 420, col: 9, offset: 13110},
						run: (*parser).callonCode2,
						expr: &seqExpr{
							pos: position{line: 420, col: 9, offset: 13110},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 420, col: 9, offset: 13110},
									val:        "- ",
									ignoreCase: false,
									want:       "\"- \"",
								},
								&labeledExpr{
									pos:   position{line: 420, col: 14, offset: 13115},
									label: "firstLineI",
									expr: &actionExpr{
										pos: position{line: 446, col: 13, offset: 13945},
										run: (*parser).callonCode6,
										expr: &seqExpr{
											pos: position{line: 446, col: 13, offset: 13945},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 446, col: 13, offset: 13945},
													label: "code",
													expr: &oneOrMoreExpr{
														pos: position{line: 446, col: 18, offset: 13950},
														expr: &charClassMatcher{
															pos:        position{line: 3735, col: 12, offset: 128270},
															val:        "[^\\r\\n]",
															chars:      []rune{'\r', '\n'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&zeroOrMoreExpr{
													pos: position{line: 3734, col: 12, offset: 128237},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&choiceExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 3734, col: 16, offset: 128241},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	expr: &litMatcher{
																		pos:        position{line: 3734, col: 16, offset: 128241},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3734, col: 22, offset: 128247},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
														&notExpr{
															pos: position{line: 3733, col: 12, offset: 128223},
															expr: &anyMatcher{
																line: 3733, col: 13, offset: 128224,
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 420, col: 34, offset: 13135},
									label: "additionalLinesI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 420, col: 51, offset: 13152},
										expr: &seqExpr{
											pos: position{line: 420, col: 52, offset: 13153},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 420, col: 52, offset: 13153},
													expr: &oneOrMoreExpr{
														pos: position{line: 3748, col: 36, offset: 128671},
														expr: &seqExpr{
															pos: position{line: 3748, col: 37, offset: 128672},
															exprs: []interface{}{
																&zeroOrMoreExpr{
																	pos: position{line: 3748, col: 37, offset: 128672},
																	expr: &charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 3747, col: 36, offset: 128625},
																	expr: &litMatcher{
																		pos:        position{line: 3747, col: 36, offset: 128625},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3747, col: 42, offset: 128631},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
												&ruleRefExpr{
													pos:  position{line: 420, col: 61, offset: 13162},
													name: "INDENTATION2",
												},
												&actionExpr{
													pos: position{line: 446, col: 13, offset: 13945},
													run: (*parser).callonCode32,
													expr: &seqExpr{
														pos: position{line: 446, col: 13, offset: 13945},
														exprs: []interface{}{
															&labeledExpr{
																pos:   position{line: 446, col: 13, offset: 13945},
																label: "code",
																expr: &oneOrMoreExpr{
																	pos: position{line: 446, col: 18, offset: 13950},
																	expr: &charClassMatcher{
																		pos:        position{line: 3735, col: 12, offset: 128270},
																		val:        "[^\\r\\n]",
																		chars:      []rune{'\r', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																},
															},
															&zeroOrMoreExpr{
																pos: position{line: 3734, col: 12, offset: 128237},
																expr: &charClassMatcher{
																	pos:        position{line: 3746, col: 36, offset: 128584},
																	val:        "[ \\t]",
																	chars:      []rune{' ', '\t'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&choiceExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																alternatives: []interface{}{
																	&seqExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		exprs: []interface{}{
																			&zeroOrOneExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				expr: &litMatcher{
																					pos:        position{line: 3734, col: 16, offset: 128241},
																					val:        "\r",
																					ignoreCase: false,
																					want:       "\"\\r\"",
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 3734, col: 22, offset: 128247},
																				val:        "\n",
																				ignoreCase: false,
																				want:       "\"\\n\"",
																			},
																		},
																	},
																	&notExpr{
																		pos: position{line: 3733, col: 12, offset: 128223},
																		expr: &anyMatcher{
																			line: 3733, col: 13, offset: 128224,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 433, col: 5, offset: 13539},
						run: (*parser).callonCode46,
						expr: &seqExpr{
							pos: position{line: 433, col: 5, offset: 13539},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 433, col: 5, offset: 13539},
									val:        "-",
									ignoreCase: false,
									want:       "\"-\"",
								},
								&labeledExpr{
									pos:   position{line: 433, col: 9, offset: 13543},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonCode50,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "condition",
			pos:  position{line: 449, col: 1, offset: 14035},
			expr: &choiceExpr{
				pos: position{line: 449, col: 14, offset: 14048},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 449, col: 14, offset: 14048},
						run: (*parser).calloncondition2,
						expr: &seqExpr{
							pos: position{line: 449, col: 14, offset: 14048},
							exprs: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 449, col: 14, offset: 14048},
									expr: &litMatcher{
										pos:        position{line: 449, col: 14, offset: 14048},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 449, col: 19, offset: 14053},
									label: "condI",
									expr: &ruleRefExpr{
										pos:  position{line: 449, col: 25, offset: 14059},
										name: "IfExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 451, col: 5, offset: 14100},
						run: (*parser).calloncondition8,
						expr: &seqExpr{
							pos: position{line: 451, col: 5, offset: 14100},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 451, col: 5, offset: 14100},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).calloncondition11,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&andExpr{
									pos: position{line: 451, col: 14, offset: 14109},
									expr: &seqExpr{
										pos: position{line: 3734, col: 12, offset: 128237},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 3734, col: 12, offset: 128237},
												expr: &charClassMatcher{
													pos:        position{line: 3746, col: 36, offset: 128584},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&choiceExpr{
												pos: position{line: 3734, col: 16, offset: 128241},
												alternatives: []interface{}{
													&seqExpr{
														pos: position{line: 3734, col: 16, offset: 128241},
														exprs: []interface{}{
															&zeroOrOneExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																expr: &litMatcher{
																	pos:        position{line: 3734, col: 16, offset: 128241},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3734, col: 22, offset: 128247},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
													&notExpr{
														pos: position{line: 3733, col: 12, offset: 128223},
														expr: &anyMatcher{
															line: 3733, col: 13, offset: 128224,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 460, col: 5, offset: 14392},
						run: (*parser).calloncondition28,
						expr: &labeledExpr{
							pos:   position{line: 460, col: 5, offset: 14392},
							label: "posI",
							expr: &actionExpr{
								pos: position{line: 3737, col: 8, offset: 128286},
								run: (*parser).calloncondition30,
								expr: &choiceExpr{
									pos: position{line: 3737, col: 9, offset: 128287},
									alternatives: []interface{}{
										&andExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											expr: &anyMatcher{
												line: 3737, col: 10, offset: 128288,
											},
										},
										&notExpr{
											pos: position{line: 3737, col: 14, offset: 128292},
											expr: &anyMatcher{
												line: 3737, col: 15, offset: 128293,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "then",
			pos:  position{line: 470, col: 1, offset: 14650},
			expr: &choiceExpr{
				pos: position{line: 470, col: 9, offset: 14658},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 470, col: 9, offset: 14658},
						run: (*parser).callonthen2,
						expr: &seqExpr{
							pos: position{line: 470, col: 9, offset: 14658},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 470, col: 13, offset: 14662},
									label: "scopeI",
									expr: &ruleRefExpr{
										pos:  position{line: 470, col: 20, offset: 14669},
										name: "Body",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 472, col: 5, offset: 14703},
						run: (*parser).callonthen15,
						expr: &seqExpr{
							pos: position{line: 3734, col: 12, offset: 128237},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 480, col: 5, offset: 14955},
						exprs: []interface{}{
							&actionExpr{
								pos: position{line: 481, col: 6, offset: 14962},
								run: (*parser).callonthen27,
								expr: &oneOrMoreExpr{
									pos: position{line: 481, col: 6, offset: 14962},
									expr: &charClassMatcher{
										pos:        position{line: 481, col: 6, offset: 14962},
										val:        "[^:\\r\\n]",
										chars:      []rune{':', '\r', '\n'},
										ignoreCase: false,
										inverted:   true,
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 481, col: 40, offset: 14996},
								run: (*parser).callonthen30,
							},
							&ruleRefExpr{
								pos:  position{line: 490, col: 3, offset: 15271},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "If",
			pos:  position{line: 499, col: 1, offset: 15472},
			expr: &actionExpr{
				pos: position{line: 499, col: 7, offset: 15478},
				run: (*parser).callonIf1,
				expr: &seqExpr{
					pos: position{line: 499, col: 7, offset: 15478},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 499, col: 7, offset: 15478},
							val:        "if",
							ignoreCase: false,
							want:       "\"if\"",
						},
						&notExpr{
							pos: position{line: 499, col: 12, offset: 15483},
							expr: &litMatcher{
								pos:        position{line: 499, col: 13, offset: 15484},
								val:        " block",
								ignoreCase: false,
								want:       "\" block\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 499, col: 22, offset: 15493},
							label: "condI",
							expr: &ruleRefExpr{
								pos:  position{line: 499, col: 28, offset: 15499},
								name: "condition",
							},
						},
						&labeledExpr{
							pos:   position{line: 499, col: 38, offset: 15509},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 499, col: 44, offset: 15515},
								name: "then",
							},
						},
						&labeledExpr{
							pos:   position{line: 499, col: 49, offset: 15520},
							label: "elseIfsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 499, col: 58, offset: 15529},
								expr: &ruleRefExpr{
									pos:  position{line: 499, col: 58, offset: 15529},
									name: "ElseIf",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 499, col: 66, offset: 15537},
							label: "elseI",
							expr: &zeroOrOneExpr{
								pos: position{line: 499, col: 72, offset: 15543},
								expr: &ruleRefExpr{
									pos:  position{line: 499, col: 72, offset: 15543},
									name: "Else",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ElseIf",
			pos:  position{line: 509, col: 1, offset: 15783},
			expr: &actionExpr{
				pos: position{line: 509, col: 11, offset: 15793},
				run: (*parser).callonElseIf1,
				expr: &seqExpr{
					pos: position{line: 509, col: 11, offset: 15793},
					exprs: []interface{}{
						&zeroOrOneExpr{
							pos: position{line: 509, col: 11, offset: 15793},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&actionExpr{
							pos: position{line: 3835, col: 17, offset: 132478},
							run: (*parser).callonElseIf11,
							expr: &zeroOrMoreExpr{
								pos: position{line: 3835, col: 17, offset: 132478},
								expr: &charClassMatcher{
									pos:        position{line: 3746, col: 36, offset: 128584},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 3835, col: 41, offset: 132502},
							run: (*parser).callonElseIf14,
						},
						&choiceExpr{
							pos: position{line: 3887, col: 5, offset: 134412},
							alternatives: []interface{}{
								&andCodeExpr{
									pos: position{line: 3887, col: 5, offset: 134412},
									run: (*parser).callonElseIf16,
								},
								&seqExpr{
									pos: position{line: 3889, col: 9, offset: 134495},
									exprs: []interface{}{
										&andCodeExpr{
											pos: position{line: 3889, col: 9, offset: 134495},
											run: (*parser).callonElseIf18,
										},
										&stateCodeExpr{
											pos: position{line: 3891, col: 7, offset: 134599},
											run: (*parser).callonElseIf19,
										},
									},
								},
								&seqExpr{
									pos: position{line: 3898, col: 9, offset: 134935},
									exprs: []interface{}{
										&andCodeExpr{
											pos: position{line: 3898, col: 9, offset: 134935},
											run: (*parser).callonElseIf21,
										},
										&choiceExpr{
											pos: position{line: 3951, col: 9, offset: 137270},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 3951, col: 9, offset: 137270},
													exprs: []interface{}{
														&andCodeExpr{
															pos: position{line: 3951, col: 9, offset: 137270},
															run: (*parser).callonElseIf24,
														},
														&andCodeExpr{
															pos: position{line: 3955, col: 11, offset: 137520},
															run: (*parser).callonElseIf25,
														},
														&stateCodeExpr{
															pos: position{line: 4021, col: 11, offset: 140726},
															run: (*parser).callonElseIf26,
														},
													},
												},
												&seqExpr{
													pos: position{line: 4029, col: 13, offset: 141079},
													exprs: []interface{}{
														&andCodeExpr{
															pos: position{line: 4029, col: 13, offset: 141079},
															run: (*parser).callonElseIf28,
														},
														&andCodeExpr{
															pos: position{line: 4033, col: 11, offset: 141334},
															run: (*parser).callonElseIf29,
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 509, col: 32, offset: 15814},
							label: "posI",
							expr: &actionExpr{
								pos: position{line: 3737, col: 8, offset: 128286},
								run: (*parser).callonElseIf31,
								expr: &choiceExpr{
									pos: position{line: 3737, col: 9, offset: 128287},
									alternatives: []interface{}{
										&andExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											expr: &anyMatcher{
												line: 3737, col: 10, offset: 128288,
											},
										},
										&notExpr{
											pos: position{line: 3737, col: 14, offset: 128292},
											expr: &anyMatcher{
												line: 3737, col: 15, offset: 128293,
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 509, col: 41, offset: 15823},
							val:        "else if",
							ignoreCase: false,
							want:       "\"else if\"",
						},
						&labeledExpr{
							pos:   position{line: 509, col: 51, offset: 15833},
							label: "condI",
							expr: &ruleRefExpr{
								pos:  position{line: 509, col: 57, offset: 15839},
								name: "condition",
							},
						},
						&labeledExpr{
							pos:   position{line: 509, col: 67, offset: 15849},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 509, col: 73, offset: 15855},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "Else",
			pos:  position{line: 517, col: 1, offset: 16018},
			expr: &actionExpr{
				pos: position{line: 517, col: 9, offset: 16026},
				run: (*parser).callonElse1,
				expr: &seqExpr{
					pos: position{line: 517, col: 9, offset: 16026},
					exprs: []interface{}{
						&zeroOrOneExpr{
							pos: position{line: 517, col: 9, offset: 16026},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&actionExpr{
							pos: position{line: 3835, col: 17, offset: 132478},
							run: (*parser).callonElse11,
							expr: &zeroOrMoreExpr{
								pos: position{line: 3835, col: 17, offset: 132478},
								expr: &charClassMatcher{
									pos:        position{line: 3746, col: 36, offset: 128584},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 3835, col: 41, offset: 132502},
							run: (*parser).callonElse14,
						},
						&choiceExpr{
							pos: position{line: 3887, col: 5, offset: 134412},
							alternatives: []interface{}{
								&andCodeExpr{
									pos: position{line: 3887, col: 5, offset: 134412},
									run: (*parser).callonElse16,
								},
								&seqExpr{
									pos: position{line: 3889, col: 9, offset: 134495},
									exprs: []interface{}{
										&andCodeExpr{
											pos: position{line: 3889, col: 9, offset: 134495},
											run: (*parser).callonElse18,
										},
										&stateCodeExpr{
											pos: position{line: 3891, col: 7, offset: 134599},
											run: (*parser).callonElse19,
										},
									},
								},
								&seqExpr{
									pos: position{line: 3898, col: 9, offset: 134935},
									exprs: []interface{}{
										&andCodeExpr{
											pos: position{line: 3898, col: 9, offset: 134935},
											run: (*parser).callonElse21,
										},
										&choiceExpr{
											pos: position{line: 3951, col: 9, offset: 137270},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 3951, col: 9, offset: 137270},
													exprs: []interface{}{
														&andCodeExpr{
															pos: position{line: 3951, col: 9, offset: 137270},
															run: (*parser).callonElse24,
														},
														&andCodeExpr{
															pos: position{line: 3955, col: 11, offset: 137520},
															run: (*parser).callonElse25,
														},
														&stateCodeExpr{
															pos: position{line: 4021, col: 11, offset: 140726},
															run: (*parser).callonElse26,
														},
													},
												},
												&seqExpr{
													pos: position{line: 4029, col: 13, offset: 141079},
													exprs: []interface{}{
														&andCodeExpr{
															pos: position{line: 4029, col: 13, offset: 141079},
															run: (*parser).callonElse28,
														},
														&andCodeExpr{
															pos: position{line: 4033, col: 11, offset: 141334},
															run: (*parser).callonElse29,
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 517, col: 30, offset: 16047},
							val:        "else",
							ignoreCase: false,
							want:       "\"else\"",
						},
						&labeledExpr{
							pos:   position{line: 517, col: 37, offset: 16054},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 517, col: 43, offset: 16060},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "IfBlock",
			pos:  position{line: 528, col: 1, offset: 16182},
			expr: &actionExpr{
				pos: position{line: 528, col: 12, offset: 16193},
				run: (*parser).callonIfBlock1,
				expr: &seqExpr{
					pos: position{line: 528, col: 12, offset: 16193},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 528, col: 12, offset: 16193},
							val:        "if block",
							ignoreCase: false,
							want:       "\"if block\"",
						},
						&labeledExpr{
							pos:   position{line: 528, col: 23, offset: 16204},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 327, col: 14, offset: 10293},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 327, col: 14, offset: 10293},
										run: (*parser).callonIfBlock6,
										expr: &seqExpr{
											pos: position{line: 327, col: 14, offset: 10293},
											exprs: []interface{}{
												&oneOrMoreExpr{
													pos: position{line: 327, col: 14, offset: 10293},
													expr: &litMatcher{
														pos:        position{line: 327, col: 14, offset: 10293},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&labeledExpr{
													pos:   position{line: 327, col: 19, offset: 10298},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 711, col: 14, offset: 21845},
														alternatives: []interface{}{
															&actionExpr{
																pos: position{line: 711, col: 14, offset: 21845},
																run: (*parser).callonIfBlock12,
																expr: &labeledExpr{
																	pos:   position{line: 711, col: 14, offset: 21845},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 697, col: 10, offset: 21290},
																		alternatives: []interface{}{
																			&actionExpr{
																				pos: position{line: 697, col: 10, offset: 21290},
																				run: (*parser).callonIfBlock15,
																				expr: &labeledExpr{
																					pos:   position{line: 697, col: 10, offset: 21290},
																					label: "identI",
																					expr: &seqExpr{
																						pos: position{line: 2367, col: 17, offset: 81233},
																						exprs: []interface{}{
																							&charClassMatcher{
																								pos:        position{line: 2350, col: 20, offset: 80988},
																								val:        "[_\\pL]",
																								chars:      []rune{'_'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&zeroOrMoreExpr{
																								pos: position{line: 2367, col: 26, offset: 81242},
																								expr: &charClassMatcher{
																									pos:        position{line: 2350, col: 20, offset: 80988},
																									val:        "[_\\pL\\pNd]",
																									chars:      []rune{'_'},
																									classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 699, col: 5, offset: 21384},
																				run: (*parser).callonIfBlock21,
																				expr: &seqExpr{
																					pos: position{line: 699, col: 5, offset: 21384},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 699, col: 5, offset: 21384},
																							label: "identI",
																							expr: &seqExpr{
																								pos: position{line: 699, col: 13, offset: 21392},
																								exprs: []interface{}{
																									&zeroOrOneExpr{
																										pos: position{line: 699, col: 13, offset: 21392},
																										expr: &litMatcher{
																											pos:        position{line: 699, col: 13, offset: 21392},
																											val:        "$",
																											ignoreCase: false,
																											want:       "\"$\"",
																										},
																									},
																									&oneOrMoreExpr{
																										pos: position{line: 699, col: 18, offset: 21397},
																										expr: &choiceExpr{
																											pos: position{line: 699, col: 19, offset: 21398},
																											alternatives: []interface{}{
																												&seqExpr{
																													pos: position{line: 699, col: 19, offset: 21398},
																													exprs: []interface{}{
																														&charClassMatcher{
																															pos:        position{line: 699, col: 19, offset: 21398},
																															val:        "[\\pNd]",
																															classes:    []*unicode.RangeTable{rangeTable("Nd")},
																															ignoreCase: false,
																															inverted:   false,
																														},
																														&charClassMatcher{
																															pos:        position{line: 699, col: 28, offset: 21407},
																															val:        "[_-\\pL]",
																															chars:      []rune{'_', '-'},
																															classes:    []*unicode.RangeTable{rangeTable("L")},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																												},
																												&charClassMatcher{
																													pos:        position{line: 699, col: 38, offset: 21417},
																													val:        "[_-\\pL]",
																													chars:      []rune{'_', '-'},
																													classes:    []*unicode.RangeTable{rangeTable("L")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 699, col: 49, offset: 21428},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3737, col: 8, offset: 128286},
																								run: (*parser).callonIfBlock34,
																								expr: &choiceExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									alternatives: []interface{}{
																										&andExpr{
																											pos: position{line: 3737, col: 9, offset: 128287},
																											expr: &anyMatcher{
																												line: 3737, col: 10, offset: 128288,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3737, col: 14, offset: 128292},
																											expr: &anyMatcher{
																												line: 3737, col: 15, offset: 128293,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 713, col: 5, offset: 21887},
																run: (*parser).callonIfBlock40,
																expr: &seqExpr{
																	pos: position{line: 713, col: 5, offset: 21887},
																	exprs: []interface{}{
																		&labeledExpr{
																			pos:   position{line: 713, col: 5, offset: 21887},
																			label: "posI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonIfBlock43,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																		&andExpr{
																			pos: position{line: 713, col: 14, offset: 21896},
																			expr: &choiceExpr{
																				pos: position{line: 713, col: 16, offset: 21898},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 3734, col: 12, offset: 128237},
																						exprs: []interface{}{
																							&zeroOrMoreExpr{
																								pos: position{line: 3734, col: 12, offset: 128237},
																								expr: &charClassMatcher{
																									pos:        position{line: 3746, col: 36, offset: 128584},
																									val:        "[ \\t]",
																									chars:      []rune{' ', '\t'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&choiceExpr{
																								pos: position{line: 3734, col: 16, offset: 128241},
																								alternatives: []interface{}{
																									&seqExpr{
																										pos: position{line: 3734, col: 16, offset: 128241},
																										exprs: []interface{}{
																											&zeroOrOneExpr{
																												pos: position{line: 3734, col: 16, offset: 128241},
																												expr: &litMatcher{
																													pos:        position{line: 3734, col: 16, offset: 128241},
																													val:        "\r",
																													ignoreCase: false,
																													want:       "\"\\r\"",
																												},
																											},
																											&litMatcher{
																												pos:        position{line: 3734, col: 22, offset: 128247},
																												val:        "\n",
																												ignoreCase: false,
																												want:       "\"\\n\"",
																											},
																										},
																									},
																									&notExpr{
																										pos: position{line: 3733, col: 12, offset: 128223},
																										expr: &anyMatcher{
																											line: 3733, col: 13, offset: 128224,
																										},
																									},
																								},
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 713, col: 22, offset: 21904},
																						val:        "[:!=(]",
																						chars:      []rune{':', '!', '=', '('},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 724, col: 5, offset: 22230},
																run: (*parser).callonIfBlock62,
																expr: &seqExpr{
																	pos: position{line: 724, col: 5, offset: 22230},
																	exprs: []interface{}{
																		&labeledExpr{
																			pos:   position{line: 724, col: 5, offset: 22230},
																			label: "identI",
																			expr: &oneOrMoreExpr{
																				pos: position{line: 724, col: 12, offset: 22237},
																				expr: &charClassMatcher{
																					pos:        position{line: 724, col: 12, offset: 22237},
																					val:        "[^ \\t\\r\\n:!=(]",
																					chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 724, col: 28, offset: 22253},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonIfBlock68,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 329, col: 5, offset: 10344},
										run: (*parser).callonIfBlock74,
										expr: &andExpr{
											pos: position{line: 329, col: 5, offset: 10344},
											expr: &seqExpr{
												pos: position{line: 3734, col: 12, offset: 128237},
												exprs: []interface{}{
													&zeroOrMoreExpr{
														pos: position{line: 3734, col: 12, offset: 128237},
														expr: &charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3734, col: 16, offset: 128241},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		expr: &litMatcher{
																			pos:        position{line: 3734, col: 16, offset: 128241},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3734, col: 22, offset: 128247},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3733, col: 12, offset: 128223},
																expr: &anyMatcher{
																	line: 3733, col: 13, offset: 128224,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 528, col: 39, offset: 16220},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 528, col: 45, offset: 16226},
								name: "then",
							},
						},
						&labeledExpr{
							pos:   position{line: 528, col: 50, offset: 16231},
							label: "elseIfsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 528, col: 59, offset: 16240},
								expr: &ruleRefExpr{
									pos:  position{line: 528, col: 59, offset: 16240},
									name: "ElseIfBlock",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 528, col: 72, offset: 16253},
							label: "elseI",
							expr: &zeroOrOneExpr{
								pos: position{line: 528, col: 78, offset: 16259},
								expr: &ruleRefExpr{
									pos:  position{line: 528, col: 78, offset: 16259},
									name: "Else",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ElseIfBlock",
			pos:  position{line: 538, col: 1, offset: 16499},
			expr: &actionExpr{
				pos: position{line: 538, col: 16, offset: 16514},
				run: (*parser).callonElseIfBlock1,
				expr: &seqExpr{
					pos: position{line: 538, col: 16, offset: 16514},
					exprs: []interface{}{
						&zeroOrOneExpr{
							pos: position{line: 538, col: 16, offset: 16514},
							expr: &oneOrMoreExpr{
								pos: position{line: 3748, col: 36, offset: 128671},
								expr: &seqExpr{
									pos: position{line: 3748, col: 37, offset: 128672},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
						&actionExpr{
							pos: position{line: 3835, col: 17, offset: 132478},
							run: (*parser).callonElseIfBlock11,
							expr: &zeroOrMoreExpr{
								pos: position{line: 3835, col: 17, offset: 132478},
								expr: &charClassMatcher{
									pos:        position{line: 3746, col: 36, offset: 128584},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 3835, col: 41, offset: 132502},
							run: (*parser).callonElseIfBlock14,
						},
						&choiceExpr{
							pos: position{line: 3887, col: 5, offset: 134412},
							alternatives: []interface{}{
								&andCodeExpr{
									pos: position{line: 3887, col: 5, offset: 134412},
									run: (*parser).callonElseIfBlock16,
								},
								&seqExpr{
									pos: position{line: 3889, col: 9, offset: 134495},
									exprs: []interface{}{
										&andCodeExpr{
											pos: position{line: 3889, col: 9, offset: 134495},
											run: (*parser).callonElseIfBlock18,
										},
										&stateCodeExpr{
											pos: position{line: 3891, col: 7, offset: 134599},
											run: (*parser).callonElseIfBlock19,
										},
									},
								},
								&seqExpr{
									pos: position{line: 3898, col: 9, offset: 134935},
									exprs: []interface{}{
										&andCodeExpr{
											pos: position{line: 3898, col: 9, offset: 134935},
											run: (*parser).callonElseIfBlock21,
										},
										&choiceExpr{
											pos: position{line: 3951, col: 9, offset: 137270},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 3951, col: 9, offset: 137270},
													exprs: []interface{}{
														&andCodeExpr{
															pos: position{line: 3951, col: 9, offset: 137270},
															run: (*parser).callonElseIfBlock24,
														},
														&andCodeExpr{
															pos: position{line: 3955, col: 11, offset: 137520},
															run: (*parser).callonElseIfBlock25,
														},
														&stateCodeExpr{
															pos: position{line: 4021, col: 11, offset: 140726},
															run: (*parser).callonElseIfBlock26,
														},
													},
												},
												&seqExpr{
													pos: position{line: 4029, col: 13, offset: 141079},
													exprs: []interface{}{
														&andCodeExpr{
															pos: position{line: 4029, col: 13, offset: 141079},
															run: (*parser).callonElseIfBlock28,
														},
														&andCodeExpr{
															pos: position{line: 4033, col: 11, offset: 141334},
															run: (*parser).callonElseIfBlock29,
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 538, col: 37, offset: 16535},
							label: "posI",
							expr: &actionExpr{
								pos: position{line: 3737, col: 8, offset: 128286},
								run: (*parser).callonElseIfBlock31,
								expr: &choiceExpr{
									pos: position{line: 3737, col: 9, offset: 128287},
									alternatives: []interface{}{
										&andExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											expr: &anyMatcher{
												line: 3737, col: 10, offset: 128288,
											},
										},
										&notExpr{
											pos: position{line: 3737, col: 14, offset: 128292},
											expr: &anyMatcher{
												line: 3737, col: 15, offset: 128293,
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 538, col: 46, offset: 16544},
							val:        "else if block",
							ignoreCase: false,
							want:       "\"else if block\"",
						},
						&labeledExpr{
							pos:   position{line: 538, col: 62, offset: 16560},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 327, col: 14, offset: 10293},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 327, col: 14, offset: 10293},
										run: (*parser).callonElseIfBlock40,
										expr: &seqExpr{
											pos: position{line: 327, col: 14, offset: 10293},
											exprs: []interface{}{
												&oneOrMoreExpr{
													pos: position{line: 327, col: 14, offset: 10293},
													expr: &litMatcher{
														pos:        position{line: 327, col: 14, offset: 10293},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&labeledExpr{
													pos:   position{line: 327, col: 19, offset: 10298},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 711, col: 14, offset: 21845},
														alternatives: []interface{}{
															&actionExpr{
																pos: position{line: 711, col: 14, offset: 21845},
																run: (*parser).callonElseIfBlock46,
																expr: &labeledExpr{
																	pos:   position{line: 711, col: 14, offset: 21845},
																	label: "identI",
																	expr: &choiceExpr{
																		pos: position{line: 697, col: 10, offset: 21290},
																		alternatives: []interface{}{
																			&actionExpr{
																				pos: position{line: 697, col: 10, offset: 21290},
																				run: (*parser).callonElseIfBlock49,
																				expr: &labeledExpr{
																					pos:   position{line: 697, col: 10, offset: 21290},
																					label: "identI",
																					expr: &seqExpr{
																						pos: position{line: 2367, col: 17, offset: 81233},
																						exprs: []interface{}{
																							&charClassMatcher{
																								pos:        position{line: 2350, col: 20, offset: 80988},
																								val:        "[_\\pL]",
																								chars:      []rune{'_'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&zeroOrMoreExpr{
																								pos: position{line: 2367, col: 26, offset: 81242},
																								expr: &charClassMatcher{
																									pos:        position{line: 2350, col: 20, offset: 80988},
																									val:        "[_\\pL\\pNd]",
																									chars:      []rune{'_'},
																									classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 699, col: 5, offset: 21384},
																				run: (*parser).callonElseIfBlock55,
																				expr: &seqExpr{
																					pos: position{line: 699, col: 5, offset: 21384},
																					exprs: []interface{}{
																						&labeledExpr{
																							pos:   position{line: 699, col: 5, offset: 21384},
																							label: "identI",
																							expr: &seqExpr{
																								pos: position{line: 699, col: 13, offset: 21392},
																								exprs: []interface{}{
																									&zeroOrOneExpr{
																										pos: position{line: 699, col: 13, offset: 21392},
																										expr: &litMatcher{
																											pos:        position{line: 699, col: 13, offset: 21392},
																											val:        "$",
																											ignoreCase: false,
																											want:       "\"$\"",
																										},
																									},
																									&oneOrMoreExpr{
																										pos: position{line: 699, col: 18, offset: 21397},
																										expr: &choiceExpr{
																											pos: position{line: 699, col: 19, offset: 21398},
																											alternatives: []interface{}{
																												&seqExpr{
																													pos: position{line: 699, col: 19, offset: 21398},
																													exprs: []interface{}{
																														&charClassMatcher{
																															pos:        position{line: 699, col: 19, offset: 21398},
																															val:        "[\\pNd]",
																															classes:    []*unicode.RangeTable{rangeTable("Nd")},
																															ignoreCase: false,
																															inverted:   false,
																														},
																														&charClassMatcher{
																															pos:        position{line: 699, col: 28, offset: 21407},
																															val:        "[_-\\pL]",
																															chars:      []rune{'_', '-'},
																															classes:    []*unicode.RangeTable{rangeTable("L")},
																															ignoreCase: false,
																															inverted:   false,
																														},
																													},
																												},
																												&charClassMatcher{
																													pos:        position{line: 699, col: 38, offset: 21417},
																													val:        "[_-\\pL]",
																													chars:      []rune{'_', '-'},
																													classes:    []*unicode.RangeTable{rangeTable("L")},
																													ignoreCase: false,
																													inverted:   false,
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																						&labeledExpr{
																							pos:   position{line: 699, col: 49, offset: 21428},
																							label: "endPosI",
																							expr: &actionExpr{
																								pos: position{line: 3737, col: 8, offset: 128286},
																								run: (*parser).callonElseIfBlock68,
																								expr: &choiceExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									alternatives: []interface{}{
																										&andExpr{
																											pos: position{line: 3737, col: 9, offset: 128287},
																											expr: &anyMatcher{
																												line: 3737, col: 10, offset: 128288,
																											},
																										},
																										&notExpr{
																											pos: position{line: 3737, col: 14, offset: 128292},
																											expr: &anyMatcher{
																												line: 3737, col: 15, offset: 128293,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 713, col: 5, offset: 21887},
																run: (*parser).callonElseIfBlock74,
																expr: &seqExpr{
																	pos: position{line: 713, col: 5, offset: 21887},
																	exprs: []interface{}{
																		&labeledExpr{
																			pos:   position{line: 713, col: 5, offset: 21887},
																			label: "posI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonElseIfBlock77,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																		&andExpr{
																			pos: position{line: 713, col: 14, offset: 21896},
																			expr: &choiceExpr{
																				pos: position{line: 713, col: 16, offset: 21898},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 3734, col: 12, offset: 128237},
																						exprs: []interface{}{
																							&zeroOrMoreExpr{
																								pos: position{line: 3734, col: 12, offset: 128237},
																								expr: &charClassMatcher{
																									pos:        position{line: 3746, col: 36, offset: 128584},
																									val:        "[ \\t]",
																									chars:      []rune{' ', '\t'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																							&choiceExpr{
																								pos: position{line: 3734, col: 16, offset: 128241},
																								alternatives: []interface{}{
																									&seqExpr{
																										pos: position{line: 3734, col: 16, offset: 128241},
																										exprs: []interface{}{
																											&zeroOrOneExpr{
																												pos: position{line: 3734, col: 16, offset: 128241},
																												expr: &litMatcher{
																													pos:        position{line: 3734, col: 16, offset: 128241},
																													val:        "\r",
																													ignoreCase: false,
																													want:       "\"\\r\"",
																												},
																											},
																											&litMatcher{
																												pos:        position{line: 3734, col: 22, offset: 128247},
																												val:        "\n",
																												ignoreCase: false,
																												want:       "\"\\n\"",
																											},
																										},
																									},
																									&notExpr{
																										pos: position{line: 3733, col: 12, offset: 128223},
																										expr: &anyMatcher{
																											line: 3733, col: 13, offset: 128224,
																										},
																									},
																								},
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 713, col: 22, offset: 21904},
																						val:        "[:!=(]",
																						chars:      []rune{':', '!', '=', '('},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 724, col: 5, offset: 22230},
																run: (*parser).callonElseIfBlock96,
																expr: &seqExpr{
																	pos: position{line: 724, col: 5, offset: 22230},
																	exprs: []interface{}{
																		&labeledExpr{
																			pos:   position{line: 724, col: 5, offset: 22230},
																			label: "identI",
																			expr: &oneOrMoreExpr{
																				pos: position{line: 724, col: 12, offset: 22237},
																				expr: &charClassMatcher{
																					pos:        position{line: 724, col: 12, offset: 22237},
																					val:        "[^ \\t\\r\\n:!=(]",
																					chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 724, col: 28, offset: 22253},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonElseIfBlock102,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 329, col: 5, offset: 10344},
										run: (*parser).callonElseIfBlock108,
										expr: &andExpr{
											pos: position{line: 329, col: 5, offset: 10344},
											expr: &seqExpr{
												pos: position{line: 3734, col: 12, offset: 128237},
												exprs: []interface{}{
													&zeroOrMoreExpr{
														pos: position{line: 3734, col: 12, offset: 128237},
														expr: &charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3734, col: 16, offset: 128241},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		expr: &litMatcher{
																			pos:        position{line: 3734, col: 16, offset: 128241},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3734, col: 22, offset: 128247},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3733, col: 12, offset: 128223},
																expr: &anyMatcher{
																	line: 3733, col: 13, offset: 128224,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 538, col: 78, offset: 16576},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 538, col: 84, offset: 16582},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "Switch",
			pos:  position{line: 557, col: 1, offset: 17071},
			expr: &actionExpr{
				pos: position{line: 557, col: 11, offset: 17081},
				run: (*parser).callonSwitch1,
				expr: &seqExpr{
					pos: position{line: 557, col: 11, offset: 17081},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 557, col: 11, offset: 17081},
							val:        "switch",
							ignoreCase: false,
							want:       "\"switch\"",
						},
						&labeledExpr{
							pos:   position{line: 557, col: 20, offset: 17090},
							label: "comparatorI",
							expr: &ruleRefExpr{
								pos:  position{line: 557, col: 32, offset: 17102},
								name: "switchComparator",
							},
						},
						&labeledExpr{
							pos:   position{line: 557, col: 49, offset: 17119},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 557, col: 55, offset: 17125},
								name: "switchBody",
							},
						},
					},
				},
			},
		},
		{
			name: "switchComparator",
			pos:  position{line: 582, col: 1, offset: 17742},
			expr: &choiceExpr{
				pos: position{line: 582, col: 21, offset: 17762},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 582, col: 21, offset: 17762},
						run: (*parser).callonswitchComparator2,
						expr: &seqExpr{
							pos: position{line: 3734, col: 12, offset: 128237},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 584, col: 5, offset: 17812},
						run: (*parser).callonswitchComparator13,
						expr: &seqExpr{
							pos: position{line: 584, col: 5, offset: 17812},
							exprs: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 584, col: 5, offset: 17812},
									expr: &litMatcher{
										pos:        position{line: 584, col: 5, offset: 17812},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 584, col: 10, offset: 17817},
									label: "compI",
									expr: &ruleRefExpr{
										pos:  position{line: 584, col: 16, offset: 17823},
										name: "IfExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 587, col: 5, offset: 17904},
						run: (*parser).callonswitchComparator28,
						expr: &seqExpr{
							pos: position{line: 587, col: 5, offset: 17904},
							exprs: []interface{}{
								&oneOrMoreExpr{
									pos: position{line: 587, col: 5, offset: 17904},
									expr: &litMatcher{
										pos:        position{line: 587, col: 5, offset: 17904},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 587, col: 10, offset: 17909},
									label: "compI",
									expr: &ruleRefExpr{
										pos:  position{line: 587, col: 16, offset: 17915},
										name: "IfExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 587, col: 29, offset: 17928},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonswitchComparator35,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&oneOrMoreExpr{
									pos: position{line: 587, col: 43, offset: 17942},
									expr: &charClassMatcher{
										pos:        position{line: 3735, col: 12, offset: 128270},
										val:        "[^\\r\\n]",
										chars:      []rune{'\r', '\n'},
										ignoreCase: false,
										inverted:   true,
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "switchBody",
			pos:  position{line: 598, col: 1, offset: 18265},
			expr: &actionExpr{
				pos: position{line: 598, col: 15, offset: 18279},
				run: (*parser).callonswitchBody1,
				expr: &seqExpr{
					pos: position{line: 598, col: 15, offset: 18279},
					exprs: []interface{}{
						&stateCodeExpr{
							pos: position{line: 4214, col: 11, offset: 148867},
							run: (*parser).callonswitchBody3,
						},
						&labeledExpr{
							pos:   position{line: 598, col: 22, offset: 18286},
							label: "itms",
							expr: &zeroOrMoreExpr{
								pos: position{line: 598, col: 27, offset: 18291},
								expr: &seqExpr{
									pos: position{line: 598, col: 28, offset: 18292},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 598, col: 28, offset: 18292},
											expr: &oneOrMoreExpr{
												pos: position{line: 3748, col: 36, offset: 128671},
												expr: &seqExpr{
													pos: position{line: 3748, col: 37, offset: 128672},
													exprs: []interface{}{
														&zeroOrMoreExpr{
															pos: position{line: 3748, col: 37, offset: 128672},
															expr: &charClassMatcher{
																pos:        position{line: 3746, col: 36, offset: 128584},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&zeroOrOneExpr{
															pos: position{line: 3747, col: 36, offset: 128625},
															expr: &litMatcher{
																pos:        position{line: 3747, col: 36, offset: 128625},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3747, col: 42, offset: 128631},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
										&actionExpr{
											pos: position{line: 3835, col: 17, offset: 132478},
											run: (*parser).callonswitchBody15,
											expr: &zeroOrMoreExpr{
												pos: position{line: 3835, col: 17, offset: 132478},
												expr: &charClassMatcher{
													pos:        position{line: 3746, col: 36, offset: 128584},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
										&andCodeExpr{
											pos: position{line: 3835, col: 41, offset: 132502},
											run: (*parser).callonswitchBody18,
										},
										&choiceExpr{
											pos: position{line: 3887, col: 5, offset: 134412},
											alternatives: []interface{}{
												&andCodeExpr{
													pos: position{line: 3887, col: 5, offset: 134412},
													run: (*parser).callonswitchBody20,
												},
												&seqExpr{
													pos: position{line: 3889, col: 9, offset: 134495},
													exprs: []interface{}{
														&andCodeExpr{
															pos: position{line: 3889, col: 9, offset: 134495},
															run: (*parser).callonswitchBody22,
														},
														&stateCodeExpr{
															pos: position{line: 3891, col: 7, offset: 134599},
															run: (*parser).callonswitchBody23,
														},
													},
												},
												&seqExpr{
													pos: position{line: 3898, col: 9, offset: 134935},
													exprs: []interface{}{
														&andCodeExpr{
															pos: position{line: 3898, col: 9, offset: 134935},
															run: (*parser).callonswitchBody25,
														},
														&choiceExpr{
															pos: position{line: 3951, col: 9, offset: 137270},
															alternatives: []interface{}{
																&seqExpr{
																	pos: position{line: 3951, col: 9, offset: 137270},
																	exprs: []interface{}{
																		&andCodeExpr{
																			pos: position{line: 3951, col: 9, offset: 137270},
																			run: (*parser).callonswitchBody28,
																		},
																		&andCodeExpr{
																			pos: position{line: 3955, col: 11, offset: 137520},
																			run: (*parser).callonswitchBody29,
																		},
																		&stateCodeExpr{
																			pos: position{line: 4021, col: 11, offset: 140726},
																			run: (*parser).callonswitchBody30,
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 4029, col: 13, offset: 141079},
																	exprs: []interface{}{
																		&andCodeExpr{
																			pos: position{line: 4029, col: 13, offset: 141079},
																			run: (*parser).callonswitchBody32,
																		},
																		&andCodeExpr{
																			pos: position{line: 4033, col: 11, offset: 141334},
																			run: (*parser).callonswitchBody33,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 598, col: 49, offset: 18313},
											name: "switchBodyItem",
										},
									},
								},
							},
						},
						&stateCodeExpr{
							pos: position{line: 4219, col: 11, offset: 148972},
							run: (*parser).callonswitchBody35,
						},
					},
				},
			},
		},
		{
			name: "switchBodyItem",
			pos:  position{line: 636, col: 1, offset: 19570},
			expr: &choiceExpr{
				pos: position{line: 636, col: 19, offset: 19588},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 636, col: 19, offset: 19588},
						run: (*parser).callonswitchBodyItem2,
						expr: &labeledExpr{
							pos:   position{line: 636, col: 19, offset: 19588},
							label: "caseI",
							expr: &choiceExpr{
								pos: position{line: 636, col: 26, offset: 19595},
								alternatives: []interface{}{
									&ruleRefExpr{
										pos:  position{line: 636, col: 26, offset: 19595},
										name: "Case",
									},
									&ruleRefExpr{
										pos:  position{line: 636, col: 33, offset: 19602},
										name: "Default",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 638, col: 5, offset: 19652},
						run: (*parser).callonswitchBodyItem7,
						expr: &labeledExpr{
							pos:   position{line: 638, col: 5, offset: 19652},
							label: "caseI",
							expr: &ruleRefExpr{
								pos:  position{line: 638, col: 11, offset: 19658},
								name: "BadCase",
							},
						},
					},
				},
			},
		},
		{
			name: "Case",
			pos:  position{line: 642, col: 1, offset: 19707},
			expr: &actionExpr{
				pos: position{line: 642, col: 9, offset: 19715},
				run: (*parser).callonCase1,
				expr: &seqExpr{
					pos: position{line: 642, col: 9, offset: 19715},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 642, col: 9, offset: 19715},
							val:        "case",
							ignoreCase: false,
							want:       "\"case\"",
						},
						&labeledExpr{
							pos:   position{line: 642, col: 16, offset: 19722},
							label: "condI",
							expr: &ruleRefExpr{
								pos:  position{line: 642, col: 22, offset: 19728},
								name: "condition",
							},
						},
						&labeledExpr{
							pos:   position{line: 642, col: 32, offset: 19738},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 642, col: 38, offset: 19744},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "Default",
			pos:  position{line: 650, col: 1, offset: 19901},
			expr: &actionExpr{
				pos: position{line: 650, col: 12, offset: 19912},
				run: (*parser).callonDefault1,
				expr: &seqExpr{
					pos: position{line: 650, col: 12, offset: 19912},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 650, col: 12, offset: 19912},
							val:        "default",
							ignoreCase: false,
							want:       "\"default\"",
						},
						&labeledExpr{
							pos:   position{line: 650, col: 22, offset: 19922},
							label: "thenI",
							expr: &ruleRefExpr{
								pos:  position{line: 650, col: 28, offset: 19928},
								name: "then",
							},
						},
					},
				},
			},
		},
		{
			name: "BadCase",
			pos:  position{line: 657, col: 1, offset: 20031},
			expr: &actionExpr{
				pos: position{line: 657, col: 12, offset: 20042},
				run: (*parser).callonBadCase1,
				expr: &seqExpr{
					pos: position{line: 657, col: 12, offset: 20042},
					exprs: []interface{}{
						&oneOrMoreExpr{
							pos: position{line: 657, col: 12, offset: 20042},
							expr: &charClassMatcher{
								pos:        position{line: 3735, col: 12, offset: 128270},
								val:        "[^\\r\\n]",
								chars:      []rune{'\r', '\n'},
								ignoreCase: false,
								inverted:   true,
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3734, col: 12, offset: 128237},
							expr: &charClassMatcher{
								pos:        position{line: 3746, col: 36, offset: 128584},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3734, col: 16, offset: 128241},
							alternatives: []interface{}{
								&seqExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											expr: &litMatcher{
												pos:        position{line: 3734, col: 16, offset: 128241},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3734, col: 22, offset: 128247},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3733, col: 12, offset: 128223},
									expr: &anyMatcher{
										line: 3733, col: 13, offset: 128224,
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 657, col: 25, offset: 20055},
							label: "bodyI",
							expr: &zeroOrOneExpr{
								pos: position{line: 657, col: 31, offset: 20061},
								expr: &ruleRefExpr{
									pos:  position{line: 657, col: 31, offset: 20061},
									name: "Body",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "CorgiComments",
			pos:  position{line: 824, col: 1, offset: 25332},
			expr: &actionExpr{
				pos: position{line: 824, col: 18, offset: 25349},
				run: (*parser).callonCorgiComments1,
				expr: &labeledExpr{
					pos:   position{line: 824, col: 18, offset: 25349},
					label: "commentsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 824, col: 28, offset: 25359},
						expr: &seqExpr{
							pos: position{line: 824, col: 29, offset: 25360},
							exprs: []interface{}{
								&zeroOrOneExpr{
									pos: position{line: 824, col: 29, offset: 25360},
									expr: &oneOrMoreExpr{
										pos: position{line: 3748, col: 36, offset: 128671},
										expr: &seqExpr{
											pos: position{line: 3748, col: 37, offset: 128672},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 3748, col: 37, offset: 128672},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 3747, col: 36, offset: 128625},
													expr: &litMatcher{
														pos:        position{line: 3747, col: 36, offset: 128625},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3747, col: 42, offset: 128631},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 824, col: 38, offset: 25369},
									name: "CorgiComment",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "CorgiComment",
			pos:  position{line: 828, col: 1, offset: 25460},
			expr: &actionExpr{
				pos: position{line: 828, col: 17, offset: 25476},
				run: (*parser).callonCorgiComment1,
				expr: &seqExpr{
					pos: position{line: 828, col: 17, offset: 25476},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 828, col: 17, offset: 25476},
							val:        "//",
							ignoreCase: false,
							want:       "\"//\"",
						},
						&notExpr{
							pos: position{line: 828, col: 22, offset: 25481},
							expr: &litMatcher{
								pos:        position{line: 828, col: 23, offset: 25482},
								val:        "-",
								ignoreCase: false,
								want:       "\"-\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 828, col: 27, offset: 25486},
							label: "linesI",
							expr: &choiceExpr{
								pos: position{line: 829, col: 5, offset: 25499},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 829, col: 5, offset: 25499},
										run: (*parser).callonCorgiComment8,
										expr: &seqExpr{
											pos: position{line: 829, col: 5, offset: 25499},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 829, col: 5, offset: 25499},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrMoreExpr{
													pos: position{line: 3734, col: 12, offset: 128237},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&choiceExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 3734, col: 16, offset: 128241},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	expr: &litMatcher{
																		pos:        position{line: 3734, col: 16, offset: 128241},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3734, col: 22, offset: 128247},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
														&notExpr{
															pos: position{line: 3733, col: 12, offset: 128223},
															expr: &anyMatcher{
																line: 3733, col: 13, offset: 128224,
															},
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 829, col: 12, offset: 25506},
													label: "linesI",
													expr: &ruleRefExpr{
														pos:  position{line: 829, col: 19, offset: 25513},
														name: "corgiCommentBlock",
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 831, col: 9, offset: 25568},
										run: (*parser).callonCorgiComment23,
										expr: &labeledExpr{
											pos:   position{line: 831, col: 9, offset: 25568},
											label: "lineI",
											expr: &actionExpr{
												pos: position{line: 845, col: 21, offset: 25995},
												run: (*parser).callonCorgiComment25,
												expr: &seqExpr{
													pos: position{line: 845, col: 21, offset: 25995},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 845, col: 21, offset: 25995},
															label: "commentI",
															expr: &zeroOrMoreExpr{
																pos: position{line: 845, col: 30, offset: 26004},
																expr: &charClassMatcher{
																	pos:        position{line: 3735, col: 12, offset: 128270},
																	val:        "[^\\r\\n]",
																	chars:      []rune{'\r', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 3734, col: 12, offset: 128237},
															expr: &charClassMatcher{
																pos:        position{line: 3746, col: 36, offset: 128584},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&choiceExpr{
															pos: position{line: 3734, col: 16, offset: 128241},
															alternatives: []interface{}{
																&seqExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	exprs: []interface{}{
																		&zeroOrOneExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			expr: &litMatcher{
																				pos:        position{line: 3734, col: 16, offset: 128241},
																				val:        "\r",
																				ignoreCase: false,
																				want:       "\"\\r\"",
																			},
																		},
																		&litMatcher{
																			pos:        position{line: 3734, col: 22, offset: 128247},
																			val:        "\n",
																			ignoreCase: false,
																			want:       "\"\\n\"",
																		},
																	},
																},
																&notExpr{
																	pos: position{line: 3733, col: 12, offset: 128223},
																	expr: &anyMatcher{
																		line: 3733, col: 13, offset: 128224,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "corgiCommentBlock",
			pos:  position{line: 841, col: 1, offset: 25797},
			expr: &actionExpr{
				pos: position{line: 841, col: 22, offset: 25818},
				run: (*parser).calloncorgiCommentBlock1,
				expr: &seqExpr{
					pos: position{line: 841, col: 22, offset: 25818},
					exprs: []interface{}{
						&stateCodeExpr{
							pos: position{line: 4214, col: 11, offset: 148867},
							run: (*parser).calloncorgiCommentBlock3,
						},
						&labeledExpr{
							pos:   position{line: 841, col: 29, offset: 25825},
							label: "linesI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 841, col: 36, offset: 25832},
								expr: &seqExpr{
									pos: position{line: 841, col: 37, offset: 25833},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 841, col: 37, offset: 25833},
											expr: &oneOrMoreExpr{
												pos: position{line: 3748, col: 36, offset: 128671},
												expr: &seqExpr{
													pos: position{line: 3748, col: 37, offset: 128672},
													exprs: []interface{}{
														&zeroOrMoreExpr{
															pos: position{line: 3748, col: 37, offset: 128672},
															expr: &charClassMatcher{
																pos:        position{line: 3746, col: 36, offset: 128584},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&zeroOrOneExpr{
															pos: position{line: 3747, col: 36, offset: 128625},
															expr: &litMatcher{
																pos:        position{line: 3747, col: 36, offset: 128625},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3747, col: 42, offset: 128631},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 841, col: 46, offset: 25842},
											name: "INDENTATION_IGNORE_ADDITIONAL",
										},
										&actionExpr{
											pos: position{line: 845, col: 21, offset: 25995},
											run: (*parser).calloncorgiCommentBlock16,
											expr: &seqExpr{
												pos: position{line: 845, col: 21, offset: 25995},
												exprs: []interface{}{
													&labeledExpr{
														pos:   position{line: 845, col: 21, offset: 25995},
														label: "commentI",
														expr: &zeroOrMoreExpr{
															pos: position{line: 845, col: 30, offset: 26004},
															expr: &charClassMatcher{
																pos:        position{line: 3735, col: 12, offset: 128270},
																val:        "[^\\r\\n]",
																chars:      []rune{'\r', '\n'},
																ignoreCase: false,
																inverted:   true,
															},
														},
													},
													&zeroOrMoreExpr{
														pos: position{line: 3734, col: 12, offset: 128237},
														expr: &charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3734, col: 16, offset: 128241},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		expr: &litMatcher{
																			pos:        position{line: 3734, col: 16, offset: 128241},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3734, col: 22, offset: 128247},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3733, col: 12, offset: 128223},
																expr: &anyMatcher{
																	line: 3733, col: 13, offset: 128224,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&stateCodeExpr{
							pos: position{line: 4219, col: 11, offset: 148972},
							run: (*parser).calloncorgiCommentBlock30,
						},
					},
				},
			},
		},
		{
			name: "HTMLComment",
			pos:  position{line: 893, col: 1, offset: 27676},
			expr: &actionExpr{
				pos: position{line: 893, col: 16, offset: 27691},
				run: (*parser).callonHTMLComment1,
				expr: &seqExpr{
					pos: position{line: 893, col: 16, offset: 27691},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 893, col: 16, offset: 27691},
							val:        "//-",
							ignoreCase: false,
							want:       "\"//-\"",
						},
						&labeledExpr{
							pos:   position{line: 893, col: 22, offset: 27697},
							label: "linesI",
							expr: &choiceExpr{
								pos: position{line: 894, col: 5, offset: 27710},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 894, col: 5, offset: 27710},
										run: (*parser).callonHTMLComment6,
										expr: &seqExpr{
											pos: position{line: 894, col: 5, offset: 27710},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 3734, col: 12, offset: 128237},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&choiceExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 3734, col: 16, offset: 128241},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	expr: &litMatcher{
																		pos:        position{line: 3734, col: 16, offset: 128241},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3734, col: 22, offset: 128247},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
														&notExpr{
															pos: position{line: 3733, col: 12, offset: 128223},
															expr: &anyMatcher{
																line: 3733, col: 13, offset: 128224,
															},
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 894, col: 9, offset: 27714},
													label: "linesI",
													expr: &ruleRefExpr{
														pos:  position{line: 894, col: 16, offset: 27721},
														name: "htmlCommentBlock",
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 896, col: 9, offset: 27775},
										run: (*parser).callonHTMLComment19,
										expr: &labeledExpr{
											pos:   position{line: 896, col: 9, offset: 27775},
											label: "lineI",
											expr: &actionExpr{
												pos: position{line: 910, col: 20, offset: 28193},
												run: (*parser).callonHTMLComment21,
												expr: &seqExpr{
													pos: position{line: 910, col: 20, offset: 28193},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 910, col: 20, offset: 28193},
															label: "commentI",
															expr: &zeroOrMoreExpr{
																pos: position{line: 910, col: 29, offset: 28202},
																expr: &charClassMatcher{
																	pos:        position{line: 3735, col: 12, offset: 128270},
																	val:        "[^\\r\\n]",
																	chars:      []rune{'\r', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 3734, col: 12, offset: 128237},
															expr: &charClassMatcher{
																pos:        position{line: 3746, col: 36, offset: 128584},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&choiceExpr{
															pos: position{line: 3734, col: 16, offset: 128241},
															alternatives: []interface{}{
																&seqExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	exprs: []interface{}{
																		&zeroOrOneExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			expr: &litMatcher{
																				pos:        position{line: 3734, col: 16, offset: 128241},
																				val:        "\r",
																				ignoreCase: false,
																				want:       "\"\\r\"",
																			},
																		},
																		&litMatcher{
																			pos:        position{line: 3734, col: 22, offset: 128247},
																			val:        "\n",
																			ignoreCase: false,
																			want:       "\"\\n\"",
																		},
																	},
																},
																&notExpr{
																	pos: position{line: 3733, col: 12, offset: 128223},
																	expr: &anyMatcher{
																		line: 3733, col: 13, offset: 128224,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "htmlCommentBlock",
			pos:  position{line: 906, col: 1, offset: 27999},
			expr: &actionExpr{
				pos: position{line: 906, col: 21, offset: 28019},
				run: (*parser).callonhtmlCommentBlock1,
				expr: &seqExpr{
					pos: position{line: 906, col: 21, offset: 28019},
					exprs: []interface{}{
						&stateCodeExpr{
							pos: position{line: 4214, col: 11, offset: 148867},
							run: (*parser).callonhtmlCommentBlock3,
						},
						&labeledExpr{
							pos:   position{line: 906, col: 28, offset: 28026},
							label: "linesI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 906, col: 35, offset: 28033},
								expr: &seqExpr{
									pos: position{line: 906, col: 36, offset: 28034},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 906, col: 36, offset: 28034},
											expr: &oneOrMoreExpr{
												pos: position{line: 3748, col: 36, offset: 128671},
												expr: &seqExpr{
													pos: position{line: 3748, col: 37, offset: 128672},
													exprs: []interface{}{
														&zeroOrMoreExpr{
															pos: position{line: 3748, col: 37, offset: 128672},
															expr: &charClassMatcher{
																pos:        position{line: 3746, col: 36, offset: 128584},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
														},
														&zeroOrOneExpr{
															pos: position{line: 3747, col: 36, offset: 128625},
															expr: &litMatcher{
																pos:        position{line: 3747, col: 36, offset: 128625},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3747, col: 42, offset: 128631},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 906, col: 45, offset: 28043},
											name: "INDENTATION_IGNORE_ADDITIONAL",
										},
										&actionExpr{
											pos: position{line: 910, col: 20, offset: 28193},
											run: (*parser).callonhtmlCommentBlock16,
											expr: &seqExpr{
												pos: position{line: 910, col: 20, offset: 28193},
												exprs: []interface{}{
													&labeledExpr{
														pos:   position{line: 910, col: 20, offset: 28193},
														label: "commentI",
														expr: &zeroOrMoreExpr{
															pos: position{line: 910, col: 29, offset: 28202},
															expr: &charClassMatcher{
																pos:        position{line: 3735, col: 12, offset: 128270},
																val:        "[^\\r\\n]",
																chars:      []rune{'\r', '\n'},
																ignoreCase: false,
																inverted:   true,
															},
														},
													},
													&zeroOrMoreExpr{
														pos: position{line: 3734, col: 12, offset: 128237},
														expr: &charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3734, col: 16, offset: 128241},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		expr: &litMatcher{
																			pos:        position{line: 3734, col: 16, offset: 128241},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3734, col: 22, offset: 128247},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3733, col: 12, offset: 128223},
																expr: &anyMatcher{
																	line: 3733, col: 13, offset: 128224,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&stateCodeExpr{
							pos: position{line: 4219, col: 11, offset: 148972},
							run: (*parser).callonhtmlCommentBlock30,
						},
					},
				},
			},
		},
		{
			name: "Element",
			pos:  position{line: 918, col: 1, offset: 28484},
			expr: &actionExpr{
				pos: position{line: 918, col: 12, offset: 28495},
				run: (*parser).callonElement1,
				expr: &seqExpr{
					pos: position{line: 918, col: 12, offset: 28495},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 918, col: 12, offset: 28495},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2836, col: 16, offset: 98915},
								expr: &charClassMatcher{
									pos:        position{line: 2822, col: 27, offset: 98255},
									val:        "[09A-Za-z]",
									chars:      []rune{'0', '9'},
									ranges:     []rune{'A', 'Z', 'a', 'z'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 918, col: 30, offset: 28513},
							label: "attrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 918, col: 37, offset: 28520},
								expr: &ruleRefExpr{
									pos:  position{line: 918, col: 37, offset: 28520},
									name: "AttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 918, col: 58, offset: 28541},
							label: "voidI",
							expr: &zeroOrOneExpr{
								pos: position{line: 918, col: 64, offset: 28547},
								expr: &litMatcher{
									pos:        position{line: 918, col: 64, offset: 28547},
									val:        "/",
									ignoreCase: false,
									want:       "\"/\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 918, col: 69, offset: 28552},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 918, col: 75, offset: 28558},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineElement",
			pos:  position{line: 928, col: 1, offset: 28789},
			expr: &actionExpr{
				pos: position{line: 928, col: 18, offset: 28806},
				run: (*parser).callonInlineElement1,
				expr: &seqExpr{
					pos: position{line: 928, col: 18, offset: 28806},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 928, col: 18, offset: 28806},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2836, col: 16, offset: 98915},
								expr: &charClassMatcher{
									pos:        position{line: 2822, col: 27, offset: 98255},
									val:        "[09A-Za-z]",
									chars:      []rune{'0', '9'},
									ranges:     []rune{'A', 'Z', 'a', 'z'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 928, col: 36, offset: 28824},
							label: "attrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 928, col: 43, offset: 28831},
								expr: &ruleRefExpr{
									pos:  position{line: 928, col: 43, offset: 28831},
									name: "SingleLineAttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 928, col: 74, offset: 28862},
							label: "voidI",
							expr: &zeroOrOneExpr{
								pos: position{line: 928, col: 80, offset: 28868},
								expr: &litMatcher{
									pos:        position{line: 928, col: 80, offset: 28868},
									val:        "/",
									ignoreCase: false,
									want:       "\"/\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 928, col: 85, offset: 28873},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 928, col: 91, offset: 28879},
								name: "Beait",
							},
						},
					},
				},
			},
		},
		{
			name: "DivShorthand",
			pos:  position{line: 942, col: 1, offset: 29296},
			expr: &actionExpr{
				pos: position{line: 942, col: 17, offset: 29312},
				run: (*parser).callonDivShorthand1,
				expr: &seqExpr{
					pos: position{line: 942, col: 17, offset: 29312},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 942, col: 17, offset: 29312},
							label: "firstAttrI",
							expr: &choiceExpr{
								pos: position{line: 942, col: 29, offset: 29324},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 1033, col: 19, offset: 32723},
										run: (*parser).callonDivShorthand5,
										expr: &seqExpr{
											pos: position{line: 1033, col: 19, offset: 32723},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 1033, col: 19, offset: 32723},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
												&labeledExpr{
													pos:   position{line: 1033, col: 23, offset: 32727},
													label: "nameI",
													expr: &oneOrMoreExpr{
														pos: position{line: 1033, col: 29, offset: 32733},
														expr: &charClassMatcher{
															pos:        position{line: 1033, col: 29, offset: 32733},
															val:        "[^ \\t\\r\\n.()]",
															chars:      []rune{' ', '\t', '\r', '\n', '.', '(', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1038, col: 5, offset: 32852},
										run: (*parser).callonDivShorthand11,
										expr: &seqExpr{
											pos: position{line: 1038, col: 5, offset: 32852},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 1038, col: 5, offset: 32852},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
												&labeledExpr{
													pos:   position{line: 1038, col: 9, offset: 32856},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonDivShorthand15,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1014, col: 16, offset: 32282},
										run: (*parser).callonDivShorthand21,
										expr: &seqExpr{
											pos: position{line: 1014, col: 16, offset: 32282},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 1014, col: 16, offset: 32282},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
												&labeledExpr{
													pos:   position{line: 1014, col: 20, offset: 32286},
													label: "idI",
													expr: &oneOrMoreExpr{
														pos: position{line: 1014, col: 24, offset: 32290},
														expr: &charClassMatcher{
															pos:        position{line: 1014, col: 24, offset: 32290},
															val:        "[^ \\t\\r\\n.()]",
															chars:      []rune{' ', '\t', '\r', '\n', '.', '(', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1019, col: 5, offset: 32402},
										run: (*parser).callonDivShorthand27,
										expr: &seqExpr{
											pos: position{line: 1019, col: 5, offset: 32402},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 1019, col: 5, offset: 32402},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
												&labeledExpr{
													pos:   position{line: 1019, col: 9, offset: 32406},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonDivShorthand31,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 942, col: 59, offset: 29354},
							label: "moreAttrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 942, col: 70, offset: 29365},
								expr: &ruleRefExpr{
									pos:  position{line: 942, col: 70, offset: 29365},
									name: "AttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 942, col: 91, offset: 29386},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 942, col: 97, offset: 29392},
								name: "Beaitb",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineDivShorthand",
			pos:  position{line: 950, col: 1, offset: 29653},
			expr: &actionExpr{
				pos: position{line: 950, col: 23, offset: 29675},
				run: (*parser).callonInlineDivShorthand1,
				expr: &seqExpr{
					pos: position{line: 950, col: 23, offset: 29675},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 950, col: 23, offset: 29675},
							label: "firstAttrI",
							expr: &choiceExpr{
								pos: position{line: 950, col: 35, offset: 29687},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 1033, col: 19, offset: 32723},
										run: (*parser).callonInlineDivShorthand5,
										expr: &seqExpr{
											pos: position{line: 1033, col: 19, offset: 32723},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 1033, col: 19, offset: 32723},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
												&labeledExpr{
													pos:   position{line: 1033, col: 23, offset: 32727},
													label: "nameI",
													expr: &oneOrMoreExpr{
														pos: position{line: 1033, col: 29, offset: 32733},
														expr: &charClassMatcher{
															pos:        position{line: 1033, col: 29, offset: 32733},
															val:        "[^ \\t\\r\\n.()]",
															chars:      []rune{' ', '\t', '\r', '\n', '.', '(', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1038, col: 5, offset: 32852},
										run: (*parser).callonInlineDivShorthand11,
										expr: &seqExpr{
											pos: position{line: 1038, col: 5, offset: 32852},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 1038, col: 5, offset: 32852},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
												&labeledExpr{
													pos:   position{line: 1038, col: 9, offset: 32856},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonInlineDivShorthand15,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1014, col: 16, offset: 32282},
										run: (*parser).callonInlineDivShorthand21,
										expr: &seqExpr{
											pos: position{line: 1014, col: 16, offset: 32282},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 1014, col: 16, offset: 32282},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
												&labeledExpr{
													pos:   position{line: 1014, col: 20, offset: 32286},
													label: "idI",
													expr: &oneOrMoreExpr{
														pos: position{line: 1014, col: 24, offset: 32290},
														expr: &charClassMatcher{
															pos:        position{line: 1014, col: 24, offset: 32290},
															val:        "[^ \\t\\r\\n.()]",
															chars:      []rune{' ', '\t', '\r', '\n', '.', '(', ')'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1019, col: 5, offset: 32402},
										run: (*parser).callonInlineDivShorthand27,
										expr: &seqExpr{
											pos: position{line: 1019, col: 5, offset: 32402},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 1019, col: 5, offset: 32402},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
												&labeledExpr{
													pos:   position{line: 1019, col: 9, offset: 32406},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonInlineDivShorthand31,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 950, col: 65, offset: 29717},
							label: "moreAttrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 950, col: 76, offset: 29728},
								expr: &ruleRefExpr{
									pos:  position{line: 950, col: 76, offset: 29728},
									name: "SingleLineAttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 950, col: 107, offset: 29759},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 950, col: 113, offset: 29765},
								name: "Beait",
							},
						},
					},
				},
			},
		},
		{
			name: "And",
			pos:  position{line: 962, col: 1, offset: 30203},
			expr: &choiceExpr{
				pos: position{line: 962, col: 8, offset: 30210},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 962, col: 8, offset: 30210},
						run: (*parser).callonAnd2,
						expr: &seqExpr{
							pos: position{line: 962, col: 8, offset: 30210},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 962, col: 8, offset: 30210},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 962, col: 12, offset: 30214},
									label: "collsI",
									expr: &oneOrMoreExpr{
										pos: position{line: 962, col: 19, offset: 30221},
										expr: &ruleRefExpr{
											pos:  position{line: 962, col: 19, offset: 30221},
											name: "AttributeCollection",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 967, col: 5, offset: 30376},
						run: (*parser).callonAnd17,
						expr: &seqExpr{
							pos: position{line: 967, col: 5, offset: 30376},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 967, col: 5, offset: 30376},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 967, col: 9, offset: 30380},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonAnd21,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 982, col: 5, offset: 30976},
						run: (*parser).callonAnd36,
						expr: &seqExpr{
							pos: position{line: 982, col: 5, offset: 30976},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 982, col: 5, offset: 30976},
									val:        "&",
									ignoreCase: false,
									want:       "\"&\"",
								},
								&labeledExpr{
									pos:   position{line: 982, col: 9, offset: 30980},
									label: "collsI",
									expr: &oneOrMoreExpr{
										pos: position{line: 982, col: 16, offset: 30987},
										expr: &ruleRefExpr{
											pos:  position{line: 982, col: 16, offset: 30987},
											name: "AttributeCollection",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 982, col: 37, offset: 31008},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonAnd43,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&oneOrMoreExpr{
									pos: position{line: 982, col: 46, offset: 31017},
									expr: &charClassMatcher{
										pos:        position{line: 3735, col: 12, offset: 128270},
										val:        "[^\\r\\n]",
										chars:      []rune{'\r', '\n'},
										ignoreCase: false,
										inverted:   true,
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeCollection",
			pos:  position{line: 1008, col: 1, offset: 32081},
			expr: &choiceExpr{
				pos: position{line: 1008, col: 34, offset: 32114},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1014, col: 16, offset: 32282},
						run: (*parser).callonAttributeCollection2,
						expr: &seqExpr{
							pos: position{line: 1014, col: 16, offset: 32282},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1014, col: 16, offset: 32282},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1014, col: 20, offset: 32286},
									label: "idI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1014, col: 24, offset: 32290},
										expr: &charClassMatcher{
											pos:        position{line: 1014, col: 24, offset: 32290},
											val:        "[^ \\t\\r\\n.()]",
											chars:      []rune{' ', '\t', '\r', '\n', '.', '(', ')'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1019, col: 5, offset: 32402},
						run: (*parser).callonAttributeCollection8,
						expr: &seqExpr{
							pos: position{line: 1019, col: 5, offset: 32402},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1019, col: 5, offset: 32402},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1019, col: 9, offset: 32406},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonAttributeCollection12,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1033, col: 19, offset: 32723},
						run: (*parser).callonAttributeCollection18,
						expr: &seqExpr{
							pos: position{line: 1033, col: 19, offset: 32723},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1033, col: 19, offset: 32723},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&labeledExpr{
									pos:   position{line: 1033, col: 23, offset: 32727},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1033, col: 29, offset: 32733},
										expr: &charClassMatcher{
											pos:        position{line: 1033, col: 29, offset: 32733},
											val:        "[^ \\t\\r\\n.()]",
											chars:      []rune{' ', '\t', '\r', '\n', '.', '(', ')'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1038, col: 5, offset: 32852},
						run: (*parser).callonAttributeCollection24,
						expr: &seqExpr{
							pos: position{line: 1038, col: 5, offset: 32852},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1038, col: 5, offset: 32852},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&labeledExpr{
									pos:   position{line: 1038, col: 9, offset: 32856},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonAttributeCollection28,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1008, col: 65, offset: 32145},
						name: "AttributeList",
					},
				},
			},
		},
		{
			name: "SingleLineAttributeCollection",
			pos:  position{line: 1009, col: 1, offset: 32159},
			expr: &choiceExpr{
				pos: position{line: 1009, col: 34, offset: 32192},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1014, col: 16, offset: 32282},
						run: (*parser).callonSingleLineAttributeCollection2,
						expr: &seqExpr{
							pos: position{line: 1014, col: 16, offset: 32282},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1014, col: 16, offset: 32282},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1014, col: 20, offset: 32286},
									label: "idI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1014, col: 24, offset: 32290},
										expr: &charClassMatcher{
											pos:        position{line: 1014, col: 24, offset: 32290},
											val:        "[^ \\t\\r\\n.()]",
											chars:      []rune{' ', '\t', '\r', '\n', '.', '(', ')'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1019, col: 5, offset: 32402},
						run: (*parser).callonSingleLineAttributeCollection8,
						expr: &seqExpr{
							pos: position{line: 1019, col: 5, offset: 32402},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1019, col: 5, offset: 32402},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1019, col: 9, offset: 32406},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonSingleLineAttributeCollection12,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1033, col: 19, offset: 32723},
						run: (*parser).callonSingleLineAttributeCollection18,
						expr: &seqExpr{
							pos: position{line: 1033, col: 19, offset: 32723},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1033, col: 19, offset: 32723},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&labeledExpr{
									pos:   position{line: 1033, col: 23, offset: 32727},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1033, col: 29, offset: 32733},
										expr: &charClassMatcher{
											pos:        position{line: 1033, col: 29, offset: 32733},
											val:        "[^ \\t\\r\\n.()]",
											chars:      []rune{' ', '\t', '\r', '\n', '.', '(', ')'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1038, col: 5, offset: 32852},
						run: (*parser).callonSingleLineAttributeCollection24,
						expr: &seqExpr{
							pos: position{line: 1038, col: 5, offset: 32852},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1038, col: 5, offset: 32852},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&labeledExpr{
									pos:   position{line: 1038, col: 9, offset: 32856},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonSingleLineAttributeCollection28,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1009, col: 65, offset: 32223},
						name: "SingleLineAttributeList",
					},
				},
			},
		},
		{
			name: "AttributeList",
			pos:  position{line: 1052, col: 1, offset: 33175},
			expr: &choiceExpr{
				pos: position{line: 1052, col: 18, offset: 33192},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1052, col: 18, offset: 33192},
						run: (*parser).callonAttributeList2,
						expr: &seqExpr{
							pos: position{line: 1052, col: 18, offset: 33192},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1052, col: 18, offset: 33192},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1052, col: 22, offset: 33196},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1052, col: 26, offset: 33200},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1052, col: 38, offset: 33212},
										expr: &ruleRefExpr{
											pos:  position{line: 1052, col: 38, offset: 33212},
											name: "attributes",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1052, col: 50, offset: 33224},
									expr: &litMatcher{
										pos:        position{line: 1052, col: 50, offset: 33224},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1052, col: 55, offset: 33229},
									expr: &seqExpr{
										pos: position{line: 1052, col: 56, offset: 33230},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1052, col: 56, offset: 33230},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1052, col: 60, offset: 33234},
												expr: &choiceExpr{
													pos: position{line: 3750, col: 20, offset: 128702},
													alternatives: []interface{}{
														&charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3747, col: 36, offset: 128625},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3747, col: 36, offset: 128625},
																	expr: &litMatcher{
																		pos:        position{line: 3747, col: 36, offset: 128625},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3747, col: 42, offset: 128631},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1052, col: 66, offset: 33240},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonAttributeList28,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1058, col: 5, offset: 33446},
						run: (*parser).callonAttributeList30,
						expr: &seqExpr{
							pos: position{line: 1058, col: 5, offset: 33446},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1058, col: 5, offset: 33446},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1058, col: 9, offset: 33450},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1058, col: 13, offset: 33454},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1058, col: 25, offset: 33466},
										expr: &ruleRefExpr{
											pos:  position{line: 1058, col: 25, offset: 33466},
											name: "attributes",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1058, col: 37, offset: 33478},
									expr: &seqExpr{
										pos: position{line: 1058, col: 38, offset: 33479},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 1058, col: 38, offset: 33479},
												expr: &litMatcher{
													pos:        position{line: 1058, col: 38, offset: 33479},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 1058, col: 43, offset: 33484},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1058, col: 49, offset: 33490},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonAttributeList49,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "attributes",
			pos:  position{line: 1077, col: 1, offset: 34043},
			expr: &actionExpr{
				pos: position{line: 1077, col: 15, offset: 34057},
				run: (*parser).callonattributes1,
				expr: &seqExpr{
					pos: position{line: 1077, col: 15, offset: 34057},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1077, col: 15, offset: 34057},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 1077, col: 22, offset: 34064},
								name: "Attribute",
							},
						},
						&labeledExpr{
							pos:   position{line: 1077, col: 32, offset: 34074},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1077, col: 38, offset: 34080},
								expr: &seqExpr{
									pos: position{line: 1077, col: 39, offset: 34081},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 1077, col: 39, offset: 34081},
											expr: &litMatcher{
												pos:        position{line: 1077, col: 39, offset: 34081},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 1077, col: 44, offset: 34086},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 1077, col: 48, offset: 34090},
											expr: &choiceExpr{
												pos: position{line: 3750, col: 20, offset: 128702},
												alternatives: []interface{}{
													&charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														exprs: []interface{}{
															&zeroOrOneExpr{
																pos: position{line: 3747, col: 36, offset: 128625},
																expr: &litMatcher{
																	pos:        position{line: 3747, col: 36, offset: 128625},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3747, col: 42, offset: 128631},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1077, col: 52, offset: 34094},
											name: "Attribute",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineAttributeList",
			pos:  position{line: 1088, col: 1, offset: 34364},
			expr: &choiceExpr{
				pos: position{line: 1088, col: 28, offset: 34391},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1088, col: 28, offset: 34391},
						run: (*parser).callonSingleLineAttributeList2,
						expr: &seqExpr{
							pos: position{line: 1088, col: 28, offset: 34391},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1088, col: 28, offset: 34391},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1088, col: 32, offset: 34395},
									expr: &litMatcher{
										pos:        position{line: 1088, col: 32, offset: 34395},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1088, col: 37, offset: 34400},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1088, col: 49, offset: 34412},
										expr: &ruleRefExpr{
											pos:  position{line: 1088, col: 49, offset: 34412},
											name: "singleLineAttributes",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1088, col: 71, offset: 34434},
									expr: &litMatcher{
										pos:        position{line: 1088, col: 71, offset: 34434},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1088, col: 76, offset: 34439},
									expr: &seqExpr{
										pos: position{line: 1088, col: 77, offset: 34440},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1088, col: 77, offset: 34440},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1088, col: 81, offset: 34444},
												expr: &litMatcher{
													pos:        position{line: 1088, col: 81, offset: 34444},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1088, col: 88, offset: 34451},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonSingleLineAttributeList18,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1094, col: 5, offset: 34657},
						run: (*parser).callonSingleLineAttributeList20,
						expr: &seqExpr{
							pos: position{line: 1094, col: 5, offset: 34657},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1094, col: 5, offset: 34657},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1094, col: 9, offset: 34661},
									expr: &litMatcher{
										pos:        position{line: 1094, col: 9, offset: 34661},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1094, col: 14, offset: 34666},
									label: "attributesI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1094, col: 26, offset: 34678},
										expr: &ruleRefExpr{
											pos:  position{line: 1094, col: 26, offset: 34678},
											name: "singleLineAttributes",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1094, col: 48, offset: 34700},
									expr: &seqExpr{
										pos: position{line: 1094, col: 49, offset: 34701},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 1094, col: 49, offset: 34701},
												expr: &litMatcher{
													pos:        position{line: 1094, col: 49, offset: 34701},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 1094, col: 54, offset: 34706},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1094, col: 60, offset: 34712},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonSingleLineAttributeList34,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineAttributes",
			pos:  position{line: 1113, col: 1, offset: 35265},
			expr: &actionExpr{
				pos: position{line: 1113, col: 25, offset: 35289},
				run: (*parser).callonsingleLineAttributes1,
				expr: &seqExpr{
					pos: position{line: 1113, col: 25, offset: 35289},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1113, col: 25, offset: 35289},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 1113, col: 32, offset: 35296},
								name: "Attribute",
							},
						},
						&labeledExpr{
							pos:   position{line: 1113, col: 42, offset: 35306},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1113, col: 48, offset: 35312},
								expr: &seqExpr{
									pos: position{line: 1113, col: 49, offset: 35313},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 1113, col: 49, offset: 35313},
											expr: &litMatcher{
												pos:        position{line: 1113, col: 49, offset: 35313},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 1113, col: 54, offset: 35318},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 1113, col: 58, offset: 35322},
											expr: &litMatcher{
												pos:        position{line: 1113, col: 58, offset: 35322},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1113, col: 63, offset: 35327},
											name: "SingleLineAttribute",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Attribute",
			pos:  position{line: 1128, col: 1, offset: 35791},
			expr: &choiceExpr{
				pos: position{line: 1128, col: 24, offset: 35814},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1128, col: 24, offset: 35814},
						name: "MixinCallAttribute",
					},
					&actionExpr{
						pos: position{line: 1192, col: 19, offset: 38018},
						run: (*parser).callonAttribute3,
						expr: &seqExpr{
							pos: position{line: 1192, col: 19, offset: 38018},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1192, col: 19, offset: 38018},
									val:        "&&",
									ignoreCase: false,
									want:       "\"&&\"",
								},
								&andExpr{
									pos: position{line: 1192, col: 24, offset: 38023},
									expr: &choiceExpr{
										pos: position{line: 1192, col: 26, offset: 38025},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 1192, col: 31, offset: 38030},
												val:        "[,(]",
												chars:      []rune{',', '('},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1128, col: 62, offset: 35852},
						name: "SimpleAttribute",
					},
				},
			},
		},
		{
			name: "SingleLineAttribute",
			pos:  position{line: 1129, col: 1, offset: 35868},
			expr: &choiceExpr{
				pos: position{line: 1129, col: 24, offset: 35891},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1129, col: 24, offset: 35891},
						name: "SingleLineMixinCallAttribute",
					},
					&actionExpr{
						pos: position{line: 1192, col: 19, offset: 38018},
						run: (*parser).callonSingleLineAttribute3,
						expr: &seqExpr{
							pos: position{line: 1192, col: 19, offset: 38018},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1192, col: 19, offset: 38018},
									val:        "&&",
									ignoreCase: false,
									want:       "\"&&\"",
								},
								&andExpr{
									pos: position{line: 1192, col: 24, offset: 38023},
									expr: &choiceExpr{
										pos: position{line: 1192, col: 26, offset: 38025},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 1192, col: 31, offset: 38030},
												val:        "[,(]",
												chars:      []rune{',', '('},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1129, col: 72, offset: 35939},
						name: "SingleLineSimpleAttribute",
					},
				},
			},
		},
		{
			name: "SimpleAttribute",
			pos:  position{line: 1136, col: 1, offset: 36039},
			expr: &choiceExpr{
				pos: position{line: 1136, col: 30, offset: 36068},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1136, col: 30, offset: 36068},
						name: "simpleValueAttribute",
					},
					&actionExpr{
						pos: position{line: 1181, col: 27, offset: 37838},
						run: (*parser).callonSimpleAttribute3,
						expr: &seqExpr{
							pos: position{line: 1181, col: 27, offset: 37838},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1181, col: 27, offset: 37838},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1131, col: 18, offset: 35983},
										expr: &seqExpr{
											pos: position{line: 1131, col: 19, offset: 35984},
											exprs: []interface{}{
												&notExpr{
													pos: position{line: 1131, col: 19, offset: 35984},
													expr: &charClassMatcher{
														pos:        position{line: 1131, col: 20, offset: 35985},
														val:        "[()]",
														chars:      []rune{'(', ')'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2843, col: 26, offset: 99195},
													expr: &charClassMatcher{
														pos:        position{line: 2819, col: 27, offset: 98104},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2843, col: 101, offset: 99270,
												},
											},
										},
									},
								},
								&notExpr{
									pos: position{line: 1181, col: 47, offset: 37858},
									expr: &seqExpr{
										pos: position{line: 1181, col: 49, offset: 37860},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 1181, col: 49, offset: 37860},
												expr: &litMatcher{
													pos:        position{line: 1181, col: 49, offset: 37860},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&charClassMatcher{
												pos:        position{line: 1181, col: 54, offset: 37865},
												val:        "[!=]",
												chars:      []rune{'!', '='},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineSimpleAttribute",
			pos:  position{line: 1137, col: 1, offset: 36114},
			expr: &choiceExpr{
				pos: position{line: 1137, col: 30, offset: 36143},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1137, col: 30, offset: 36143},
						name: "singleLineSimpleValueAttribute",
					},
					&actionExpr{
						pos: position{line: 1181, col: 27, offset: 37838},
						run: (*parser).callonSingleLineSimpleAttribute3,
						expr: &seqExpr{
							pos: position{line: 1181, col: 27, offset: 37838},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1181, col: 27, offset: 37838},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1131, col: 18, offset: 35983},
										expr: &seqExpr{
											pos: position{line: 1131, col: 19, offset: 35984},
											exprs: []interface{}{
												&notExpr{
													pos: position{line: 1131, col: 19, offset: 35984},
													expr: &charClassMatcher{
														pos:        position{line: 1131, col: 20, offset: 35985},
														val:        "[()]",
														chars:      []rune{'(', ')'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2843, col: 26, offset: 99195},
													expr: &charClassMatcher{
														pos:        position{line: 2819, col: 27, offset: 98104},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2843, col: 101, offset: 99270,
												},
											},
										},
									},
								},
								&notExpr{
									pos: position{line: 1181, col: 47, offset: 37858},
									expr: &seqExpr{
										pos: position{line: 1181, col: 49, offset: 37860},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 1181, col: 49, offset: 37860},
												expr: &litMatcher{
													pos:        position{line: 1181, col: 49, offset: 37860},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&charClassMatcher{
												pos:        position{line: 1181, col: 54, offset: 37865},
												val:        "[!=]",
												chars:      []rune{'!', '='},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "simpleValueAttribute",
			pos:  position{line: 1139, col: 1, offset: 36200},
			expr: &choiceExpr{
				pos: position{line: 1139, col: 25, offset: 36224},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1139, col: 25, offset: 36224},
						run: (*parser).callonsimpleValueAttribute2,
						expr: &seqExpr{
							pos: position{line: 1139, col: 25, offset: 36224},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1139, col: 25, offset: 36224},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1131, col: 18, offset: 35983},
										expr: &seqExpr{
											pos: position{line: 1131, col: 19, offset: 35984},
											exprs: []interface{}{
												&notExpr{
													pos: position{line: 1131, col: 19, offset: 35984},
													expr: &charClassMatcher{
														pos:        position{line: 1131, col: 20, offset: 35985},
														val:        "[()]",
														chars:      []rune{'(', ')'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2843, col: 26, offset: 99195},
													expr: &charClassMatcher{
														pos:        position{line: 2819, col: 27, offset: 98104},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2843, col: 101, offset: 99270,
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1139, col: 45, offset: 36244},
									expr: &litMatcher{
										pos:        position{line: 1139, col: 45, offset: 36244},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1139, col: 50, offset: 36249},
									label: "assignPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonsimpleValueAttribute15,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1139, col: 65, offset: 36264},
									label: "noEscapeI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1139, col: 75, offset: 36274},
										expr: &litMatcher{
											pos:        position{line: 1139, col: 75, offset: 36274},
											val:        "!",
											ignoreCase: false,
											want:       "\"!\"",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1139, col: 80, offset: 36279},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1139, col: 84, offset: 36283},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1139, col: 88, offset: 36287},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonsimpleValueAttribute33,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1139, col: 97, offset: 36296},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1139, col: 103, offset: 36302},
										name: "Expression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1146, col: 5, offset: 36529},
						run: (*parser).callonsimpleValueAttribute41,
						expr: &seqExpr{
							pos: position{line: 1146, col: 5, offset: 36529},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1146, col: 5, offset: 36529},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1131, col: 18, offset: 35983},
										expr: &seqExpr{
											pos: position{line: 1131, col: 19, offset: 35984},
											exprs: []interface{}{
												&notExpr{
													pos: position{line: 1131, col: 19, offset: 35984},
													expr: &charClassMatcher{
														pos:        position{line: 1131, col: 20, offset: 35985},
														val:        "[()]",
														chars:      []rune{'(', ')'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2843, col: 26, offset: 99195},
													expr: &charClassMatcher{
														pos:        position{line: 2819, col: 27, offset: 98104},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2843, col: 101, offset: 99270,
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1146, col: 25, offset: 36549},
									expr: &litMatcher{
										pos:        position{line: 1146, col: 25, offset: 36549},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1146, col: 30, offset: 36554},
									label: "assignPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonsimpleValueAttribute54,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1146, col: 45, offset: 36569},
									label: "noEscapeI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1146, col: 55, offset: 36579},
										expr: &litMatcher{
											pos:        position{line: 1146, col: 55, offset: 36579},
											val:        "!",
											ignoreCase: false,
											want:       "\"!\"",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1146, col: 60, offset: 36584},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&labeledExpr{
									pos:   position{line: 1146, col: 64, offset: 36588},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonsimpleValueAttribute65,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineSimpleValueAttribute",
			pos:  position{line: 1160, col: 1, offset: 36995},
			expr: &choiceExpr{
				pos: position{line: 1160, col: 35, offset: 37029},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1160, col: 35, offset: 37029},
						run: (*parser).callonsingleLineSimpleValueAttribute2,
						expr: &seqExpr{
							pos: position{line: 1160, col: 35, offset: 37029},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1160, col: 35, offset: 37029},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1131, col: 18, offset: 35983},
										expr: &seqExpr{
											pos: position{line: 1131, col: 19, offset: 35984},
											exprs: []interface{}{
												&notExpr{
													pos: position{line: 1131, col: 19, offset: 35984},
													expr: &charClassMatcher{
														pos:        position{line: 1131, col: 20, offset: 35985},
														val:        "[()]",
														chars:      []rune{'(', ')'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2843, col: 26, offset: 99195},
													expr: &charClassMatcher{
														pos:        position{line: 2819, col: 27, offset: 98104},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2843, col: 101, offset: 99270,
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1160, col: 55, offset: 37049},
									expr: &litMatcher{
										pos:        position{line: 1160, col: 55, offset: 37049},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1160, col: 60, offset: 37054},
									label: "assignPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonsingleLineSimpleValueAttribute15,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1160, col: 75, offset: 37069},
									label: "noEscapeI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1160, col: 85, offset: 37079},
										expr: &litMatcher{
											pos:        position{line: 1160, col: 85, offset: 37079},
											val:        "!",
											ignoreCase: false,
											want:       "\"!\"",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1160, col: 90, offset: 37084},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1160, col: 94, offset: 37088},
									expr: &litMatcher{
										pos:        position{line: 1160, col: 94, offset: 37088},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1160, col: 99, offset: 37093},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1160, col: 105, offset: 37099},
										name: "Expression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1167, col: 5, offset: 37330},
						run: (*parser).callonsingleLineSimpleValueAttribute29,
						expr: &seqExpr{
							pos: position{line: 1167, col: 5, offset: 37330},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 1167, col: 5, offset: 37330},
									label: "nameI",
									expr: &oneOrMoreExpr{
										pos: position{line: 1131, col: 18, offset: 35983},
										expr: &seqExpr{
											pos: position{line: 1131, col: 19, offset: 35984},
											exprs: []interface{}{
												&notExpr{
													pos: position{line: 1131, col: 19, offset: 35984},
													expr: &charClassMatcher{
														pos:        position{line: 1131, col: 20, offset: 35985},
														val:        "[()]",
														chars:      []rune{'(', ')'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&notExpr{
													pos: position{line: 2843, col: 26, offset: 99195},
													expr: &charClassMatcher{
														pos:        position{line: 2819, col: 27, offset: 98104},
														val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
														chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
														ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&anyMatcher{
													line: 2843, col: 101, offset: 99270,
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1167, col: 25, offset: 37350},
									expr: &litMatcher{
										pos:        position{line: 1167, col: 25, offset: 37350},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1167, col: 30, offset: 37355},
									label: "assignPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonsingleLineSimpleValueAttribute42,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1167, col: 45, offset: 37370},
									label: "noEscapeI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1167, col: 55, offset: 37380},
										expr: &litMatcher{
											pos:        position{line: 1167, col: 55, offset: 37380},
											val:        "!",
											ignoreCase: false,
											want:       "\"!\"",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1167, col: 60, offset: 37385},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&labeledExpr{
									pos:   position{line: 1167, col: 64, offset: 37389},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonsingleLineSimpleValueAttribute53,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "MixinCallAttribute",
			pos:  position{line: 1200, col: 1, offset: 38129},
			expr: &actionExpr{
				pos: position{line: 1200, col: 23, offset: 38151},
				run: (*parser).callonMixinCallAttribute1,
				expr: &seqExpr{
					pos: position{line: 1200, col: 23, offset: 38151},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1200, col: 23, offset: 38151},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 1131, col: 18, offset: 35983},
								expr: &seqExpr{
									pos: position{line: 1131, col: 19, offset: 35984},
									exprs: []interface{}{
										&notExpr{
											pos: position{line: 1131, col: 19, offset: 35984},
											expr: &charClassMatcher{
												pos:        position{line: 1131, col: 20, offset: 35985},
												val:        "[()]",
												chars:      []rune{'(', ')'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&notExpr{
											pos: position{line: 2843, col: 26, offset: 99195},
											expr: &charClassMatcher{
												pos:        position{line: 2819, col: 27, offset: 98104},
												val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
												chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
												ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&anyMatcher{
											line: 2843, col: 101, offset: 99270,
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1200, col: 43, offset: 38171},
							expr: &litMatcher{
								pos:        position{line: 1200, col: 43, offset: 38171},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1200, col: 48, offset: 38176},
							label: "assignPosI",
							expr: &actionExpr{
								pos: position{line: 3737, col: 8, offset: 128286},
								run: (*parser).callonMixinCallAttribute14,
								expr: &choiceExpr{
									pos: position{line: 3737, col: 9, offset: 128287},
									alternatives: []interface{}{
										&andExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											expr: &anyMatcher{
												line: 3737, col: 10, offset: 128288,
											},
										},
										&notExpr{
											pos: position{line: 3737, col: 14, offset: 128292},
											expr: &anyMatcher{
												line: 3737, col: 15, offset: 128293,
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1200, col: 63, offset: 38191},
							label: "noEscapeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1200, col: 73, offset: 38201},
								expr: &litMatcher{
									pos:        position{line: 1200, col: 73, offset: 38201},
									val:        "!",
									ignoreCase: false,
									want:       "\"!\"",
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1200, col: 78, offset: 38206},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1200, col: 82, offset: 38210},
							expr: &choiceExpr{
								pos: position{line: 3750, col: 20, offset: 128702},
								alternatives: []interface{}{
									&charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
									&seqExpr{
										pos: position{line: 3747, col: 36, offset: 128625},
										exprs: []interface{}{
											&zeroOrOneExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												expr: &litMatcher{
													pos:        position{line: 3747, col: 36, offset: 128625},
													val:        "\r",
													ignoreCase: false,
													want:       "\"\\r\"",
												},
											},
											&litMatcher{
												pos:        position{line: 3747, col: 42, offset: 128631},
												val:        "\n",
												ignoreCase: false,
												want:       "\"\\n\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1200, col: 86, offset: 38214},
							label: "callI",
							expr: &ruleRefExpr{
								pos:  position{line: 1200, col: 92, offset: 38220},
								name: "mixinCallAttributeCall",
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineMixinCallAttribute",
			pos:  position{line: 1211, col: 1, offset: 38538},
			expr: &actionExpr{
				pos: position{line: 1211, col: 33, offset: 38570},
				run: (*parser).callonSingleLineMixinCallAttribute1,
				expr: &seqExpr{
					pos: position{line: 1211, col: 33, offset: 38570},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 1211, col: 33, offset: 38570},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 1131, col: 18, offset: 35983},
								expr: &seqExpr{
									pos: position{line: 1131, col: 19, offset: 35984},
									exprs: []interface{}{
										&notExpr{
											pos: position{line: 1131, col: 19, offset: 35984},
											expr: &charClassMatcher{
												pos:        position{line: 1131, col: 20, offset: 35985},
												val:        "[()]",
												chars:      []rune{'(', ')'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&notExpr{
											pos: position{line: 2843, col: 26, offset: 99195},
											expr: &charClassMatcher{
												pos:        position{line: 2819, col: 27, offset: 98104},
												val:        "[ \"\\>/=\\ufffe\\uffff\\U0001fffe\\U0001ffff\\U0002fffe\\U0002ffff\\U0003fffe\\U0003ffff\\U0004fffe\\U0004ffff\\U0005fffe\\U0005ffff\\U0006fffe\\U0006ffff\\U0007fffe\\U0007ffff\\U0008fffe\\U0008ffff\\U0009fffe\\U0009ffff\\U000afffe\\U000affff\\U000bfffe\\U000bffff\\U000cfffe\\U000cffff\\U000dfffe\\U000dffff\\U000efffe\\U000fffff\\U0010fffe\\U0010ffff\\x00-\\x1f\\x7f-\\u009f\\ufdd0-\\ufdef]",
												chars:      []rune{' ', '"', '\'', '>', '/', '=', '\ufffe', '\uffff', '\U0001fffe', '\U0001ffff', '\U0002fffe', '\U0002ffff', '\U0003fffe', '\U0003ffff', '\U0004fffe', '\U0004ffff', '\U0005fffe', '\U0005ffff', '\U0006fffe', '\U0006ffff', '\U0007fffe', '\U0007ffff', '\U0008fffe', '\U0008ffff', '\U0009fffe', '\U0009ffff', '\U000afffe', '\U000affff', '\U000bfffe', '\U000bffff', '\U000cfffe', '\U000cffff', '\U000dfffe', '\U000dffff', '\U000efffe', '\U000fffff', '\U0010fffe', '\U0010ffff'},
												ranges:     []rune{'\x00', '\x1f', '\x7f', '\u009f', '\ufdd0', '\ufdef'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&anyMatcher{
											line: 2843, col: 101, offset: 99270,
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1211, col: 53, offset: 38590},
							expr: &litMatcher{
								pos:        position{line: 1211, col: 53, offset: 38590},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1211, col: 58, offset: 38595},
							label: "assignPosI",
							expr: &actionExpr{
								pos: position{line: 3737, col: 8, offset: 128286},
								run: (*parser).callonSingleLineMixinCallAttribute14,
								expr: &choiceExpr{
									pos: position{line: 3737, col: 9, offset: 128287},
									alternatives: []interface{}{
										&andExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											expr: &anyMatcher{
												line: 3737, col: 10, offset: 128288,
											},
										},
										&notExpr{
											pos: position{line: 3737, col: 14, offset: 128292},
											expr: &anyMatcher{
												line: 3737, col: 15, offset: 128293,
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1211, col: 73, offset: 38610},
							label: "noEscapeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1211, col: 83, offset: 38620},
								expr: &litMatcher{
									pos:        position{line: 1211, col: 83, offset: 38620},
									val:        "!",
									ignoreCase: false,
									want:       "\"!\"",
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1211, col: 88, offset: 38625},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1211, col: 92, offset: 38629},
							expr: &litMatcher{
								pos:        position{line: 1211, col: 92, offset: 38629},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1211, col: 97, offset: 38634},
							label: "callI",
							expr: &ruleRefExpr{
								pos:  position{line: 1211, col: 103, offset: 38640},
								name: "singleLineMixinCallAttributeCall",
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallAttributeCall",
			pos:  position{line: 1223, col: 1, offset: 38969},
			expr: &actionExpr{
				pos: position{line: 1223, col: 27, offset: 38995},
				run: (*parser).callonmixinCallAttributeCall1,
				expr: &seqExpr{
					pos: position{line: 1223, col: 27, offset: 38995},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 1223, col: 27, offset: 38995},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 1223, col: 31, offset: 38999},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1223, col: 42, offset: 39010},
								expr: &seqExpr{
									pos: position{line: 1223, col: 43, offset: 39011},
									exprs: []interface{}{
										&choiceExpr{
											pos: position{line: 697, col: 10, offset: 21290},
											alternatives: []interface{}{
												&actionExpr{
													pos: position{line: 697, col: 10, offset: 21290},
													run: (*parser).callonmixinCallAttributeCall8,
													expr: &labeledExpr{
														pos:   position{line: 697, col: 10, offset: 21290},
														label: "identI",
														expr: &seqExpr{
															pos: position{line: 2367, col: 17, offset: 81233},
															exprs: []interface{}{
																&charClassMatcher{
																	pos:        position{line: 2350, col: 20, offset: 80988},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2367, col: 26, offset: 81242},
																	expr: &charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 699, col: 5, offset: 21384},
													run: (*parser).callonmixinCallAttributeCall14,
													expr: &seqExpr{
														pos: position{line: 699, col: 5, offset: 21384},
														exprs: []interface{}{
															&labeledExpr{
																pos:   position{line: 699, col: 5, offset: 21384},
																label: "identI",
																expr: &seqExpr{
																	pos: position{line: 699, col: 13, offset: 21392},
																	exprs: []interface{}{
																		&zeroOrOneExpr{
																			pos: position{line: 699, col: 13, offset: 21392},
																			expr: &litMatcher{
																				pos:        position{line: 699, col: 13, offset: 21392},
																				val:        "$",
																				ignoreCase: false,
																				want:       "\"$\"",
																			},
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 699, col: 18, offset: 21397},
																			expr: &choiceExpr{
																				pos: position{line: 699, col: 19, offset: 21398},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 699, col: 19, offset: 21398},
																						exprs: []interface{}{
																							&charClassMatcher{
																								pos:        position{line: 699, col: 19, offset: 21398},
																								val:        "[\\pNd]",
																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 699, col: 28, offset: 21407},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 699, col: 38, offset: 21417},
																						val:        "[_-\\pL]",
																						chars:      []rune{'_', '-'},
																						classes:    []*unicode.RangeTable{rangeTable("L")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&labeledExpr{
																pos:   position{line: 699, col: 49, offset: 21428},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonmixinCallAttributeCall27,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 1223, col: 49, offset: 39017},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1223, col: 55, offset: 39023},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 711, col: 14, offset: 21845},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 711, col: 14, offset: 21845},
										run: (*parser).callonmixinCallAttributeCall36,
										expr: &labeledExpr{
											pos:   position{line: 711, col: 14, offset: 21845},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 697, col: 10, offset: 21290},
												alternatives: []interface{}{
													&actionExpr{
														pos: position{line: 697, col: 10, offset: 21290},
														run: (*parser).callonmixinCallAttributeCall39,
														expr: &labeledExpr{
															pos:   position{line: 697, col: 10, offset: 21290},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2367, col: 17, offset: 81233},
																exprs: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2367, col: 26, offset: 81242},
																		expr: &charClassMatcher{
																			pos:        position{line: 2350, col: 20, offset: 80988},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 699, col: 5, offset: 21384},
														run: (*parser).callonmixinCallAttributeCall45,
														expr: &seqExpr{
															pos: position{line: 699, col: 5, offset: 21384},
															exprs: []interface{}{
																&labeledExpr{
																	pos:   position{line: 699, col: 5, offset: 21384},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 699, col: 13, offset: 21392},
																		exprs: []interface{}{
																			&zeroOrOneExpr{
																				pos: position{line: 699, col: 13, offset: 21392},
																				expr: &litMatcher{
																					pos:        position{line: 699, col: 13, offset: 21392},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 699, col: 18, offset: 21397},
																				expr: &choiceExpr{
																					pos: position{line: 699, col: 19, offset: 21398},
																					alternatives: []interface{}{
																						&seqExpr{
																							pos: position{line: 699, col: 19, offset: 21398},
																							exprs: []interface{}{
																								&charClassMatcher{
																									pos:        position{line: 699, col: 19, offset: 21398},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 699, col: 28, offset: 21407},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 699, col: 38, offset: 21417},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 699, col: 49, offset: 21428},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3737, col: 8, offset: 128286},
																		run: (*parser).callonmixinCallAttributeCall58,
																		expr: &choiceExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			alternatives: []interface{}{
																				&andExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					expr: &anyMatcher{
																						line: 3737, col: 10, offset: 128288,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3737, col: 14, offset: 128292},
																					expr: &anyMatcher{
																						line: 3737, col: 15, offset: 128293,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 713, col: 5, offset: 21887},
										run: (*parser).callonmixinCallAttributeCall64,
										expr: &seqExpr{
											pos: position{line: 713, col: 5, offset: 21887},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 713, col: 5, offset: 21887},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonmixinCallAttributeCall67,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
												&andExpr{
													pos: position{line: 713, col: 14, offset: 21896},
													expr: &choiceExpr{
														pos: position{line: 713, col: 16, offset: 21898},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 12, offset: 128237},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 713, col: 22, offset: 21904},
																val:        "[:!=(]",
																chars:      []rune{':', '!', '=', '('},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 724, col: 5, offset: 22230},
										run: (*parser).callonmixinCallAttributeCall86,
										expr: &seqExpr{
											pos: position{line: 724, col: 5, offset: 22230},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 724, col: 5, offset: 22230},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 724, col: 12, offset: 22237},
														expr: &charClassMatcher{
															pos:        position{line: 724, col: 12, offset: 22237},
															val:        "[^ \\t\\r\\n:!=(]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 724, col: 28, offset: 22253},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonmixinCallAttributeCall92,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1223, col: 71, offset: 39039},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1223, col: 77, offset: 39045},
								expr: &ruleRefExpr{
									pos:  position{line: 1223, col: 77, offset: 39045},
									name: "mixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1223, col: 91, offset: 39059},
							label: "valueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1223, col: 98, offset: 39066},
								expr: &ruleRefExpr{
									pos:  position{line: 1223, col: 98, offset: 39066},
									name: "mixinCallAttributeValue",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinCallAttributeCall",
			pos:  position{line: 1236, col: 1, offset: 39473},
			expr: &actionExpr{
				pos: position{line: 1236, col: 37, offset: 39509},
				run: (*parser).callonsingleLineMixinCallAttributeCall1,
				expr: &seqExpr{
					pos: position{line: 1236, col: 37, offset: 39509},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 1236, col: 37, offset: 39509},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 1236, col: 41, offset: 39513},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1236, col: 52, offset: 39524},
								expr: &seqExpr{
									pos: position{line: 1236, col: 53, offset: 39525},
									exprs: []interface{}{
										&choiceExpr{
											pos: position{line: 697, col: 10, offset: 21290},
											alternatives: []interface{}{
												&actionExpr{
													pos: position{line: 697, col: 10, offset: 21290},
													run: (*parser).callonsingleLineMixinCallAttributeCall8,
													expr: &labeledExpr{
														pos:   position{line: 697, col: 10, offset: 21290},
														label: "identI",
														expr: &seqExpr{
															pos: position{line: 2367, col: 17, offset: 81233},
															exprs: []interface{}{
																&charClassMatcher{
																	pos:        position{line: 2350, col: 20, offset: 80988},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2367, col: 26, offset: 81242},
																	expr: &charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 699, col: 5, offset: 21384},
													run: (*parser).callonsingleLineMixinCallAttributeCall14,
													expr: &seqExpr{
														pos: position{line: 699, col: 5, offset: 21384},
														exprs: []interface{}{
															&labeledExpr{
																pos:   position{line: 699, col: 5, offset: 21384},
																label: "identI",
																expr: &seqExpr{
																	pos: position{line: 699, col: 13, offset: 21392},
																	exprs: []interface{}{
																		&zeroOrOneExpr{
																			pos: position{line: 699, col: 13, offset: 21392},
																			expr: &litMatcher{
																				pos:        position{line: 699, col: 13, offset: 21392},
																				val:        "$",
																				ignoreCase: false,
																				want:       "\"$\"",
																			},
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 699, col: 18, offset: 21397},
																			expr: &choiceExpr{
																				pos: position{line: 699, col: 19, offset: 21398},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 699, col: 19, offset: 21398},
																						exprs: []interface{}{
																							&charClassMatcher{
																								pos:        position{line: 699, col: 19, offset: 21398},
																								val:        "[\\pNd]",
																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 699, col: 28, offset: 21407},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 699, col: 38, offset: 21417},
																						val:        "[_-\\pL]",
																						chars:      []rune{'_', '-'},
																						classes:    []*unicode.RangeTable{rangeTable("L")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&labeledExpr{
																pos:   position{line: 699, col: 49, offset: 21428},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonsingleLineMixinCallAttributeCall27,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 1236, col: 59, offset: 39531},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1236, col: 65, offset: 39537},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 711, col: 14, offset: 21845},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 711, col: 14, offset: 21845},
										run: (*parser).callonsingleLineMixinCallAttributeCall36,
										expr: &labeledExpr{
											pos:   position{line: 711, col: 14, offset: 21845},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 697, col: 10, offset: 21290},
												alternatives: []interface{}{
													&actionExpr{
														pos: position{line: 697, col: 10, offset: 21290},
														run: (*parser).callonsingleLineMixinCallAttributeCall39,
														expr: &labeledExpr{
															pos:   position{line: 697, col: 10, offset: 21290},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2367, col: 17, offset: 81233},
																exprs: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2367, col: 26, offset: 81242},
																		expr: &charClassMatcher{
																			pos:        position{line: 2350, col: 20, offset: 80988},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 699, col: 5, offset: 21384},
														run: (*parser).callonsingleLineMixinCallAttributeCall45,
														expr: &seqExpr{
															pos: position{line: 699, col: 5, offset: 21384},
															exprs: []interface{}{
																&labeledExpr{
																	pos:   position{line: 699, col: 5, offset: 21384},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 699, col: 13, offset: 21392},
																		exprs: []interface{}{
																			&zeroOrOneExpr{
																				pos: position{line: 699, col: 13, offset: 21392},
																				expr: &litMatcher{
																					pos:        position{line: 699, col: 13, offset: 21392},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 699, col: 18, offset: 21397},
																				expr: &choiceExpr{
																					pos: position{line: 699, col: 19, offset: 21398},
																					alternatives: []interface{}{
																						&seqExpr{
																							pos: position{line: 699, col: 19, offset: 21398},
																							exprs: []interface{}{
																								&charClassMatcher{
																									pos:        position{line: 699, col: 19, offset: 21398},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 699, col: 28, offset: 21407},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 699, col: 38, offset: 21417},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 699, col: 49, offset: 21428},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3737, col: 8, offset: 128286},
																		run: (*parser).callonsingleLineMixinCallAttributeCall58,
																		expr: &choiceExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			alternatives: []interface{}{
																				&andExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					expr: &anyMatcher{
																						line: 3737, col: 10, offset: 128288,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3737, col: 14, offset: 128292},
																					expr: &anyMatcher{
																						line: 3737, col: 15, offset: 128293,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 713, col: 5, offset: 21887},
										run: (*parser).callonsingleLineMixinCallAttributeCall64,
										expr: &seqExpr{
											pos: position{line: 713, col: 5, offset: 21887},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 713, col: 5, offset: 21887},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonsingleLineMixinCallAttributeCall67,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
												&andExpr{
													pos: position{line: 713, col: 14, offset: 21896},
													expr: &choiceExpr{
														pos: position{line: 713, col: 16, offset: 21898},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 12, offset: 128237},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 713, col: 22, offset: 21904},
																val:        "[:!=(]",
																chars:      []rune{':', '!', '=', '('},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 724, col: 5, offset: 22230},
										run: (*parser).callonsingleLineMixinCallAttributeCall86,
										expr: &seqExpr{
											pos: position{line: 724, col: 5, offset: 22230},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 724, col: 5, offset: 22230},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 724, col: 12, offset: 22237},
														expr: &charClassMatcher{
															pos:        position{line: 724, col: 12, offset: 22237},
															val:        "[^ \\t\\r\\n:!=(]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 724, col: 28, offset: 22253},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonsingleLineMixinCallAttributeCall92,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1236, col: 81, offset: 39553},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1236, col: 87, offset: 39559},
								expr: &ruleRefExpr{
									pos:  position{line: 1236, col: 87, offset: 39559},
									name: "singleLineMixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1236, col: 111, offset: 39583},
							label: "valueI",
							expr: &zeroOrOneExpr{
								pos: position{line: 1236, col: 118, offset: 39590},
								expr: &ruleRefExpr{
									pos:  position{line: 1236, col: 118, offset: 39590},
									name: "mixinCallAttributeValue",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallAttributeValue",
			pos:  position{line: 1250, col: 1, offset: 39998},
			expr: &choiceExpr{
				pos: position{line: 1250, col: 28, offset: 40025},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3699, col: 27, offset: 126966},
						run: (*parser).callonmixinCallAttributeValue2,
						expr: &seqExpr{
							pos: position{line: 3699, col: 27, offset: 126966},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3699, col: 27, offset: 126966},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3762, col: 14, offset: 129078},
										run: (*parser).callonmixinCallAttributeValue5,
										expr: &litMatcher{
											pos:        position{line: 3762, col: 14, offset: 129078},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3699, col: 50, offset: 126989},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3699, col: 56, offset: 126995},
										expr: &charClassMatcher{
											pos:        position{line: 3699, col: 56, offset: 126995},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3699, col: 67, offset: 127006},
									label: "rBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3763, col: 14, offset: 129118},
										run: (*parser).callonmixinCallAttributeValue11,
										expr: &litMatcher{
											pos:        position{line: 3763, col: 14, offset: 129118},
											val:        "]",
											ignoreCase: false,
											want:       "\"]\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3705, col: 5, offset: 127217},
						run: (*parser).callonmixinCallAttributeValue13,
						expr: &seqExpr{
							pos: position{line: 3705, col: 5, offset: 127217},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3705, col: 5, offset: 127217},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3762, col: 14, offset: 129078},
										run: (*parser).callonmixinCallAttributeValue16,
										expr: &litMatcher{
											pos:        position{line: 3762, col: 14, offset: 129078},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3705, col: 28, offset: 127240},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3705, col: 34, offset: 127246},
										expr: &charClassMatcher{
											pos:        position{line: 3705, col: 34, offset: 127246},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1250, col: 53, offset: 40050},
						name: "expressionInterpolationValue",
					},
				},
			},
		},
		{
			name: "Expression",
			pos:  position{line: 1261, col: 1, offset: 40333},
			expr: &choiceExpr{
				pos: position{line: 1261, col: 15, offset: 40347},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1261, col: 15, offset: 40347},
						run: (*parser).callonExpression2,
						expr: &labeledExpr{
							pos:   position{line: 1261, col: 15, offset: 40347},
							label: "cExprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1261, col: 22, offset: 40354},
								name: "ChainExpression",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1263, col: 5, offset: 40475},
						name: "GoExpression",
					},
				},
			},
		},
		{
			name: "SingleLineExpression",
			pos:  position{line: 1265, col: 1, offset: 40489},
			expr: &choiceExpr{
				pos: position{line: 1265, col: 25, offset: 40513},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1265, col: 25, offset: 40513},
						run: (*parser).callonSingleLineExpression2,
						expr: &labeledExpr{
							pos:   position{line: 1265, col: 25, offset: 40513},
							label: "cExprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1265, col: 32, offset: 40520},
								name: "SingleLineChainExpression",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1267, col: 5, offset: 40651},
						name: "SingleLineGoExpression",
					},
				},
			},
		},
		{
			name: "GoExpression",
			pos:  position{line: 1277, col: 1, offset: 41059},
			expr: &actionExpr{
				pos: position{line: 1277, col: 17, offset: 41075},
				run: (*parser).callonGoExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1277, col: 17, offset: 41075},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1277, col: 24, offset: 41082},
						expr: &choiceExpr{
							pos: position{line: 1278, col: 5, offset: 41088},
							alternatives: []interface{}{
								&actionExpr{
									pos: position{line: 1278, col: 5, offset: 41088},
									run: (*parser).callonGoExpression5,
									expr: &labeledExpr{
										pos:   position{line: 1278, col: 5, offset: 41088},
										label: "exprI",
										expr: &choiceExpr{
											pos: position{line: 1278, col: 12, offset: 41095},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 1278, col: 12, offset: 41095},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1278, col: 12, offset: 41095},
															val:        "(",
															ignoreCase: false,
															want:       "\"(\"",
														},
														&zeroOrOneExpr{
															pos: position{line: 1278, col: 16, offset: 41099},
															expr: &ruleRefExpr{
																pos:  position{line: 1278, col: 16, offset: 41099},
																name: "goSubExpression",
															},
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonGoExpression12,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1278, col: 37, offset: 41120},
															val:        ")",
															ignoreCase: false,
															want:       "\")\"",
														},
													},
												},
												&seqExpr{
													pos: position{line: 1278, col: 43, offset: 41126},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1278, col: 43, offset: 41126},
															val:        "[",
															ignoreCase: false,
															want:       "\"[\"",
														},
														&zeroOrOneExpr{
															pos: position{line: 1278, col: 47, offset: 41130},
															expr: &ruleRefExpr{
																pos:  position{line: 1278, col: 47, offset: 41130},
																name: "goSubExpression",
															},
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonGoExpression23,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1278, col: 68, offset: 41151},
															val:        "]",
															ignoreCase: false,
															want:       "\"]\"",
														},
													},
												},
												&seqExpr{
													pos: position{line: 1278, col: 74, offset: 41157},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1278, col: 74, offset: 41157},
															val:        "{",
															ignoreCase: false,
															want:       "\"{\"",
														},
														&zeroOrOneExpr{
															pos: position{line: 1278, col: 78, offset: 41161},
															expr: &ruleRefExpr{
																pos:  position{line: 1278, col: 78, offset: 41161},
																name: "goSubExpression",
															},
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonGoExpression34,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1278, col: 99, offset: 41182},
															val:        "}",
															ignoreCase: false,
															want:       "\"}\"",
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 1301, col: 9, offset: 41911},
									run: (*parser).callonGoExpression41,
									expr: &seqExpr{
										pos: position{line: 1301, col: 9, offset: 41911},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 1301, col: 9, offset: 41911},
												label: "parenI",
												expr: &charClassMatcher{
													pos:        position{line: 1301, col: 16, offset: 41918},
													val:        "[([{]",
													chars:      []rune{'(', '[', '{'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&labeledExpr{
												pos:   position{line: 1301, col: 22, offset: 41924},
												label: "startPosI",
												expr: &actionExpr{
													pos: position{line: 3737, col: 8, offset: 128286},
													run: (*parser).callonGoExpression46,
													expr: &choiceExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														alternatives: []interface{}{
															&andExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																expr: &anyMatcher{
																	line: 3737, col: 10, offset: 128288,
																},
															},
															&notExpr{
																pos: position{line: 3737, col: 14, offset: 128292},
																expr: &anyMatcher{
																	line: 3737, col: 15, offset: 128293,
																},
															},
														},
													},
												},
											},
											&labeledExpr{
												pos:   position{line: 1301, col: 36, offset: 41938},
												label: "exprI",
												expr: &zeroOrOneExpr{
													pos: position{line: 1301, col: 42, offset: 41944},
													expr: &ruleRefExpr{
														pos:  position{line: 1301, col: 42, offset: 41944},
														name: "goSubExpression",
													},
												},
											},
										},
									},
								},
								&seqExpr{
									pos: position{line: 1331, col: 10, offset: 42986},
									exprs: []interface{}{
										&actionExpr{
											pos: position{line: 3737, col: 8, offset: 128286},
											run: (*parser).callonGoExpression56,
											expr: &choiceExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												alternatives: []interface{}{
													&andExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														expr: &anyMatcher{
															line: 3737, col: 10, offset: 128288,
														},
													},
													&notExpr{
														pos: position{line: 3737, col: 14, offset: 128292},
														expr: &anyMatcher{
															line: 3737, col: 15, offset: 128293,
														},
													},
												},
											},
										},
										&choiceExpr{
											pos: position{line: 2414, col: 14, offset: 82561},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 2414, col: 14, offset: 82561},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 2414, col: 14, offset: 82561},
															val:        "'",
															ignoreCase: false,
															want:       "\"'\"",
														},
														&choiceExpr{
															pos: position{line: 2414, col: 20, offset: 82567},
															alternatives: []interface{}{
																&seqExpr{
																	pos: position{line: 2462, col: 19, offset: 84712},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2462, col: 19, offset: 84712},
																			val:        "\\u",
																			ignoreCase: false,
																			want:       "\"\\\\u\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2463, col: 5, offset: 84771},
																	run: (*parser).callonGoExpression72,
																	expr: &seqExpr{
																		pos: position{line: 2463, col: 5, offset: 84771},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2463, col: 5, offset: 84771},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 14, offset: 84780},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 26, offset: 84792},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 38, offset: 84804},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 50, offset: 84816},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2492, col: 16, offset: 85952},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2492, col: 16, offset: 85952},
																			val:        "\\U",
																			ignoreCase: false,
																			want:       "\"\\\\U\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2493, col: 5, offset: 86055},
																	run: (*parser).callonGoExpression93,
																	expr: &seqExpr{
																		pos: position{line: 2493, col: 5, offset: 86055},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2493, col: 5, offset: 86055},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 14, offset: 86064},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 26, offset: 86076},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 38, offset: 86088},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 50, offset: 86100},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 62, offset: 86112},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 74, offset: 86124},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 86, offset: 86136},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 98, offset: 86148},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2527, col: 24, offset: 87533},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2527, col: 24, offset: 87533},
																			val:        "\\",
																			ignoreCase: false,
																			want:       "\"\\\\\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2527, col: 29, offset: 87538},
																			val:        "[abfnrtv\\\\\\]",
																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&charClassMatcher{
																	pos:        position{line: 2441, col: 75, offset: 83824},
																	val:        "[^\\\\\\\\n]",
																	chars:      []rune{'\'', '\\', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
																&seqExpr{
																	pos: position{line: 2443, col: 24, offset: 83970},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2443, col: 24, offset: 83970},
																			val:        "\\",
																			ignoreCase: false,
																			want:       "\"\\\\\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2444, col: 24, offset: 84037},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2444, col: 24, offset: 84037},
																			val:        "\\x",
																			ignoreCase: false,
																			want:       "\"\\\\x\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2445, col: 5, offset: 84074},
																	run: (*parser).callonGoExpression125,
																	expr: &seqExpr{
																		pos: position{line: 2445, col: 5, offset: 84074},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2445, col: 5, offset: 84074},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2445, col: 14, offset: 84083},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2445, col: 26, offset: 84095},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2528, col: 24, offset: 87616},
																	run: (*parser).callonGoExpression132,
																	expr: &seqExpr{
																		pos: position{line: 2528, col: 24, offset: 87616},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2528, col: 24, offset: 87616},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2552, col: 5, offset: 88632},
																	run: (*parser).callonGoExpression143,
																	expr: &seqExpr{
																		pos: position{line: 2552, col: 5, offset: 88632},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2552, col: 5, offset: 88632},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2573, col: 5, offset: 89473},
																	run: (*parser).callonGoExpression150,
																	expr: &seqExpr{
																		pos: position{line: 2573, col: 5, offset: 89473},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2573, col: 5, offset: 89473},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2591, col: 5, offset: 90158},
																	run: (*parser).callonGoExpression155,
																	expr: &seqExpr{
																		pos: position{line: 2591, col: 5, offset: 90158},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2591, col: 5, offset: 90158},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2591, col: 10, offset: 90163},
																				expr: &charClassMatcher{
																					pos:        position{line: 3735, col: 12, offset: 128270},
																					val:        "[^\\r\\n]",
																					chars:      []rune{'\r', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 2414, col: 76, offset: 82623},
															val:        "'",
															ignoreCase: false,
															want:       "\"'\"",
														},
													},
												},
												&actionExpr{
													pos: position{line: 2415, col: 5, offset: 82634},
													run: (*parser).callonGoExpression161,
													expr: &seqExpr{
														pos: position{line: 2415, col: 5, offset: 82634},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2415, col: 5, offset: 82634},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&labeledExpr{
																pos:   position{line: 2415, col: 10, offset: 82639},
																label: "valsI",
																expr: &zeroOrMoreExpr{
																	pos: position{line: 2415, col: 16, offset: 82645},
																	expr: &choiceExpr{
																		pos: position{line: 2415, col: 17, offset: 82646},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 2462, col: 19, offset: 84712},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2462, col: 19, offset: 84712},
																						val:        "\\u",
																						ignoreCase: false,
																						want:       "\"\\\\u\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2463, col: 5, offset: 84771},
																				run: (*parser).callonGoExpression173,
																				expr: &seqExpr{
																					pos: position{line: 2463, col: 5, offset: 84771},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2463, col: 5, offset: 84771},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 14, offset: 84780},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 26, offset: 84792},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 38, offset: 84804},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 50, offset: 84816},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2492, col: 16, offset: 85952},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2492, col: 16, offset: 85952},
																						val:        "\\U",
																						ignoreCase: false,
																						want:       "\"\\\\U\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2493, col: 5, offset: 86055},
																				run: (*parser).callonGoExpression194,
																				expr: &seqExpr{
																					pos: position{line: 2493, col: 5, offset: 86055},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2493, col: 5, offset: 86055},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 14, offset: 86064},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 26, offset: 86076},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 38, offset: 86088},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 50, offset: 86100},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 62, offset: 86112},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 74, offset: 86124},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 86, offset: 86136},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 98, offset: 86148},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2527, col: 24, offset: 87533},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2527, col: 24, offset: 87533},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2527, col: 29, offset: 87538},
																						val:        "[abfnrtv\\\\\\]",
																						chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&charClassMatcher{
																				pos:        position{line: 2441, col: 75, offset: 83824},
																				val:        "[^\\\\\\\\n]",
																				chars:      []rune{'\'', '\\', '\n'},
																				ignoreCase: false,
																				inverted:   true,
																			},
																			&seqExpr{
																				pos: position{line: 2443, col: 24, offset: 83970},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2443, col: 24, offset: 83970},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2444, col: 24, offset: 84037},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2444, col: 24, offset: 84037},
																						val:        "\\x",
																						ignoreCase: false,
																						want:       "\"\\\\x\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2445, col: 5, offset: 84074},
																				run: (*parser).callonGoExpression226,
																				expr: &seqExpr{
																					pos: position{line: 2445, col: 5, offset: 84074},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2445, col: 5, offset: 84074},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2445, col: 14, offset: 84083},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2445, col: 26, offset: 84095},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2528, col: 24, offset: 87616},
																				run: (*parser).callonGoExpression233,
																				expr: &seqExpr{
																					pos: position{line: 2528, col: 24, offset: 87616},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2528, col: 24, offset: 87616},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2552, col: 5, offset: 88632},
																				run: (*parser).callonGoExpression244,
																				expr: &seqExpr{
																					pos: position{line: 2552, col: 5, offset: 88632},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2552, col: 5, offset: 88632},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2573, col: 5, offset: 89473},
																				run: (*parser).callonGoExpression251,
																				expr: &seqExpr{
																					pos: position{line: 2573, col: 5, offset: 89473},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2573, col: 5, offset: 89473},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2591, col: 5, offset: 90158},
																				run: (*parser).callonGoExpression256,
																				expr: &seqExpr{
																					pos: position{line: 2591, col: 5, offset: 90158},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2591, col: 5, offset: 90158},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2591, col: 10, offset: 90163},
																							expr: &charClassMatcher{
																								pos:        position{line: 3735, col: 12, offset: 128270},
																								val:        "[^\\r\\n]",
																								chars:      []rune{'\r', '\n'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2415, col: 74, offset: 82703},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&labeledExpr{
																pos:   position{line: 2415, col: 79, offset: 82708},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonGoExpression263,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 1331, col: 27, offset: 43003},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1331, col: 46, offset: 43022},
									name: "TernaryExpression",
								},
								&seqExpr{
									pos: position{line: 1332, col: 6, offset: 43047},
									exprs: []interface{}{
										&actionExpr{
											pos: position{line: 3737, col: 8, offset: 128286},
											run: (*parser).callonGoExpression272,
											expr: &choiceExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												alternatives: []interface{}{
													&andExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														expr: &anyMatcher{
															line: 3737, col: 10, offset: 128288,
														},
													},
													&notExpr{
														pos: position{line: 3737, col: 14, offset: 128292},
														expr: &anyMatcher{
															line: 3737, col: 15, offset: 128293,
														},
													},
												},
											},
										},
										&notExpr{
											pos: position{line: 1332, col: 11, offset: 43052},
											expr: &choiceExpr{
												pos: position{line: 1269, col: 25, offset: 40699},
												alternatives: []interface{}{
													&charClassMatcher{
														pos:        position{line: 1269, col: 25, offset: 40699},
														val:        "[)}],]",
														chars:      []rune{')', '}', ']', ','},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 1269, col: 40, offset: 40714},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 1269, col: 40, offset: 40714},
																val:        ":",
																ignoreCase: false,
																want:       "\":\"",
															},
															&notExpr{
																pos: position{line: 1269, col: 44, offset: 40718},
																expr: &litMatcher{
																	pos:        position{line: 1269, col: 45, offset: 40719},
																	val:        "=",
																	ignoreCase: false,
																	want:       "\"=\"",
																},
															},
														},
													},
												},
											},
										},
										&charClassMatcher{
											pos:        position{line: 3735, col: 12, offset: 128270},
											val:        "[^\\r\\n]",
											chars:      []rune{'\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
										&zeroOrMoreExpr{
											pos: position{line: 1332, col: 41, offset: 43082},
											expr: &seqExpr{
												pos: position{line: 1332, col: 42, offset: 43083},
												exprs: []interface{}{
													&notExpr{
														pos: position{line: 1332, col: 42, offset: 43083},
														expr: &choiceExpr{
															pos: position{line: 1269, col: 25, offset: 40699},
															alternatives: []interface{}{
																&charClassMatcher{
																	pos:        position{line: 1269, col: 25, offset: 40699},
																	val:        "[)}],]",
																	chars:      []rune{')', '}', ']', ','},
																	ignoreCase: false,
																	inverted:   false,
																},
																&seqExpr{
																	pos: position{line: 1269, col: 40, offset: 40714},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 1269, col: 40, offset: 40714},
																			val:        ":",
																			ignoreCase: false,
																			want:       "\":\"",
																		},
																		&notExpr{
																			pos: position{line: 1269, col: 44, offset: 40718},
																			expr: &litMatcher{
																				pos:        position{line: 1269, col: 45, offset: 40719},
																				val:        "=",
																				ignoreCase: false,
																				want:       "\"=\"",
																			},
																		},
																	},
																},
															},
														},
													},
													&notExpr{
														pos: position{line: 1332, col: 64, offset: 43105},
														expr: &seqExpr{
															pos: position{line: 3734, col: 12, offset: 128237},
															exprs: []interface{}{
																&zeroOrMoreExpr{
																	pos: position{line: 3734, col: 12, offset: 128237},
																	expr: &charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&choiceExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	alternatives: []interface{}{
																		&seqExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			exprs: []interface{}{
																				&zeroOrOneExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					expr: &litMatcher{
																						pos:        position{line: 3734, col: 16, offset: 128241},
																						val:        "\r",
																						ignoreCase: false,
																						want:       "\"\\r\"",
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 3734, col: 22, offset: 128247},
																					val:        "\n",
																					ignoreCase: false,
																					want:       "\"\\n\"",
																				},
																			},
																		},
																		&notExpr{
																			pos: position{line: 3733, col: 12, offset: 128223},
																			expr: &anyMatcher{
																				line: 3733, col: 13, offset: 128224,
																			},
																		},
																	},
																},
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 1332, col: 69, offset: 43110},
														val:        "[^\\\"`?([{]",
														chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goSubExpression",
			pos:  position{line: 1337, col: 1, offset: 43171},
			expr: &actionExpr{
				pos: position{line: 1337, col: 20, offset: 43190},
				run: (*parser).callongoSubExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1337, col: 20, offset: 43190},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1337, col: 27, offset: 43197},
						expr: &choiceExpr{
							pos: position{line: 1338, col: 5, offset: 43203},
							alternatives: []interface{}{
								&actionExpr{
									pos: position{line: 1338, col: 5, offset: 43203},
									run: (*parser).callongoSubExpression5,
									expr: &labeledExpr{
										pos:   position{line: 1338, col: 5, offset: 43203},
										label: "exprI",
										expr: &choiceExpr{
											pos: position{line: 1338, col: 12, offset: 43210},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 1338, col: 12, offset: 43210},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1338, col: 12, offset: 43210},
															val:        "(",
															ignoreCase: false,
															want:       "\"(\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1338, col: 16, offset: 43214},
															name: "goSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callongoSubExpression11,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1338, col: 36, offset: 43234},
															val:        ")",
															ignoreCase: false,
															want:       "\")\"",
														},
													},
												},
												&seqExpr{
													pos: position{line: 1338, col: 42, offset: 43240},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1338, col: 42, offset: 43240},
															val:        "[",
															ignoreCase: false,
															want:       "\"[\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1338, col: 46, offset: 43244},
															name: "goSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callongoSubExpression21,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1338, col: 66, offset: 43264},
															val:        "]",
															ignoreCase: false,
															want:       "\"]\"",
														},
													},
												},
												&seqExpr{
													pos: position{line: 1338, col: 72, offset: 43270},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1338, col: 72, offset: 43270},
															val:        "{",
															ignoreCase: false,
															want:       "\"{\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1338, col: 76, offset: 43274},
															name: "goSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callongoSubExpression31,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1338, col: 96, offset: 43294},
															val:        "}",
															ignoreCase: false,
															want:       "\"}\"",
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 1361, col: 9, offset: 44023},
									run: (*parser).callongoSubExpression38,
									expr: &seqExpr{
										pos: position{line: 1361, col: 9, offset: 44023},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 1361, col: 9, offset: 44023},
												label: "parenI",
												expr: &charClassMatcher{
													pos:        position{line: 1361, col: 16, offset: 44030},
													val:        "[([{]",
													chars:      []rune{'(', '[', '{'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&labeledExpr{
												pos:   position{line: 1361, col: 22, offset: 44036},
												label: "startPosI",
												expr: &actionExpr{
													pos: position{line: 3737, col: 8, offset: 128286},
													run: (*parser).callongoSubExpression43,
													expr: &choiceExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														alternatives: []interface{}{
															&andExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																expr: &anyMatcher{
																	line: 3737, col: 10, offset: 128288,
																},
															},
															&notExpr{
																pos: position{line: 3737, col: 14, offset: 128292},
																expr: &anyMatcher{
																	line: 3737, col: 15, offset: 128293,
																},
															},
														},
													},
												},
											},
											&labeledExpr{
												pos:   position{line: 1361, col: 36, offset: 44050},
												label: "exprI",
												expr: &ruleRefExpr{
													pos:  position{line: 1361, col: 42, offset: 44056},
													name: "goSubExpression",
												},
											},
										},
									},
								},
								&seqExpr{
									pos: position{line: 1391, col: 10, offset: 45097},
									exprs: []interface{}{
										&actionExpr{
											pos: position{line: 3737, col: 8, offset: 128286},
											run: (*parser).callongoSubExpression52,
											expr: &choiceExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												alternatives: []interface{}{
													&andExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														expr: &anyMatcher{
															line: 3737, col: 10, offset: 128288,
														},
													},
													&notExpr{
														pos: position{line: 3737, col: 14, offset: 128292},
														expr: &anyMatcher{
															line: 3737, col: 15, offset: 128293,
														},
													},
												},
											},
										},
										&choiceExpr{
											pos: position{line: 2414, col: 14, offset: 82561},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 2414, col: 14, offset: 82561},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 2414, col: 14, offset: 82561},
															val:        "'",
															ignoreCase: false,
															want:       "\"'\"",
														},
														&choiceExpr{
															pos: position{line: 2414, col: 20, offset: 82567},
															alternatives: []interface{}{
																&seqExpr{
																	pos: position{line: 2462, col: 19, offset: 84712},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2462, col: 19, offset: 84712},
																			val:        "\\u",
																			ignoreCase: false,
																			want:       "\"\\\\u\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2463, col: 5, offset: 84771},
																	run: (*parser).callongoSubExpression68,
																	expr: &seqExpr{
																		pos: position{line: 2463, col: 5, offset: 84771},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2463, col: 5, offset: 84771},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 14, offset: 84780},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 26, offset: 84792},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 38, offset: 84804},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 50, offset: 84816},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2492, col: 16, offset: 85952},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2492, col: 16, offset: 85952},
																			val:        "\\U",
																			ignoreCase: false,
																			want:       "\"\\\\U\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2493, col: 5, offset: 86055},
																	run: (*parser).callongoSubExpression89,
																	expr: &seqExpr{
																		pos: position{line: 2493, col: 5, offset: 86055},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2493, col: 5, offset: 86055},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 14, offset: 86064},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 26, offset: 86076},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 38, offset: 86088},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 50, offset: 86100},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 62, offset: 86112},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 74, offset: 86124},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 86, offset: 86136},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 98, offset: 86148},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2527, col: 24, offset: 87533},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2527, col: 24, offset: 87533},
																			val:        "\\",
																			ignoreCase: false,
																			want:       "\"\\\\\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2527, col: 29, offset: 87538},
																			val:        "[abfnrtv\\\\\\]",
																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&charClassMatcher{
																	pos:        position{line: 2441, col: 75, offset: 83824},
																	val:        "[^\\\\\\\\n]",
																	chars:      []rune{'\'', '\\', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
																&seqExpr{
																	pos: position{line: 2443, col: 24, offset: 83970},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2443, col: 24, offset: 83970},
																			val:        "\\",
																			ignoreCase: false,
																			want:       "\"\\\\\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2444, col: 24, offset: 84037},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2444, col: 24, offset: 84037},
																			val:        "\\x",
																			ignoreCase: false,
																			want:       "\"\\\\x\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2445, col: 5, offset: 84074},
																	run: (*parser).callongoSubExpression121,
																	expr: &seqExpr{
																		pos: position{line: 2445, col: 5, offset: 84074},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2445, col: 5, offset: 84074},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2445, col: 14, offset: 84083},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2445, col: 26, offset: 84095},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2528, col: 24, offset: 87616},
																	run: (*parser).callongoSubExpression128,
																	expr: &seqExpr{
																		pos: position{line: 2528, col: 24, offset: 87616},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2528, col: 24, offset: 87616},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2552, col: 5, offset: 88632},
																	run: (*parser).callongoSubExpression139,
																	expr: &seqExpr{
																		pos: position{line: 2552, col: 5, offset: 88632},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2552, col: 5, offset: 88632},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2573, col: 5, offset: 89473},
																	run: (*parser).callongoSubExpression146,
																	expr: &seqExpr{
																		pos: position{line: 2573, col: 5, offset: 89473},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2573, col: 5, offset: 89473},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2591, col: 5, offset: 90158},
																	run: (*parser).callongoSubExpression151,
																	expr: &seqExpr{
																		pos: position{line: 2591, col: 5, offset: 90158},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2591, col: 5, offset: 90158},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2591, col: 10, offset: 90163},
																				expr: &charClassMatcher{
																					pos:        position{line: 3735, col: 12, offset: 128270},
																					val:        "[^\\r\\n]",
																					chars:      []rune{'\r', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 2414, col: 76, offset: 82623},
															val:        "'",
															ignoreCase: false,
															want:       "\"'\"",
														},
													},
												},
												&actionExpr{
													pos: position{line: 2415, col: 5, offset: 82634},
													run: (*parser).callongoSubExpression157,
													expr: &seqExpr{
														pos: position{line: 2415, col: 5, offset: 82634},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2415, col: 5, offset: 82634},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&labeledExpr{
																pos:   position{line: 2415, col: 10, offset: 82639},
																label: "valsI",
																expr: &zeroOrMoreExpr{
																	pos: position{line: 2415, col: 16, offset: 82645},
																	expr: &choiceExpr{
																		pos: position{line: 2415, col: 17, offset: 82646},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 2462, col: 19, offset: 84712},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2462, col: 19, offset: 84712},
																						val:        "\\u",
																						ignoreCase: false,
																						want:       "\"\\\\u\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2463, col: 5, offset: 84771},
																				run: (*parser).callongoSubExpression169,
																				expr: &seqExpr{
																					pos: position{line: 2463, col: 5, offset: 84771},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2463, col: 5, offset: 84771},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 14, offset: 84780},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 26, offset: 84792},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 38, offset: 84804},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 50, offset: 84816},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2492, col: 16, offset: 85952},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2492, col: 16, offset: 85952},
																						val:        "\\U",
																						ignoreCase: false,
																						want:       "\"\\\\U\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2493, col: 5, offset: 86055},
																				run: (*parser).callongoSubExpression190,
																				expr: &seqExpr{
																					pos: position{line: 2493, col: 5, offset: 86055},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2493, col: 5, offset: 86055},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 14, offset: 86064},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 26, offset: 86076},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 38, offset: 86088},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 50, offset: 86100},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 62, offset: 86112},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 74, offset: 86124},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 86, offset: 86136},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 98, offset: 86148},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2527, col: 24, offset: 87533},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2527, col: 24, offset: 87533},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2527, col: 29, offset: 87538},
																						val:        "[abfnrtv\\\\\\]",
																						chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&charClassMatcher{
																				pos:        position{line: 2441, col: 75, offset: 83824},
																				val:        "[^\\\\\\\\n]",
																				chars:      []rune{'\'', '\\', '\n'},
																				ignoreCase: false,
																				inverted:   true,
																			},
																			&seqExpr{
																				pos: position{line: 2443, col: 24, offset: 83970},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2443, col: 24, offset: 83970},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2444, col: 24, offset: 84037},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2444, col: 24, offset: 84037},
																						val:        "\\x",
																						ignoreCase: false,
																						want:       "\"\\\\x\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2445, col: 5, offset: 84074},
																				run: (*parser).callongoSubExpression222,
																				expr: &seqExpr{
																					pos: position{line: 2445, col: 5, offset: 84074},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2445, col: 5, offset: 84074},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2445, col: 14, offset: 84083},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2445, col: 26, offset: 84095},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2528, col: 24, offset: 87616},
																				run: (*parser).callongoSubExpression229,
																				expr: &seqExpr{
																					pos: position{line: 2528, col: 24, offset: 87616},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2528, col: 24, offset: 87616},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2552, col: 5, offset: 88632},
																				run: (*parser).callongoSubExpression240,
																				expr: &seqExpr{
																					pos: position{line: 2552, col: 5, offset: 88632},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2552, col: 5, offset: 88632},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2573, col: 5, offset: 89473},
																				run: (*parser).callongoSubExpression247,
																				expr: &seqExpr{
																					pos: position{line: 2573, col: 5, offset: 89473},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2573, col: 5, offset: 89473},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2591, col: 5, offset: 90158},
																				run: (*parser).callongoSubExpression252,
																				expr: &seqExpr{
																					pos: position{line: 2591, col: 5, offset: 90158},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2591, col: 5, offset: 90158},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2591, col: 10, offset: 90163},
																							expr: &charClassMatcher{
																								pos:        position{line: 3735, col: 12, offset: 128270},
																								val:        "[^\\r\\n]",
																								chars:      []rune{'\r', '\n'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2415, col: 74, offset: 82703},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&labeledExpr{
																pos:   position{line: 2415, col: 79, offset: 82708},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callongoSubExpression259,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 1391, col: 27, offset: 45114},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1391, col: 46, offset: 45133},
									name: "TernaryExpression",
								},
								&seqExpr{
									pos: position{line: 1392, col: 6, offset: 45158},
									exprs: []interface{}{
										&actionExpr{
											pos: position{line: 3737, col: 8, offset: 128286},
											run: (*parser).callongoSubExpression268,
											expr: &choiceExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												alternatives: []interface{}{
													&andExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														expr: &anyMatcher{
															line: 3737, col: 10, offset: 128288,
														},
													},
													&notExpr{
														pos: position{line: 3737, col: 14, offset: 128292},
														expr: &anyMatcher{
															line: 3737, col: 15, offset: 128293,
														},
													},
												},
											},
										},
										&charClassMatcher{
											pos:        position{line: 1392, col: 11, offset: 45163},
											val:        "[^)}]]",
											chars:      []rune{')', '}', ']'},
											ignoreCase: false,
											inverted:   true,
										},
										&zeroOrMoreExpr{
											pos: position{line: 1392, col: 19, offset: 45171},
											expr: &charClassMatcher{
												pos:        position{line: 1392, col: 19, offset: 45171},
												val:        "[^\\\"`?([{}])]",
												chars:      []rune{'\'', '"', '`', '?', '(', '[', '{', '}', ']', ')'},
												ignoreCase: false,
												inverted:   true,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "multiLineGoExpression",
			pos:  position{line: 1397, col: 1, offset: 45235},
			expr: &actionExpr{
				pos: position{line: 1397, col: 26, offset: 45260},
				run: (*parser).callonmultiLineGoExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1397, col: 26, offset: 45260},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1397, col: 33, offset: 45267},
						expr: &choiceExpr{
							pos: position{line: 1398, col: 5, offset: 45273},
							alternatives: []interface{}{
								&actionExpr{
									pos: position{line: 1398, col: 5, offset: 45273},
									run: (*parser).callonmultiLineGoExpression5,
									expr: &labeledExpr{
										pos:   position{line: 1398, col: 5, offset: 45273},
										label: "exprI",
										expr: &choiceExpr{
											pos: position{line: 1398, col: 12, offset: 45280},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 1398, col: 12, offset: 45280},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1398, col: 12, offset: 45280},
															val:        "(",
															ignoreCase: false,
															want:       "\"(\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1398, col: 16, offset: 45284},
															name: "goSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonmultiLineGoExpression11,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1398, col: 36, offset: 45304},
															val:        ")",
															ignoreCase: false,
															want:       "\")\"",
														},
													},
												},
												&seqExpr{
													pos: position{line: 1398, col: 42, offset: 45310},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1398, col: 42, offset: 45310},
															val:        "[",
															ignoreCase: false,
															want:       "\"[\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1398, col: 46, offset: 45314},
															name: "goSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonmultiLineGoExpression21,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1398, col: 66, offset: 45334},
															val:        "]",
															ignoreCase: false,
															want:       "\"]\"",
														},
													},
												},
												&seqExpr{
													pos: position{line: 1398, col: 72, offset: 45340},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1398, col: 72, offset: 45340},
															val:        "{",
															ignoreCase: false,
															want:       "\"{\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1398, col: 76, offset: 45344},
															name: "goSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonmultiLineGoExpression31,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1398, col: 96, offset: 45364},
															val:        "}",
															ignoreCase: false,
															want:       "\"}\"",
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 1421, col: 9, offset: 46093},
									run: (*parser).callonmultiLineGoExpression38,
									expr: &seqExpr{
										pos: position{line: 1421, col: 9, offset: 46093},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 1421, col: 9, offset: 46093},
												label: "parenI",
												expr: &charClassMatcher{
													pos:        position{line: 1421, col: 16, offset: 46100},
													val:        "[([{]",
													chars:      []rune{'(', '[', '{'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&labeledExpr{
												pos:   position{line: 1421, col: 22, offset: 46106},
												label: "startPosI",
												expr: &actionExpr{
													pos: position{line: 3737, col: 8, offset: 128286},
													run: (*parser).callonmultiLineGoExpression43,
													expr: &choiceExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														alternatives: []interface{}{
															&andExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																expr: &anyMatcher{
																	line: 3737, col: 10, offset: 128288,
																},
															},
															&notExpr{
																pos: position{line: 3737, col: 14, offset: 128292},
																expr: &anyMatcher{
																	line: 3737, col: 15, offset: 128293,
																},
															},
														},
													},
												},
											},
											&labeledExpr{
												pos:   position{line: 1421, col: 36, offset: 46120},
												label: "exprI",
												expr: &ruleRefExpr{
													pos:  position{line: 1421, col: 42, offset: 46126},
													name: "goSubExpression",
												},
											},
										},
									},
								},
								&seqExpr{
									pos: position{line: 1451, col: 10, offset: 47167},
									exprs: []interface{}{
										&actionExpr{
											pos: position{line: 3737, col: 8, offset: 128286},
											run: (*parser).callonmultiLineGoExpression52,
											expr: &choiceExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												alternatives: []interface{}{
													&andExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														expr: &anyMatcher{
															line: 3737, col: 10, offset: 128288,
														},
													},
													&notExpr{
														pos: position{line: 3737, col: 14, offset: 128292},
														expr: &anyMatcher{
															line: 3737, col: 15, offset: 128293,
														},
													},
												},
											},
										},
										&choiceExpr{
											pos: position{line: 2414, col: 14, offset: 82561},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 2414, col: 14, offset: 82561},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 2414, col: 14, offset: 82561},
															val:        "'",
															ignoreCase: false,
															want:       "\"'\"",
														},
														&choiceExpr{
															pos: position{line: 2414, col: 20, offset: 82567},
															alternatives: []interface{}{
																&seqExpr{
																	pos: position{line: 2462, col: 19, offset: 84712},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2462, col: 19, offset: 84712},
																			val:        "\\u",
																			ignoreCase: false,
																			want:       "\"\\\\u\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2463, col: 5, offset: 84771},
																	run: (*parser).callonmultiLineGoExpression68,
																	expr: &seqExpr{
																		pos: position{line: 2463, col: 5, offset: 84771},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2463, col: 5, offset: 84771},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 14, offset: 84780},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 26, offset: 84792},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 38, offset: 84804},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 50, offset: 84816},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2492, col: 16, offset: 85952},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2492, col: 16, offset: 85952},
																			val:        "\\U",
																			ignoreCase: false,
																			want:       "\"\\\\U\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2493, col: 5, offset: 86055},
																	run: (*parser).callonmultiLineGoExpression89,
																	expr: &seqExpr{
																		pos: position{line: 2493, col: 5, offset: 86055},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2493, col: 5, offset: 86055},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 14, offset: 86064},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 26, offset: 86076},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 38, offset: 86088},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 50, offset: 86100},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 62, offset: 86112},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 74, offset: 86124},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 86, offset: 86136},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 98, offset: 86148},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2527, col: 24, offset: 87533},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2527, col: 24, offset: 87533},
																			val:        "\\",
																			ignoreCase: false,
																			want:       "\"\\\\\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2527, col: 29, offset: 87538},
																			val:        "[abfnrtv\\\\\\]",
																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&charClassMatcher{
																	pos:        position{line: 2441, col: 75, offset: 83824},
																	val:        "[^\\\\\\\\n]",
																	chars:      []rune{'\'', '\\', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
																&seqExpr{
																	pos: position{line: 2443, col: 24, offset: 83970},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2443, col: 24, offset: 83970},
																			val:        "\\",
																			ignoreCase: false,
																			want:       "\"\\\\\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2444, col: 24, offset: 84037},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2444, col: 24, offset: 84037},
																			val:        "\\x",
																			ignoreCase: false,
																			want:       "\"\\\\x\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2445, col: 5, offset: 84074},
																	run: (*parser).callonmultiLineGoExpression121,
																	expr: &seqExpr{
																		pos: position{line: 2445, col: 5, offset: 84074},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2445, col: 5, offset: 84074},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2445, col: 14, offset: 84083},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2445, col: 26, offset: 84095},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2528, col: 24, offset: 87616},
																	run: (*parser).callonmultiLineGoExpression128,
																	expr: &seqExpr{
																		pos: position{line: 2528, col: 24, offset: 87616},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2528, col: 24, offset: 87616},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2552, col: 5, offset: 88632},
																	run: (*parser).callonmultiLineGoExpression139,
																	expr: &seqExpr{
																		pos: position{line: 2552, col: 5, offset: 88632},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2552, col: 5, offset: 88632},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2573, col: 5, offset: 89473},
																	run: (*parser).callonmultiLineGoExpression146,
																	expr: &seqExpr{
																		pos: position{line: 2573, col: 5, offset: 89473},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2573, col: 5, offset: 89473},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2591, col: 5, offset: 90158},
																	run: (*parser).callonmultiLineGoExpression151,
																	expr: &seqExpr{
																		pos: position{line: 2591, col: 5, offset: 90158},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2591, col: 5, offset: 90158},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2591, col: 10, offset: 90163},
																				expr: &charClassMatcher{
																					pos:        position{line: 3735, col: 12, offset: 128270},
																					val:        "[^\\r\\n]",
																					chars:      []rune{'\r', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 2414, col: 76, offset: 82623},
															val:        "'",
															ignoreCase: false,
															want:       "\"'\"",
														},
													},
												},
												&actionExpr{
													pos: position{line: 2415, col: 5, offset: 82634},
													run: (*parser).callonmultiLineGoExpression157,
													expr: &seqExpr{
														pos: position{line: 2415, col: 5, offset: 82634},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2415, col: 5, offset: 82634},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&labeledExpr{
																pos:   position{line: 2415, col: 10, offset: 82639},
																label: "valsI",
																expr: &zeroOrMoreExpr{
																	pos: position{line: 2415, col: 16, offset: 82645},
																	expr: &choiceExpr{
																		pos: position{line: 2415, col: 17, offset: 82646},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 2462, col: 19, offset: 84712},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2462, col: 19, offset: 84712},
																						val:        "\\u",
																						ignoreCase: false,
																						want:       "\"\\\\u\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2463, col: 5, offset: 84771},
																				run: (*parser).callonmultiLineGoExpression169,
																				expr: &seqExpr{
																					pos: position{line: 2463, col: 5, offset: 84771},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2463, col: 5, offset: 84771},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 14, offset: 84780},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 26, offset: 84792},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 38, offset: 84804},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 50, offset: 84816},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2492, col: 16, offset: 85952},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2492, col: 16, offset: 85952},
																						val:        "\\U",
																						ignoreCase: false,
																						want:       "\"\\\\U\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2493, col: 5, offset: 86055},
																				run: (*parser).callonmultiLineGoExpression190,
																				expr: &seqExpr{
																					pos: position{line: 2493, col: 5, offset: 86055},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2493, col: 5, offset: 86055},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 14, offset: 86064},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 26, offset: 86076},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 38, offset: 86088},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 50, offset: 86100},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 62, offset: 86112},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 74, offset: 86124},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 86, offset: 86136},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 98, offset: 86148},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2527, col: 24, offset: 87533},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2527, col: 24, offset: 87533},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2527, col: 29, offset: 87538},
																						val:        "[abfnrtv\\\\\\]",
																						chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&charClassMatcher{
																				pos:        position{line: 2441, col: 75, offset: 83824},
																				val:        "[^\\\\\\\\n]",
																				chars:      []rune{'\'', '\\', '\n'},
																				ignoreCase: false,
																				inverted:   true,
																			},
																			&seqExpr{
																				pos: position{line: 2443, col: 24, offset: 83970},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2443, col: 24, offset: 83970},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2444, col: 24, offset: 84037},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2444, col: 24, offset: 84037},
																						val:        "\\x",
																						ignoreCase: false,
																						want:       "\"\\\\x\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2445, col: 5, offset: 84074},
																				run: (*parser).callonmultiLineGoExpression222,
																				expr: &seqExpr{
																					pos: position{line: 2445, col: 5, offset: 84074},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2445, col: 5, offset: 84074},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2445, col: 14, offset: 84083},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2445, col: 26, offset: 84095},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2528, col: 24, offset: 87616},
																				run: (*parser).callonmultiLineGoExpression229,
																				expr: &seqExpr{
																					pos: position{line: 2528, col: 24, offset: 87616},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2528, col: 24, offset: 87616},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2552, col: 5, offset: 88632},
																				run: (*parser).callonmultiLineGoExpression240,
																				expr: &seqExpr{
																					pos: position{line: 2552, col: 5, offset: 88632},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2552, col: 5, offset: 88632},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2573, col: 5, offset: 89473},
																				run: (*parser).callonmultiLineGoExpression247,
																				expr: &seqExpr{
																					pos: position{line: 2573, col: 5, offset: 89473},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2573, col: 5, offset: 89473},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2591, col: 5, offset: 90158},
																				run: (*parser).callonmultiLineGoExpression252,
																				expr: &seqExpr{
																					pos: position{line: 2591, col: 5, offset: 90158},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2591, col: 5, offset: 90158},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2591, col: 10, offset: 90163},
																							expr: &charClassMatcher{
																								pos:        position{line: 3735, col: 12, offset: 128270},
																								val:        "[^\\r\\n]",
																								chars:      []rune{'\r', '\n'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2415, col: 74, offset: 82703},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&labeledExpr{
																pos:   position{line: 2415, col: 79, offset: 82708},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonmultiLineGoExpression259,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 1451, col: 27, offset: 47184},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1451, col: 46, offset: 47203},
									name: "TernaryExpression",
								},
								&seqExpr{
									pos: position{line: 1452, col: 6, offset: 47228},
									exprs: []interface{}{
										&actionExpr{
											pos: position{line: 3737, col: 8, offset: 128286},
											run: (*parser).callonmultiLineGoExpression268,
											expr: &choiceExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												alternatives: []interface{}{
													&andExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														expr: &anyMatcher{
															line: 3737, col: 10, offset: 128288,
														},
													},
													&notExpr{
														pos: position{line: 3737, col: 14, offset: 128292},
														expr: &anyMatcher{
															line: 3737, col: 15, offset: 128293,
														},
													},
												},
											},
										},
										&notExpr{
											pos: position{line: 1452, col: 11, offset: 47233},
											expr: &choiceExpr{
												pos: position{line: 1269, col: 25, offset: 40699},
												alternatives: []interface{}{
													&charClassMatcher{
														pos:        position{line: 1269, col: 25, offset: 40699},
														val:        "[)}],]",
														chars:      []rune{')', '}', ']', ','},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 1269, col: 40, offset: 40714},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 1269, col: 40, offset: 40714},
																val:        ":",
																ignoreCase: false,
																want:       "\":\"",
															},
															&notExpr{
																pos: position{line: 1269, col: 44, offset: 40718},
																expr: &litMatcher{
																	pos:        position{line: 1269, col: 45, offset: 40719},
																	val:        "=",
																	ignoreCase: false,
																	want:       "\"=\"",
																},
															},
														},
													},
												},
											},
										},
										&anyMatcher{
											line: 1452, col: 33, offset: 47255,
										},
										&zeroOrMoreExpr{
											pos: position{line: 1452, col: 35, offset: 47257},
											expr: &seqExpr{
												pos: position{line: 1452, col: 36, offset: 47258},
												exprs: []interface{}{
													&notExpr{
														pos: position{line: 1452, col: 36, offset: 47258},
														expr: &choiceExpr{
															pos: position{line: 1269, col: 25, offset: 40699},
															alternatives: []interface{}{
																&charClassMatcher{
																	pos:        position{line: 1269, col: 25, offset: 40699},
																	val:        "[)}],]",
																	chars:      []rune{')', '}', ']', ','},
																	ignoreCase: false,
																	inverted:   false,
																},
																&seqExpr{
																	pos: position{line: 1269, col: 40, offset: 40714},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 1269, col: 40, offset: 40714},
																			val:        ":",
																			ignoreCase: false,
																			want:       "\":\"",
																		},
																		&notExpr{
																			pos: position{line: 1269, col: 44, offset: 40718},
																			expr: &litMatcher{
																				pos:        position{line: 1269, col: 45, offset: 40719},
																				val:        "=",
																				ignoreCase: false,
																				want:       "\"=\"",
																			},
																		},
																	},
																},
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 1452, col: 58, offset: 47280},
														val:        "[^\\\"`?([{]",
														chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineGoExpression",
			pos:  position{line: 1457, col: 1, offset: 47341},
			expr: &actionExpr{
				pos: position{line: 1457, col: 27, offset: 47367},
				run: (*parser).callonSingleLineGoExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1457, col: 27, offset: 47367},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1457, col: 34, offset: 47374},
						expr: &choiceExpr{
							pos: position{line: 1458, col: 5, offset: 47380},
							alternatives: []interface{}{
								&actionExpr{
									pos: position{line: 1458, col: 5, offset: 47380},
									run: (*parser).callonSingleLineGoExpression5,
									expr: &labeledExpr{
										pos:   position{line: 1458, col: 5, offset: 47380},
										label: "exprI",
										expr: &choiceExpr{
											pos: position{line: 1458, col: 12, offset: 47387},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 1458, col: 12, offset: 47387},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1458, col: 12, offset: 47387},
															val:        "(",
															ignoreCase: false,
															want:       "\"(\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1458, col: 16, offset: 47391},
															name: "singleLineGoSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonSingleLineGoExpression11,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1458, col: 46, offset: 47421},
															val:        ")",
															ignoreCase: false,
															want:       "\")\"",
														},
													},
												},
												&seqExpr{
													pos: position{line: 1458, col: 52, offset: 47427},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1458, col: 52, offset: 47427},
															val:        "[",
															ignoreCase: false,
															want:       "\"[\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1458, col: 56, offset: 47431},
															name: "singleLineGoSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonSingleLineGoExpression21,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1458, col: 86, offset: 47461},
															val:        "]",
															ignoreCase: false,
															want:       "\"]\"",
														},
													},
												},
												&seqExpr{
													pos: position{line: 1458, col: 92, offset: 47467},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1458, col: 92, offset: 47467},
															val:        "{",
															ignoreCase: false,
															want:       "\"{\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1458, col: 96, offset: 47471},
															name: "singleLineGoSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonSingleLineGoExpression31,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1458, col: 126, offset: 47501},
															val:        "}",
															ignoreCase: false,
															want:       "\"}\"",
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 1481, col: 9, offset: 48230},
									run: (*parser).callonSingleLineGoExpression38,
									expr: &seqExpr{
										pos: position{line: 1481, col: 9, offset: 48230},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 1481, col: 9, offset: 48230},
												label: "parenI",
												expr: &charClassMatcher{
													pos:        position{line: 1481, col: 16, offset: 48237},
													val:        "[([{]",
													chars:      []rune{'(', '[', '{'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&labeledExpr{
												pos:   position{line: 1481, col: 22, offset: 48243},
												label: "startPosI",
												expr: &actionExpr{
													pos: position{line: 3737, col: 8, offset: 128286},
													run: (*parser).callonSingleLineGoExpression43,
													expr: &choiceExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														alternatives: []interface{}{
															&andExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																expr: &anyMatcher{
																	line: 3737, col: 10, offset: 128288,
																},
															},
															&notExpr{
																pos: position{line: 3737, col: 14, offset: 128292},
																expr: &anyMatcher{
																	line: 3737, col: 15, offset: 128293,
																},
															},
														},
													},
												},
											},
											&labeledExpr{
												pos:   position{line: 1481, col: 36, offset: 48257},
												label: "exprI",
												expr: &ruleRefExpr{
													pos:  position{line: 1481, col: 42, offset: 48263},
													name: "singleLineGoSubExpression",
												},
											},
										},
									},
								},
								&seqExpr{
									pos: position{line: 1510, col: 10, offset: 49264},
									exprs: []interface{}{
										&actionExpr{
											pos: position{line: 3737, col: 8, offset: 128286},
											run: (*parser).callonSingleLineGoExpression52,
											expr: &choiceExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												alternatives: []interface{}{
													&andExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														expr: &anyMatcher{
															line: 3737, col: 10, offset: 128288,
														},
													},
													&notExpr{
														pos: position{line: 3737, col: 14, offset: 128292},
														expr: &anyMatcher{
															line: 3737, col: 15, offset: 128293,
														},
													},
												},
											},
										},
										&choiceExpr{
											pos: position{line: 2414, col: 14, offset: 82561},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 2414, col: 14, offset: 82561},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 2414, col: 14, offset: 82561},
															val:        "'",
															ignoreCase: false,
															want:       "\"'\"",
														},
														&choiceExpr{
															pos: position{line: 2414, col: 20, offset: 82567},
															alternatives: []interface{}{
																&seqExpr{
																	pos: position{line: 2462, col: 19, offset: 84712},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2462, col: 19, offset: 84712},
																			val:        "\\u",
																			ignoreCase: false,
																			want:       "\"\\\\u\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2463, col: 5, offset: 84771},
																	run: (*parser).callonSingleLineGoExpression68,
																	expr: &seqExpr{
																		pos: position{line: 2463, col: 5, offset: 84771},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2463, col: 5, offset: 84771},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 14, offset: 84780},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 26, offset: 84792},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 38, offset: 84804},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 50, offset: 84816},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2492, col: 16, offset: 85952},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2492, col: 16, offset: 85952},
																			val:        "\\U",
																			ignoreCase: false,
																			want:       "\"\\\\U\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2493, col: 5, offset: 86055},
																	run: (*parser).callonSingleLineGoExpression89,
																	expr: &seqExpr{
																		pos: position{line: 2493, col: 5, offset: 86055},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2493, col: 5, offset: 86055},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 14, offset: 86064},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 26, offset: 86076},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 38, offset: 86088},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 50, offset: 86100},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 62, offset: 86112},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 74, offset: 86124},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 86, offset: 86136},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 98, offset: 86148},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2527, col: 24, offset: 87533},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2527, col: 24, offset: 87533},
																			val:        "\\",
																			ignoreCase: false,
																			want:       "\"\\\\\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2527, col: 29, offset: 87538},
																			val:        "[abfnrtv\\\\\\]",
																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&charClassMatcher{
																	pos:        position{line: 2441, col: 75, offset: 83824},
																	val:        "[^\\\\\\\\n]",
																	chars:      []rune{'\'', '\\', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
																&seqExpr{
																	pos: position{line: 2443, col: 24, offset: 83970},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2443, col: 24, offset: 83970},
																			val:        "\\",
																			ignoreCase: false,
																			want:       "\"\\\\\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2444, col: 24, offset: 84037},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2444, col: 24, offset: 84037},
																			val:        "\\x",
																			ignoreCase: false,
																			want:       "\"\\\\x\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2445, col: 5, offset: 84074},
																	run: (*parser).callonSingleLineGoExpression121,
																	expr: &seqExpr{
																		pos: position{line: 2445, col: 5, offset: 84074},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2445, col: 5, offset: 84074},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2445, col: 14, offset: 84083},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2445, col: 26, offset: 84095},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2528, col: 24, offset: 87616},
																	run: (*parser).callonSingleLineGoExpression128,
																	expr: &seqExpr{
																		pos: position{line: 2528, col: 24, offset: 87616},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2528, col: 24, offset: 87616},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2552, col: 5, offset: 88632},
																	run: (*parser).callonSingleLineGoExpression139,
																	expr: &seqExpr{
																		pos: position{line: 2552, col: 5, offset: 88632},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2552, col: 5, offset: 88632},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2573, col: 5, offset: 89473},
																	run: (*parser).callonSingleLineGoExpression146,
																	expr: &seqExpr{
																		pos: position{line: 2573, col: 5, offset: 89473},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2573, col: 5, offset: 89473},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2591, col: 5, offset: 90158},
																	run: (*parser).callonSingleLineGoExpression151,
																	expr: &seqExpr{
																		pos: position{line: 2591, col: 5, offset: 90158},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2591, col: 5, offset: 90158},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2591, col: 10, offset: 90163},
																				expr: &charClassMatcher{
																					pos:        position{line: 3735, col: 12, offset: 128270},
																					val:        "[^\\r\\n]",
																					chars:      []rune{'\r', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 2414, col: 76, offset: 82623},
															val:        "'",
															ignoreCase: false,
															want:       "\"'\"",
														},
													},
												},
												&actionExpr{
													pos: position{line: 2415, col: 5, offset: 82634},
													run: (*parser).callonSingleLineGoExpression157,
													expr: &seqExpr{
														pos: position{line: 2415, col: 5, offset: 82634},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2415, col: 5, offset: 82634},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&labeledExpr{
																pos:   position{line: 2415, col: 10, offset: 82639},
																label: "valsI",
																expr: &zeroOrMoreExpr{
																	pos: position{line: 2415, col: 16, offset: 82645},
																	expr: &choiceExpr{
																		pos: position{line: 2415, col: 17, offset: 82646},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 2462, col: 19, offset: 84712},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2462, col: 19, offset: 84712},
																						val:        "\\u",
																						ignoreCase: false,
																						want:       "\"\\\\u\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2463, col: 5, offset: 84771},
																				run: (*parser).callonSingleLineGoExpression169,
																				expr: &seqExpr{
																					pos: position{line: 2463, col: 5, offset: 84771},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2463, col: 5, offset: 84771},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 14, offset: 84780},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 26, offset: 84792},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 38, offset: 84804},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 50, offset: 84816},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2492, col: 16, offset: 85952},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2492, col: 16, offset: 85952},
																						val:        "\\U",
																						ignoreCase: false,
																						want:       "\"\\\\U\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2493, col: 5, offset: 86055},
																				run: (*parser).callonSingleLineGoExpression190,
																				expr: &seqExpr{
																					pos: position{line: 2493, col: 5, offset: 86055},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2493, col: 5, offset: 86055},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 14, offset: 86064},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 26, offset: 86076},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 38, offset: 86088},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 50, offset: 86100},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 62, offset: 86112},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 74, offset: 86124},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 86, offset: 86136},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 98, offset: 86148},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2527, col: 24, offset: 87533},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2527, col: 24, offset: 87533},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2527, col: 29, offset: 87538},
																						val:        "[abfnrtv\\\\\\]",
																						chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&charClassMatcher{
																				pos:        position{line: 2441, col: 75, offset: 83824},
																				val:        "[^\\\\\\\\n]",
																				chars:      []rune{'\'', '\\', '\n'},
																				ignoreCase: false,
																				inverted:   true,
																			},
																			&seqExpr{
																				pos: position{line: 2443, col: 24, offset: 83970},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2443, col: 24, offset: 83970},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2444, col: 24, offset: 84037},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2444, col: 24, offset: 84037},
																						val:        "\\x",
																						ignoreCase: false,
																						want:       "\"\\\\x\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2445, col: 5, offset: 84074},
																				run: (*parser).callonSingleLineGoExpression222,
																				expr: &seqExpr{
																					pos: position{line: 2445, col: 5, offset: 84074},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2445, col: 5, offset: 84074},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2445, col: 14, offset: 84083},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2445, col: 26, offset: 84095},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2528, col: 24, offset: 87616},
																				run: (*parser).callonSingleLineGoExpression229,
																				expr: &seqExpr{
																					pos: position{line: 2528, col: 24, offset: 87616},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2528, col: 24, offset: 87616},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2552, col: 5, offset: 88632},
																				run: (*parser).callonSingleLineGoExpression240,
																				expr: &seqExpr{
																					pos: position{line: 2552, col: 5, offset: 88632},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2552, col: 5, offset: 88632},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2573, col: 5, offset: 89473},
																				run: (*parser).callonSingleLineGoExpression247,
																				expr: &seqExpr{
																					pos: position{line: 2573, col: 5, offset: 89473},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2573, col: 5, offset: 89473},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2591, col: 5, offset: 90158},
																				run: (*parser).callonSingleLineGoExpression252,
																				expr: &seqExpr{
																					pos: position{line: 2591, col: 5, offset: 90158},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2591, col: 5, offset: 90158},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2591, col: 10, offset: 90163},
																							expr: &charClassMatcher{
																								pos:        position{line: 3735, col: 12, offset: 128270},
																								val:        "[^\\r\\n]",
																								chars:      []rune{'\r', '\n'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2415, col: 74, offset: 82703},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&labeledExpr{
																pos:   position{line: 2415, col: 79, offset: 82708},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonSingleLineGoExpression259,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 1510, col: 27, offset: 49281},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1510, col: 46, offset: 49300},
									name: "SingleLineTernaryExpression",
								},
								&seqExpr{
									pos: position{line: 1511, col: 6, offset: 49335},
									exprs: []interface{}{
										&actionExpr{
											pos: position{line: 3737, col: 8, offset: 128286},
											run: (*parser).callonSingleLineGoExpression268,
											expr: &choiceExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												alternatives: []interface{}{
													&andExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														expr: &anyMatcher{
															line: 3737, col: 10, offset: 128288,
														},
													},
													&notExpr{
														pos: position{line: 3737, col: 14, offset: 128292},
														expr: &anyMatcher{
															line: 3737, col: 15, offset: 128293,
														},
													},
												},
											},
										},
										&notExpr{
											pos: position{line: 1511, col: 11, offset: 49340},
											expr: &choiceExpr{
												pos: position{line: 1269, col: 25, offset: 40699},
												alternatives: []interface{}{
													&charClassMatcher{
														pos:        position{line: 1269, col: 25, offset: 40699},
														val:        "[)}],]",
														chars:      []rune{')', '}', ']', ','},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 1269, col: 40, offset: 40714},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 1269, col: 40, offset: 40714},
																val:        ":",
																ignoreCase: false,
																want:       "\":\"",
															},
															&notExpr{
																pos: position{line: 1269, col: 44, offset: 40718},
																expr: &litMatcher{
																	pos:        position{line: 1269, col: 45, offset: 40719},
																	val:        "=",
																	ignoreCase: false,
																	want:       "\"=\"",
																},
															},
														},
													},
												},
											},
										},
										&charClassMatcher{
											pos:        position{line: 3735, col: 12, offset: 128270},
											val:        "[^\\r\\n]",
											chars:      []rune{'\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
										&zeroOrMoreExpr{
											pos: position{line: 1511, col: 41, offset: 49370},
											expr: &seqExpr{
												pos: position{line: 1511, col: 42, offset: 49371},
												exprs: []interface{}{
													&notExpr{
														pos: position{line: 1511, col: 42, offset: 49371},
														expr: &choiceExpr{
															pos: position{line: 1269, col: 25, offset: 40699},
															alternatives: []interface{}{
																&charClassMatcher{
																	pos:        position{line: 1269, col: 25, offset: 40699},
																	val:        "[)}],]",
																	chars:      []rune{')', '}', ']', ','},
																	ignoreCase: false,
																	inverted:   false,
																},
																&seqExpr{
																	pos: position{line: 1269, col: 40, offset: 40714},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 1269, col: 40, offset: 40714},
																			val:        ":",
																			ignoreCase: false,
																			want:       "\":\"",
																		},
																		&notExpr{
																			pos: position{line: 1269, col: 44, offset: 40718},
																			expr: &litMatcher{
																				pos:        position{line: 1269, col: 45, offset: 40719},
																				val:        "=",
																				ignoreCase: false,
																				want:       "\"=\"",
																			},
																		},
																	},
																},
															},
														},
													},
													&notExpr{
														pos: position{line: 1511, col: 64, offset: 49393},
														expr: &seqExpr{
															pos: position{line: 3734, col: 12, offset: 128237},
															exprs: []interface{}{
																&zeroOrMoreExpr{
																	pos: position{line: 3734, col: 12, offset: 128237},
																	expr: &charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&choiceExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	alternatives: []interface{}{
																		&seqExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			exprs: []interface{}{
																				&zeroOrOneExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					expr: &litMatcher{
																						pos:        position{line: 3734, col: 16, offset: 128241},
																						val:        "\r",
																						ignoreCase: false,
																						want:       "\"\\r\"",
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 3734, col: 22, offset: 128247},
																					val:        "\n",
																					ignoreCase: false,
																					want:       "\"\\n\"",
																				},
																			},
																		},
																		&notExpr{
																			pos: position{line: 3733, col: 12, offset: 128223},
																			expr: &anyMatcher{
																				line: 3733, col: 13, offset: 128224,
																			},
																		},
																	},
																},
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 1511, col: 69, offset: 49398},
														val:        "[^\\\"`?([{]",
														chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineGoSubExpression",
			pos:  position{line: 1516, col: 1, offset: 49459},
			expr: &actionExpr{
				pos: position{line: 1516, col: 30, offset: 49488},
				run: (*parser).callonsingleLineGoSubExpression1,
				expr: &labeledExpr{
					pos:   position{line: 1516, col: 30, offset: 49488},
					label: "exprsI",
					expr: &oneOrMoreExpr{
						pos: position{line: 1516, col: 37, offset: 49495},
						expr: &choiceExpr{
							pos: position{line: 1517, col: 5, offset: 49501},
							alternatives: []interface{}{
								&actionExpr{
									pos: position{line: 1517, col: 5, offset: 49501},
									run: (*parser).callonsingleLineGoSubExpression5,
									expr: &labeledExpr{
										pos:   position{line: 1517, col: 5, offset: 49501},
										label: "exprI",
										expr: &choiceExpr{
											pos: position{line: 1517, col: 12, offset: 49508},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 1517, col: 12, offset: 49508},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1517, col: 12, offset: 49508},
															val:        "(",
															ignoreCase: false,
															want:       "\"(\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1517, col: 16, offset: 49512},
															name: "singleLineGoSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonsingleLineGoSubExpression11,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1517, col: 46, offset: 49542},
															val:        ")",
															ignoreCase: false,
															want:       "\")\"",
														},
													},
												},
												&seqExpr{
													pos: position{line: 1517, col: 52, offset: 49548},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1517, col: 52, offset: 49548},
															val:        "[",
															ignoreCase: false,
															want:       "\"[\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1517, col: 56, offset: 49552},
															name: "singleLineGoSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonsingleLineGoSubExpression21,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1517, col: 86, offset: 49582},
															val:        "]",
															ignoreCase: false,
															want:       "\"]\"",
														},
													},
												},
												&seqExpr{
													pos: position{line: 1517, col: 92, offset: 49588},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 1517, col: 92, offset: 49588},
															val:        "{",
															ignoreCase: false,
															want:       "\"{\"",
														},
														&ruleRefExpr{
															pos:  position{line: 1517, col: 96, offset: 49592},
															name: "singleLineGoSubExpression",
														},
														&actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonsingleLineGoSubExpression31,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 1517, col: 126, offset: 49622},
															val:        "}",
															ignoreCase: false,
															want:       "\"}\"",
														},
													},
												},
											},
										},
									},
								},
								&actionExpr{
									pos: position{line: 1540, col: 9, offset: 50351},
									run: (*parser).callonsingleLineGoSubExpression38,
									expr: &seqExpr{
										pos: position{line: 1540, col: 9, offset: 50351},
										exprs: []interface{}{
											&labeledExpr{
												pos:   position{line: 1540, col: 9, offset: 50351},
												label: "parenI",
												expr: &charClassMatcher{
													pos:        position{line: 1540, col: 16, offset: 50358},
													val:        "[([{]",
													chars:      []rune{'(', '[', '{'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&labeledExpr{
												pos:   position{line: 1540, col: 22, offset: 50364},
												label: "startPosI",
												expr: &actionExpr{
													pos: position{line: 3737, col: 8, offset: 128286},
													run: (*parser).callonsingleLineGoSubExpression43,
													expr: &choiceExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														alternatives: []interface{}{
															&andExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																expr: &anyMatcher{
																	line: 3737, col: 10, offset: 128288,
																},
															},
															&notExpr{
																pos: position{line: 3737, col: 14, offset: 128292},
																expr: &anyMatcher{
																	line: 3737, col: 15, offset: 128293,
																},
															},
														},
													},
												},
											},
											&labeledExpr{
												pos:   position{line: 1540, col: 36, offset: 50378},
												label: "exprI",
												expr: &ruleRefExpr{
													pos:  position{line: 1540, col: 42, offset: 50384},
													name: "singleLineGoSubExpression",
												},
											},
										},
									},
								},
								&seqExpr{
									pos: position{line: 1569, col: 10, offset: 51385},
									exprs: []interface{}{
										&actionExpr{
											pos: position{line: 3737, col: 8, offset: 128286},
											run: (*parser).callonsingleLineGoSubExpression52,
											expr: &choiceExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												alternatives: []interface{}{
													&andExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														expr: &anyMatcher{
															line: 3737, col: 10, offset: 128288,
														},
													},
													&notExpr{
														pos: position{line: 3737, col: 14, offset: 128292},
														expr: &anyMatcher{
															line: 3737, col: 15, offset: 128293,
														},
													},
												},
											},
										},
										&choiceExpr{
											pos: position{line: 2414, col: 14, offset: 82561},
											alternatives: []interface{}{
												&seqExpr{
													pos: position{line: 2414, col: 14, offset: 82561},
													exprs: []interface{}{
														&litMatcher{
															pos:        position{line: 2414, col: 14, offset: 82561},
															val:        "'",
															ignoreCase: false,
															want:       "\"'\"",
														},
														&choiceExpr{
															pos: position{line: 2414, col: 20, offset: 82567},
															alternatives: []interface{}{
																&seqExpr{
																	pos: position{line: 2462, col: 19, offset: 84712},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2462, col: 19, offset: 84712},
																			val:        "\\u",
																			ignoreCase: false,
																			want:       "\"\\\\u\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2463, col: 5, offset: 84771},
																	run: (*parser).callonsingleLineGoSubExpression68,
																	expr: &seqExpr{
																		pos: position{line: 2463, col: 5, offset: 84771},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2463, col: 5, offset: 84771},
																				val:        "\\u",
																				ignoreCase: false,
																				want:       "\"\\\\u\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 14, offset: 84780},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 26, offset: 84792},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 38, offset: 84804},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2463, col: 50, offset: 84816},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2492, col: 16, offset: 85952},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2492, col: 16, offset: 85952},
																			val:        "\\U",
																			ignoreCase: false,
																			want:       "\"\\\\U\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2493, col: 5, offset: 86055},
																	run: (*parser).callonsingleLineGoSubExpression89,
																	expr: &seqExpr{
																		pos: position{line: 2493, col: 5, offset: 86055},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2493, col: 5, offset: 86055},
																				val:        "\\U",
																				ignoreCase: false,
																				want:       "\"\\\\U\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 14, offset: 86064},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 26, offset: 86076},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 38, offset: 86088},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 50, offset: 86100},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 62, offset: 86112},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 74, offset: 86124},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 86, offset: 86136},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2493, col: 98, offset: 86148},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2527, col: 24, offset: 87533},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2527, col: 24, offset: 87533},
																			val:        "\\",
																			ignoreCase: false,
																			want:       "\"\\\\\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2527, col: 29, offset: 87538},
																			val:        "[abfnrtv\\\\\\]",
																			chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&charClassMatcher{
																	pos:        position{line: 2441, col: 75, offset: 83824},
																	val:        "[^\\\\\\\\n]",
																	chars:      []rune{'\'', '\\', '\n'},
																	ignoreCase: false,
																	inverted:   true,
																},
																&seqExpr{
																	pos: position{line: 2443, col: 24, offset: 83970},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2443, col: 24, offset: 83970},
																			val:        "\\",
																			ignoreCase: false,
																			want:       "\"\\\\\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2360, col: 19, offset: 81158},
																			val:        "[0-7]",
																			ranges:     []rune{'0', '7'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&seqExpr{
																	pos: position{line: 2444, col: 24, offset: 84037},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 2444, col: 24, offset: 84037},
																			val:        "\\x",
																			ignoreCase: false,
																			want:       "\"\\\\x\"",
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2445, col: 5, offset: 84074},
																	run: (*parser).callonsingleLineGoSubExpression121,
																	expr: &seqExpr{
																		pos: position{line: 2445, col: 5, offset: 84074},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2445, col: 5, offset: 84074},
																				val:        "\\x",
																				ignoreCase: false,
																				want:       "\"\\\\x\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2445, col: 14, offset: 84083},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2445, col: 26, offset: 84095},
																				expr: &charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2528, col: 24, offset: 87616},
																	run: (*parser).callonsingleLineGoSubExpression128,
																	expr: &seqExpr{
																		pos: position{line: 2528, col: 24, offset: 87616},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2528, col: 24, offset: 87616},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2552, col: 5, offset: 88632},
																	run: (*parser).callonsingleLineGoSubExpression139,
																	expr: &seqExpr{
																		pos: position{line: 2552, col: 5, offset: 88632},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2552, col: 5, offset: 88632},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2573, col: 5, offset: 89473},
																	run: (*parser).callonsingleLineGoSubExpression146,
																	expr: &seqExpr{
																		pos: position{line: 2573, col: 5, offset: 89473},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2573, col: 5, offset: 89473},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&charClassMatcher{
																				pos:        position{line: 2361, col: 19, offset: 81182},
																				val:        "[0-9A-Fa-f]",
																				ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
																&actionExpr{
																	pos: position{line: 2591, col: 5, offset: 90158},
																	run: (*parser).callonsingleLineGoSubExpression151,
																	expr: &seqExpr{
																		pos: position{line: 2591, col: 5, offset: 90158},
																		exprs: []interface{}{
																			&litMatcher{
																				pos:        position{line: 2591, col: 5, offset: 90158},
																				val:        "\\",
																				ignoreCase: false,
																				want:       "\"\\\\\"",
																			},
																			&zeroOrOneExpr{
																				pos: position{line: 2591, col: 10, offset: 90163},
																				expr: &charClassMatcher{
																					pos:        position{line: 3735, col: 12, offset: 128270},
																					val:        "[^\\r\\n]",
																					chars:      []rune{'\r', '\n'},
																					ignoreCase: false,
																					inverted:   true,
																				},
																			},
																		},
																	},
																},
															},
														},
														&litMatcher{
															pos:        position{line: 2414, col: 76, offset: 82623},
															val:        "'",
															ignoreCase: false,
															want:       "\"'\"",
														},
													},
												},
												&actionExpr{
													pos: position{line: 2415, col: 5, offset: 82634},
													run: (*parser).callonsingleLineGoSubExpression157,
													expr: &seqExpr{
														pos: position{line: 2415, col: 5, offset: 82634},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2415, col: 5, offset: 82634},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&labeledExpr{
																pos:   position{line: 2415, col: 10, offset: 82639},
																label: "valsI",
																expr: &zeroOrMoreExpr{
																	pos: position{line: 2415, col: 16, offset: 82645},
																	expr: &choiceExpr{
																		pos: position{line: 2415, col: 17, offset: 82646},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 2462, col: 19, offset: 84712},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2462, col: 19, offset: 84712},
																						val:        "\\u",
																						ignoreCase: false,
																						want:       "\"\\\\u\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2463, col: 5, offset: 84771},
																				run: (*parser).callonsingleLineGoSubExpression169,
																				expr: &seqExpr{
																					pos: position{line: 2463, col: 5, offset: 84771},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2463, col: 5, offset: 84771},
																							val:        "\\u",
																							ignoreCase: false,
																							want:       "\"\\\\u\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 14, offset: 84780},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 26, offset: 84792},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 38, offset: 84804},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2463, col: 50, offset: 84816},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2492, col: 16, offset: 85952},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2492, col: 16, offset: 85952},
																						val:        "\\U",
																						ignoreCase: false,
																						want:       "\"\\\\U\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2493, col: 5, offset: 86055},
																				run: (*parser).callonsingleLineGoSubExpression190,
																				expr: &seqExpr{
																					pos: position{line: 2493, col: 5, offset: 86055},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2493, col: 5, offset: 86055},
																							val:        "\\U",
																							ignoreCase: false,
																							want:       "\"\\\\U\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 14, offset: 86064},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 26, offset: 86076},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 38, offset: 86088},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 50, offset: 86100},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 62, offset: 86112},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 74, offset: 86124},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 86, offset: 86136},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2493, col: 98, offset: 86148},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2527, col: 24, offset: 87533},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2527, col: 24, offset: 87533},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2527, col: 29, offset: 87538},
																						val:        "[abfnrtv\\\\\\]",
																						chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&charClassMatcher{
																				pos:        position{line: 2441, col: 75, offset: 83824},
																				val:        "[^\\\\\\\\n]",
																				chars:      []rune{'\'', '\\', '\n'},
																				ignoreCase: false,
																				inverted:   true,
																			},
																			&seqExpr{
																				pos: position{line: 2443, col: 24, offset: 83970},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2443, col: 24, offset: 83970},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2360, col: 19, offset: 81158},
																						val:        "[0-7]",
																						ranges:     []rune{'0', '7'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&seqExpr{
																				pos: position{line: 2444, col: 24, offset: 84037},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2444, col: 24, offset: 84037},
																						val:        "\\x",
																						ignoreCase: false,
																						want:       "\"\\\\x\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2445, col: 5, offset: 84074},
																				run: (*parser).callonsingleLineGoSubExpression222,
																				expr: &seqExpr{
																					pos: position{line: 2445, col: 5, offset: 84074},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2445, col: 5, offset: 84074},
																							val:        "\\x",
																							ignoreCase: false,
																							want:       "\"\\\\x\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2445, col: 14, offset: 84083},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2445, col: 26, offset: 84095},
																							expr: &charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2528, col: 24, offset: 87616},
																				run: (*parser).callonsingleLineGoSubExpression229,
																				expr: &seqExpr{
																					pos: position{line: 2528, col: 24, offset: 87616},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2528, col: 24, offset: 87616},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2552, col: 5, offset: 88632},
																				run: (*parser).callonsingleLineGoSubExpression240,
																				expr: &seqExpr{
																					pos: position{line: 2552, col: 5, offset: 88632},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2552, col: 5, offset: 88632},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2573, col: 5, offset: 89473},
																				run: (*parser).callonsingleLineGoSubExpression247,
																				expr: &seqExpr{
																					pos: position{line: 2573, col: 5, offset: 89473},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2573, col: 5, offset: 89473},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																			&actionExpr{
																				pos: position{line: 2591, col: 5, offset: 90158},
																				run: (*parser).callonsingleLineGoSubExpression252,
																				expr: &seqExpr{
																					pos: position{line: 2591, col: 5, offset: 90158},
																					exprs: []interface{}{
																						&litMatcher{
																							pos:        position{line: 2591, col: 5, offset: 90158},
																							val:        "\\",
																							ignoreCase: false,
																							want:       "\"\\\\\"",
																						},
																						&zeroOrOneExpr{
																							pos: position{line: 2591, col: 10, offset: 90163},
																							expr: &charClassMatcher{
																								pos:        position{line: 3735, col: 12, offset: 128270},
																								val:        "[^\\r\\n]",
																								chars:      []rune{'\r', '\n'},
																								ignoreCase: false,
																								inverted:   true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															&litMatcher{
																pos:        position{line: 2415, col: 74, offset: 82703},
																val:        "'",
																ignoreCase: false,
																want:       "\"'\"",
															},
															&labeledExpr{
																pos:   position{line: 2415, col: 79, offset: 82708},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonsingleLineGoSubExpression259,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 1569, col: 27, offset: 51402},
									name: "StringExpression",
								},
								&ruleRefExpr{
									pos:  position{line: 1569, col: 46, offset: 51421},
									name: "SingleLineTernaryExpression",
								},
								&seqExpr{
									pos: position{line: 1570, col: 6, offset: 51456},
									exprs: []interface{}{
										&actionExpr{
											pos: position{line: 3737, col: 8, offset: 128286},
											run: (*parser).callonsingleLineGoSubExpression268,
											expr: &choiceExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												alternatives: []interface{}{
													&andExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														expr: &anyMatcher{
															line: 3737, col: 10, offset: 128288,
														},
													},
													&notExpr{
														pos: position{line: 3737, col: 14, offset: 128292},
														expr: &anyMatcher{
															line: 3737, col: 15, offset: 128293,
														},
													},
												},
											},
										},
										&notExpr{
											pos: position{line: 1570, col: 11, offset: 51461},
											expr: &seqExpr{
												pos: position{line: 3734, col: 12, offset: 128237},
												exprs: []interface{}{
													&zeroOrMoreExpr{
														pos: position{line: 3734, col: 12, offset: 128237},
														expr: &charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3734, col: 16, offset: 128241},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		expr: &litMatcher{
																			pos:        position{line: 3734, col: 16, offset: 128241},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3734, col: 22, offset: 128247},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3733, col: 12, offset: 128223},
																expr: &anyMatcher{
																	line: 3733, col: 13, offset: 128224,
																},
															},
														},
													},
												},
											},
										},
										&charClassMatcher{
											pos:        position{line: 1570, col: 16, offset: 51466},
											val:        "[^)}]]",
											chars:      []rune{')', '}', ']'},
											ignoreCase: false,
											inverted:   true,
										},
										&zeroOrMoreExpr{
											pos: position{line: 1570, col: 24, offset: 51474},
											expr: &seqExpr{
												pos: position{line: 1570, col: 25, offset: 51475},
												exprs: []interface{}{
													&notExpr{
														pos: position{line: 1570, col: 25, offset: 51475},
														expr: &seqExpr{
															pos: position{line: 3734, col: 12, offset: 128237},
															exprs: []interface{}{
																&zeroOrMoreExpr{
																	pos: position{line: 3734, col: 12, offset: 128237},
																	expr: &charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&choiceExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	alternatives: []interface{}{
																		&seqExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			exprs: []interface{}{
																				&zeroOrOneExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					expr: &litMatcher{
																						pos:        position{line: 3734, col: 16, offset: 128241},
																						val:        "\r",
																						ignoreCase: false,
																						want:       "\"\\r\"",
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 3734, col: 22, offset: 128247},
																					val:        "\n",
																					ignoreCase: false,
																					want:       "\"\\n\"",
																				},
																			},
																		},
																		&notExpr{
																			pos: position{line: 3733, col: 12, offset: 128223},
																			expr: &anyMatcher{
																				line: 3733, col: 13, offset: 128224,
																			},
																		},
																	},
																},
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 1570, col: 30, offset: 51480},
														val:        "[^\\\"`?([{}])]",
														chars:      []rune{'\'', '"', '`', '?', '(', '[', '{', '}', ']', ')'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "IfExpression",
			pos:  position{line: 1581, col: 1, offset: 51778},
			expr: &choiceExpr{
				pos: position{line: 1581, col: 17, offset: 51794},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1581, col: 17, offset: 51794},
						run: (*parser).callonIfExpression2,
						expr: &labeledExpr{
							pos:   position{line: 1581, col: 17, offset: 51794},
							label: "cExprI",
							expr: &ruleRefExpr{
								pos:  position{line: 1581, col: 24, offset: 51801},
								name: "ChainExpression",
							},
						},
					},
					&actionExpr{
						pos: position{line: 1598, col: 5, offset: 52406},
						run: (*parser).callonIfExpression5,
						expr: &labeledExpr{
							pos:   position{line: 1598, col: 5, offset: 52406},
							label: "exprsI",
							expr: &oneOrMoreExpr{
								pos: position{line: 1598, col: 12, offset: 52413},
								expr: &choiceExpr{
									pos: position{line: 1599, col: 5, offset: 52419},
									alternatives: []interface{}{
										&actionExpr{
											pos: position{line: 1599, col: 5, offset: 52419},
											run: (*parser).callonIfExpression9,
											expr: &labeledExpr{
												pos:   position{line: 1599, col: 5, offset: 52419},
												label: "exprI",
												expr: &choiceExpr{
													pos: position{line: 1599, col: 12, offset: 52426},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 1599, col: 12, offset: 52426},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 1599, col: 12, offset: 52426},
																	val:        "(",
																	ignoreCase: false,
																	want:       "\"(\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 1599, col: 16, offset: 52430},
																	expr: &ruleRefExpr{
																		pos:  position{line: 1599, col: 16, offset: 52430},
																		name: "goSubExpression",
																	},
																},
																&actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonIfExpression16,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
																&litMatcher{
																	pos:        position{line: 1599, col: 37, offset: 52451},
																	val:        ")",
																	ignoreCase: false,
																	want:       "\")\"",
																},
															},
														},
														&seqExpr{
															pos: position{line: 1599, col: 43, offset: 52457},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 1599, col: 43, offset: 52457},
																	val:        "[",
																	ignoreCase: false,
																	want:       "\"[\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 1599, col: 47, offset: 52461},
																	expr: &ruleRefExpr{
																		pos:  position{line: 1599, col: 47, offset: 52461},
																		name: "goSubExpression",
																	},
																},
																&actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonIfExpression27,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
																&litMatcher{
																	pos:        position{line: 1599, col: 68, offset: 52482},
																	val:        "]",
																	ignoreCase: false,
																	want:       "\"]\"",
																},
															},
														},
														&seqExpr{
															pos: position{line: 1599, col: 74, offset: 52488},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 1599, col: 74, offset: 52488},
																	val:        "{",
																	ignoreCase: false,
																	want:       "\"{\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 1599, col: 78, offset: 52492},
																	expr: &ruleRefExpr{
																		pos:  position{line: 1599, col: 78, offset: 52492},
																		name: "goSubExpression",
																	},
																},
																&actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonIfExpression38,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
																&litMatcher{
																	pos:        position{line: 1599, col: 99, offset: 52513},
																	val:        "}",
																	ignoreCase: false,
																	want:       "\"}\"",
																},
															},
														},
													},
												},
											},
										},
										&actionExpr{
											pos: position{line: 1622, col: 9, offset: 53242},
											run: (*parser).callonIfExpression45,
											expr: &seqExpr{
												pos: position{line: 1622, col: 9, offset: 53242},
												exprs: []interface{}{
													&labeledExpr{
														pos:   position{line: 1622, col: 9, offset: 53242},
														label: "parenI",
														expr: &charClassMatcher{
															pos:        position{line: 1622, col: 16, offset: 53249},
															val:        "[([{]",
															chars:      []rune{'(', '[', '{'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&labeledExpr{
														pos:   position{line: 1622, col: 22, offset: 53255},
														label: "startPosI",
														expr: &actionExpr{
															pos: position{line: 3737, col: 8, offset: 128286},
															run: (*parser).callonIfExpression50,
															expr: &choiceExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																alternatives: []interface{}{
																	&andExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		expr: &anyMatcher{
																			line: 3737, col: 10, offset: 128288,
																		},
																	},
																	&notExpr{
																		pos: position{line: 3737, col: 14, offset: 128292},
																		expr: &anyMatcher{
																			line: 3737, col: 15, offset: 128293,
																		},
																	},
																},
															},
														},
													},
													&labeledExpr{
														pos:   position{line: 1622, col: 36, offset: 53269},
														label: "exprI",
														expr: &zeroOrOneExpr{
															pos: position{line: 1622, col: 42, offset: 53275},
															expr: &ruleRefExpr{
																pos:  position{line: 1622, col: 42, offset: 53275},
																name: "goSubExpression",
															},
														},
													},
												},
											},
										},
										&seqExpr{
											pos: position{line: 1652, col: 10, offset: 54317},
											exprs: []interface{}{
												&actionExpr{
													pos: position{line: 3737, col: 8, offset: 128286},
													run: (*parser).callonIfExpression60,
													expr: &choiceExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														alternatives: []interface{}{
															&andExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																expr: &anyMatcher{
																	line: 3737, col: 10, offset: 128288,
																},
															},
															&notExpr{
																pos: position{line: 3737, col: 14, offset: 128292},
																expr: &anyMatcher{
																	line: 3737, col: 15, offset: 128293,
																},
															},
														},
													},
												},
												&choiceExpr{
													pos: position{line: 2414, col: 14, offset: 82561},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 2414, col: 14, offset: 82561},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2414, col: 14, offset: 82561},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
																&choiceExpr{
																	pos: position{line: 2414, col: 20, offset: 82567},
																	alternatives: []interface{}{
																		&seqExpr{
																			pos: position{line: 2462, col: 19, offset: 84712},
																			exprs: []interface{}{
																				&litMatcher{
																					pos:        position{line: 2462, col: 19, offset: 84712},
																					val:        "\\u",
																					ignoreCase: false,
																					want:       "\"\\\\u\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 2463, col: 5, offset: 84771},
																			run: (*parser).callonIfExpression76,
																			expr: &seqExpr{
																				pos: position{line: 2463, col: 5, offset: 84771},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2463, col: 5, offset: 84771},
																						val:        "\\u",
																						ignoreCase: false,
																						want:       "\"\\\\u\"",
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2463, col: 14, offset: 84780},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2463, col: 26, offset: 84792},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2463, col: 38, offset: 84804},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2463, col: 50, offset: 84816},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																		&seqExpr{
																			pos: position{line: 2492, col: 16, offset: 85952},
																			exprs: []interface{}{
																				&litMatcher{
																					pos:        position{line: 2492, col: 16, offset: 85952},
																					val:        "\\U",
																					ignoreCase: false,
																					want:       "\"\\\\U\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 2493, col: 5, offset: 86055},
																			run: (*parser).callonIfExpression97,
																			expr: &seqExpr{
																				pos: position{line: 2493, col: 5, offset: 86055},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2493, col: 5, offset: 86055},
																						val:        "\\U",
																						ignoreCase: false,
																						want:       "\"\\\\U\"",
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2493, col: 14, offset: 86064},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2493, col: 26, offset: 86076},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2493, col: 38, offset: 86088},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2493, col: 50, offset: 86100},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2493, col: 62, offset: 86112},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2493, col: 74, offset: 86124},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2493, col: 86, offset: 86136},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2493, col: 98, offset: 86148},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																		&seqExpr{
																			pos: position{line: 2527, col: 24, offset: 87533},
																			exprs: []interface{}{
																				&litMatcher{
																					pos:        position{line: 2527, col: 24, offset: 87533},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2527, col: 29, offset: 87538},
																					val:        "[abfnrtv\\\\\\]",
																					chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																		&charClassMatcher{
																			pos:        position{line: 2441, col: 75, offset: 83824},
																			val:        "[^\\\\\\\\n]",
																			chars:      []rune{'\'', '\\', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																		&seqExpr{
																			pos: position{line: 2443, col: 24, offset: 83970},
																			exprs: []interface{}{
																				&litMatcher{
																					pos:        position{line: 2443, col: 24, offset: 83970},
																					val:        "\\",
																					ignoreCase: false,
																					want:       "\"\\\\\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2360, col: 19, offset: 81158},
																					val:        "[0-7]",
																					ranges:     []rune{'0', '7'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2360, col: 19, offset: 81158},
																					val:        "[0-7]",
																					ranges:     []rune{'0', '7'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2360, col: 19, offset: 81158},
																					val:        "[0-7]",
																					ranges:     []rune{'0', '7'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																		&seqExpr{
																			pos: position{line: 2444, col: 24, offset: 84037},
																			exprs: []interface{}{
																				&litMatcher{
																					pos:        position{line: 2444, col: 24, offset: 84037},
																					val:        "\\x",
																					ignoreCase: false,
																					want:       "\"\\\\x\"",
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2361, col: 19, offset: 81182},
																					val:        "[0-9A-Fa-f]",
																					ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 2445, col: 5, offset: 84074},
																			run: (*parser).callonIfExpression129,
																			expr: &seqExpr{
																				pos: position{line: 2445, col: 5, offset: 84074},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2445, col: 5, offset: 84074},
																						val:        "\\x",
																						ignoreCase: false,
																						want:       "\"\\\\x\"",
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2445, col: 14, offset: 84083},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2445, col: 26, offset: 84095},
																						expr: &charClassMatcher{
																							pos:        position{line: 2361, col: 19, offset: 81182},
																							val:        "[0-9A-Fa-f]",
																							ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 2528, col: 24, offset: 87616},
																			run: (*parser).callonIfExpression136,
																			expr: &seqExpr{
																				pos: position{line: 2528, col: 24, offset: 87616},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2528, col: 24, offset: 87616},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 2552, col: 5, offset: 88632},
																			run: (*parser).callonIfExpression147,
																			expr: &seqExpr{
																				pos: position{line: 2552, col: 5, offset: 88632},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2552, col: 5, offset: 88632},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 2573, col: 5, offset: 89473},
																			run: (*parser).callonIfExpression154,
																			expr: &seqExpr{
																				pos: position{line: 2573, col: 5, offset: 89473},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2573, col: 5, offset: 89473},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																					&charClassMatcher{
																						pos:        position{line: 2361, col: 19, offset: 81182},
																						val:        "[0-9A-Fa-f]",
																						ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 2591, col: 5, offset: 90158},
																			run: (*parser).callonIfExpression159,
																			expr: &seqExpr{
																				pos: position{line: 2591, col: 5, offset: 90158},
																				exprs: []interface{}{
																					&litMatcher{
																						pos:        position{line: 2591, col: 5, offset: 90158},
																						val:        "\\",
																						ignoreCase: false,
																						want:       "\"\\\\\"",
																					},
																					&zeroOrOneExpr{
																						pos: position{line: 2591, col: 10, offset: 90163},
																						expr: &charClassMatcher{
																							pos:        position{line: 3735, col: 12, offset: 128270},
																							val:        "[^\\r\\n]",
																							chars:      []rune{'\r', '\n'},
																							ignoreCase: false,
																							inverted:   true,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&litMatcher{
																	pos:        position{line: 2414, col: 76, offset: 82623},
																	val:        "'",
																	ignoreCase: false,
																	want:       "\"'\"",
																},
															},
														},
														&actionExpr{
															pos: position{line: 2415, col: 5, offset: 82634},
															run: (*parser).callonIfExpression165,
															expr: &seqExpr{
																pos: position{line: 2415, col: 5, offset: 82634},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 2415, col: 5, offset: 82634},
																		val:        "'",
																		ignoreCase: false,
																		want:       "\"'\"",
																	},
																	&labeledExpr{
																		pos:   position{line: 2415, col: 10, offset: 82639},
																		label: "valsI",
																		expr: &zeroOrMoreExpr{
																			pos: position{line: 2415, col: 16, offset: 82645},
																			expr: &choiceExpr{
																				pos: position{line: 2415, col: 17, offset: 82646},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 2462, col: 19, offset: 84712},
																						exprs: []interface{}{
																							&litMatcher{
																								pos:        position{line: 2462, col: 19, offset: 84712},
																								val:        "\\u",
																								ignoreCase: false,
																								want:       "\"\\\\u\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&actionExpr{
																						pos: position{line: 2463, col: 5, offset: 84771},
																						run: (*parser).callonIfExpression177,
																						expr: &seqExpr{
																							pos: position{line: 2463, col: 5, offset: 84771},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2463, col: 5, offset: 84771},
																									val:        "\\u",
																									ignoreCase: false,
																									want:       "\"\\\\u\"",
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2463, col: 14, offset: 84780},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2463, col: 26, offset: 84792},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2463, col: 38, offset: 84804},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2463, col: 50, offset: 84816},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																					},
																					&seqExpr{
																						pos: position{line: 2492, col: 16, offset: 85952},
																						exprs: []interface{}{
																							&litMatcher{
																								pos:        position{line: 2492, col: 16, offset: 85952},
																								val:        "\\U",
																								ignoreCase: false,
																								want:       "\"\\\\U\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&actionExpr{
																						pos: position{line: 2493, col: 5, offset: 86055},
																						run: (*parser).callonIfExpression198,
																						expr: &seqExpr{
																							pos: position{line: 2493, col: 5, offset: 86055},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2493, col: 5, offset: 86055},
																									val:        "\\U",
																									ignoreCase: false,
																									want:       "\"\\\\U\"",
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2493, col: 14, offset: 86064},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2493, col: 26, offset: 86076},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2493, col: 38, offset: 86088},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2493, col: 50, offset: 86100},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2493, col: 62, offset: 86112},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2493, col: 74, offset: 86124},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2493, col: 86, offset: 86136},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2493, col: 98, offset: 86148},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																					},
																					&seqExpr{
																						pos: position{line: 2527, col: 24, offset: 87533},
																						exprs: []interface{}{
																							&litMatcher{
																								pos:        position{line: 2527, col: 24, offset: 87533},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2527, col: 29, offset: 87538},
																								val:        "[abfnrtv\\\\\\]",
																								chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '\''},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 2441, col: 75, offset: 83824},
																						val:        "[^\\\\\\\\n]",
																						chars:      []rune{'\'', '\\', '\n'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																					&seqExpr{
																						pos: position{line: 2443, col: 24, offset: 83970},
																						exprs: []interface{}{
																							&litMatcher{
																								pos:        position{line: 2443, col: 24, offset: 83970},
																								val:        "\\",
																								ignoreCase: false,
																								want:       "\"\\\\\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2360, col: 19, offset: 81158},
																								val:        "[0-7]",
																								ranges:     []rune{'0', '7'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2360, col: 19, offset: 81158},
																								val:        "[0-7]",
																								ranges:     []rune{'0', '7'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2360, col: 19, offset: 81158},
																								val:        "[0-7]",
																								ranges:     []rune{'0', '7'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&seqExpr{
																						pos: position{line: 2444, col: 24, offset: 84037},
																						exprs: []interface{}{
																							&litMatcher{
																								pos:        position{line: 2444, col: 24, offset: 84037},
																								val:        "\\x",
																								ignoreCase: false,
																								want:       "\"\\\\x\"",
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2361, col: 19, offset: 81182},
																								val:        "[0-9A-Fa-f]",
																								ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&actionExpr{
																						pos: position{line: 2445, col: 5, offset: 84074},
																						run: (*parser).callonIfExpression230,
																						expr: &seqExpr{
																							pos: position{line: 2445, col: 5, offset: 84074},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2445, col: 5, offset: 84074},
																									val:        "\\x",
																									ignoreCase: false,
																									want:       "\"\\\\x\"",
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2445, col: 14, offset: 84083},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2445, col: 26, offset: 84095},
																									expr: &charClassMatcher{
																										pos:        position{line: 2361, col: 19, offset: 81182},
																										val:        "[0-9A-Fa-f]",
																										ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																						},
																					},
																					&actionExpr{
																						pos: position{line: 2528, col: 24, offset: 87616},
																						run: (*parser).callonIfExpression237,
																						expr: &seqExpr{
																							pos: position{line: 2528, col: 24, offset: 87616},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2528, col: 24, offset: 87616},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																					&actionExpr{
																						pos: position{line: 2552, col: 5, offset: 88632},
																						run: (*parser).callonIfExpression248,
																						expr: &seqExpr{
																							pos: position{line: 2552, col: 5, offset: 88632},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2552, col: 5, offset: 88632},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																					&actionExpr{
																						pos: position{line: 2573, col: 5, offset: 89473},
																						run: (*parser).callonIfExpression255,
																						expr: &seqExpr{
																							pos: position{line: 2573, col: 5, offset: 89473},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2573, col: 5, offset: 89473},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 2361, col: 19, offset: 81182},
																									val:        "[0-9A-Fa-f]",
																									ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																					&actionExpr{
																						pos: position{line: 2591, col: 5, offset: 90158},
																						run: (*parser).callonIfExpression260,
																						expr: &seqExpr{
																							pos: position{line: 2591, col: 5, offset: 90158},
																							exprs: []interface{}{
																								&litMatcher{
																									pos:        position{line: 2591, col: 5, offset: 90158},
																									val:        "\\",
																									ignoreCase: false,
																									want:       "\"\\\\\"",
																								},
																								&zeroOrOneExpr{
																									pos: position{line: 2591, col: 10, offset: 90163},
																									expr: &charClassMatcher{
																										pos:        position{line: 3735, col: 12, offset: 128270},
																										val:        "[^\\r\\n]",
																										chars:      []rune{'\r', '\n'},
																										ignoreCase: false,
																										inverted:   true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 2415, col: 74, offset: 82703},
																		val:        "'",
																		ignoreCase: false,
																		want:       "\"'\"",
																	},
																	&labeledExpr{
																		pos:   position{line: 2415, col: 79, offset: 82708},
																		label: "endPosI",
																		expr: &actionExpr{
																			pos: position{line: 3737, col: 8, offset: 128286},
																			run: (*parser).callonIfExpression267,
																			expr: &choiceExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				alternatives: []interface{}{
																					&andExpr{
																						pos: position{line: 3737, col: 9, offset: 128287},
																						expr: &anyMatcher{
																							line: 3737, col: 10, offset: 128288,
																						},
																					},
																					&notExpr{
																						pos: position{line: 3737, col: 14, offset: 128292},
																						expr: &anyMatcher{
																							line: 3737, col: 15, offset: 128293,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1652, col: 27, offset: 54334},
											name: "StringExpression",
										},
										&ruleRefExpr{
											pos:  position{line: 1652, col: 46, offset: 54353},
											name: "TernaryExpression",
										},
										&seqExpr{
											pos: position{line: 1653, col: 6, offset: 54378},
											exprs: []interface{}{
												&actionExpr{
													pos: position{line: 3737, col: 8, offset: 128286},
													run: (*parser).callonIfExpression276,
													expr: &choiceExpr{
														pos: position{line: 3737, col: 9, offset: 128287},
														alternatives: []interface{}{
															&andExpr{
																pos: position{line: 3737, col: 9, offset: 128287},
																expr: &anyMatcher{
																	line: 3737, col: 10, offset: 128288,
																},
															},
															&notExpr{
																pos: position{line: 3737, col: 14, offset: 128292},
																expr: &anyMatcher{
																	line: 3737, col: 15, offset: 128293,
																},
															},
														},
													},
												},
												&notExpr{
													pos: position{line: 1653, col: 11, offset: 54383},
													expr: &choiceExpr{
														pos: position{line: 1579, col: 27, offset: 51759},
														alternatives: []interface{}{
															&charClassMatcher{
																pos:        position{line: 1579, col: 27, offset: 51759},
																val:        "[)}]]",
																chars:      []rune{')', '}', ']'},
																ignoreCase: false,
																inverted:   false,
															},
															&seqExpr{
																pos: position{line: 1579, col: 36, offset: 51768},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 1579, col: 36, offset: 51768},
																		val:        ":",
																		ignoreCase: false,
																		want:       "\":\"",
																	},
																	&notExpr{
																		pos: position{line: 1579, col: 40, offset: 51772},
																		expr: &litMatcher{
																			pos:        position{line: 1579, col: 41, offset: 51773},
																			val:        "=",
																			ignoreCase: false,
																			want:       "\"=\"",
																		},
																	},
																},
															},
														},
													},
												},
												&charClassMatcher{
													pos:        position{line: 3735, col: 12, offset: 128270},
													val:        "[^\\r\\n]",
													chars:      []rune{'\r', '\n'},
													ignoreCase: false,
													inverted:   true,
												},
												&zeroOrMoreExpr{
													pos: position{line: 1653, col: 43, offset: 54415},
													expr: &seqExpr{
														pos: position{line: 1653, col: 44, offset: 54416},
														exprs: []interface{}{
															&notExpr{
																pos: position{line: 1653, col: 44, offset: 54416},
																expr: &choiceExpr{
																	pos: position{line: 1579, col: 27, offset: 51759},
																	alternatives: []interface{}{
																		&charClassMatcher{
																			pos:        position{line: 1579, col: 27, offset: 51759},
																			val:        "[)}]]",
																			chars:      []rune{')', '}', ']'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&seqExpr{
																			pos: position{line: 1579, col: 36, offset: 51768},
																			exprs: []interface{}{
																				&litMatcher{
																					pos:        position{line: 1579, col: 36, offset: 51768},
																					val:        ":",
																					ignoreCase: false,
																					want:       "\":\"",
																				},
																				&notExpr{
																					pos: position{line: 1579, col: 40, offset: 51772},
																					expr: &litMatcher{
																						pos:        position{line: 1579, col: 41, offset: 51773},
																						val:        "=",
																						ignoreCase: false,
																						want:       "\"=\"",
																					},
																				},
																			},
																		},
																	},
																},
															},
															&notExpr{
																pos: position{line: 1653, col: 68, offset: 54440},
																expr: &seqExpr{
																	pos: position{line: 3734, col: 12, offset: 128237},
																	exprs: []interface{}{
																		&zeroOrMoreExpr{
																			pos: position{line: 3734, col: 12, offset: 128237},
																			expr: &charClassMatcher{
																				pos:        position{line: 3746, col: 36, offset: 128584},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																		&choiceExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					exprs: []interface{}{
																						&zeroOrOneExpr{
																							pos: position{line: 3734, col: 16, offset: 128241},
																							expr: &litMatcher{
																								pos:        position{line: 3734, col: 16, offset: 128241},
																								val:        "\r",
																								ignoreCase: false,
																								want:       "\"\\r\"",
																							},
																						},
																						&litMatcher{
																							pos:        position{line: 3734, col: 22, offset: 128247},
																							val:        "\n",
																							ignoreCase: false,
																							want:       "\"\\n\"",
																						},
																					},
																				},
																				&notExpr{
																					pos: position{line: 3733, col: 12, offset: 128223},
																					expr: &anyMatcher{
																						line: 3733, col: 13, offset: 128224,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 1653, col: 73, offset: 54445},
																val:        "[^\\\"`?([{]",
																chars:      []rune{'\'', '"', '`', '?', '(', '[', '{'},
																ignoreCase: false,
																inverted:   true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "StringExpression",
			pos:  position{line: 1700, col: 1, offset: 55808},
			expr: &choiceExpr{
				pos: position{line: 1700, col: 21, offset: 55828},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 1700, col: 21, offset: 55828},
						name: "InterpretedStringExpression",
					},
					&ruleRefExpr{
						pos:  position{line: 1700, col: 51, offset: 55858},
						name: "RawStringExpression",
					},
				},
			},
		},
		{
			name: "InterpretedStringExpression",
			pos:  position{line: 1702, col: 1, offset: 55879},
			expr: &choiceExpr{
				pos: position{line: 1702, col: 32, offset: 55910},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1702, col: 32, offset: 55910},
						run: (*parser).callonInterpretedStringExpression2,
						expr: &seqExpr{
							pos: position{line: 1702, col: 32, offset: 55910},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1702, col: 32, offset: 55910},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
								&labeledExpr{
									pos:   position{line: 1702, col: 36, offset: 55914},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1702, col: 46, offset: 55924},
										expr: &ruleRefExpr{
											pos:  position{line: 1702, col: 46, offset: 55924},
											name: "InterpretedStringExpressionItem",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1702, col: 79, offset: 55957},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1708, col: 5, offset: 56126},
						run: (*parser).callonInterpretedStringExpression9,
						expr: &seqExpr{
							pos: position{line: 1708, col: 5, offset: 56126},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1708, col: 5, offset: 56126},
									val:        "\"",
									ignoreCase: false,
									want:       "\"\\\"\"",
								},
								&labeledExpr{
									pos:   position{line: 1708, col: 9, offset: 56130},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonInterpretedStringExpression13,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1708, col: 23, offset: 56144},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1708, col: 33, offset: 56154},
										expr: &ruleRefExpr{
											pos:  position{line: 1708, col: 33, offset: 56154},
											name: "InterpretedStringExpressionItem",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "RawStringExpression",
			pos:  position{line: 1728, col: 1, offset: 56804},
			expr: &choiceExpr{
				pos: position{line: 1728, col: 24, offset: 56827},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1728, col: 24, offset: 56827},
						run: (*parser).callonRawStringExpression2,
						expr: &seqExpr{
							pos: position{line: 1728, col: 24, offset: 56827},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1728, col: 24, offset: 56827},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
								&labeledExpr{
									pos:   position{line: 1728, col: 28, offset: 56831},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1728, col: 38, offset: 56841},
										expr: &ruleRefExpr{
											pos:  position{line: 1728, col: 38, offset: 56841},
											name: "RawStringExpressionItem",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1728, col: 63, offset: 56866},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1734, col: 5, offset: 57035},
						run: (*parser).callonRawStringExpression9,
						expr: &seqExpr{
							pos: position{line: 1734, col: 5, offset: 57035},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1734, col: 5, offset: 57035},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
								&labeledExpr{
									pos:   position{line: 1734, col: 9, offset: 57039},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonRawStringExpression13,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1734, col: 23, offset: 57053},
									label: "contentsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 1734, col: 33, offset: 57063},
										expr: &ruleRefExpr{
											pos:  position{line: 1734, col: 33, offset: 57063},
											name: "RawStringExpressionItem",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InterpretedStringExpressionItem",
			pos:  position{line: 1755, col: 1, offset: 57705},
			expr: &choiceExpr{
				pos: position{line: 1755, col: 36, offset: 57740},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1758, col: 36, offset: 57931},
						run: (*parser).callonInterpretedStringExpressionItem2,
						expr: &oneOrMoreExpr{
							pos: position{line: 1758, col: 36, offset: 57931},
							expr: &choiceExpr{
								pos: position{line: 1758, col: 37, offset: 57932},
								alternatives: []interface{}{
									&litMatcher{
										pos:        position{line: 1758, col: 37, offset: 57932},
										val:        "##",
										ignoreCase: false,
										want:       "\"##\"",
									},
									&seqExpr{
										pos: position{line: 1758, col: 44, offset: 57939},
										exprs: []interface{}{
											&notExpr{
												pos: position{line: 1758, col: 44, offset: 57939},
												expr: &litMatcher{
													pos:        position{line: 1758, col: 45, offset: 57940},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
											},
											&choiceExpr{
												pos: position{line: 2717, col: 36, offset: 94909},
												alternatives: []interface{}{
													&seqExpr{
														pos: position{line: 2462, col: 19, offset: 84712},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2462, col: 19, offset: 84712},
																val:        "\\u",
																ignoreCase: false,
																want:       "\"\\\\u\"",
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&actionExpr{
														pos: position{line: 2463, col: 5, offset: 84771},
														run: (*parser).callonInterpretedStringExpressionItem16,
														expr: &seqExpr{
															pos: position{line: 2463, col: 5, offset: 84771},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2463, col: 5, offset: 84771},
																	val:        "\\u",
																	ignoreCase: false,
																	want:       "\"\\\\u\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2463, col: 14, offset: 84780},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2463, col: 26, offset: 84792},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2463, col: 38, offset: 84804},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2463, col: 50, offset: 84816},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
													&seqExpr{
														pos: position{line: 2492, col: 16, offset: 85952},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2492, col: 16, offset: 85952},
																val:        "\\U",
																ignoreCase: false,
																want:       "\"\\\\U\"",
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&actionExpr{
														pos: position{line: 2493, col: 5, offset: 86055},
														run: (*parser).callonInterpretedStringExpressionItem37,
														expr: &seqExpr{
															pos: position{line: 2493, col: 5, offset: 86055},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2493, col: 5, offset: 86055},
																	val:        "\\U",
																	ignoreCase: false,
																	want:       "\"\\\\U\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 14, offset: 86064},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 26, offset: 86076},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 38, offset: 86088},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 50, offset: 86100},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 62, offset: 86112},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 74, offset: 86124},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 86, offset: 86136},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 98, offset: 86148},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
													&seqExpr{
														pos: position{line: 2720, col: 36, offset: 95085},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2720, col: 36, offset: 95085},
																val:        "\\",
																ignoreCase: false,
																want:       "\"\\\\\"",
															},
															&charClassMatcher{
																pos:        position{line: 2720, col: 41, offset: 95090},
																val:        "[abfnrtv\\\\\"]",
																chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 2718, col: 38, offset: 94977},
														val:        "[^\"\\\\\\n]",
														chars:      []rune{'"', '\\', '\n'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
									},
									&seqExpr{
										pos: position{line: 2443, col: 24, offset: 83970},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 2443, col: 24, offset: 83970},
												val:        "\\",
												ignoreCase: false,
												want:       "\"\\\\\"",
											},
											&charClassMatcher{
												pos:        position{line: 2360, col: 19, offset: 81158},
												val:        "[0-7]",
												ranges:     []rune{'0', '7'},
												ignoreCase: false,
												inverted:   false,
											},
											&charClassMatcher{
												pos:        position{line: 2360, col: 19, offset: 81158},
												val:        "[0-7]",
												ranges:     []rune{'0', '7'},
												ignoreCase: false,
												inverted:   false,
											},
											&charClassMatcher{
												pos:        position{line: 2360, col: 19, offset: 81158},
												val:        "[0-7]",
												ranges:     []rune{'0', '7'},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
									&seqExpr{
										pos: position{line: 2444, col: 24, offset: 84037},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 2444, col: 24, offset: 84037},
												val:        "\\x",
												ignoreCase: false,
												want:       "\"\\\\x\"",
											},
											&charClassMatcher{
												pos:        position{line: 2361, col: 19, offset: 81182},
												val:        "[0-9A-Fa-f]",
												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
												ignoreCase: false,
												inverted:   false,
											},
											&charClassMatcher{
												pos:        position{line: 2361, col: 19, offset: 81182},
												val:        "[0-9A-Fa-f]",
												ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
									&actionExpr{
										pos: position{line: 2445, col: 5, offset: 84074},
										run: (*parser).callonInterpretedStringExpressionItem69,
										expr: &seqExpr{
											pos: position{line: 2445, col: 5, offset: 84074},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 2445, col: 5, offset: 84074},
													val:        "\\x",
													ignoreCase: false,
													want:       "\"\\\\x\"",
												},
												&zeroOrOneExpr{
													pos: position{line: 2445, col: 14, offset: 84083},
													expr: &charClassMatcher{
														pos:        position{line: 2361, col: 19, offset: 81182},
														val:        "[0-9A-Fa-f]",
														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&zeroOrOneExpr{
													pos: position{line: 2445, col: 26, offset: 84095},
													expr: &charClassMatcher{
														pos:        position{line: 2361, col: 19, offset: 81182},
														val:        "[0-9A-Fa-f]",
														ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
														ignoreCase: false,
														inverted:   false,
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 2607, col: 37, offset: 90735},
										run: (*parser).callonInterpretedStringExpressionItem76,
										expr: &seqExpr{
											pos: position{line: 2607, col: 37, offset: 90735},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 2607, col: 37, offset: 90735},
													val:        "\\",
													ignoreCase: false,
													want:       "\"\\\\\"",
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 2631, col: 5, offset: 91752},
										run: (*parser).callonInterpretedStringExpressionItem87,
										expr: &seqExpr{
											pos: position{line: 2631, col: 5, offset: 91752},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 2631, col: 5, offset: 91752},
													val:        "\\",
													ignoreCase: false,
													want:       "\"\\\\\"",
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 2652, col: 5, offset: 92594},
										run: (*parser).callonInterpretedStringExpressionItem94,
										expr: &seqExpr{
											pos: position{line: 2652, col: 5, offset: 92594},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 2652, col: 5, offset: 92594},
													val:        "\\",
													ignoreCase: false,
													want:       "\"\\\\\"",
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
												&charClassMatcher{
													pos:        position{line: 2361, col: 19, offset: 81182},
													val:        "[0-9A-Fa-f]",
													ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 2670, col: 5, offset: 93280},
										run: (*parser).callonInterpretedStringExpressionItem99,
										expr: &seqExpr{
											pos: position{line: 2670, col: 5, offset: 93280},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 2670, col: 5, offset: 93280},
													val:        "\\",
													ignoreCase: false,
													want:       "\"\\\\\"",
												},
												&zeroOrOneExpr{
													pos: position{line: 2670, col: 10, offset: 93285},
													expr: &charClassMatcher{
														pos:        position{line: 3735, col: 12, offset: 128270},
														val:        "[^\\r\\n]",
														chars:      []rune{'\r', '\n'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1755, col: 70, offset: 57774},
						name: "StringExpressionInterpolation",
					},
				},
			},
		},
		{
			name: "RawStringExpressionItem",
			pos:  position{line: 1756, col: 1, offset: 57804},
			expr: &choiceExpr{
				pos: position{line: 1756, col: 36, offset: 57839},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1764, col: 28, offset: 58163},
						run: (*parser).callonRawStringExpressionItem2,
						expr: &oneOrMoreExpr{
							pos: position{line: 1764, col: 28, offset: 58163},
							expr: &choiceExpr{
								pos: position{line: 1764, col: 29, offset: 58164},
								alternatives: []interface{}{
									&litMatcher{
										pos:        position{line: 1764, col: 29, offset: 58164},
										val:        "##",
										ignoreCase: false,
										want:       "\"##\"",
									},
									&seqExpr{
										pos: position{line: 1764, col: 36, offset: 58171},
										exprs: []interface{}{
											&notExpr{
												pos: position{line: 1764, col: 36, offset: 58171},
												expr: &litMatcher{
													pos:        position{line: 1764, col: 37, offset: 58172},
													val:        "#",
													ignoreCase: false,
													want:       "\"#\"",
												},
											},
											&charClassMatcher{
												pos:        position{line: 2704, col: 27, offset: 94307},
												val:        "[^\\n`]",
												chars:      []rune{'\n', '`'},
												ignoreCase: false,
												inverted:   true,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1756, col: 62, offset: 57865},
						name: "StringExpressionInterpolation",
					},
				},
			},
		},
		{
			name: "StringExpressionInterpolation",
			pos:  position{line: 1771, col: 1, offset: 58311},
			expr: &choiceExpr{
				pos: position{line: 1771, col: 34, offset: 58344},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1771, col: 34, offset: 58344},
						run: (*parser).callonStringExpressionInterpolation2,
						expr: &seqExpr{
							pos: position{line: 1771, col: 34, offset: 58344},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1771, col: 34, offset: 58344},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1771, col: 38, offset: 58348},
									label: "noEscapeI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1771, col: 48, offset: 58358},
										expr: &litMatcher{
											pos:        position{line: 1771, col: 48, offset: 58358},
											val:        "!",
											ignoreCase: false,
											want:       "\"!\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1771, col: 53, offset: 58363},
									label: "fmtDirectiveI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1771, col: 67, offset: 58377},
										expr: &choiceExpr{
											pos: position{line: 1836, col: 17, offset: 60871},
											alternatives: []interface{}{
												&actionExpr{
													pos: position{line: 1836, col: 17, offset: 60871},
													run: (*parser).callonStringExpressionInterpolation11,
													expr: &seqExpr{
														pos: position{line: 1836, col: 17, offset: 60871},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 1836, col: 17, offset: 60871},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1836, col: 21, offset: 60875},
																expr: &charClassMatcher{
																	pos:        position{line: 1858, col: 12, offset: 61789},
																	val:        "[ 0+-#]",
																	chars:      []rune{' ', '0'},
																	ranges:     []rune{'+', '#'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1836, col: 30, offset: 60884},
																expr: &seqExpr{
																	pos: position{line: 1836, col: 31, offset: 60885},
																	exprs: []interface{}{
																		&charClassMatcher{
																			pos:        position{line: 1836, col: 31, offset: 60885},
																			val:        "[1-9]",
																			ranges:     []rune{'1', '9'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1836, col: 36, offset: 60890},
																			expr: &charClassMatcher{
																				pos:        position{line: 1836, col: 36, offset: 60890},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1836, col: 45, offset: 60899},
																expr: &seqExpr{
																	pos: position{line: 1836, col: 46, offset: 60900},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 1836, col: 46, offset: 60900},
																			val:        ".",
																			ignoreCase: false,
																			want:       "\".\"",
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1836, col: 50, offset: 60904},
																			expr: &charClassMatcher{
																				pos:        position{line: 1836, col: 50, offset: 60904},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&choiceExpr{
																pos: position{line: 1859, col: 12, offset: 61808},
																alternatives: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 1859, col: 12, offset: 61808},
																		val:        "[vTtbcdoOqxXUeEfFgGsp]",
																		chars:      []rune{'v', 'T', 't', 'b', 'c', 'd', 'o', 'O', 'q', 'x', 'X', 'U', 'e', 'E', 'f', 'F', 'g', 'G', 's', 'p'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&actionExpr{
																		pos: position{line: 1859, col: 74, offset: 61870},
																		run: (*parser).callonStringExpressionInterpolation28,
																		expr: &andExpr{
																			pos: position{line: 1859, col: 74, offset: 61870},
																			expr: &charClassMatcher{
																				pos:        position{line: 1859, col: 76, offset: 61872},
																				val:        "[{\"`]",
																				chars:      []rune{'{', '"', '`'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 1871, col: 5, offset: 62409},
																		run: (*parser).callonStringExpressionInterpolation31,
																		expr: &anyMatcher{
																			line: 1871, col: 5, offset: 62409,
																		},
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 1838, col: 5, offset: 60962},
													run: (*parser).callonStringExpressionInterpolation33,
													expr: &seqExpr{
														pos: position{line: 1838, col: 5, offset: 60962},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 1838, col: 5, offset: 60962},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1838, col: 9, offset: 60966},
																expr: &charClassMatcher{
																	pos:        position{line: 1838, col: 9, offset: 60966},
																	val:        "[^`\"{]",
																	chars:      []rune{'`', '"', '{'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
															&labeledExpr{
																pos:   position{line: 1838, col: 17, offset: 60974},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonStringExpressionInterpolation39,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1771, col: 81, offset: 58391},
									val:        "{",
									ignoreCase: false,
									want:       "\"{\"",
								},
								&labeledExpr{
									pos:   position{line: 1771, col: 85, offset: 58395},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1771, col: 91, offset: 58401},
										name: "SingleLineExpression",
									},
								},
								&litMatcher{
									pos:        position{line: 1771, col: 112, offset: 58422},
									val:        "}",
									ignoreCase: false,
									want:       "\"}\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1778, col: 5, offset: 58645},
						run: (*parser).callonStringExpressionInterpolation49,
						expr: &seqExpr{
							pos: position{line: 1778, col: 5, offset: 58645},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1778, col: 5, offset: 58645},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1778, col: 9, offset: 58649},
									label: "noEscapeI",
									expr: &litMatcher{
										pos:        position{line: 1778, col: 19, offset: 58659},
										val:        "!",
										ignoreCase: false,
										want:       "\"!\"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1778, col: 23, offset: 58663},
									label: "fmtDirectiveI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1778, col: 37, offset: 58677},
										expr: &choiceExpr{
											pos: position{line: 1836, col: 17, offset: 60871},
											alternatives: []interface{}{
												&actionExpr{
													pos: position{line: 1836, col: 17, offset: 60871},
													run: (*parser).callonStringExpressionInterpolation57,
													expr: &seqExpr{
														pos: position{line: 1836, col: 17, offset: 60871},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 1836, col: 17, offset: 60871},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1836, col: 21, offset: 60875},
																expr: &charClassMatcher{
																	pos:        position{line: 1858, col: 12, offset: 61789},
																	val:        "[ 0+-#]",
																	chars:      []rune{' ', '0'},
																	ranges:     []rune{'+', '#'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1836, col: 30, offset: 60884},
																expr: &seqExpr{
																	pos: position{line: 1836, col: 31, offset: 60885},
																	exprs: []interface{}{
																		&charClassMatcher{
																			pos:        position{line: 1836, col: 31, offset: 60885},
																			val:        "[1-9]",
																			ranges:     []rune{'1', '9'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1836, col: 36, offset: 60890},
																			expr: &charClassMatcher{
																				pos:        position{line: 1836, col: 36, offset: 60890},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1836, col: 45, offset: 60899},
																expr: &seqExpr{
																	pos: position{line: 1836, col: 46, offset: 60900},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 1836, col: 46, offset: 60900},
																			val:        ".",
																			ignoreCase: false,
																			want:       "\".\"",
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1836, col: 50, offset: 60904},
																			expr: &charClassMatcher{
																				pos:        position{line: 1836, col: 50, offset: 60904},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&choiceExpr{
																pos: position{line: 1859, col: 12, offset: 61808},
																alternatives: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 1859, col: 12, offset: 61808},
																		val:        "[vTtbcdoOqxXUeEfFgGsp]",
																		chars:      []rune{'v', 'T', 't', 'b', 'c', 'd', 'o', 'O', 'q', 'x', 'X', 'U', 'e', 'E', 'f', 'F', 'g', 'G', 's', 'p'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&actionExpr{
																		pos: position{line: 1859, col: 74, offset: 61870},
																		run: (*parser).callonStringExpressionInterpolation74,
																		expr: &andExpr{
																			pos: position{line: 1859, col: 74, offset: 61870},
																			expr: &charClassMatcher{
																				pos:        position{line: 1859, col: 76, offset: 61872},
																				val:        "[{\"`]",
																				chars:      []rune{'{', '"', '`'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 1871, col: 5, offset: 62409},
																		run: (*parser).callonStringExpressionInterpolation77,
																		expr: &anyMatcher{
																			line: 1871, col: 5, offset: 62409,
																		},
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 1838, col: 5, offset: 60962},
													run: (*parser).callonStringExpressionInterpolation79,
													expr: &seqExpr{
														pos: position{line: 1838, col: 5, offset: 60962},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 1838, col: 5, offset: 60962},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1838, col: 9, offset: 60966},
																expr: &charClassMatcher{
																	pos:        position{line: 1838, col: 9, offset: 60966},
																	val:        "[^`\"{]",
																	chars:      []rune{'`', '"', '{'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
															&labeledExpr{
																pos:   position{line: 1838, col: 17, offset: 60974},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonStringExpressionInterpolation85,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1778, col: 51, offset: 58691},
									label: "parenPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonStringExpressionInterpolation92,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1806, col: 5, offset: 59716},
						run: (*parser).callonStringExpressionInterpolation98,
						expr: &seqExpr{
							pos: position{line: 1806, col: 5, offset: 59716},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1806, col: 5, offset: 59716},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&labeledExpr{
									pos:   position{line: 1806, col: 9, offset: 59720},
									label: "noEscapeI",
									expr: &litMatcher{
										pos:        position{line: 1806, col: 19, offset: 59730},
										val:        "!",
										ignoreCase: false,
										want:       "\"!\"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1806, col: 23, offset: 59734},
									label: "fmtDirectiveI",
									expr: &zeroOrOneExpr{
										pos: position{line: 1806, col: 37, offset: 59748},
										expr: &choiceExpr{
											pos: position{line: 1836, col: 17, offset: 60871},
											alternatives: []interface{}{
												&actionExpr{
													pos: position{line: 1836, col: 17, offset: 60871},
													run: (*parser).callonStringExpressionInterpolation106,
													expr: &seqExpr{
														pos: position{line: 1836, col: 17, offset: 60871},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 1836, col: 17, offset: 60871},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1836, col: 21, offset: 60875},
																expr: &charClassMatcher{
																	pos:        position{line: 1858, col: 12, offset: 61789},
																	val:        "[ 0+-#]",
																	chars:      []rune{' ', '0'},
																	ranges:     []rune{'+', '#'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1836, col: 30, offset: 60884},
																expr: &seqExpr{
																	pos: position{line: 1836, col: 31, offset: 60885},
																	exprs: []interface{}{
																		&charClassMatcher{
																			pos:        position{line: 1836, col: 31, offset: 60885},
																			val:        "[1-9]",
																			ranges:     []rune{'1', '9'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1836, col: 36, offset: 60890},
																			expr: &charClassMatcher{
																				pos:        position{line: 1836, col: 36, offset: 60890},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&zeroOrOneExpr{
																pos: position{line: 1836, col: 45, offset: 60899},
																expr: &seqExpr{
																	pos: position{line: 1836, col: 46, offset: 60900},
																	exprs: []interface{}{
																		&litMatcher{
																			pos:        position{line: 1836, col: 46, offset: 60900},
																			val:        ".",
																			ignoreCase: false,
																			want:       "\".\"",
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 1836, col: 50, offset: 60904},
																			expr: &charClassMatcher{
																				pos:        position{line: 1836, col: 50, offset: 60904},
																				val:        "[0-9]",
																				ranges:     []rune{'0', '9'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
															&choiceExpr{
																pos: position{line: 1859, col: 12, offset: 61808},
																alternatives: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 1859, col: 12, offset: 61808},
																		val:        "[vTtbcdoOqxXUeEfFgGsp]",
																		chars:      []rune{'v', 'T', 't', 'b', 'c', 'd', 'o', 'O', 'q', 'x', 'X', 'U', 'e', 'E', 'f', 'F', 'g', 'G', 's', 'p'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&actionExpr{
																		pos: position{line: 1859, col: 74, offset: 61870},
																		run: (*parser).callonStringExpressionInterpolation123,
																		expr: &andExpr{
																			pos: position{line: 1859, col: 74, offset: 61870},
																			expr: &charClassMatcher{
																				pos:        position{line: 1859, col: 76, offset: 61872},
																				val:        "[{\"`]",
																				chars:      []rune{'{', '"', '`'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 1871, col: 5, offset: 62409},
																		run: (*parser).callonStringExpressionInterpolation126,
																		expr: &anyMatcher{
																			line: 1871, col: 5, offset: 62409,
																		},
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 1838, col: 5, offset: 60962},
													run: (*parser).callonStringExpressionInterpolation128,
													expr: &seqExpr{
														pos: position{line: 1838, col: 5, offset: 60962},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 1838, col: 5, offset: 60962},
																val:        "%",
																ignoreCase: false,
																want:       "\"%\"",
															},
															&zeroOrMoreExpr{
																pos: position{line: 1838, col: 9, offset: 60966},
																expr: &charClassMatcher{
																	pos:        position{line: 1838, col: 9, offset: 60966},
																	val:        "[^`\"{]",
																	chars:      []rune{'`', '"', '{'},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
															&labeledExpr{
																pos:   position{line: 1838, col: 17, offset: 60974},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonStringExpressionInterpolation134,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1806, col: 51, offset: 59762},
									label: "parenPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonStringExpressionInterpolation141,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&litMatcher{
									pos:        position{line: 1806, col: 65, offset: 59776},
									val:        "{",
									ignoreCase: false,
									want:       "\"{\"",
								},
								&labeledExpr{
									pos:   position{line: 1806, col: 69, offset: 59780},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonStringExpressionInterpolation149,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1806, col: 83, offset: 59794},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 1806, col: 89, offset: 59800},
										name: "SingleLineExpression",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TernaryExpression",
			pos:  position{line: 1895, col: 1, offset: 63224},
			expr: &choiceExpr{
				pos: position{line: 1895, col: 22, offset: 63245},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1895, col: 22, offset: 63245},
						run: (*parser).callonTernaryExpression2,
						expr: &seqExpr{
							pos: position{line: 1895, col: 22, offset: 63245},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1895, col: 22, offset: 63245},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1895, col: 27, offset: 63250},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1895, col: 31, offset: 63254},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1895, col: 42, offset: 63265},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1895, col: 64, offset: 63287},
									expr: &litMatcher{
										pos:        position{line: 1895, col: 64, offset: 63287},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1895, col: 69, offset: 63292},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1895, col: 73, offset: 63296},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1895, col: 77, offset: 63300},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1895, col: 85, offset: 63308},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1895, col: 107, offset: 63330},
									expr: &litMatcher{
										pos:        position{line: 1895, col: 107, offset: 63330},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1895, col: 112, offset: 63335},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1895, col: 116, offset: 63339},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1895, col: 120, offset: 63343},
									label: "ifFalseI",
									expr: &ruleRefExpr{
										pos:  position{line: 1895, col: 129, offset: 63352},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1895, col: 151, offset: 63374},
									expr: &litMatcher{
										pos:        position{line: 1895, col: 151, offset: 63374},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1895, col: 156, offset: 63379},
									expr: &seqExpr{
										pos: position{line: 1895, col: 157, offset: 63380},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1895, col: 157, offset: 63380},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1895, col: 161, offset: 63384},
												expr: &choiceExpr{
													pos: position{line: 3750, col: 20, offset: 128702},
													alternatives: []interface{}{
														&charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3747, col: 36, offset: 128625},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3747, col: 36, offset: 128625},
																	expr: &litMatcher{
																		pos:        position{line: 3747, col: 36, offset: 128625},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3747, col: 42, offset: 128631},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1895, col: 167, offset: 63390},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonTernaryExpression51,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1903, col: 5, offset: 63671},
						run: (*parser).callonTernaryExpression53,
						expr: &seqExpr{
							pos: position{line: 1903, col: 5, offset: 63671},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1903, col: 5, offset: 63671},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&labeledExpr{
									pos:   position{line: 1903, col: 10, offset: 63676},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonTernaryExpression57,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1903, col: 24, offset: 63690},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1903, col: 28, offset: 63694},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonTernaryExpression71,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1917, col: 5, offset: 64285},
						run: (*parser).callonTernaryExpression73,
						expr: &seqExpr{
							pos: position{line: 1917, col: 5, offset: 64285},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1917, col: 5, offset: 64285},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1917, col: 10, offset: 64290},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1917, col: 14, offset: 64294},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1917, col: 25, offset: 64305},
										name: "multiLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1917, col: 47, offset: 64327},
									label: "startPosI",
									expr: &choiceExpr{
										pos: position{line: 1889, col: 13, offset: 63135},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 1889, col: 13, offset: 63135},
												run: (*parser).callonTernaryExpression87,
												expr: &seqExpr{
													pos: position{line: 1889, col: 13, offset: 63135},
													exprs: []interface{}{
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 13, offset: 63135},
															expr: &litMatcher{
																pos:        position{line: 1889, col: 13, offset: 63135},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&litMatcher{
															pos:        position{line: 1889, col: 18, offset: 63140},
															val:        ",",
															ignoreCase: false,
															want:       "\",\"",
														},
														&labeledExpr{
															pos:   position{line: 1889, col: 22, offset: 63144},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonTernaryExpression93,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 31, offset: 63153},
															expr: &choiceExpr{
																pos: position{line: 3750, col: 20, offset: 128702},
																alternatives: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 3747, col: 36, offset: 128625},
																		exprs: []interface{}{
																			&zeroOrOneExpr{
																				pos: position{line: 3747, col: 36, offset: 128625},
																				expr: &litMatcher{
																					pos:        position{line: 3747, col: 36, offset: 128625},
																					val:        "\r",
																					ignoreCase: false,
																					want:       "\"\\r\"",
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 3747, col: 42, offset: 128631},
																				val:        "\n",
																				ignoreCase: false,
																				want:       "\"\\n\"",
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 1891, col: 5, offset: 63184},
												run: (*parser).callonTernaryExpression106,
												expr: &seqExpr{
													pos: position{line: 1891, col: 5, offset: 63184},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 1891, col: 5, offset: 63184},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonTernaryExpression109,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1891, col: 14, offset: 63193},
															expr: &litMatcher{
																pos:        position{line: 1891, col: 14, offset: 63193},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1917, col: 66, offset: 64346},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonTernaryExpression118,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1932, col: 5, offset: 64972},
						run: (*parser).callonTernaryExpression120,
						expr: &seqExpr{
							pos: position{line: 1932, col: 5, offset: 64972},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1932, col: 5, offset: 64972},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1932, col: 10, offset: 64977},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1932, col: 14, offset: 64981},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1932, col: 25, offset: 64992},
										name: "multiLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1932, col: 47, offset: 65014},
									expr: &litMatcher{
										pos:        position{line: 1932, col: 47, offset: 65014},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1932, col: 52, offset: 65019},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1932, col: 56, offset: 65023},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1932, col: 60, offset: 65027},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1932, col: 68, offset: 65035},
										name: "multiLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1932, col: 90, offset: 65057},
									label: "startPosI",
									expr: &choiceExpr{
										pos: position{line: 1889, col: 13, offset: 63135},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 1889, col: 13, offset: 63135},
												run: (*parser).callonTernaryExpression146,
												expr: &seqExpr{
													pos: position{line: 1889, col: 13, offset: 63135},
													exprs: []interface{}{
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 13, offset: 63135},
															expr: &litMatcher{
																pos:        position{line: 1889, col: 13, offset: 63135},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&litMatcher{
															pos:        position{line: 1889, col: 18, offset: 63140},
															val:        ",",
															ignoreCase: false,
															want:       "\",\"",
														},
														&labeledExpr{
															pos:   position{line: 1889, col: 22, offset: 63144},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonTernaryExpression152,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 31, offset: 63153},
															expr: &choiceExpr{
																pos: position{line: 3750, col: 20, offset: 128702},
																alternatives: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 3747, col: 36, offset: 128625},
																		exprs: []interface{}{
																			&zeroOrOneExpr{
																				pos: position{line: 3747, col: 36, offset: 128625},
																				expr: &litMatcher{
																					pos:        position{line: 3747, col: 36, offset: 128625},
																					val:        "\r",
																					ignoreCase: false,
																					want:       "\"\\r\"",
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 3747, col: 42, offset: 128631},
																				val:        "\n",
																				ignoreCase: false,
																				want:       "\"\\n\"",
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 1891, col: 5, offset: 63184},
												run: (*parser).callonTernaryExpression165,
												expr: &seqExpr{
													pos: position{line: 1891, col: 5, offset: 63184},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 1891, col: 5, offset: 63184},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonTernaryExpression168,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1891, col: 14, offset: 63193},
															expr: &litMatcher{
																pos:        position{line: 1891, col: 14, offset: 63193},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1932, col: 109, offset: 65076},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonTernaryExpression177,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineTernaryExpression",
			pos:  position{line: 1950, col: 1, offset: 65723},
			expr: &choiceExpr{
				pos: position{line: 1950, col: 32, offset: 65754},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 1950, col: 32, offset: 65754},
						run: (*parser).callonSingleLineTernaryExpression2,
						expr: &seqExpr{
							pos: position{line: 1950, col: 32, offset: 65754},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1950, col: 32, offset: 65754},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1950, col: 37, offset: 65759},
									expr: &litMatcher{
										pos:        position{line: 1950, col: 37, offset: 65759},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1950, col: 42, offset: 65764},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1950, col: 53, offset: 65775},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1950, col: 76, offset: 65798},
									expr: &litMatcher{
										pos:        position{line: 1950, col: 76, offset: 65798},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1950, col: 81, offset: 65803},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1950, col: 85, offset: 65807},
									expr: &litMatcher{
										pos:        position{line: 1950, col: 85, offset: 65807},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1950, col: 90, offset: 65812},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1950, col: 98, offset: 65820},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1950, col: 121, offset: 65843},
									expr: &litMatcher{
										pos:        position{line: 1950, col: 121, offset: 65843},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1950, col: 126, offset: 65848},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1950, col: 130, offset: 65852},
									expr: &litMatcher{
										pos:        position{line: 1950, col: 130, offset: 65852},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 1950, col: 135, offset: 65857},
									label: "ifFalseI",
									expr: &ruleRefExpr{
										pos:  position{line: 1950, col: 144, offset: 65866},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1950, col: 167, offset: 65889},
									expr: &litMatcher{
										pos:        position{line: 1950, col: 167, offset: 65889},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 1950, col: 172, offset: 65894},
									expr: &seqExpr{
										pos: position{line: 1950, col: 173, offset: 65895},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 1950, col: 173, offset: 65895},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 1950, col: 177, offset: 65899},
												expr: &litMatcher{
													pos:        position{line: 1950, col: 177, offset: 65899},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1950, col: 184, offset: 65906},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonSingleLineTernaryExpression31,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1958, col: 5, offset: 66187},
						run: (*parser).callonSingleLineTernaryExpression33,
						expr: &seqExpr{
							pos: position{line: 1958, col: 5, offset: 66187},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1958, col: 5, offset: 66187},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&labeledExpr{
									pos:   position{line: 1958, col: 10, offset: 66192},
									label: "startPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonSingleLineTernaryExpression37,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1958, col: 24, offset: 66206},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1958, col: 28, offset: 66210},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonSingleLineTernaryExpression51,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1972, col: 5, offset: 66801},
						run: (*parser).callonSingleLineTernaryExpression53,
						expr: &seqExpr{
							pos: position{line: 1972, col: 5, offset: 66801},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1972, col: 5, offset: 66801},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1972, col: 10, offset: 66806},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1972, col: 14, offset: 66810},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1972, col: 25, offset: 66821},
										name: "SingleLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1972, col: 48, offset: 66844},
									label: "startPosI",
									expr: &choiceExpr{
										pos: position{line: 1889, col: 13, offset: 63135},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 1889, col: 13, offset: 63135},
												run: (*parser).callonSingleLineTernaryExpression67,
												expr: &seqExpr{
													pos: position{line: 1889, col: 13, offset: 63135},
													exprs: []interface{}{
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 13, offset: 63135},
															expr: &litMatcher{
																pos:        position{line: 1889, col: 13, offset: 63135},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&litMatcher{
															pos:        position{line: 1889, col: 18, offset: 63140},
															val:        ",",
															ignoreCase: false,
															want:       "\",\"",
														},
														&labeledExpr{
															pos:   position{line: 1889, col: 22, offset: 63144},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonSingleLineTernaryExpression73,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 31, offset: 63153},
															expr: &choiceExpr{
																pos: position{line: 3750, col: 20, offset: 128702},
																alternatives: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 3747, col: 36, offset: 128625},
																		exprs: []interface{}{
																			&zeroOrOneExpr{
																				pos: position{line: 3747, col: 36, offset: 128625},
																				expr: &litMatcher{
																					pos:        position{line: 3747, col: 36, offset: 128625},
																					val:        "\r",
																					ignoreCase: false,
																					want:       "\"\\r\"",
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 3747, col: 42, offset: 128631},
																				val:        "\n",
																				ignoreCase: false,
																				want:       "\"\\n\"",
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 1891, col: 5, offset: 63184},
												run: (*parser).callonSingleLineTernaryExpression86,
												expr: &seqExpr{
													pos: position{line: 1891, col: 5, offset: 63184},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 1891, col: 5, offset: 63184},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonSingleLineTernaryExpression89,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1891, col: 14, offset: 63193},
															expr: &litMatcher{
																pos:        position{line: 1891, col: 14, offset: 63193},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1972, col: 67, offset: 66863},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonSingleLineTernaryExpression98,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1987, col: 5, offset: 67489},
						run: (*parser).callonSingleLineTernaryExpression100,
						expr: &seqExpr{
							pos: position{line: 1987, col: 5, offset: 67489},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 1987, col: 5, offset: 67489},
									val:        "?(",
									ignoreCase: false,
									want:       "\"?(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1987, col: 10, offset: 67494},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1987, col: 14, offset: 67498},
									label: "conditionI",
									expr: &ruleRefExpr{
										pos:  position{line: 1987, col: 25, offset: 67509},
										name: "SingleLineGoExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 1987, col: 48, offset: 67532},
									expr: &litMatcher{
										pos:        position{line: 1987, col: 48, offset: 67532},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 1987, col: 53, offset: 67537},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 1987, col: 57, offset: 67541},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1987, col: 61, offset: 67545},
									label: "ifTrueI",
									expr: &ruleRefExpr{
										pos:  position{line: 1987, col: 69, offset: 67553},
										name: "SingleLineGoExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 1987, col: 92, offset: 67576},
									label: "startPosI",
									expr: &choiceExpr{
										pos: position{line: 1889, col: 13, offset: 63135},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 1889, col: 13, offset: 63135},
												run: (*parser).callonSingleLineTernaryExpression126,
												expr: &seqExpr{
													pos: position{line: 1889, col: 13, offset: 63135},
													exprs: []interface{}{
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 13, offset: 63135},
															expr: &litMatcher{
																pos:        position{line: 1889, col: 13, offset: 63135},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
														&litMatcher{
															pos:        position{line: 1889, col: 18, offset: 63140},
															val:        ",",
															ignoreCase: false,
															want:       "\",\"",
														},
														&labeledExpr{
															pos:   position{line: 1889, col: 22, offset: 63144},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonSingleLineTernaryExpression132,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1889, col: 31, offset: 63153},
															expr: &choiceExpr{
																pos: position{line: 3750, col: 20, offset: 128702},
																alternatives: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&seqExpr{
																		pos: position{line: 3747, col: 36, offset: 128625},
																		exprs: []interface{}{
																			&zeroOrOneExpr{
																				pos: position{line: 3747, col: 36, offset: 128625},
																				expr: &litMatcher{
																					pos:        position{line: 3747, col: 36, offset: 128625},
																					val:        "\r",
																					ignoreCase: false,
																					want:       "\"\\r\"",
																				},
																			},
																			&litMatcher{
																				pos:        position{line: 3747, col: 42, offset: 128631},
																				val:        "\n",
																				ignoreCase: false,
																				want:       "\"\\n\"",
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 1891, col: 5, offset: 63184},
												run: (*parser).callonSingleLineTernaryExpression145,
												expr: &seqExpr{
													pos: position{line: 1891, col: 5, offset: 63184},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 1891, col: 5, offset: 63184},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonSingleLineTernaryExpression148,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&zeroOrMoreExpr{
															pos: position{line: 1891, col: 14, offset: 63193},
															expr: &litMatcher{
																pos:        position{line: 1891, col: 14, offset: 63193},
																val:        " ",
																ignoreCase: false,
																want:       "\" \"",
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 1987, col: 111, offset: 67595},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonSingleLineTernaryExpression157,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ChainExpression",
			pos:  position{line: 2009, col: 1, offset: 68433},
			expr: &choiceExpr{
				pos: position{line: 2009, col: 20, offset: 68452},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2009, col: 20, offset: 68452},
						run: (*parser).callonChainExpression2,
						expr: &seqExpr{
							pos: position{line: 2009, col: 20, offset: 68452},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 2009, col: 20, offset: 68452},
									label: "derefsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2009, col: 28, offset: 68460},
										expr: &litMatcher{
											pos:        position{line: 2009, col: 28, offset: 68460},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2009, col: 33, offset: 68465},
									label: "rootI",
									expr: &ruleRefExpr{
										pos:  position{line: 2009, col: 39, offset: 68471},
										name: "chainExpressionRoot",
									},
								},
								&labeledExpr{
									pos:   position{line: 2009, col: 59, offset: 68491},
									label: "checkRootI",
									expr: &litMatcher{
										pos:        position{line: 2009, col: 70, offset: 68502},
										val:        "?",
										ignoreCase: false,
										want:       "\"?\"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2009, col: 74, offset: 68506},
									label: "chainI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2009, col: 81, offset: 68513},
										expr: &ruleRefExpr{
											pos:  position{line: 2009, col: 81, offset: 68513},
											name: "ChainExpressionItem",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2010, col: 20, offset: 68553},
									label: "defaultI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2010, col: 29, offset: 68562},
										expr: &seqExpr{
											pos: position{line: 2010, col: 30, offset: 68563},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 2010, col: 30, offset: 68563},
													expr: &litMatcher{
														pos:        position{line: 2010, col: 30, offset: 68563},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&labeledExpr{
													pos:   position{line: 2010, col: 35, offset: 68568},
													label: "defaultPosI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonChainExpression20,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
												&litMatcher{
													pos:        position{line: 2010, col: 51, offset: 68584},
													val:        "~",
													ignoreCase: false,
													want:       "\"~\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 2010, col: 55, offset: 68588},
													expr: &choiceExpr{
														pos: position{line: 3750, col: 20, offset: 128702},
														alternatives: []interface{}{
															&charClassMatcher{
																pos:        position{line: 3746, col: 36, offset: 128584},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
															&seqExpr{
																pos: position{line: 3747, col: 36, offset: 128625},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 3747, col: 36, offset: 128625},
																		expr: &litMatcher{
																			pos:        position{line: 3747, col: 36, offset: 128625},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3747, col: 42, offset: 128631},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
														},
													},
												},
												&ruleRefExpr{
													pos:  position{line: 2010, col: 59, offset: 68592},
													name: "GoExpression",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2010, col: 74, offset: 68607},
									label: "endPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonChainExpression36,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&andExpr{
									pos: position{line: 2010, col: 86, offset: 68619},
									expr: &choiceExpr{
										pos: position{line: 2010, col: 88, offset: 68621},
										alternatives: []interface{}{
											&seqExpr{
												pos: position{line: 3734, col: 12, offset: 128237},
												exprs: []interface{}{
													&zeroOrMoreExpr{
														pos: position{line: 3734, col: 12, offset: 128237},
														expr: &charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3734, col: 16, offset: 128241},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		expr: &litMatcher{
																			pos:        position{line: 3734, col: 16, offset: 128241},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3734, col: 22, offset: 128247},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3733, col: 12, offset: 128223},
																expr: &anyMatcher{
																	line: 3733, col: 13, offset: 128224,
																},
															},
														},
													},
												},
											},
											&seqExpr{
												pos: position{line: 2010, col: 94, offset: 68627},
												exprs: []interface{}{
													&zeroOrMoreExpr{
														pos: position{line: 2010, col: 94, offset: 68627},
														expr: &litMatcher{
															pos:        position{line: 2010, col: 94, offset: 68627},
															val:        " ",
															ignoreCase: false,
															want:       "\" \"",
														},
													},
													&choiceExpr{
														pos: position{line: 1269, col: 25, offset: 40699},
														alternatives: []interface{}{
															&charClassMatcher{
																pos:        position{line: 1269, col: 25, offset: 40699},
																val:        "[)}],]",
																chars:      []rune{')', '}', ']', ','},
																ignoreCase: false,
																inverted:   false,
															},
															&seqExpr{
																pos: position{line: 1269, col: 40, offset: 40714},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 1269, col: 40, offset: 40714},
																		val:        ":",
																		ignoreCase: false,
																		want:       "\":\"",
																	},
																	&notExpr{
																		pos: position{line: 1269, col: 44, offset: 40718},
																		expr: &litMatcher{
																			pos:        position{line: 1269, col: 45, offset: 40719},
																			val:        "=",
																			ignoreCase: false,
																			want:       "\"=\"",
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&andCodeExpr{
									pos: position{line: 2010, col: 121, offset: 68654},
									run: (*parser).callonChainExpression63,
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 2028, col: 5, offset: 69246},
						exprs: []interface{}{
							&labeledExpr{
								pos:   position{line: 2028, col: 5, offset: 69246},
								label: "startPosI",
								expr: &actionExpr{
									pos: position{line: 3737, col: 8, offset: 128286},
									run: (*parser).callonChainExpression66,
									expr: &choiceExpr{
										pos: position{line: 3737, col: 9, offset: 128287},
										alternatives: []interface{}{
											&andExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												expr: &anyMatcher{
													line: 3737, col: 10, offset: 128288,
												},
											},
											&notExpr{
												pos: position{line: 3737, col: 14, offset: 128292},
												expr: &anyMatcher{
													line: 3737, col: 15, offset: 128293,
												},
											},
										},
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 2028, col: 19, offset: 69260},
								label: "derefsI",
								expr: &zeroOrMoreExpr{
									pos: position{line: 2028, col: 27, offset: 69268},
									expr: &litMatcher{
										pos:        position{line: 2028, col: 27, offset: 69268},
										val:        "*",
										ignoreCase: false,
										want:       "\"*\"",
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 2028, col: 32, offset: 69273},
								label: "rootI",
								expr: &ruleRefExpr{
									pos:  position{line: 2028, col: 38, offset: 69279},
									name: "chainExpressionRoot",
								},
							},
							&labeledExpr{
								pos:   position{line: 2028, col: 58, offset: 69299},
								label: "checkRootI",
								expr: &litMatcher{
									pos:        position{line: 2028, col: 69, offset: 69310},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
							&labeledExpr{
								pos:   position{line: 2028, col: 73, offset: 69314},
								label: "chainI",
								expr: &zeroOrMoreExpr{
									pos: position{line: 2028, col: 80, offset: 69321},
									expr: &ruleRefExpr{
										pos:  position{line: 2028, col: 80, offset: 69321},
										name: "ChainExpressionItem",
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 2028, col: 101, offset: 69342},
								label: "endPosI",
								expr: &actionExpr{
									pos: position{line: 3737, col: 8, offset: 128286},
									run: (*parser).callonChainExpression83,
									expr: &choiceExpr{
										pos: position{line: 3737, col: 9, offset: 128287},
										alternatives: []interface{}{
											&andExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												expr: &anyMatcher{
													line: 3737, col: 10, offset: 128288,
												},
											},
											&notExpr{
												pos: position{line: 3737, col: 14, offset: 128292},
												expr: &anyMatcher{
													line: 3737, col: 15, offset: 128293,
												},
											},
										},
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 2028, col: 113, offset: 69354},
								run: (*parser).callonChainExpression89,
							},
							&labeledExpr{
								pos:   position{line: 2030, col: 3, offset: 69420},
								label: "malStartPosI",
								expr: &actionExpr{
									pos: position{line: 3737, col: 8, offset: 128286},
									run: (*parser).callonChainExpression91,
									expr: &choiceExpr{
										pos: position{line: 3737, col: 9, offset: 128287},
										alternatives: []interface{}{
											&andExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												expr: &anyMatcher{
													line: 3737, col: 10, offset: 128288,
												},
											},
											&notExpr{
												pos: position{line: 3737, col: 14, offset: 128292},
												expr: &anyMatcher{
													line: 3737, col: 15, offset: 128293,
												},
											},
										},
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 2030, col: 20, offset: 69437},
								name: "GoExpression",
							},
							&labeledExpr{
								pos:   position{line: 2030, col: 33, offset: 69450},
								label: "malEndPosI",
								expr: &actionExpr{
									pos: position{line: 3737, col: 8, offset: 128286},
									run: (*parser).callonChainExpression99,
									expr: &choiceExpr{
										pos: position{line: 3737, col: 9, offset: 128287},
										alternatives: []interface{}{
											&andExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												expr: &anyMatcher{
													line: 3737, col: 10, offset: 128288,
												},
											},
											&notExpr{
												pos: position{line: 3737, col: 14, offset: 128292},
												expr: &anyMatcher{
													line: 3737, col: 15, offset: 128293,
												},
											},
										},
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 2030, col: 48, offset: 69465},
								run: (*parser).callonChainExpression105,
							},
						},
					},
				},
			},
		},
		{
			name: "chainExpressionRoot",
			pos:  position{line: 2063, col: 1, offset: 70693},
			expr: &choiceExpr{
				pos: position{line: 2063, col: 24, offset: 70716},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2063, col: 24, offset: 70716},
						run: (*parser).callonchainExpressionRoot2,
						expr: &seqExpr{
							pos: position{line: 2063, col: 24, offset: 70716},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2063, col: 24, offset: 70716},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 2063, col: 28, offset: 70720},
									expr: &ruleRefExpr{
										pos:  position{line: 2063, col: 28, offset: 70720},
										name: "chainExpressionRootParenContent",
									},
								},
								&litMatcher{
									pos:        position{line: 2063, col: 61, offset: 70753},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2068, col: 5, offset: 70866},
						run: (*parser).callonchainExpressionRoot8,
						expr: &labeledExpr{
							pos:   position{line: 2068, col: 5, offset: 70866},
							label: "identI",
							expr: &choiceExpr{
								pos: position{line: 2319, col: 12, offset: 79887},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 2319, col: 12, offset: 79887},
										run: (*parser).callonchainExpressionRoot11,
										expr: &labeledExpr{
											pos:   position{line: 2319, col: 12, offset: 79887},
											label: "ident",
											expr: &seqExpr{
												pos: position{line: 2367, col: 17, offset: 81233},
												exprs: []interface{}{
													&charClassMatcher{
														pos:        position{line: 2350, col: 20, offset: 80988},
														val:        "[_\\pL]",
														chars:      []rune{'_'},
														classes:    []*unicode.RangeTable{rangeTable("L")},
														ignoreCase: false,
														inverted:   false,
													},
													&zeroOrMoreExpr{
														pos: position{line: 2367, col: 26, offset: 81242},
														expr: &charClassMatcher{
															pos:        position{line: 2350, col: 20, offset: 80988},
															val:        "[_\\pL\\pNd]",
															chars:      []rune{'_'},
															classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
															ignoreCase: false,
															inverted:   false,
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 2321, col: 5, offset: 79981},
										run: (*parser).callonchainExpressionRoot17,
										expr: &seqExpr{
											pos: position{line: 2321, col: 5, offset: 79981},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 2321, col: 5, offset: 79981},
													label: "identI",
													expr: &seqExpr{
														pos: position{line: 2321, col: 13, offset: 79989},
														exprs: []interface{}{
															&zeroOrOneExpr{
																pos: position{line: 2321, col: 13, offset: 79989},
																expr: &litMatcher{
																	pos:        position{line: 2321, col: 13, offset: 79989},
																	val:        "$",
																	ignoreCase: false,
																	want:       "\"$\"",
																},
															},
															&oneOrMoreExpr{
																pos: position{line: 2321, col: 18, offset: 79994},
																expr: &choiceExpr{
																	pos: position{line: 2321, col: 19, offset: 79995},
																	alternatives: []interface{}{
																		&seqExpr{
																			pos: position{line: 2321, col: 19, offset: 79995},
																			exprs: []interface{}{
																				&charClassMatcher{
																					pos:        position{line: 2321, col: 19, offset: 79995},
																					val:        "[\\pNd]",
																					classes:    []*unicode.RangeTable{rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																				&charClassMatcher{
																					pos:        position{line: 2321, col: 28, offset: 80004},
																					val:        "[_-\\pL]",
																					chars:      []rune{'_', '-'},
																					classes:    []*unicode.RangeTable{rangeTable("L")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																		&charClassMatcher{
																			pos:        position{line: 2321, col: 38, offset: 80014},
																			val:        "[_-\\pL]",
																			chars:      []rune{'_', '-'},
																			classes:    []*unicode.RangeTable{rangeTable("L")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 2321, col: 49, offset: 80025},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonchainExpressionRoot30,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "chainExpressionRootParenContent",
			pos:  position{line: 2075, col: 1, offset: 71028},
			expr: &choiceExpr{
				pos: position{line: 2075, col: 36, offset: 71063},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2075, col: 36, offset: 71063},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2075, col: 36, offset: 71063},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2075, col: 40, offset: 71067},
								name: "chainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2075, col: 72, offset: 71099},
								val:        ")",
								ignoreCase: false,
								want:       "\")\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2076, col: 36, offset: 71140},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2076, col: 36, offset: 71140},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2076, col: 40, offset: 71144},
								name: "chainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2076, col: 72, offset: 71176},
								val:        "]",
								ignoreCase: false,
								want:       "\"]\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2077, col: 36, offset: 71217},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2077, col: 36, offset: 71217},
								val:        "{",
								ignoreCase: false,
								want:       "\"{\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2077, col: 40, offset: 71221},
								name: "chainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2077, col: 72, offset: 71253},
								val:        "}",
								ignoreCase: false,
								want:       "\"}\"",
							},
						},
					},
					&oneOrMoreExpr{
						pos: position{line: 2078, col: 36, offset: 71294},
						expr: &charClassMatcher{
							pos:        position{line: 2078, col: 36, offset: 71294},
							val:        "[^({[]})]",
							chars:      []rune{'(', '{', '[', ']', '}', ')'},
							ignoreCase: false,
							inverted:   true,
						},
					},
				},
			},
		},
		{
			name: "SingleLineChainExpression",
			pos:  position{line: 2080, col: 1, offset: 71307},
			expr: &choiceExpr{
				pos: position{line: 2080, col: 30, offset: 71336},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2080, col: 30, offset: 71336},
						run: (*parser).callonSingleLineChainExpression2,
						expr: &seqExpr{
							pos: position{line: 2080, col: 30, offset: 71336},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 2080, col: 30, offset: 71336},
									label: "derefsI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2080, col: 38, offset: 71344},
										expr: &litMatcher{
											pos:        position{line: 2080, col: 38, offset: 71344},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2080, col: 43, offset: 71349},
									label: "rootI",
									expr: &ruleRefExpr{
										pos:  position{line: 2080, col: 49, offset: 71355},
										name: "chainExpressionRoot",
									},
								},
								&labeledExpr{
									pos:   position{line: 2080, col: 69, offset: 71375},
									label: "checkRootI",
									expr: &litMatcher{
										pos:        position{line: 2080, col: 80, offset: 71386},
										val:        "?",
										ignoreCase: false,
										want:       "\"?\"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2080, col: 84, offset: 71390},
									label: "chainI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 2080, col: 91, offset: 71397},
										expr: &ruleRefExpr{
											pos:  position{line: 2080, col: 91, offset: 71397},
											name: "SingleLineChainExpressionItem",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2081, col: 30, offset: 71457},
									label: "defaultI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2081, col: 39, offset: 71466},
										expr: &seqExpr{
											pos: position{line: 2081, col: 40, offset: 71467},
											exprs: []interface{}{
												&zeroOrMoreExpr{
													pos: position{line: 2081, col: 40, offset: 71467},
													expr: &litMatcher{
														pos:        position{line: 2081, col: 40, offset: 71467},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&labeledExpr{
													pos:   position{line: 2081, col: 45, offset: 71472},
													label: "defaultPosI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonSingleLineChainExpression20,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
												&litMatcher{
													pos:        position{line: 2081, col: 61, offset: 71488},
													val:        "?!",
													ignoreCase: false,
													want:       "\"?!\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 2081, col: 66, offset: 71493},
													expr: &litMatcher{
														pos:        position{line: 2081, col: 66, offset: 71493},
														val:        " ",
														ignoreCase: false,
														want:       "\" \"",
													},
												},
												&ruleRefExpr{
													pos:  position{line: 2081, col: 71, offset: 71498},
													name: "SingleLineGoExpression",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2081, col: 96, offset: 71523},
									label: "endPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonSingleLineChainExpression31,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&andExpr{
									pos: position{line: 2081, col: 108, offset: 71535},
									expr: &choiceExpr{
										pos: position{line: 2081, col: 110, offset: 71537},
										alternatives: []interface{}{
											&seqExpr{
												pos: position{line: 3734, col: 12, offset: 128237},
												exprs: []interface{}{
													&zeroOrMoreExpr{
														pos: position{line: 3734, col: 12, offset: 128237},
														expr: &charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3734, col: 16, offset: 128241},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		expr: &litMatcher{
																			pos:        position{line: 3734, col: 16, offset: 128241},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3734, col: 22, offset: 128247},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3733, col: 12, offset: 128223},
																expr: &anyMatcher{
																	line: 3733, col: 13, offset: 128224,
																},
															},
														},
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 1269, col: 25, offset: 40699},
												val:        "[)}],]",
												chars:      []rune{')', '}', ']', ','},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 1269, col: 40, offset: 40714},
												exprs: []interface{}{
													&litMatcher{
														pos:        position{line: 1269, col: 40, offset: 40714},
														val:        ":",
														ignoreCase: false,
														want:       "\":\"",
													},
													&notExpr{
														pos: position{line: 1269, col: 44, offset: 40718},
														expr: &litMatcher{
															pos:        position{line: 1269, col: 45, offset: 40719},
															val:        "=",
															ignoreCase: false,
															want:       "\"=\"",
														},
													},
												},
											},
										},
									},
								},
								&andCodeExpr{
									pos: position{line: 2081, col: 138, offset: 71565},
									run: (*parser).callonSingleLineChainExpression54,
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 2099, col: 5, offset: 72157},
						exprs: []interface{}{
							&labeledExpr{
								pos:   position{line: 2099, col: 5, offset: 72157},
								label: "startPosI",
								expr: &actionExpr{
									pos: position{line: 3737, col: 8, offset: 128286},
									run: (*parser).callonSingleLineChainExpression57,
									expr: &choiceExpr{
										pos: position{line: 3737, col: 9, offset: 128287},
										alternatives: []interface{}{
											&andExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												expr: &anyMatcher{
													line: 3737, col: 10, offset: 128288,
												},
											},
											&notExpr{
												pos: position{line: 3737, col: 14, offset: 128292},
												expr: &anyMatcher{
													line: 3737, col: 15, offset: 128293,
												},
											},
										},
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 2099, col: 19, offset: 72171},
								label: "derefsI",
								expr: &zeroOrMoreExpr{
									pos: position{line: 2099, col: 27, offset: 72179},
									expr: &litMatcher{
										pos:        position{line: 2099, col: 27, offset: 72179},
										val:        "*",
										ignoreCase: false,
										want:       "\"*\"",
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 2099, col: 32, offset: 72184},
								label: "rootI",
								expr: &ruleRefExpr{
									pos:  position{line: 2099, col: 38, offset: 72190},
									name: "chainExpressionRoot",
								},
							},
							&labeledExpr{
								pos:   position{line: 2099, col: 58, offset: 72210},
								label: "checkRootI",
								expr: &litMatcher{
									pos:        position{line: 2099, col: 69, offset: 72221},
									val:        "?",
									ignoreCase: false,
									want:       "\"?\"",
								},
							},
							&labeledExpr{
								pos:   position{line: 2099, col: 73, offset: 72225},
								label: "chainI",
								expr: &zeroOrMoreExpr{
									pos: position{line: 2099, col: 80, offset: 72232},
									expr: &ruleRefExpr{
										pos:  position{line: 2099, col: 80, offset: 72232},
										name: "SingleLineChainExpressionItem",
									},
								},
							},
							&labeledExpr{
								pos:   position{line: 2099, col: 111, offset: 72263},
								label: "endPosI",
								expr: &actionExpr{
									pos: position{line: 3737, col: 8, offset: 128286},
									run: (*parser).callonSingleLineChainExpression74,
									expr: &choiceExpr{
										pos: position{line: 3737, col: 9, offset: 128287},
										alternatives: []interface{}{
											&andExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												expr: &anyMatcher{
													line: 3737, col: 10, offset: 128288,
												},
											},
											&notExpr{
												pos: position{line: 3737, col: 14, offset: 128292},
												expr: &anyMatcher{
													line: 3737, col: 15, offset: 128293,
												},
											},
										},
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 2099, col: 123, offset: 72275},
								run: (*parser).callonSingleLineChainExpression80,
							},
							&labeledExpr{
								pos:   position{line: 2101, col: 3, offset: 72341},
								label: "malStartPosI",
								expr: &actionExpr{
									pos: position{line: 3737, col: 8, offset: 128286},
									run: (*parser).callonSingleLineChainExpression82,
									expr: &choiceExpr{
										pos: position{line: 3737, col: 9, offset: 128287},
										alternatives: []interface{}{
											&andExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												expr: &anyMatcher{
													line: 3737, col: 10, offset: 128288,
												},
											},
											&notExpr{
												pos: position{line: 3737, col: 14, offset: 128292},
												expr: &anyMatcher{
													line: 3737, col: 15, offset: 128293,
												},
											},
										},
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 2101, col: 20, offset: 72358},
								name: "GoExpression",
							},
							&labeledExpr{
								pos:   position{line: 2101, col: 33, offset: 72371},
								label: "malEndPosI",
								expr: &actionExpr{
									pos: position{line: 3737, col: 8, offset: 128286},
									run: (*parser).callonSingleLineChainExpression90,
									expr: &choiceExpr{
										pos: position{line: 3737, col: 9, offset: 128287},
										alternatives: []interface{}{
											&andExpr{
												pos: position{line: 3737, col: 9, offset: 128287},
												expr: &anyMatcher{
													line: 3737, col: 10, offset: 128288,
												},
											},
											&notExpr{
												pos: position{line: 3737, col: 14, offset: 128292},
												expr: &anyMatcher{
													line: 3737, col: 15, offset: 128293,
												},
											},
										},
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 2101, col: 48, offset: 72386},
								run: (*parser).callonSingleLineChainExpression96,
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineChainExpressionRootParenContent",
			pos:  position{line: 2141, col: 1, offset: 73800},
			expr: &choiceExpr{
				pos: position{line: 2141, col: 46, offset: 73845},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2141, col: 46, offset: 73845},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2141, col: 46, offset: 73845},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2141, col: 50, offset: 73849},
								name: "singleLineChainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2141, col: 92, offset: 73891},
								val:        ")",
								ignoreCase: false,
								want:       "\")\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2142, col: 46, offset: 73942},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2142, col: 46, offset: 73942},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2142, col: 50, offset: 73946},
								name: "singleLineChainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2142, col: 92, offset: 73988},
								val:        "]",
								ignoreCase: false,
								want:       "\"]\"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 2143, col: 46, offset: 74039},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2143, col: 46, offset: 74039},
								val:        "{",
								ignoreCase: false,
								want:       "\"{\"",
							},
							&ruleRefExpr{
								pos:  position{line: 2143, col: 50, offset: 74043},
								name: "singleLineChainExpressionRootParenContent",
							},
							&litMatcher{
								pos:        position{line: 2143, col: 92, offset: 74085},
								val:        "}",
								ignoreCase: false,
								want:       "\"}\"",
							},
						},
					},
					&oneOrMoreExpr{
						pos: position{line: 2144, col: 46, offset: 74136},
						expr: &charClassMatcher{
							pos:        position{line: 2144, col: 46, offset: 74136},
							val:        "[^({[]})\\r\\n]",
							chars:      []rune{'(', '{', '[', ']', '}', ')', '\r', '\n'},
							ignoreCase: false,
							inverted:   true,
						},
					},
				},
			},
		},
		{
			name: "ChainExpressionItem",
			pos:  position{line: 2150, col: 1, offset: 74185},
			expr: &choiceExpr{
				pos: position{line: 2150, col: 34, offset: 74218},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2150, col: 34, offset: 74218},
						name: "IndexExpression",
					},
					&actionExpr{
						pos: position{line: 2174, col: 23, offset: 75250},
						run: (*parser).callonChainExpressionItem3,
						expr: &seqExpr{
							pos: position{line: 2174, col: 23, offset: 75250},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2174, col: 23, offset: 75250},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2174, col: 27, offset: 75254},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2174, col: 31, offset: 75258},
									label: "identI",
									expr: &choiceExpr{
										pos: position{line: 2319, col: 12, offset: 79887},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 2319, col: 12, offset: 79887},
												run: (*parser).callonChainExpressionItem15,
												expr: &labeledExpr{
													pos:   position{line: 2319, col: 12, offset: 79887},
													label: "ident",
													expr: &seqExpr{
														pos: position{line: 2367, col: 17, offset: 81233},
														exprs: []interface{}{
															&charClassMatcher{
																pos:        position{line: 2350, col: 20, offset: 80988},
																val:        "[_\\pL]",
																chars:      []rune{'_'},
																classes:    []*unicode.RangeTable{rangeTable("L")},
																ignoreCase: false,
																inverted:   false,
															},
															&zeroOrMoreExpr{
																pos: position{line: 2367, col: 26, offset: 81242},
																expr: &charClassMatcher{
																	pos:        position{line: 2350, col: 20, offset: 80988},
																	val:        "[_\\pL\\pNd]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 2321, col: 5, offset: 79981},
												run: (*parser).callonChainExpressionItem21,
												expr: &seqExpr{
													pos: position{line: 2321, col: 5, offset: 79981},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 2321, col: 5, offset: 79981},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2321, col: 13, offset: 79989},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 2321, col: 13, offset: 79989},
																		expr: &litMatcher{
																			pos:        position{line: 2321, col: 13, offset: 79989},
																			val:        "$",
																			ignoreCase: false,
																			want:       "\"$\"",
																		},
																	},
																	&oneOrMoreExpr{
																		pos: position{line: 2321, col: 18, offset: 79994},
																		expr: &choiceExpr{
																			pos: position{line: 2321, col: 19, offset: 79995},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 2321, col: 19, offset: 79995},
																					exprs: []interface{}{
																						&charClassMatcher{
																							pos:        position{line: 2321, col: 19, offset: 79995},
																							val:        "[\\pNd]",
																							classes:    []*unicode.RangeTable{rangeTable("Nd")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2321, col: 28, offset: 80004},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2321, col: 38, offset: 80014},
																					val:        "[_-\\pL]",
																					chars:      []rune{'_', '-'},
																					classes:    []*unicode.RangeTable{rangeTable("L")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 2321, col: 49, offset: 80025},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonChainExpressionItem34,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2174, col: 46, offset: 75273},
									label: "checkI",
									expr: &litMatcher{
										pos:        position{line: 2174, col: 53, offset: 75280},
										val:        "?",
										ignoreCase: false,
										want:       "\"?\"",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2150, col: 73, offset: 74257},
						name: "ParenExpression",
					},
					&actionExpr{
						pos: position{line: 2230, col: 28, offset: 76962},
						run: (*parser).callonChainExpressionItem43,
						expr: &seqExpr{
							pos: position{line: 2230, col: 28, offset: 76962},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2230, col: 28, offset: 76962},
									val:        ".(",
									ignoreCase: false,
									want:       "\".(\"",
								},
								&labeledExpr{
									pos:   position{line: 2230, col: 33, offset: 76967},
									label: "packageI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2230, col: 42, offset: 76976},
										expr: &seqExpr{
											pos: position{line: 2230, col: 43, offset: 76977},
											exprs: []interface{}{
												&choiceExpr{
													pos: position{line: 2319, col: 12, offset: 79887},
													alternatives: []interface{}{
														&actionExpr{
															pos: position{line: 2319, col: 12, offset: 79887},
															run: (*parser).callonChainExpressionItem50,
															expr: &labeledExpr{
																pos:   position{line: 2319, col: 12, offset: 79887},
																label: "ident",
																expr: &seqExpr{
																	pos: position{line: 2367, col: 17, offset: 81233},
																	exprs: []interface{}{
																		&charClassMatcher{
																			pos:        position{line: 2350, col: 20, offset: 80988},
																			val:        "[_\\pL]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 2367, col: 26, offset: 81242},
																			expr: &charClassMatcher{
																				pos:        position{line: 2350, col: 20, offset: 80988},
																				val:        "[_\\pL\\pNd]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 2321, col: 5, offset: 79981},
															run: (*parser).callonChainExpressionItem56,
															expr: &seqExpr{
																pos: position{line: 2321, col: 5, offset: 79981},
																exprs: []interface{}{
																	&labeledExpr{
																		pos:   position{line: 2321, col: 5, offset: 79981},
																		label: "identI",
																		expr: &seqExpr{
																			pos: position{line: 2321, col: 13, offset: 79989},
																			exprs: []interface{}{
																				&zeroOrOneExpr{
																					pos: position{line: 2321, col: 13, offset: 79989},
																					expr: &litMatcher{
																						pos:        position{line: 2321, col: 13, offset: 79989},
																						val:        "$",
																						ignoreCase: false,
																						want:       "\"$\"",
																					},
																				},
																				&oneOrMoreExpr{
																					pos: position{line: 2321, col: 18, offset: 79994},
																					expr: &choiceExpr{
																						pos: position{line: 2321, col: 19, offset: 79995},
																						alternatives: []interface{}{
																							&seqExpr{
																								pos: position{line: 2321, col: 19, offset: 79995},
																								exprs: []interface{}{
																									&charClassMatcher{
																										pos:        position{line: 2321, col: 19, offset: 79995},
																										val:        "[\\pNd]",
																										classes:    []*unicode.RangeTable{rangeTable("Nd")},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2321, col: 28, offset: 80004},
																										val:        "[_-\\pL]",
																										chars:      []rune{'_', '-'},
																										classes:    []*unicode.RangeTable{rangeTable("L")},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&charClassMatcher{
																								pos:        position{line: 2321, col: 38, offset: 80014},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&labeledExpr{
																		pos:   position{line: 2321, col: 49, offset: 80025},
																		label: "endPosI",
																		expr: &actionExpr{
																			pos: position{line: 3737, col: 8, offset: 128286},
																			run: (*parser).callonChainExpressionItem69,
																			expr: &choiceExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				alternatives: []interface{}{
																					&andExpr{
																						pos: position{line: 3737, col: 9, offset: 128287},
																						expr: &anyMatcher{
																							line: 3737, col: 10, offset: 128288,
																						},
																					},
																					&notExpr{
																						pos: position{line: 3737, col: 14, offset: 128292},
																						expr: &anyMatcher{
																							line: 3737, col: 15, offset: 128293,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												&litMatcher{
													pos:        position{line: 2230, col: 51, offset: 76985},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2230, col: 57, offset: 76991},
									label: "typeI",
									expr: &choiceExpr{
										pos: position{line: 2319, col: 12, offset: 79887},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 2319, col: 12, offset: 79887},
												run: (*parser).callonChainExpressionItem78,
												expr: &labeledExpr{
													pos:   position{line: 2319, col: 12, offset: 79887},
													label: "ident",
													expr: &seqExpr{
														pos: position{line: 2367, col: 17, offset: 81233},
														exprs: []interface{}{
															&charClassMatcher{
																pos:        position{line: 2350, col: 20, offset: 80988},
																val:        "[_\\pL]",
																chars:      []rune{'_'},
																classes:    []*unicode.RangeTable{rangeTable("L")},
																ignoreCase: false,
																inverted:   false,
															},
															&zeroOrMoreExpr{
																pos: position{line: 2367, col: 26, offset: 81242},
																expr: &charClassMatcher{
																	pos:        position{line: 2350, col: 20, offset: 80988},
																	val:        "[_\\pL\\pNd]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 2321, col: 5, offset: 79981},
												run: (*parser).callonChainExpressionItem84,
												expr: &seqExpr{
													pos: position{line: 2321, col: 5, offset: 79981},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 2321, col: 5, offset: 79981},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2321, col: 13, offset: 79989},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 2321, col: 13, offset: 79989},
																		expr: &litMatcher{
																			pos:        position{line: 2321, col: 13, offset: 79989},
																			val:        "$",
																			ignoreCase: false,
																			want:       "\"$\"",
																		},
																	},
																	&oneOrMoreExpr{
																		pos: position{line: 2321, col: 18, offset: 79994},
																		expr: &choiceExpr{
																			pos: position{line: 2321, col: 19, offset: 79995},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 2321, col: 19, offset: 79995},
																					exprs: []interface{}{
																						&charClassMatcher{
																							pos:        position{line: 2321, col: 19, offset: 79995},
																							val:        "[\\pNd]",
																							classes:    []*unicode.RangeTable{rangeTable("Nd")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2321, col: 28, offset: 80004},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2321, col: 38, offset: 80014},
																					val:        "[_-\\pL]",
																					chars:      []rune{'_', '-'},
																					classes:    []*unicode.RangeTable{rangeTable("L")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 2321, col: 49, offset: 80025},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonChainExpressionItem97,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2230, col: 71, offset: 77005},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonChainExpressionItem104,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2230, col: 90, offset: 77024},
									label: "checkI",
									expr: &litMatcher{
										pos:        position{line: 2230, col: 97, offset: 77031},
										val:        "?",
										ignoreCase: false,
										want:       "\"?\"",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineChainExpressionItem",
			pos:  position{line: 2151, col: 1, offset: 74299},
			expr: &choiceExpr{
				pos: position{line: 2151, col: 34, offset: 74332},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2151, col: 34, offset: 74332},
						name: "SingleLineIndexExpression",
					},
					&actionExpr{
						pos: position{line: 2182, col: 33, offset: 75462},
						run: (*parser).callonSingleLineChainExpressionItem3,
						expr: &seqExpr{
							pos: position{line: 2182, col: 33, offset: 75462},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2182, col: 33, offset: 75462},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2182, col: 37, offset: 75466},
									expr: &litMatcher{
										pos:        position{line: 2182, col: 37, offset: 75466},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2182, col: 42, offset: 75471},
									label: "identI",
									expr: &choiceExpr{
										pos: position{line: 2319, col: 12, offset: 79887},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 2319, col: 12, offset: 79887},
												run: (*parser).callonSingleLineChainExpressionItem10,
												expr: &labeledExpr{
													pos:   position{line: 2319, col: 12, offset: 79887},
													label: "ident",
													expr: &seqExpr{
														pos: position{line: 2367, col: 17, offset: 81233},
														exprs: []interface{}{
															&charClassMatcher{
																pos:        position{line: 2350, col: 20, offset: 80988},
																val:        "[_\\pL]",
																chars:      []rune{'_'},
																classes:    []*unicode.RangeTable{rangeTable("L")},
																ignoreCase: false,
																inverted:   false,
															},
															&zeroOrMoreExpr{
																pos: position{line: 2367, col: 26, offset: 81242},
																expr: &charClassMatcher{
																	pos:        position{line: 2350, col: 20, offset: 80988},
																	val:        "[_\\pL\\pNd]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 2321, col: 5, offset: 79981},
												run: (*parser).callonSingleLineChainExpressionItem16,
												expr: &seqExpr{
													pos: position{line: 2321, col: 5, offset: 79981},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 2321, col: 5, offset: 79981},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2321, col: 13, offset: 79989},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 2321, col: 13, offset: 79989},
																		expr: &litMatcher{
																			pos:        position{line: 2321, col: 13, offset: 79989},
																			val:        "$",
																			ignoreCase: false,
																			want:       "\"$\"",
																		},
																	},
																	&oneOrMoreExpr{
																		pos: position{line: 2321, col: 18, offset: 79994},
																		expr: &choiceExpr{
																			pos: position{line: 2321, col: 19, offset: 79995},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 2321, col: 19, offset: 79995},
																					exprs: []interface{}{
																						&charClassMatcher{
																							pos:        position{line: 2321, col: 19, offset: 79995},
																							val:        "[\\pNd]",
																							classes:    []*unicode.RangeTable{rangeTable("Nd")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2321, col: 28, offset: 80004},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2321, col: 38, offset: 80014},
																					val:        "[_-\\pL]",
																					chars:      []rune{'_', '-'},
																					classes:    []*unicode.RangeTable{rangeTable("L")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 2321, col: 49, offset: 80025},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonSingleLineChainExpressionItem29,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2182, col: 57, offset: 75486},
									label: "checkI",
									expr: &litMatcher{
										pos:        position{line: 2182, col: 64, offset: 75493},
										val:        "?",
										ignoreCase: false,
										want:       "\"?\"",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2152, col: 34, offset: 74424},
						name: "SingleLineParenExpression",
					},
					&actionExpr{
						pos: position{line: 2230, col: 28, offset: 76962},
						run: (*parser).callonSingleLineChainExpressionItem38,
						expr: &seqExpr{
							pos: position{line: 2230, col: 28, offset: 76962},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2230, col: 28, offset: 76962},
									val:        ".(",
									ignoreCase: false,
									want:       "\".(\"",
								},
								&labeledExpr{
									pos:   position{line: 2230, col: 33, offset: 76967},
									label: "packageI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2230, col: 42, offset: 76976},
										expr: &seqExpr{
											pos: position{line: 2230, col: 43, offset: 76977},
											exprs: []interface{}{
												&choiceExpr{
													pos: position{line: 2319, col: 12, offset: 79887},
													alternatives: []interface{}{
														&actionExpr{
															pos: position{line: 2319, col: 12, offset: 79887},
															run: (*parser).callonSingleLineChainExpressionItem45,
															expr: &labeledExpr{
																pos:   position{line: 2319, col: 12, offset: 79887},
																label: "ident",
																expr: &seqExpr{
																	pos: position{line: 2367, col: 17, offset: 81233},
																	exprs: []interface{}{
																		&charClassMatcher{
																			pos:        position{line: 2350, col: 20, offset: 80988},
																			val:        "[_\\pL]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																		&zeroOrMoreExpr{
																			pos: position{line: 2367, col: 26, offset: 81242},
																			expr: &charClassMatcher{
																				pos:        position{line: 2350, col: 20, offset: 80988},
																				val:        "[_\\pL\\pNd]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 2321, col: 5, offset: 79981},
															run: (*parser).callonSingleLineChainExpressionItem51,
															expr: &seqExpr{
																pos: position{line: 2321, col: 5, offset: 79981},
																exprs: []interface{}{
																	&labeledExpr{
																		pos:   position{line: 2321, col: 5, offset: 79981},
																		label: "identI",
																		expr: &seqExpr{
																			pos: position{line: 2321, col: 13, offset: 79989},
																			exprs: []interface{}{
																				&zeroOrOneExpr{
																					pos: position{line: 2321, col: 13, offset: 79989},
																					expr: &litMatcher{
																						pos:        position{line: 2321, col: 13, offset: 79989},
																						val:        "$",
																						ignoreCase: false,
																						want:       "\"$\"",
																					},
																				},
																				&oneOrMoreExpr{
																					pos: position{line: 2321, col: 18, offset: 79994},
																					expr: &choiceExpr{
																						pos: position{line: 2321, col: 19, offset: 79995},
																						alternatives: []interface{}{
																							&seqExpr{
																								pos: position{line: 2321, col: 19, offset: 79995},
																								exprs: []interface{}{
																									&charClassMatcher{
																										pos:        position{line: 2321, col: 19, offset: 79995},
																										val:        "[\\pNd]",
																										classes:    []*unicode.RangeTable{rangeTable("Nd")},
																										ignoreCase: false,
																										inverted:   false,
																									},
																									&charClassMatcher{
																										pos:        position{line: 2321, col: 28, offset: 80004},
																										val:        "[_-\\pL]",
																										chars:      []rune{'_', '-'},
																										classes:    []*unicode.RangeTable{rangeTable("L")},
																										ignoreCase: false,
																										inverted:   false,
																									},
																								},
																							},
																							&charClassMatcher{
																								pos:        position{line: 2321, col: 38, offset: 80014},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&labeledExpr{
																		pos:   position{line: 2321, col: 49, offset: 80025},
																		label: "endPosI",
																		expr: &actionExpr{
																			pos: position{line: 3737, col: 8, offset: 128286},
																			run: (*parser).callonSingleLineChainExpressionItem64,
																			expr: &choiceExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				alternatives: []interface{}{
																					&andExpr{
																						pos: position{line: 3737, col: 9, offset: 128287},
																						expr: &anyMatcher{
																							line: 3737, col: 10, offset: 128288,
																						},
																					},
																					&notExpr{
																						pos: position{line: 3737, col: 14, offset: 128292},
																						expr: &anyMatcher{
																							line: 3737, col: 15, offset: 128293,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												&litMatcher{
													pos:        position{line: 2230, col: 51, offset: 76985},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2230, col: 57, offset: 76991},
									label: "typeI",
									expr: &choiceExpr{
										pos: position{line: 2319, col: 12, offset: 79887},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 2319, col: 12, offset: 79887},
												run: (*parser).callonSingleLineChainExpressionItem73,
												expr: &labeledExpr{
													pos:   position{line: 2319, col: 12, offset: 79887},
													label: "ident",
													expr: &seqExpr{
														pos: position{line: 2367, col: 17, offset: 81233},
														exprs: []interface{}{
															&charClassMatcher{
																pos:        position{line: 2350, col: 20, offset: 80988},
																val:        "[_\\pL]",
																chars:      []rune{'_'},
																classes:    []*unicode.RangeTable{rangeTable("L")},
																ignoreCase: false,
																inverted:   false,
															},
															&zeroOrMoreExpr{
																pos: position{line: 2367, col: 26, offset: 81242},
																expr: &charClassMatcher{
																	pos:        position{line: 2350, col: 20, offset: 80988},
																	val:        "[_\\pL\\pNd]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 2321, col: 5, offset: 79981},
												run: (*parser).callonSingleLineChainExpressionItem79,
												expr: &seqExpr{
													pos: position{line: 2321, col: 5, offset: 79981},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 2321, col: 5, offset: 79981},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2321, col: 13, offset: 79989},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 2321, col: 13, offset: 79989},
																		expr: &litMatcher{
																			pos:        position{line: 2321, col: 13, offset: 79989},
																			val:        "$",
																			ignoreCase: false,
																			want:       "\"$\"",
																		},
																	},
																	&oneOrMoreExpr{
																		pos: position{line: 2321, col: 18, offset: 79994},
																		expr: &choiceExpr{
																			pos: position{line: 2321, col: 19, offset: 79995},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 2321, col: 19, offset: 79995},
																					exprs: []interface{}{
																						&charClassMatcher{
																							pos:        position{line: 2321, col: 19, offset: 79995},
																							val:        "[\\pNd]",
																							classes:    []*unicode.RangeTable{rangeTable("Nd")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2321, col: 28, offset: 80004},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2321, col: 38, offset: 80014},
																					val:        "[_-\\pL]",
																					chars:      []rune{'_', '-'},
																					classes:    []*unicode.RangeTable{rangeTable("L")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 2321, col: 49, offset: 80025},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonSingleLineChainExpressionItem92,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2230, col: 71, offset: 77005},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonSingleLineChainExpressionItem99,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2230, col: 90, offset: 77024},
									label: "checkI",
									expr: &litMatcher{
										pos:        position{line: 2230, col: 97, offset: 77031},
										val:        "?",
										ignoreCase: false,
										want:       "\"?\"",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "IndexExpression",
			pos:  position{line: 2154, col: 1, offset: 74487},
			expr: &actionExpr{
				pos: position{line: 2154, col: 20, offset: 74506},
				run: (*parser).callonIndexExpression1,
				expr: &seqExpr{
					pos: position{line: 2154, col: 20, offset: 74506},
					exprs: []interface{}{
						&actionExpr{
							pos: position{line: 3759, col: 12, offset: 128999},
							run: (*parser).callonIndexExpression3,
							expr: &litMatcher{
								pos:        position{line: 3759, col: 12, offset: 128999},
								val:        "{",
								ignoreCase: false,
								want:       "\"{\"",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2154, col: 28, offset: 74514},
							expr: &choiceExpr{
								pos: position{line: 3750, col: 20, offset: 128702},
								alternatives: []interface{}{
									&charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
									&seqExpr{
										pos: position{line: 3747, col: 36, offset: 128625},
										exprs: []interface{}{
											&zeroOrOneExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												expr: &litMatcher{
													pos:        position{line: 3747, col: 36, offset: 128625},
													val:        "\r",
													ignoreCase: false,
													want:       "\"\\r\"",
												},
											},
											&litMatcher{
												pos:        position{line: 3747, col: 42, offset: 128631},
												val:        "\n",
												ignoreCase: false,
												want:       "\"\\n\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2154, col: 32, offset: 74518},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 2154, col: 38, offset: 74524},
								name: "GoExpression",
							},
						},
						&labeledExpr{
							pos:   position{line: 2154, col: 51, offset: 74537},
							label: "checkIndexI",
							expr: &litMatcher{
								pos:        position{line: 2154, col: 63, offset: 74549},
								val:        "?",
								ignoreCase: false,
								want:       "\"?\"",
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2154, col: 67, offset: 74553},
							expr: &seqExpr{
								pos: position{line: 2154, col: 68, offset: 74554},
								exprs: []interface{}{
									&litMatcher{
										pos:        position{line: 2154, col: 68, offset: 74554},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2154, col: 72, offset: 74558},
										expr: &choiceExpr{
											pos: position{line: 3750, col: 20, offset: 128702},
											alternatives: []interface{}{
												&charClassMatcher{
													pos:        position{line: 3746, col: 36, offset: 128584},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
												&seqExpr{
													pos: position{line: 3747, col: 36, offset: 128625},
													exprs: []interface{}{
														&zeroOrOneExpr{
															pos: position{line: 3747, col: 36, offset: 128625},
															expr: &litMatcher{
																pos:        position{line: 3747, col: 36, offset: 128625},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3747, col: 42, offset: 128631},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2154, col: 78, offset: 74564},
							expr: &litMatcher{
								pos:        position{line: 2154, col: 78, offset: 74564},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2154, col: 83, offset: 74569},
							label: "rBracePosI",
							expr: &actionExpr{
								pos: position{line: 3760, col: 12, offset: 129037},
								run: (*parser).callonIndexExpression29,
								expr: &litMatcher{
									pos:        position{line: 3760, col: 12, offset: 129037},
									val:        "}",
									ignoreCase: false,
									want:       "\"}\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2154, col: 102, offset: 74588},
							label: "checkValueI",
							expr: &litMatcher{
								pos:        position{line: 2154, col: 114, offset: 74600},
								val:        "?",
								ignoreCase: false,
								want:       "\"?\"",
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineIndexExpression",
			pos:  position{line: 2164, col: 1, offset: 74847},
			expr: &actionExpr{
				pos: position{line: 2164, col: 30, offset: 74876},
				run: (*parser).callonSingleLineIndexExpression1,
				expr: &seqExpr{
					pos: position{line: 2164, col: 30, offset: 74876},
					exprs: []interface{}{
						&actionExpr{
							pos: position{line: 3759, col: 12, offset: 128999},
							run: (*parser).callonSingleLineIndexExpression3,
							expr: &litMatcher{
								pos:        position{line: 3759, col: 12, offset: 128999},
								val:        "{",
								ignoreCase: false,
								want:       "\"{\"",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2164, col: 38, offset: 74884},
							expr: &choiceExpr{
								pos: position{line: 3750, col: 20, offset: 128702},
								alternatives: []interface{}{
									&charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
									&seqExpr{
										pos: position{line: 3747, col: 36, offset: 128625},
										exprs: []interface{}{
											&zeroOrOneExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												expr: &litMatcher{
													pos:        position{line: 3747, col: 36, offset: 128625},
													val:        "\r",
													ignoreCase: false,
													want:       "\"\\r\"",
												},
											},
											&litMatcher{
												pos:        position{line: 3747, col: 42, offset: 128631},
												val:        "\n",
												ignoreCase: false,
												want:       "\"\\n\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2164, col: 42, offset: 74888},
							label: "exprI",
							expr: &ruleRefExpr{
								pos:  position{line: 2164, col: 48, offset: 74894},
								name: "SingleLineGoExpression",
							},
						},
						&labeledExpr{
							pos:   position{line: 2164, col: 71, offset: 74917},
							label: "checkIndexI",
							expr: &litMatcher{
								pos:        position{line: 2164, col: 83, offset: 74929},
								val:        "?",
								ignoreCase: false,
								want:       "\"?\"",
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2164, col: 87, offset: 74933},
							expr: &seqExpr{
								pos: position{line: 2164, col: 88, offset: 74934},
								exprs: []interface{}{
									&litMatcher{
										pos:        position{line: 2164, col: 88, offset: 74934},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2164, col: 92, offset: 74938},
										expr: &litMatcher{
											pos:        position{line: 2164, col: 92, offset: 74938},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2164, col: 99, offset: 74945},
							expr: &litMatcher{
								pos:        position{line: 2164, col: 99, offset: 74945},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2164, col: 104, offset: 74950},
							label: "rBracePosI",
							expr: &actionExpr{
								pos: position{line: 3760, col: 12, offset: 129037},
								run: (*parser).callonSingleLineIndexExpression24,
								expr: &litMatcher{
									pos:        position{line: 3760, col: 12, offset: 129037},
									val:        "}",
									ignoreCase: false,
									want:       "\"}\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2164, col: 123, offset: 74969},
							label: "checkValueI",
							expr: &litMatcher{
								pos:        position{line: 2164, col: 135, offset: 74981},
								val:        "?",
								ignoreCase: false,
								want:       "\"?\"",
							},
						},
					},
				},
			},
		},
		{
			name: "ParenExpression",
			pos:  position{line: 2190, col: 1, offset: 75643},
			expr: &actionExpr{
				pos: position{line: 2190, col: 20, offset: 75662},
				run: (*parser).callonParenExpression1,
				expr: &seqExpr{
					pos: position{line: 2190, col: 20, offset: 75662},
					exprs: []interface{}{
						&actionExpr{
							pos: position{line: 3756, col: 12, offset: 128922},
							run: (*parser).callonParenExpression3,
							expr: &litMatcher{
								pos:        position{line: 3756, col: 12, offset: 128922},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2190, col: 28, offset: 75670},
							expr: &litMatcher{
								pos:        position{line: 2190, col: 28, offset: 75670},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2190, col: 33, offset: 75675},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2190, col: 39, offset: 75681},
								expr: &ruleRefExpr{
									pos:  position{line: 2190, col: 39, offset: 75681},
									name: "parenExpressionArgs",
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2190, col: 60, offset: 75702},
							expr: &litMatcher{
								pos:        position{line: 2190, col: 60, offset: 75702},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2190, col: 65, offset: 75707},
							expr: &seqExpr{
								pos: position{line: 2190, col: 66, offset: 75708},
								exprs: []interface{}{
									&litMatcher{
										pos:        position{line: 2190, col: 66, offset: 75708},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2190, col: 70, offset: 75712},
										expr: &choiceExpr{
											pos: position{line: 3750, col: 20, offset: 128702},
											alternatives: []interface{}{
												&charClassMatcher{
													pos:        position{line: 3746, col: 36, offset: 128584},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
												&seqExpr{
													pos: position{line: 3747, col: 36, offset: 128625},
													exprs: []interface{}{
														&zeroOrOneExpr{
															pos: position{line: 3747, col: 36, offset: 128625},
															expr: &litMatcher{
																pos:        position{line: 3747, col: 36, offset: 128625},
																val:        "\r",
																ignoreCase: false,
																want:       "\"\\r\"",
															},
														},
														&litMatcher{
															pos:        position{line: 3747, col: 42, offset: 128631},
															val:        "\n",
															ignoreCase: false,
															want:       "\"\\n\"",
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2190, col: 76, offset: 75718},
							label: "rParenPosI",
							expr: &actionExpr{
								pos: position{line: 3757, col: 12, offset: 128960},
								run: (*parser).callonParenExpression23,
								expr: &litMatcher{
									pos:        position{line: 3757, col: 12, offset: 128960},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2190, col: 95, offset: 75737},
							label: "checkI",
							expr: &litMatcher{
								pos:        position{line: 2190, col: 102, offset: 75744},
								val:        "?",
								ignoreCase: false,
								want:       "\"?\"",
							},
						},
					},
				},
			},
		},
		{
			name: "parenExpressionArgs",
			pos:  position{line: 2198, col: 1, offset: 75934},
			expr: &actionExpr{
				pos: position{line: 2198, col: 24, offset: 75957},
				run: (*parser).callonparenExpressionArgs1,
				expr: &seqExpr{
					pos: position{line: 2198, col: 24, offset: 75957},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 2198, col: 24, offset: 75957},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 2198, col: 31, offset: 75964},
								name: "GoExpression",
							},
						},
						&labeledExpr{
							pos:   position{line: 2198, col: 44, offset: 75977},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2198, col: 50, offset: 75983},
								expr: &seqExpr{
									pos: position{line: 2198, col: 51, offset: 75984},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 2198, col: 51, offset: 75984},
											expr: &litMatcher{
												pos:        position{line: 2198, col: 51, offset: 75984},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 2198, col: 56, offset: 75989},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2198, col: 60, offset: 75993},
											expr: &choiceExpr{
												pos: position{line: 3750, col: 20, offset: 128702},
												alternatives: []interface{}{
													&charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														exprs: []interface{}{
															&zeroOrOneExpr{
																pos: position{line: 3747, col: 36, offset: 128625},
																expr: &litMatcher{
																	pos:        position{line: 3747, col: 36, offset: 128625},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3747, col: 42, offset: 128631},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2198, col: 64, offset: 75997},
											name: "GoExpression",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineParenExpression",
			pos:  position{line: 2210, col: 1, offset: 76264},
			expr: &actionExpr{
				pos: position{line: 2210, col: 30, offset: 76293},
				run: (*parser).callonSingleLineParenExpression1,
				expr: &seqExpr{
					pos: position{line: 2210, col: 30, offset: 76293},
					exprs: []interface{}{
						&actionExpr{
							pos: position{line: 3756, col: 12, offset: 128922},
							run: (*parser).callonSingleLineParenExpression3,
							expr: &litMatcher{
								pos:        position{line: 3756, col: 12, offset: 128922},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2210, col: 38, offset: 76301},
							expr: &litMatcher{
								pos:        position{line: 2210, col: 38, offset: 76301},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 2210, col: 43, offset: 76306},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2210, col: 49, offset: 76312},
								expr: &ruleRefExpr{
									pos:  position{line: 2210, col: 49, offset: 76312},
									name: "singleLinearenExpressionArgs",
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 2210, col: 79, offset: 76342},
							expr: &litMatcher{
								pos:        position{line: 2210, col: 79, offset: 76342},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2210, col: 84, offset: 76347},
							expr: &seqExpr{
								pos: position{line: 2210, col: 85, offset: 76348},
								exprs: []interface{}{
									&litMatcher{
										pos:        position{line: 2210, col: 85, offset: 76348},
										val:        ",",
										ignoreCase: false,
										want:       "\",\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2210, col: 89, offset: 76352},
										expr: &litMatcher{
											pos:        position{line: 2210, col: 89, offset: 76352},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2210, col: 96, offset: 76359},
							label: "rParenPosI",
							expr: &actionExpr{
								pos: position{line: 3757, col: 12, offset: 128960},
								run: (*parser).callonSingleLineParenExpression18,
								expr: &litMatcher{
									pos:        position{line: 3757, col: 12, offset: 128960},
									val:        ")",
									ignoreCase: false,
									want:       "\")\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2210, col: 115, offset: 76378},
							label: "checkI",
							expr: &litMatcher{
								pos:        position{line: 2210, col: 122, offset: 76385},
								val:        "?",
								ignoreCase: false,
								want:       "\"?\"",
							},
						},
					},
				},
			},
		},
		{
			name: "singleLinearenExpressionArgs",
			pos:  position{line: 2218, col: 1, offset: 76575},
			expr: &actionExpr{
				pos: position{line: 2218, col: 33, offset: 76607},
				run: (*parser).callonsingleLinearenExpressionArgs1,
				expr: &seqExpr{
					pos: position{line: 2218, col: 33, offset: 76607},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 2218, col: 33, offset: 76607},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 2218, col: 40, offset: 76614},
								name: "SingleLineGoExpression",
							},
						},
						&labeledExpr{
							pos:   position{line: 2218, col: 63, offset: 76637},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2218, col: 69, offset: 76643},
								expr: &seqExpr{
									pos: position{line: 2218, col: 70, offset: 76644},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 2218, col: 70, offset: 76644},
											expr: &litMatcher{
												pos:        position{line: 2218, col: 70, offset: 76644},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 2218, col: 75, offset: 76649},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2218, col: 79, offset: 76653},
											expr: &litMatcher{
												pos:        position{line: 2218, col: 79, offset: 76653},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2218, col: 84, offset: 76658},
											name: "SingleLineGoExpression",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "GoType",
			pos:  position{line: 2336, col: 1, offset: 80581},
			expr: &actionExpr{
				pos: position{line: 2336, col: 11, offset: 80591},
				run: (*parser).callonGoType1,
				expr: &labeledExpr{
					pos:   position{line: 2336, col: 11, offset: 80591},
					label: "goTypeI",
					expr: &ruleRefExpr{
						pos:  position{line: 2336, col: 19, offset: 80599},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goType",
			pos:  position{line: 2726, col: 1, offset: 95162},
			expr: &choiceExpr{
				pos: position{line: 2726, col: 15, offset: 95176},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 2726, col: 16, offset: 95177},
						exprs: []interface{}{
							&choiceExpr{
								pos: position{line: 2727, col: 15, offset: 95259},
								alternatives: []interface{}{
									&seqExpr{
										pos: position{line: 2384, col: 21, offset: 81785},
										exprs: []interface{}{
											&charClassMatcher{
												pos:        position{line: 2350, col: 20, offset: 80988},
												val:        "[_\\pL]",
												chars:      []rune{'_'},
												classes:    []*unicode.RangeTable{rangeTable("L")},
												ignoreCase: false,
												inverted:   false,
											},
											&zeroOrMoreExpr{
												pos: position{line: 2367, col: 26, offset: 81242},
												expr: &charClassMatcher{
													pos:        position{line: 2350, col: 20, offset: 80988},
													val:        "[_\\pL\\pNd]",
													chars:      []rune{'_'},
													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&zeroOrMoreExpr{
												pos: position{line: 2384, col: 35, offset: 81799},
												expr: &litMatcher{
													pos:        position{line: 2384, col: 35, offset: 81799},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 2384, col: 40, offset: 81804},
												val:        ".",
												ignoreCase: false,
												want:       "\".\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2384, col: 44, offset: 81808},
												expr: &litMatcher{
													pos:        position{line: 2384, col: 44, offset: 81808},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&zeroOrMoreExpr{
												pos: position{line: 2384, col: 49, offset: 81813},
												expr: &seqExpr{
													pos: position{line: 2367, col: 17, offset: 81233},
													exprs: []interface{}{
														&charClassMatcher{
															pos:        position{line: 2350, col: 20, offset: 80988},
															val:        "[_\\pL]",
															chars:      []rune{'_'},
															classes:    []*unicode.RangeTable{rangeTable("L")},
															ignoreCase: false,
															inverted:   false,
														},
														&zeroOrMoreExpr{
															pos: position{line: 2367, col: 26, offset: 81242},
															expr: &charClassMatcher{
																pos:        position{line: 2350, col: 20, offset: 80988},
																val:        "[_\\pL\\pNd]",
																chars:      []rune{'_'},
																classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&seqExpr{
										pos: position{line: 2367, col: 17, offset: 81233},
										exprs: []interface{}{
											&charClassMatcher{
												pos:        position{line: 2350, col: 20, offset: 80988},
												val:        "[_\\pL]",
												chars:      []rune{'_'},
												classes:    []*unicode.RangeTable{rangeTable("L")},
												ignoreCase: false,
												inverted:   false,
											},
											&zeroOrMoreExpr{
												pos: position{line: 2367, col: 26, offset: 81242},
												expr: &charClassMatcher{
													pos:        position{line: 2350, col: 20, offset: 80988},
													val:        "[_\\pL\\pNd]",
													chars:      []rune{'_'},
													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
								},
							},
							&zeroOrMoreExpr{
								pos: position{line: 2726, col: 27, offset: 95188},
								expr: &litMatcher{
									pos:        position{line: 2726, col: 27, offset: 95188},
									val:        " ",
									ignoreCase: false,
									want:       "\" \"",
								},
							},
							&zeroOrOneExpr{
								pos: position{line: 2726, col: 32, offset: 95193},
								expr: &ruleRefExpr{
									pos:  position{line: 2726, col: 32, offset: 95193},
									name: "goTypeArgs",
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2726, col: 47, offset: 95208},
						name: "goTypeLit",
					},
					&seqExpr{
						pos: position{line: 2726, col: 59, offset: 95220},
						exprs: []interface{}{
							&litMatcher{
								pos:        position{line: 2726, col: 59, offset: 95220},
								val:        "(",
								ignoreCase: false,
								want:       "\"(\"",
							},
							&zeroOrMoreExpr{
								pos: position{line: 2726, col: 63, offset: 95224},
								expr: &litMatcher{
									pos:        position{line: 2726, col: 63, offset: 95224},
									val:        " ",
									ignoreCase: false,
									want:       "\" \"",
								},
							},
							&ruleRefExpr{
								pos:  position{line: 2726, col: 68, offset: 95229},
								name: "goType",
							},
							&zeroOrMoreExpr{
								pos: position{line: 2726, col: 75, offset: 95236},
								expr: &litMatcher{
									pos:        position{line: 2726, col: 75, offset: 95236},
									val:        " ",
									ignoreCase: false,
									want:       "\" \"",
								},
							},
							&litMatcher{
								pos:        position{line: 2726, col: 80, offset: 95241},
								val:        ")",
								ignoreCase: false,
								want:       "\")\"",
							},
						},
					},
				},
			},
		},
		{
			name: "goTypeArgs",
			pos:  position{line: 2728, col: 1, offset: 95291},
			expr: &seqExpr{
				pos: position{line: 2728, col: 15, offset: 95305},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2728, col: 15, offset: 95305},
						val:        "[",
						ignoreCase: false,
						want:       "\"[\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2728, col: 19, offset: 95309},
						expr: &litMatcher{
							pos:        position{line: 2728, col: 19, offset: 95309},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2728, col: 24, offset: 95314},
						name: "goTypeList",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2728, col: 35, offset: 95325},
						expr: &litMatcher{
							pos:        position{line: 2728, col: 35, offset: 95325},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2728, col: 40, offset: 95330},
						expr: &seqExpr{
							pos: position{line: 2728, col: 41, offset: 95331},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2728, col: 41, offset: 95331},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2728, col: 45, offset: 95335},
									expr: &litMatcher{
										pos:        position{line: 2728, col: 45, offset: 95335},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2728, col: 52, offset: 95342},
						val:        "]",
						ignoreCase: false,
						want:       "\"]\"",
					},
				},
			},
		},
		{
			name: "goTypeList",
			pos:  position{line: 2729, col: 1, offset: 95346},
			expr: &seqExpr{
				pos: position{line: 2729, col: 15, offset: 95360},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2729, col: 15, offset: 95360},
						name: "goType",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2729, col: 22, offset: 95367},
						expr: &litMatcher{
							pos:        position{line: 2729, col: 22, offset: 95367},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2729, col: 27, offset: 95372},
						expr: &seqExpr{
							pos: position{line: 2729, col: 28, offset: 95373},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2729, col: 28, offset: 95373},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2729, col: 32, offset: 95377},
									expr: &litMatcher{
										pos:        position{line: 2729, col: 32, offset: 95377},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2729, col: 37, offset: 95382},
									name: "goType",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goTypeLit",
			pos:  position{line: 2730, col: 1, offset: 95391},
			expr: &choiceExpr{
				pos: position{line: 2730, col: 16, offset: 95406},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2730, col: 16, offset: 95406},
						name: "goArrayType",
					},
					&ruleRefExpr{
						pos:  position{line: 2730, col: 30, offset: 95420},
						name: "goStructType",
					},
					&ruleRefExpr{
						pos:  position{line: 2730, col: 45, offset: 95435},
						name: "goPointerType",
					},
					&ruleRefExpr{
						pos:  position{line: 2730, col: 61, offset: 95451},
						name: "goFunctionType",
					},
					&ruleRefExpr{
						pos:  position{line: 2730, col: 78, offset: 95468},
						name: "goInterfaceType",
					},
					&ruleRefExpr{
						pos:  position{line: 2730, col: 96, offset: 95486},
						name: "goSliceType",
					},
					&ruleRefExpr{
						pos:  position{line: 2730, col: 110, offset: 95500},
						name: "goMapType",
					},
					&ruleRefExpr{
						pos:  position{line: 2730, col: 122, offset: 95512},
						name: "goChannelType",
					},
				},
			},
		},
		{
			name: "goArrayType",
			pos:  position{line: 2736, col: 1, offset: 95550},
			expr: &seqExpr{
				pos: position{line: 2736, col: 18, offset: 95567},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2736, col: 18, offset: 95567},
						val:        "[",
						ignoreCase: false,
						want:       "\"[\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2736, col: 22, offset: 95571},
						expr: &litMatcher{
							pos:        position{line: 2736, col: 22, offset: 95571},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2736, col: 27, offset: 95576},
						name: "goArrayLength",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2736, col: 41, offset: 95590},
						expr: &litMatcher{
							pos:        position{line: 2736, col: 41, offset: 95590},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2736, col: 46, offset: 95595},
						val:        "]",
						ignoreCase: false,
						want:       "\"]\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2736, col: 50, offset: 95599},
						expr: &litMatcher{
							pos:        position{line: 2736, col: 50, offset: 95599},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2736, col: 55, offset: 95604},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "goArrayLength",
			pos:  position{line: 2737, col: 1, offset: 95618},
			expr: &seqExpr{
				pos: position{line: 2737, col: 18, offset: 95635},
				exprs: []interface{}{
					&oneOrMoreExpr{
						pos: position{line: 2737, col: 18, offset: 95635},
						expr: &charClassMatcher{
							pos:        position{line: 2737, col: 18, offset: 95635},
							val:        "[0-9]",
							ranges:     []rune{'0', '9'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2737, col: 25, offset: 95642},
						expr: &seqExpr{
							pos: position{line: 2737, col: 26, offset: 95643},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 2737, col: 26, offset: 95643},
									expr: &litMatcher{
										pos:        position{line: 2737, col: 26, offset: 95643},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&choiceExpr{
									pos: position{line: 2737, col: 32, offset: 95649},
									alternatives: []interface{}{
										&litMatcher{
											pos:        position{line: 2737, col: 32, offset: 95649},
											val:        "<<",
											ignoreCase: false,
											want:       "\"<<\"",
										},
										&litMatcher{
											pos:        position{line: 2737, col: 39, offset: 95656},
											val:        ">>",
											ignoreCase: false,
											want:       "\">>\"",
										},
										&charClassMatcher{
											pos:        position{line: 2737, col: 46, offset: 95663},
											val:        "[+-*/]",
											chars:      []rune{'+', '-', '*', '/'},
											ignoreCase: false,
											inverted:   false,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2737, col: 69, offset: 95686},
									expr: &litMatcher{
										pos:        position{line: 2737, col: 69, offset: 95686},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2737, col: 74, offset: 95691},
									name: "goArrayLength",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goElementType",
			pos:  position{line: 2738, col: 1, offset: 95788},
			expr: &ruleRefExpr{
				pos:  position{line: 2738, col: 18, offset: 95805},
				name: "goType",
			},
		},
		{
			name: "goSliceType",
			pos:  position{line: 2744, col: 1, offset: 95835},
			expr: &seqExpr{
				pos: position{line: 2744, col: 16, offset: 95850},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2744, col: 16, offset: 95850},
						val:        "[]",
						ignoreCase: false,
						want:       "\"[]\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2744, col: 21, offset: 95855},
						expr: &litMatcher{
							pos:        position{line: 2744, col: 21, offset: 95855},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2744, col: 26, offset: 95860},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "goStructType",
			pos:  position{line: 2750, col: 1, offset: 95898},
			expr: &seqExpr{
				pos: position{line: 2750, col: 20, offset: 95917},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2750, col: 20, offset: 95917},
						val:        "struct",
						ignoreCase: false,
						want:       "\"struct\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2750, col: 29, offset: 95926},
						expr: &litMatcher{
							pos:        position{line: 2750, col: 29, offset: 95926},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2750, col: 34, offset: 95931},
						val:        "{",
						ignoreCase: false,
						want:       "\"{\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2750, col: 38, offset: 95935},
						expr: &seqExpr{
							pos: position{line: 2750, col: 39, offset: 95936},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 2750, col: 39, offset: 95936},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2750, col: 43, offset: 95940},
									expr: &ruleRefExpr{
										pos:  position{line: 2750, col: 43, offset: 95940},
										name: "goFieldDecl",
									},
								},
								&choiceExpr{
									pos: position{line: 2750, col: 57, offset: 95954},
									alternatives: []interface{}{
										&litMatcher{
											pos:        position{line: 2750, col: 57, offset: 95954},
											val:        ";",
											ignoreCase: false,
											want:       "\";\"",
										},
										&seqExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3747, col: 36, offset: 128625},
													expr: &litMatcher{
														pos:        position{line: 3747, col: 36, offset: 128625},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3747, col: 42, offset: 128631},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
									},
								},
							},
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2750, col: 71, offset: 95968},
						expr: &choiceExpr{
							pos: position{line: 3750, col: 20, offset: 128702},
							alternatives: []interface{}{
								&charClassMatcher{
									pos:        position{line: 3746, col: 36, offset: 128584},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
								&seqExpr{
									pos: position{line: 3747, col: 36, offset: 128625},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2750, col: 75, offset: 95972},
						val:        "}",
						ignoreCase: false,
						want:       "\"}\"",
					},
				},
			},
		},
		{
			name: "goFieldDecl",
			pos:  position{line: 2751, col: 1, offset: 95976},
			expr: &seqExpr{
				pos: position{line: 2751, col: 20, offset: 95995},
				exprs: []interface{}{
					&choiceExpr{
						pos: position{line: 2751, col: 21, offset: 95996},
						alternatives: []interface{}{
							&seqExpr{
								pos: position{line: 2751, col: 21, offset: 95996},
								exprs: []interface{}{
									&charClassMatcher{
										pos:        position{line: 2350, col: 20, offset: 80988},
										val:        "[_\\pL]",
										chars:      []rune{'_'},
										classes:    []*unicode.RangeTable{rangeTable("L")},
										ignoreCase: false,
										inverted:   false,
									},
									&zeroOrMoreExpr{
										pos: position{line: 2367, col: 26, offset: 81242},
										expr: &charClassMatcher{
											pos:        position{line: 2350, col: 20, offset: 80988},
											val:        "[_\\pL\\pNd]",
											chars:      []rune{'_'},
											classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
											ignoreCase: false,
											inverted:   false,
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 2802, col: 34, offset: 97227},
										expr: &litMatcher{
											pos:        position{line: 2802, col: 34, offset: 97227},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 2802, col: 39, offset: 97232},
										expr: &seqExpr{
											pos: position{line: 2802, col: 40, offset: 97233},
											exprs: []interface{}{
												&litMatcher{
													pos:        position{line: 2802, col: 40, offset: 97233},
													val:        ",",
													ignoreCase: false,
													want:       "\",\"",
												},
												&zeroOrMoreExpr{
													pos: position{line: 2802, col: 44, offset: 97237},
													expr: &choiceExpr{
														pos: position{line: 3750, col: 20, offset: 128702},
														alternatives: []interface{}{
															&charClassMatcher{
																pos:        position{line: 3746, col: 36, offset: 128584},
																val:        "[ \\t]",
																chars:      []rune{' ', '\t'},
																ignoreCase: false,
																inverted:   false,
															},
															&seqExpr{
																pos: position{line: 3747, col: 36, offset: 128625},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 3747, col: 36, offset: 128625},
																		expr: &litMatcher{
																			pos:        position{line: 3747, col: 36, offset: 128625},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3747, col: 42, offset: 128631},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
														},
													},
												},
												&charClassMatcher{
													pos:        position{line: 2350, col: 20, offset: 80988},
													val:        "[_\\pL]",
													chars:      []rune{'_'},
													classes:    []*unicode.RangeTable{rangeTable("L")},
													ignoreCase: false,
													inverted:   false,
												},
												&zeroOrMoreExpr{
													pos: position{line: 2367, col: 26, offset: 81242},
													expr: &charClassMatcher{
														pos:        position{line: 2350, col: 20, offset: 80988},
														val:        "[_\\pL\\pNd]",
														chars:      []rune{'_'},
														classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
														ignoreCase: false,
														inverted:   false,
													},
												},
											},
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 2751, col: 38, offset: 96013},
										expr: &litMatcher{
											pos:        position{line: 2751, col: 38, offset: 96013},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&ruleRefExpr{
										pos:  position{line: 2751, col: 43, offset: 96018},
										name: "goType",
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 2751, col: 52, offset: 96027},
								name: "goEmbeddedField",
							},
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2751, col: 69, offset: 96044},
						expr: &choiceExpr{
							pos: position{line: 2691, col: 16, offset: 93864},
							alternatives: []interface{}{
								&seqExpr{
									pos: position{line: 2693, col: 19, offset: 93923},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 2693, col: 19, offset: 93923},
											val:        "`",
											ignoreCase: false,
											want:       "\"`\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2693, col: 23, offset: 93927},
											expr: &charClassMatcher{
												pos:        position{line: 2704, col: 27, offset: 94307},
												val:        "[^\\n`]",
												chars:      []rune{'\n', '`'},
												ignoreCase: false,
												inverted:   true,
											},
										},
										&litMatcher{
											pos:        position{line: 2693, col: 47, offset: 93951},
											val:        "`",
											ignoreCase: false,
											want:       "\"`\"",
										},
									},
								},
								&actionExpr{
									pos: position{line: 2694, col: 5, offset: 93961},
									run: (*parser).callongoFieldDecl33,
									expr: &seqExpr{
										pos: position{line: 2694, col: 5, offset: 93961},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 2694, col: 5, offset: 93961},
												val:        "`",
												ignoreCase: false,
												want:       "\"`\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2694, col: 9, offset: 93965},
												expr: &charClassMatcher{
													pos:        position{line: 2704, col: 27, offset: 94307},
													val:        "[^\\n`]",
													chars:      []rune{'\n', '`'},
													ignoreCase: false,
													inverted:   true,
												},
											},
											&zeroOrMoreExpr{
												pos: position{line: 3734, col: 12, offset: 128237},
												expr: &charClassMatcher{
													pos:        position{line: 3746, col: 36, offset: 128584},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&choiceExpr{
												pos: position{line: 3734, col: 16, offset: 128241},
												alternatives: []interface{}{
													&seqExpr{
														pos: position{line: 3734, col: 16, offset: 128241},
														exprs: []interface{}{
															&zeroOrOneExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																expr: &litMatcher{
																	pos:        position{line: 3734, col: 16, offset: 128241},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3734, col: 22, offset: 128247},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
													&notExpr{
														pos: position{line: 3733, col: 12, offset: 128223},
														expr: &anyMatcher{
															line: 3733, col: 13, offset: 128224,
														},
													},
												},
											},
										},
									},
								},
								&seqExpr{
									pos: position{line: 2706, col: 27, offset: 94391},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 2706, col: 27, offset: 94391},
											val:        "\"",
											ignoreCase: false,
											want:       "\"\\\"\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2706, col: 31, offset: 94395},
											expr: &choiceExpr{
												pos: position{line: 2706, col: 32, offset: 94396},
												alternatives: []interface{}{
													&seqExpr{
														pos: position{line: 2462, col: 19, offset: 84712},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2462, col: 19, offset: 84712},
																val:        "\\u",
																ignoreCase: false,
																want:       "\"\\\\u\"",
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&actionExpr{
														pos: position{line: 2463, col: 5, offset: 84771},
														run: (*parser).callongoFieldDecl57,
														expr: &seqExpr{
															pos: position{line: 2463, col: 5, offset: 84771},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2463, col: 5, offset: 84771},
																	val:        "\\u",
																	ignoreCase: false,
																	want:       "\"\\\\u\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2463, col: 14, offset: 84780},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2463, col: 26, offset: 84792},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2463, col: 38, offset: 84804},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2463, col: 50, offset: 84816},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
													&seqExpr{
														pos: position{line: 2492, col: 16, offset: 85952},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2492, col: 16, offset: 85952},
																val:        "\\U",
																ignoreCase: false,
																want:       "\"\\\\U\"",
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&actionExpr{
														pos: position{line: 2493, col: 5, offset: 86055},
														run: (*parser).callongoFieldDecl78,
														expr: &seqExpr{
															pos: position{line: 2493, col: 5, offset: 86055},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2493, col: 5, offset: 86055},
																	val:        "\\U",
																	ignoreCase: false,
																	want:       "\"\\\\U\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 14, offset: 86064},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 26, offset: 86076},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 38, offset: 86088},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 50, offset: 86100},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 62, offset: 86112},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 74, offset: 86124},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 86, offset: 86136},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2493, col: 98, offset: 86148},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
													&seqExpr{
														pos: position{line: 2720, col: 36, offset: 95085},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2720, col: 36, offset: 95085},
																val:        "\\",
																ignoreCase: false,
																want:       "\"\\\\\"",
															},
															&charClassMatcher{
																pos:        position{line: 2720, col: 41, offset: 95090},
																val:        "[abfnrtv\\\\\"]",
																chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 2718, col: 38, offset: 94977},
														val:        "[^\"\\\\\\n]",
														chars:      []rune{'"', '\\', '\n'},
														ignoreCase: false,
														inverted:   true,
													},
													&seqExpr{
														pos: position{line: 2443, col: 24, offset: 83970},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2443, col: 24, offset: 83970},
																val:        "\\",
																ignoreCase: false,
																want:       "\"\\\\\"",
															},
															&charClassMatcher{
																pos:        position{line: 2360, col: 19, offset: 81158},
																val:        "[0-7]",
																ranges:     []rune{'0', '7'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2360, col: 19, offset: 81158},
																val:        "[0-7]",
																ranges:     []rune{'0', '7'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2360, col: 19, offset: 81158},
																val:        "[0-7]",
																ranges:     []rune{'0', '7'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&seqExpr{
														pos: position{line: 2444, col: 24, offset: 84037},
														exprs: []interface{}{
															&litMatcher{
																pos:        position{line: 2444, col: 24, offset: 84037},
																val:        "\\x",
																ignoreCase: false,
																want:       "\"\\\\x\"",
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
															&charClassMatcher{
																pos:        position{line: 2361, col: 19, offset: 81182},
																val:        "[0-9A-Fa-f]",
																ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
													&actionExpr{
														pos: position{line: 2445, col: 5, offset: 84074},
														run: (*parser).callongoFieldDecl110,
														expr: &seqExpr{
															pos: position{line: 2445, col: 5, offset: 84074},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2445, col: 5, offset: 84074},
																	val:        "\\x",
																	ignoreCase: false,
																	want:       "\"\\\\x\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2445, col: 14, offset: 84083},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 2445, col: 26, offset: 84095},
																	expr: &charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 2607, col: 37, offset: 90735},
														run: (*parser).callongoFieldDecl117,
														expr: &seqExpr{
															pos: position{line: 2607, col: 37, offset: 90735},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2607, col: 37, offset: 90735},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 2631, col: 5, offset: 91752},
														run: (*parser).callongoFieldDecl128,
														expr: &seqExpr{
															pos: position{line: 2631, col: 5, offset: 91752},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2631, col: 5, offset: 91752},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 2652, col: 5, offset: 92594},
														run: (*parser).callongoFieldDecl135,
														expr: &seqExpr{
															pos: position{line: 2652, col: 5, offset: 92594},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2652, col: 5, offset: 92594},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 2670, col: 5, offset: 93280},
														run: (*parser).callongoFieldDecl140,
														expr: &seqExpr{
															pos: position{line: 2670, col: 5, offset: 93280},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2670, col: 5, offset: 93280},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&zeroOrOneExpr{
																	pos: position{line: 2670, col: 10, offset: 93285},
																	expr: &charClassMatcher{
																		pos:        position{line: 3735, col: 12, offset: 128270},
																		val:        "[^\\r\\n]",
																		chars:      []rune{'\r', '\n'},
																		ignoreCase: false,
																		inverted:   true,
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 2706, col: 115, offset: 94479},
											val:        "\"",
											ignoreCase: false,
											want:       "\"\\\"\"",
										},
									},
								},
								&actionExpr{
									pos: position{line: 2707, col: 5, offset: 94489},
									run: (*parser).callongoFieldDecl146,
									expr: &seqExpr{
										pos: position{line: 2707, col: 5, offset: 94489},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 2707, col: 5, offset: 94489},
												val:        "\"",
												ignoreCase: false,
												want:       "\"\\\"\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2707, col: 9, offset: 94493},
												expr: &choiceExpr{
													pos: position{line: 2707, col: 10, offset: 94494},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 2462, col: 19, offset: 84712},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2462, col: 19, offset: 84712},
																	val:        "\\u",
																	ignoreCase: false,
																	want:       "\"\\\\u\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&actionExpr{
															pos: position{line: 2463, col: 5, offset: 84771},
															run: (*parser).callongoFieldDecl157,
															expr: &seqExpr{
																pos: position{line: 2463, col: 5, offset: 84771},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 2463, col: 5, offset: 84771},
																		val:        "\\u",
																		ignoreCase: false,
																		want:       "\"\\\\u\"",
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2463, col: 14, offset: 84780},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2463, col: 26, offset: 84792},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2463, col: 38, offset: 84804},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2463, col: 50, offset: 84816},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
														&seqExpr{
															pos: position{line: 2492, col: 16, offset: 85952},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2492, col: 16, offset: 85952},
																	val:        "\\U",
																	ignoreCase: false,
																	want:       "\"\\\\U\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&actionExpr{
															pos: position{line: 2493, col: 5, offset: 86055},
															run: (*parser).callongoFieldDecl178,
															expr: &seqExpr{
																pos: position{line: 2493, col: 5, offset: 86055},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 2493, col: 5, offset: 86055},
																		val:        "\\U",
																		ignoreCase: false,
																		want:       "\"\\\\U\"",
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2493, col: 14, offset: 86064},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2493, col: 26, offset: 86076},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2493, col: 38, offset: 86088},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2493, col: 50, offset: 86100},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2493, col: 62, offset: 86112},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2493, col: 74, offset: 86124},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2493, col: 86, offset: 86136},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2493, col: 98, offset: 86148},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
														&seqExpr{
															pos: position{line: 2720, col: 36, offset: 95085},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2720, col: 36, offset: 95085},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2720, col: 41, offset: 95090},
																	val:        "[abfnrtv\\\\\"]",
																	chars:      []rune{'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&charClassMatcher{
															pos:        position{line: 2718, col: 38, offset: 94977},
															val:        "[^\"\\\\\\n]",
															chars:      []rune{'"', '\\', '\n'},
															ignoreCase: false,
															inverted:   true,
														},
														&seqExpr{
															pos: position{line: 2443, col: 24, offset: 83970},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2443, col: 24, offset: 83970},
																	val:        "\\",
																	ignoreCase: false,
																	want:       "\"\\\\\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2360, col: 19, offset: 81158},
																	val:        "[0-7]",
																	ranges:     []rune{'0', '7'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2360, col: 19, offset: 81158},
																	val:        "[0-7]",
																	ranges:     []rune{'0', '7'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2360, col: 19, offset: 81158},
																	val:        "[0-7]",
																	ranges:     []rune{'0', '7'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&seqExpr{
															pos: position{line: 2444, col: 24, offset: 84037},
															exprs: []interface{}{
																&litMatcher{
																	pos:        position{line: 2444, col: 24, offset: 84037},
																	val:        "\\x",
																	ignoreCase: false,
																	want:       "\"\\\\x\"",
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
																&charClassMatcher{
																	pos:        position{line: 2361, col: 19, offset: 81182},
																	val:        "[0-9A-Fa-f]",
																	ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
														&actionExpr{
															pos: position{line: 2445, col: 5, offset: 84074},
															run: (*parser).callongoFieldDecl210,
															expr: &seqExpr{
																pos: position{line: 2445, col: 5, offset: 84074},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 2445, col: 5, offset: 84074},
																		val:        "\\x",
																		ignoreCase: false,
																		want:       "\"\\\\x\"",
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2445, col: 14, offset: 84083},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2445, col: 26, offset: 84095},
																		expr: &charClassMatcher{
																			pos:        position{line: 2361, col: 19, offset: 81182},
																			val:        "[0-9A-Fa-f]",
																			ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 2607, col: 37, offset: 90735},
															run: (*parser).callongoFieldDecl217,
															expr: &seqExpr{
																pos: position{line: 2607, col: 37, offset: 90735},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 2607, col: 37, offset: 90735},
																		val:        "\\",
																		ignoreCase: false,
																		want:       "\"\\\\\"",
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 2631, col: 5, offset: 91752},
															run: (*parser).callongoFieldDecl228,
															expr: &seqExpr{
																pos: position{line: 2631, col: 5, offset: 91752},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 2631, col: 5, offset: 91752},
																		val:        "\\",
																		ignoreCase: false,
																		want:       "\"\\\\\"",
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 2652, col: 5, offset: 92594},
															run: (*parser).callongoFieldDecl235,
															expr: &seqExpr{
																pos: position{line: 2652, col: 5, offset: 92594},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 2652, col: 5, offset: 92594},
																		val:        "\\",
																		ignoreCase: false,
																		want:       "\"\\\\\"",
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&charClassMatcher{
																		pos:        position{line: 2361, col: 19, offset: 81182},
																		val:        "[0-9A-Fa-f]",
																		ranges:     []rune{'0', '9', 'A', 'F', 'a', 'f'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
														&actionExpr{
															pos: position{line: 2670, col: 5, offset: 93280},
															run: (*parser).callongoFieldDecl240,
															expr: &seqExpr{
																pos: position{line: 2670, col: 5, offset: 93280},
																exprs: []interface{}{
																	&litMatcher{
																		pos:        position{line: 2670, col: 5, offset: 93280},
																		val:        "\\",
																		ignoreCase: false,
																		want:       "\"\\\\\"",
																	},
																	&zeroOrOneExpr{
																		pos: position{line: 2670, col: 10, offset: 93285},
																		expr: &charClassMatcher{
																			pos:        position{line: 3735, col: 12, offset: 128270},
																			val:        "[^\\r\\n]",
																			chars:      []rune{'\r', '\n'},
																			ignoreCase: false,
																			inverted:   true,
																		},
																	},
																},
															},
														},
													},
												},
											},
											&notExpr{
												pos: position{line: 3733, col: 12, offset: 128223},
												expr: &anyMatcher{
													line: 3733, col: 13, offset: 128224,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goEmbeddedField",
			pos:  position{line: 2752, col: 1, offset: 96051},
			expr: &seqExpr{
				pos: position{line: 2752, col: 20, offset: 96070},
				exprs: []interface{}{
					&zeroOrOneExpr{
						pos: position{line: 2752, col: 20, offset: 96070},
						expr: &litMatcher{
							pos:        position{line: 2752, col: 20, offset: 96070},
							val:        "*",
							ignoreCase: false,
							want:       "\"*\"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2752, col: 25, offset: 96075},
						expr: &litMatcher{
							pos:        position{line: 2752, col: 25, offset: 96075},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&choiceExpr{
						pos: position{line: 2727, col: 15, offset: 95259},
						alternatives: []interface{}{
							&seqExpr{
								pos: position{line: 2384, col: 21, offset: 81785},
								exprs: []interface{}{
									&charClassMatcher{
										pos:        position{line: 2350, col: 20, offset: 80988},
										val:        "[_\\pL]",
										chars:      []rune{'_'},
										classes:    []*unicode.RangeTable{rangeTable("L")},
										ignoreCase: false,
										inverted:   false,
									},
									&zeroOrMoreExpr{
										pos: position{line: 2367, col: 26, offset: 81242},
										expr: &charClassMatcher{
											pos:        position{line: 2350, col: 20, offset: 80988},
											val:        "[_\\pL\\pNd]",
											chars:      []rune{'_'},
											classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
											ignoreCase: false,
											inverted:   false,
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 2384, col: 35, offset: 81799},
										expr: &litMatcher{
											pos:        position{line: 2384, col: 35, offset: 81799},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&litMatcher{
										pos:        position{line: 2384, col: 40, offset: 81804},
										val:        ".",
										ignoreCase: false,
										want:       "\".\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 2384, col: 44, offset: 81808},
										expr: &litMatcher{
											pos:        position{line: 2384, col: 44, offset: 81808},
											val:        " ",
											ignoreCase: false,
											want:       "\" \"",
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 2384, col: 49, offset: 81813},
										expr: &seqExpr{
											pos: position{line: 2367, col: 17, offset: 81233},
											exprs: []interface{}{
												&charClassMatcher{
													pos:        position{line: 2350, col: 20, offset: 80988},
													val:        "[_\\pL]",
													chars:      []rune{'_'},
													classes:    []*unicode.RangeTable{rangeTable("L")},
													ignoreCase: false,
													inverted:   false,
												},
												&zeroOrMoreExpr{
													pos: position{line: 2367, col: 26, offset: 81242},
													expr: &charClassMatcher{
														pos:        position{line: 2350, col: 20, offset: 80988},
														val:        "[_\\pL\\pNd]",
														chars:      []rune{'_'},
														classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
														ignoreCase: false,
														inverted:   false,
													},
												},
											},
										},
									},
								},
							},
							&seqExpr{
								pos: position{line: 2367, col: 17, offset: 81233},
								exprs: []interface{}{
									&charClassMatcher{
										pos:        position{line: 2350, col: 20, offset: 80988},
										val:        "[_\\pL]",
										chars:      []rune{'_'},
										classes:    []*unicode.RangeTable{rangeTable("L")},
										ignoreCase: false,
										inverted:   false,
									},
									&zeroOrMoreExpr{
										pos: position{line: 2367, col: 26, offset: 81242},
										expr: &charClassMatcher{
											pos:        position{line: 2350, col: 20, offset: 80988},
											val:        "[_\\pL\\pNd]",
											chars:      []rune{'_'},
											classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
											ignoreCase: false,
											inverted:   false,
										},
									},
								},
							},
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2752, col: 41, offset: 96091},
						expr: &litMatcher{
							pos:        position{line: 2752, col: 41, offset: 96091},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2752, col: 46, offset: 96096},
						expr: &ruleRefExpr{
							pos:  position{line: 2752, col: 46, offset: 96096},
							name: "goTypeArgs",
						},
					},
				},
			},
		},
		{
			name: "goPointerType",
			pos:  position{line: 2759, col: 1, offset: 96164},
			expr: &seqExpr{
				pos: position{line: 2759, col: 18, offset: 96181},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2759, col: 18, offset: 96181},
						val:        "*",
						ignoreCase: false,
						want:       "\"*\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2759, col: 22, offset: 96185},
						expr: &litMatcher{
							pos:        position{line: 2759, col: 22, offset: 96185},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2759, col: 27, offset: 96190},
						name: "goBaseType",
					},
				},
			},
		},
		{
			name: "goBaseType",
			pos:  position{line: 2760, col: 1, offset: 96201},
			expr: &ruleRefExpr{
				pos:  position{line: 2760, col: 18, offset: 96218},
				name: "goType",
			},
		},
		{
			name: "goFunctionType",
			pos:  position{line: 2766, col: 1, offset: 96251},
			expr: &seqExpr{
				pos: position{line: 2766, col: 20, offset: 96270},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2766, col: 20, offset: 96270},
						val:        "func",
						ignoreCase: false,
						want:       "\"func\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2766, col: 27, offset: 96277},
						expr: &litMatcher{
							pos:        position{line: 2766, col: 27, offset: 96277},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2766, col: 32, offset: 96282},
						name: "goSignature",
					},
				},
			},
		},
		{
			name: "goSignature",
			pos:  position{line: 2767, col: 1, offset: 96294},
			expr: &seqExpr{
				pos: position{line: 2767, col: 20, offset: 96313},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2767, col: 20, offset: 96313},
						name: "goParameters",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2767, col: 33, offset: 96326},
						expr: &litMatcher{
							pos:        position{line: 2767, col: 33, offset: 96326},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2767, col: 38, offset: 96331},
						expr: &ruleRefExpr{
							pos:  position{line: 2767, col: 38, offset: 96331},
							name: "goResult",
						},
					},
				},
			},
		},
		{
			name: "goResult",
			pos:  position{line: 2768, col: 1, offset: 96341},
			expr: &choiceExpr{
				pos: position{line: 2768, col: 20, offset: 96360},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2768, col: 20, offset: 96360},
						name: "goParameters",
					},
					&ruleRefExpr{
						pos:  position{line: 2768, col: 35, offset: 96375},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goParameters",
			pos:  position{line: 2769, col: 1, offset: 96382},
			expr: &seqExpr{
				pos: position{line: 2769, col: 20, offset: 96401},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2769, col: 20, offset: 96401},
						val:        "(",
						ignoreCase: false,
						want:       "\"(\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2769, col: 24, offset: 96405},
						expr: &choiceExpr{
							pos: position{line: 3750, col: 20, offset: 128702},
							alternatives: []interface{}{
								&charClassMatcher{
									pos:        position{line: 3746, col: 36, offset: 128584},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
								&seqExpr{
									pos: position{line: 3747, col: 36, offset: 128625},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2769, col: 28, offset: 96409},
						expr: &seqExpr{
							pos: position{line: 2769, col: 29, offset: 96410},
							exprs: []interface{}{
								&ruleRefExpr{
									pos:  position{line: 2769, col: 29, offset: 96410},
									name: "goParameterList",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2769, col: 45, offset: 96426},
									expr: &litMatcher{
										pos:        position{line: 2769, col: 45, offset: 96426},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2769, col: 50, offset: 96431},
									expr: &seqExpr{
										pos: position{line: 2769, col: 51, offset: 96432},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 2769, col: 51, offset: 96432},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2769, col: 55, offset: 96436},
												expr: &choiceExpr{
													pos: position{line: 3750, col: 20, offset: 128702},
													alternatives: []interface{}{
														&charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3747, col: 36, offset: 128625},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3747, col: 36, offset: 128625},
																	expr: &litMatcher{
																		pos:        position{line: 3747, col: 36, offset: 128625},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3747, col: 42, offset: 128631},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2769, col: 63, offset: 96444},
						val:        ")",
						ignoreCase: false,
						want:       "\")\"",
					},
				},
			},
		},
		{
			name: "goParameterList",
			pos:  position{line: 2770, col: 1, offset: 96448},
			expr: &seqExpr{
				pos: position{line: 2770, col: 20, offset: 96467},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2770, col: 20, offset: 96467},
						name: "goParameterDecl",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2770, col: 36, offset: 96483},
						expr: &litMatcher{
							pos:        position{line: 2770, col: 36, offset: 96483},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2770, col: 41, offset: 96488},
						expr: &seqExpr{
							pos: position{line: 2770, col: 42, offset: 96489},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2770, col: 42, offset: 96489},
									val:        ",",
									ignoreCase: false,
									want:       "\",\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2770, col: 46, offset: 96493},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2770, col: 50, offset: 96497},
									name: "goParameterDecl",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goParameterDecl",
			pos:  position{line: 2771, col: 1, offset: 96515},
			expr: &seqExpr{
				pos: position{line: 2771, col: 20, offset: 96534},
				exprs: []interface{}{
					&zeroOrOneExpr{
						pos: position{line: 2771, col: 20, offset: 96534},
						expr: &seqExpr{
							pos: position{line: 2802, col: 21, offset: 97214},
							exprs: []interface{}{
								&charClassMatcher{
									pos:        position{line: 2350, col: 20, offset: 80988},
									val:        "[_\\pL]",
									chars:      []rune{'_'},
									classes:    []*unicode.RangeTable{rangeTable("L")},
									ignoreCase: false,
									inverted:   false,
								},
								&zeroOrMoreExpr{
									pos: position{line: 2367, col: 26, offset: 81242},
									expr: &charClassMatcher{
										pos:        position{line: 2350, col: 20, offset: 80988},
										val:        "[_\\pL\\pNd]",
										chars:      []rune{'_'},
										classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2802, col: 34, offset: 97227},
									expr: &litMatcher{
										pos:        position{line: 2802, col: 34, offset: 97227},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2802, col: 39, offset: 97232},
									expr: &seqExpr{
										pos: position{line: 2802, col: 40, offset: 97233},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 2802, col: 40, offset: 97233},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2802, col: 44, offset: 97237},
												expr: &choiceExpr{
													pos: position{line: 3750, col: 20, offset: 128702},
													alternatives: []interface{}{
														&charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3747, col: 36, offset: 128625},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3747, col: 36, offset: 128625},
																	expr: &litMatcher{
																		pos:        position{line: 3747, col: 36, offset: 128625},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3747, col: 42, offset: 128631},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
											&charClassMatcher{
												pos:        position{line: 2350, col: 20, offset: 80988},
												val:        "[_\\pL]",
												chars:      []rune{'_'},
												classes:    []*unicode.RangeTable{rangeTable("L")},
												ignoreCase: false,
												inverted:   false,
											},
											&zeroOrMoreExpr{
												pos: position{line: 2367, col: 26, offset: 81242},
												expr: &charClassMatcher{
													pos:        position{line: 2350, col: 20, offset: 80988},
													val:        "[_\\pL\\pNd]",
													chars:      []rune{'_'},
													classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
													ignoreCase: false,
													inverted:   false,
												},
											},
										},
									},
								},
							},
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2771, col: 38, offset: 96552},
						expr: &litMatcher{
							pos:        position{line: 2771, col: 38, offset: 96552},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2771, col: 43, offset: 96557},
						expr: &litMatcher{
							pos:        position{line: 2771, col: 43, offset: 96557},
							val:        "...",
							ignoreCase: false,
							want:       "\"...\"",
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2771, col: 50, offset: 96564},
						expr: &litMatcher{
							pos:        position{line: 2771, col: 50, offset: 96564},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2771, col: 55, offset: 96569},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goInterfaceType",
			pos:  position{line: 2777, col: 1, offset: 96603},
			expr: &seqExpr{
				pos: position{line: 2777, col: 21, offset: 96623},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2777, col: 21, offset: 96623},
						val:        "interface",
						ignoreCase: false,
						want:       "\"interface\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2777, col: 33, offset: 96635},
						expr: &litMatcher{
							pos:        position{line: 2777, col: 33, offset: 96635},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2777, col: 38, offset: 96640},
						val:        "{",
						ignoreCase: false,
						want:       "\"{\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2777, col: 42, offset: 96644},
						expr: &seqExpr{
							pos: position{line: 2777, col: 43, offset: 96645},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 2777, col: 43, offset: 96645},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2777, col: 47, offset: 96649},
									name: "goInterfaceElem",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2777, col: 63, offset: 96665},
									expr: &litMatcher{
										pos:        position{line: 2777, col: 63, offset: 96665},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&choiceExpr{
									pos: position{line: 2777, col: 69, offset: 96671},
									alternatives: []interface{}{
										&litMatcher{
											pos:        position{line: 2777, col: 69, offset: 96671},
											val:        ";",
											ignoreCase: false,
											want:       "\";\"",
										},
										&oneOrMoreExpr{
											pos: position{line: 3748, col: 36, offset: 128671},
											expr: &seqExpr{
												pos: position{line: 3748, col: 37, offset: 128672},
												exprs: []interface{}{
													&zeroOrMoreExpr{
														pos: position{line: 3748, col: 37, offset: 128672},
														expr: &charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&zeroOrMoreExpr{
						pos: position{line: 2777, col: 86, offset: 96688},
						expr: &choiceExpr{
							pos: position{line: 3750, col: 20, offset: 128702},
							alternatives: []interface{}{
								&charClassMatcher{
									pos:        position{line: 3746, col: 36, offset: 128584},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
								&seqExpr{
									pos: position{line: 3747, col: 36, offset: 128625},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 3747, col: 36, offset: 128625},
											expr: &litMatcher{
												pos:        position{line: 3747, col: 36, offset: 128625},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3747, col: 42, offset: 128631},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2777, col: 90, offset: 96692},
						val:        "}",
						ignoreCase: false,
						want:       "\"}\"",
					},
				},
			},
		},
		{
			name: "goInterfaceElem",
			pos:  position{line: 2778, col: 1, offset: 96696},
			expr: &choiceExpr{
				pos: position{line: 2778, col: 21, offset: 96716},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2778, col: 21, offset: 96716},
						name: "goMethodElem",
					},
					&ruleRefExpr{
						pos:  position{line: 2778, col: 36, offset: 96731},
						name: "goTypeElem",
					},
				},
			},
		},
		{
			name: "goMethodElem",
			pos:  position{line: 2779, col: 1, offset: 96742},
			expr: &seqExpr{
				pos: position{line: 2779, col: 21, offset: 96762},
				exprs: []interface{}{
					&charClassMatcher{
						pos:        position{line: 2350, col: 20, offset: 80988},
						val:        "[_\\pL]",
						chars:      []rune{'_'},
						classes:    []*unicode.RangeTable{rangeTable("L")},
						ignoreCase: false,
						inverted:   false,
					},
					&zeroOrMoreExpr{
						pos: position{line: 2367, col: 26, offset: 81242},
						expr: &charClassMatcher{
							pos:        position{line: 2350, col: 20, offset: 80988},
							val:        "[_\\pL\\pNd]",
							chars:      []rune{'_'},
							classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2779, col: 34, offset: 96775},
						name: "goSignature",
					},
				},
			},
		},
		{
			name: "goTypeElem",
			pos:  position{line: 2781, col: 1, offset: 96820},
			expr: &seqExpr{
				pos: position{line: 2781, col: 21, offset: 96840},
				exprs: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2781, col: 21, offset: 96840},
						name: "goTypeTerm",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2781, col: 32, offset: 96851},
						expr: &seqExpr{
							pos: position{line: 2781, col: 33, offset: 96852},
							exprs: []interface{}{
								&zeroOrMoreExpr{
									pos: position{line: 2781, col: 33, offset: 96852},
									expr: &litMatcher{
										pos:        position{line: 2781, col: 33, offset: 96852},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 2781, col: 38, offset: 96857},
									val:        "|",
									ignoreCase: false,
									want:       "\"|\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2781, col: 42, offset: 96861},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&ruleRefExpr{
									pos:  position{line: 2781, col: 46, offset: 96865},
									name: "goTypeTerm",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "goTypeTerm",
			pos:  position{line: 2782, col: 1, offset: 96878},
			expr: &choiceExpr{
				pos: position{line: 2782, col: 21, offset: 96898},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 2782, col: 21, offset: 96898},
						name: "goType",
					},
					&ruleRefExpr{
						pos:  position{line: 2782, col: 30, offset: 96907},
						name: "goUnderlyingType",
					},
				},
			},
		},
		{
			name: "goUnderlyingType",
			pos:  position{line: 2783, col: 1, offset: 96924},
			expr: &seqExpr{
				pos: position{line: 2783, col: 21, offset: 96944},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2783, col: 21, offset: 96944},
						val:        "~",
						ignoreCase: false,
						want:       "\"~\"",
					},
					&ruleRefExpr{
						pos:  position{line: 2783, col: 25, offset: 96948},
						name: "goType",
					},
				},
			},
		},
		{
			name: "goMapType",
			pos:  position{line: 2789, col: 1, offset: 96976},
			expr: &seqExpr{
				pos: position{line: 2789, col: 14, offset: 96989},
				exprs: []interface{}{
					&litMatcher{
						pos:        position{line: 2789, col: 14, offset: 96989},
						val:        "map",
						ignoreCase: false,
						want:       "\"map\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2789, col: 20, offset: 96995},
						expr: &litMatcher{
							pos:        position{line: 2789, col: 20, offset: 96995},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2789, col: 25, offset: 97000},
						val:        "[",
						ignoreCase: false,
						want:       "\"[\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2789, col: 29, offset: 97004},
						expr: &litMatcher{
							pos:        position{line: 2789, col: 29, offset: 97004},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2789, col: 34, offset: 97009},
						name: "goKeyType",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2789, col: 44, offset: 97019},
						expr: &litMatcher{
							pos:        position{line: 2789, col: 44, offset: 97019},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&litMatcher{
						pos:        position{line: 2789, col: 49, offset: 97024},
						val:        "]",
						ignoreCase: false,
						want:       "\"]\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2789, col: 53, offset: 97028},
						expr: &litMatcher{
							pos:        position{line: 2789, col: 53, offset: 97028},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2789, col: 58, offset: 97033},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "goKeyType",
			pos:  position{line: 2790, col: 1, offset: 97047},
			expr: &ruleRefExpr{
				pos:  position{line: 2790, col: 14, offset: 97060},
				name: "goType",
			},
		},
		{
			name: "goChannelType",
			pos:  position{line: 2796, col: 1, offset: 97092},
			expr: &seqExpr{
				pos: position{line: 2796, col: 18, offset: 97109},
				exprs: []interface{}{
					&zeroOrOneExpr{
						pos: position{line: 2796, col: 18, offset: 97109},
						expr: &seqExpr{
							pos: position{line: 2796, col: 19, offset: 97110},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2796, col: 19, offset: 97110},
									val:        "<-",
									ignoreCase: false,
									want:       "\"<-\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2796, col: 24, offset: 97115},
									expr: &litMatcher{
										pos:        position{line: 2796, col: 24, offset: 97115},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
							},
						},
					},
					&litMatcher{
						pos:        position{line: 2796, col: 31, offset: 97122},
						val:        "chan",
						ignoreCase: false,
						want:       "\"chan\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 2796, col: 38, offset: 97129},
						expr: &litMatcher{
							pos:        position{line: 2796, col: 38, offset: 97129},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
					},
					&zeroOrOneExpr{
						pos: position{line: 2796, col: 43, offset: 97134},
						expr: &seqExpr{
							pos: position{line: 2796, col: 44, offset: 97135},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2796, col: 44, offset: 97135},
									val:        "<-",
									ignoreCase: false,
									want:       "\"<-\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2796, col: 49, offset: 97140},
									expr: &litMatcher{
										pos:        position{line: 2796, col: 49, offset: 97140},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 2796, col: 56, offset: 97147},
						name: "goElementType",
					},
				},
			},
		},
		{
			name: "Mixin",
			pos:  position{line: 2855, col: 1, offset: 99595},
			expr: &choiceExpr{
				pos: position{line: 2855, col: 10, offset: 99604},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2855, col: 10, offset: 99604},
						run: (*parser).callonMixin2,
						expr: &seqExpr{
							pos: position{line: 2855, col: 10, offset: 99604},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2855, col: 10, offset: 99604},
									val:        "mixin",
									ignoreCase: false,
									want:       "\"mixin\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 2855, col: 18, offset: 99612},
									expr: &litMatcher{
										pos:        position{line: 2855, col: 18, offset: 99612},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2855, col: 23, offset: 99617},
									label: "nameI",
									expr: &choiceExpr{
										pos: position{line: 711, col: 14, offset: 21845},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 711, col: 14, offset: 21845},
												run: (*parser).callonMixin9,
												expr: &labeledExpr{
													pos:   position{line: 711, col: 14, offset: 21845},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 697, col: 10, offset: 21290},
														alternatives: []interface{}{
															&actionExpr{
																pos: position{line: 697, col: 10, offset: 21290},
																run: (*parser).callonMixin12,
																expr: &labeledExpr{
																	pos:   position{line: 697, col: 10, offset: 21290},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 2367, col: 17, offset: 81233},
																		exprs: []interface{}{
																			&charClassMatcher{
																				pos:        position{line: 2350, col: 20, offset: 80988},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2367, col: 26, offset: 81242},
																				expr: &charClassMatcher{
																					pos:        position{line: 2350, col: 20, offset: 80988},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 699, col: 5, offset: 21384},
																run: (*parser).callonMixin18,
																expr: &seqExpr{
																	pos: position{line: 699, col: 5, offset: 21384},
																	exprs: []interface{}{
																		&labeledExpr{
																			pos:   position{line: 699, col: 5, offset: 21384},
																			label: "identI",
																			expr: &seqExpr{
																				pos: position{line: 699, col: 13, offset: 21392},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 699, col: 13, offset: 21392},
																						expr: &litMatcher{
																							pos:        position{line: 699, col: 13, offset: 21392},
																							val:        "$",
																							ignoreCase: false,
																							want:       "\"$\"",
																						},
																					},
																					&oneOrMoreExpr{
																						pos: position{line: 699, col: 18, offset: 21397},
																						expr: &choiceExpr{
																							pos: position{line: 699, col: 19, offset: 21398},
																							alternatives: []interface{}{
																								&seqExpr{
																									pos: position{line: 699, col: 19, offset: 21398},
																									exprs: []interface{}{
																										&charClassMatcher{
																											pos:        position{line: 699, col: 19, offset: 21398},
																											val:        "[\\pNd]",
																											classes:    []*unicode.RangeTable{rangeTable("Nd")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 699, col: 28, offset: 21407},
																											val:        "[_-\\pL]",
																											chars:      []rune{'_', '-'},
																											classes:    []*unicode.RangeTable{rangeTable("L")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 699, col: 38, offset: 21417},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 699, col: 49, offset: 21428},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonMixin31,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 713, col: 5, offset: 21887},
												run: (*parser).callonMixin37,
												expr: &seqExpr{
													pos: position{line: 713, col: 5, offset: 21887},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 713, col: 5, offset: 21887},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonMixin40,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&andExpr{
															pos: position{line: 713, col: 14, offset: 21896},
															expr: &choiceExpr{
																pos: position{line: 713, col: 16, offset: 21898},
																alternatives: []interface{}{
																	&seqExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		exprs: []interface{}{
																			&zeroOrMoreExpr{
																				pos: position{line: 3734, col: 12, offset: 128237},
																				expr: &charClassMatcher{
																					pos:        position{line: 3746, col: 36, offset: 128584},
																					val:        "[ \\t]",
																					chars:      []rune{' ', '\t'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&choiceExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						exprs: []interface{}{
																							&zeroOrOneExpr{
																								pos: position{line: 3734, col: 16, offset: 128241},
																								expr: &litMatcher{
																									pos:        position{line: 3734, col: 16, offset: 128241},
																									val:        "\r",
																									ignoreCase: false,
																									want:       "\"\\r\"",
																								},
																							},
																							&litMatcher{
																								pos:        position{line: 3734, col: 22, offset: 128247},
																								val:        "\n",
																								ignoreCase: false,
																								want:       "\"\\n\"",
																							},
																						},
																					},
																					&notExpr{
																						pos: position{line: 3733, col: 12, offset: 128223},
																						expr: &anyMatcher{
																							line: 3733, col: 13, offset: 128224,
																						},
																					},
																				},
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 713, col: 22, offset: 21904},
																		val:        "[:!=(]",
																		chars:      []rune{':', '!', '=', '('},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 724, col: 5, offset: 22230},
												run: (*parser).callonMixin59,
												expr: &seqExpr{
													pos: position{line: 724, col: 5, offset: 22230},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 724, col: 5, offset: 22230},
															label: "identI",
															expr: &oneOrMoreExpr{
																pos: position{line: 724, col: 12, offset: 22237},
																expr: &charClassMatcher{
																	pos:        position{line: 724, col: 12, offset: 22237},
																	val:        "[^ \\t\\r\\n:!=(]",
																	chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 724, col: 28, offset: 22253},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonMixin65,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2855, col: 39, offset: 99633},
									label: "paramsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2855, col: 47, offset: 99641},
										expr: &ruleRefExpr{
											pos:  position{line: 2855, col: 47, offset: 99641},
											name: "mixinParamList",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2855, col: 63, offset: 99657},
									label: "bodyI",
									expr: &ruleRefExpr{
										pos:  position{line: 2855, col: 69, offset: 99663},
										name: "Beaitb",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2865, col: 5, offset: 99957},
						run: (*parser).callonMixin76,
						expr: &seqExpr{
							pos: position{line: 2865, col: 5, offset: 99957},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2865, col: 5, offset: 99957},
									val:        "mixin",
									ignoreCase: false,
									want:       "\"mixin\"",
								},
								&labeledExpr{
									pos:   position{line: 2865, col: 13, offset: 99965},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonMixin80,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2865, col: 22, offset: 99974},
									label: "bodyI",
									expr: &ruleRefExpr{
										pos:  position{line: 2865, col: 28, offset: 99980},
										name: "Beaitb",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParamList",
			pos:  position{line: 2881, col: 1, offset: 100393},
			expr: &choiceExpr{
				pos: position{line: 2881, col: 19, offset: 100411},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2881, col: 19, offset: 100411},
						run: (*parser).callonmixinParamList2,
						expr: &seqExpr{
							pos: position{line: 2881, col: 19, offset: 100411},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2881, col: 19, offset: 100411},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2881, col: 23, offset: 100415},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2881, col: 27, offset: 100419},
									label: "paramsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2881, col: 35, offset: 100427},
										expr: &ruleRefExpr{
											pos:  position{line: 2881, col: 35, offset: 100427},
											name: "mixinParams",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 2881, col: 48, offset: 100440},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2881, col: 51, offset: 100443},
									expr: &seqExpr{
										pos: position{line: 2881, col: 52, offset: 100444},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 2881, col: 52, offset: 100444},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 2881, col: 56, offset: 100448},
												expr: &choiceExpr{
													pos: position{line: 3750, col: 20, offset: 128702},
													alternatives: []interface{}{
														&charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3747, col: 36, offset: 128625},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3747, col: 36, offset: 128625},
																	expr: &litMatcher{
																		pos:        position{line: 3747, col: 36, offset: 128625},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3747, col: 42, offset: 128631},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2881, col: 62, offset: 100454},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonmixinParamList28,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2887, col: 5, offset: 100655},
						run: (*parser).callonmixinParamList30,
						expr: &seqExpr{
							pos: position{line: 2887, col: 5, offset: 100655},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2887, col: 5, offset: 100655},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2887, col: 9, offset: 100659},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2887, col: 13, offset: 100663},
									label: "paramsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 2887, col: 21, offset: 100671},
										expr: &ruleRefExpr{
											pos:  position{line: 2887, col: 21, offset: 100671},
											name: "mixinParams",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 2887, col: 34, offset: 100684},
									expr: &seqExpr{
										pos: position{line: 2887, col: 35, offset: 100685},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 2887, col: 35, offset: 100685},
												expr: &charClassMatcher{
													pos:        position{line: 3746, col: 36, offset: 128584},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&litMatcher{
												pos:        position{line: 2887, col: 38, offset: 100688},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 2887, col: 44, offset: 100694},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonmixinParamList49,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParams",
			pos:  position{line: 2906, col: 1, offset: 101239},
			expr: &actionExpr{
				pos: position{line: 2906, col: 16, offset: 101254},
				run: (*parser).callonmixinParams1,
				expr: &seqExpr{
					pos: position{line: 2906, col: 16, offset: 101254},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 2906, col: 16, offset: 101254},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 2906, col: 23, offset: 101261},
								name: "mixinParam",
							},
						},
						&labeledExpr{
							pos:   position{line: 2906, col: 34, offset: 101272},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 2906, col: 40, offset: 101278},
								expr: &seqExpr{
									pos: position{line: 2906, col: 41, offset: 101279},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 2906, col: 41, offset: 101279},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&litMatcher{
											pos:        position{line: 2906, col: 44, offset: 101282},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 2906, col: 48, offset: 101286},
											expr: &choiceExpr{
												pos: position{line: 3750, col: 20, offset: 128702},
												alternatives: []interface{}{
													&charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														exprs: []interface{}{
															&zeroOrOneExpr{
																pos: position{line: 3747, col: 36, offset: 128625},
																expr: &litMatcher{
																	pos:        position{line: 3747, col: 36, offset: 128625},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3747, col: 42, offset: 128631},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2906, col: 52, offset: 101290},
											name: "mixinParam",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParam",
			pos:  position{line: 2917, col: 1, offset: 101568},
			expr: &actionExpr{
				pos: position{line: 2917, col: 15, offset: 101582},
				run: (*parser).callonmixinParam1,
				expr: &seqExpr{
					pos: position{line: 2917, col: 15, offset: 101582},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 2917, col: 15, offset: 101582},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 711, col: 14, offset: 21845},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 711, col: 14, offset: 21845},
										run: (*parser).callonmixinParam5,
										expr: &labeledExpr{
											pos:   position{line: 711, col: 14, offset: 21845},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 697, col: 10, offset: 21290},
												alternatives: []interface{}{
													&actionExpr{
														pos: position{line: 697, col: 10, offset: 21290},
														run: (*parser).callonmixinParam8,
														expr: &labeledExpr{
															pos:   position{line: 697, col: 10, offset: 21290},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2367, col: 17, offset: 81233},
																exprs: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2367, col: 26, offset: 81242},
																		expr: &charClassMatcher{
																			pos:        position{line: 2350, col: 20, offset: 80988},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 699, col: 5, offset: 21384},
														run: (*parser).callonmixinParam14,
														expr: &seqExpr{
															pos: position{line: 699, col: 5, offset: 21384},
															exprs: []interface{}{
																&labeledExpr{
																	pos:   position{line: 699, col: 5, offset: 21384},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 699, col: 13, offset: 21392},
																		exprs: []interface{}{
																			&zeroOrOneExpr{
																				pos: position{line: 699, col: 13, offset: 21392},
																				expr: &litMatcher{
																					pos:        position{line: 699, col: 13, offset: 21392},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 699, col: 18, offset: 21397},
																				expr: &choiceExpr{
																					pos: position{line: 699, col: 19, offset: 21398},
																					alternatives: []interface{}{
																						&seqExpr{
																							pos: position{line: 699, col: 19, offset: 21398},
																							exprs: []interface{}{
																								&charClassMatcher{
																									pos:        position{line: 699, col: 19, offset: 21398},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 699, col: 28, offset: 21407},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 699, col: 38, offset: 21417},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 699, col: 49, offset: 21428},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3737, col: 8, offset: 128286},
																		run: (*parser).callonmixinParam27,
																		expr: &choiceExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			alternatives: []interface{}{
																				&andExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					expr: &anyMatcher{
																						line: 3737, col: 10, offset: 128288,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3737, col: 14, offset: 128292},
																					expr: &anyMatcher{
																						line: 3737, col: 15, offset: 128293,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 713, col: 5, offset: 21887},
										run: (*parser).callonmixinParam33,
										expr: &seqExpr{
											pos: position{line: 713, col: 5, offset: 21887},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 713, col: 5, offset: 21887},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonmixinParam36,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
												&andExpr{
													pos: position{line: 713, col: 14, offset: 21896},
													expr: &choiceExpr{
														pos: position{line: 713, col: 16, offset: 21898},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 12, offset: 128237},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 713, col: 22, offset: 21904},
																val:        "[:!=(]",
																chars:      []rune{':', '!', '=', '('},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 724, col: 5, offset: 22230},
										run: (*parser).callonmixinParam55,
										expr: &seqExpr{
											pos: position{line: 724, col: 5, offset: 22230},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 724, col: 5, offset: 22230},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 724, col: 12, offset: 22237},
														expr: &charClassMatcher{
															pos:        position{line: 724, col: 12, offset: 22237},
															val:        "[^ \\t\\r\\n:!=(]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 724, col: 28, offset: 22253},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonmixinParam61,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2917, col: 31, offset: 101598},
							label: "posI",
							expr: &actionExpr{
								pos: position{line: 3737, col: 8, offset: 128286},
								run: (*parser).callonmixinParam68,
								expr: &choiceExpr{
									pos: position{line: 3737, col: 9, offset: 128287},
									alternatives: []interface{}{
										&andExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											expr: &anyMatcher{
												line: 3737, col: 10, offset: 128288,
											},
										},
										&notExpr{
											pos: position{line: 3737, col: 14, offset: 128292},
											expr: &anyMatcher{
												line: 3737, col: 15, offset: 128293,
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2917, col: 40, offset: 101607},
							label: "typeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2917, col: 46, offset: 101613},
								expr: &seqExpr{
									pos: position{line: 2917, col: 47, offset: 101614},
									exprs: []interface{}{
										&oneOrMoreExpr{
											pos: position{line: 2917, col: 47, offset: 101614},
											expr: &litMatcher{
												pos:        position{line: 2917, col: 47, offset: 101614},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2917, col: 52, offset: 101619},
											name: "GoType",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2917, col: 61, offset: 101628},
							label: "defaultI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2917, col: 70, offset: 101637},
								expr: &seqExpr{
									pos: position{line: 2917, col: 71, offset: 101638},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 2917, col: 71, offset: 101638},
											expr: &litMatcher{
												pos:        position{line: 2917, col: 71, offset: 101638},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 2917, col: 76, offset: 101643},
											name: "mixinParamDefault",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinParamDefault",
			pos:  position{line: 2955, col: 1, offset: 102863},
			expr: &choiceExpr{
				pos: position{line: 2955, col: 22, offset: 102884},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 2955, col: 22, offset: 102884},
						run: (*parser).callonmixinParamDefault2,
						expr: &seqExpr{
							pos: position{line: 2955, col: 22, offset: 102884},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2955, col: 22, offset: 102884},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 2955, col: 26, offset: 102888},
									expr: &litMatcher{
										pos:        position{line: 2955, col: 26, offset: 102888},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 2955, col: 31, offset: 102893},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 2955, col: 37, offset: 102899},
										name: "GoExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 2960, col: 5, offset: 103040},
						run: (*parser).callonmixinParamDefault9,
						expr: &seqExpr{
							pos: position{line: 2960, col: 5, offset: 103040},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 2960, col: 5, offset: 103040},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&labeledExpr{
									pos:   position{line: 2960, col: 9, offset: 103044},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonmixinParamDefault13,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Return",
			pos:  position{line: 2985, col: 1, offset: 103836},
			expr: &actionExpr{
				pos: position{line: 2985, col: 11, offset: 103846},
				run: (*parser).callonReturn1,
				expr: &seqExpr{
					pos: position{line: 2985, col: 11, offset: 103846},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2985, col: 11, offset: 103846},
							val:        "return",
							ignoreCase: false,
							want:       "\"return\"",
						},
						&labeledExpr{
							pos:   position{line: 2985, col: 20, offset: 103855},
							label: "errExprI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2985, col: 29, offset: 103864},
								expr: &ruleRefExpr{
									pos:  position{line: 2985, col: 29, offset: 103864},
									name: "Expression",
								},
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 2985, col: 41, offset: 103876},
							expr: &actionExpr{
								pos: position{line: 1251, col: 21, offset: 40099},
								run: (*parser).callonReturn8,
								expr: &oneOrMoreExpr{
									pos: position{line: 1251, col: 21, offset: 40099},
									expr: &charClassMatcher{
										pos:        position{line: 3735, col: 12, offset: 128270},
										val:        "[^\\r\\n]",
										chars:      []rune{'\r', '\n'},
										ignoreCase: false,
										inverted:   true,
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3734, col: 12, offset: 128237},
							expr: &charClassMatcher{
								pos:        position{line: 3746, col: 36, offset: 128584},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3734, col: 16, offset: 128241},
							alternatives: []interface{}{
								&seqExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											expr: &litMatcher{
												pos:        position{line: 3734, col: 16, offset: 128241},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3734, col: 22, offset: 128247},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3733, col: 12, offset: 128223},
									expr: &anyMatcher{
										line: 3733, col: 13, offset: 128224,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "MixinCall",
			pos:  position{line: 2996, col: 1, offset: 104199},
			expr: &actionExpr{
				pos: position{line: 2996, col: 14, offset: 104212},
				run: (*parser).callonMixinCall1,
				expr: &seqExpr{
					pos: position{line: 2996, col: 14, offset: 104212},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 2996, col: 14, offset: 104212},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 2996, col: 18, offset: 104216},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2996, col: 29, offset: 104227},
								expr: &seqExpr{
									pos: position{line: 2996, col: 30, offset: 104228},
									exprs: []interface{}{
										&choiceExpr{
											pos: position{line: 697, col: 10, offset: 21290},
											alternatives: []interface{}{
												&actionExpr{
													pos: position{line: 697, col: 10, offset: 21290},
													run: (*parser).callonMixinCall8,
													expr: &labeledExpr{
														pos:   position{line: 697, col: 10, offset: 21290},
														label: "identI",
														expr: &seqExpr{
															pos: position{line: 2367, col: 17, offset: 81233},
															exprs: []interface{}{
																&charClassMatcher{
																	pos:        position{line: 2350, col: 20, offset: 80988},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2367, col: 26, offset: 81242},
																	expr: &charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 699, col: 5, offset: 21384},
													run: (*parser).callonMixinCall14,
													expr: &seqExpr{
														pos: position{line: 699, col: 5, offset: 21384},
														exprs: []interface{}{
															&labeledExpr{
																pos:   position{line: 699, col: 5, offset: 21384},
																label: "identI",
																expr: &seqExpr{
																	pos: position{line: 699, col: 13, offset: 21392},
																	exprs: []interface{}{
																		&zeroOrOneExpr{
																			pos: position{line: 699, col: 13, offset: 21392},
																			expr: &litMatcher{
																				pos:        position{line: 699, col: 13, offset: 21392},
																				val:        "$",
																				ignoreCase: false,
																				want:       "\"$\"",
																			},
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 699, col: 18, offset: 21397},
																			expr: &choiceExpr{
																				pos: position{line: 699, col: 19, offset: 21398},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 699, col: 19, offset: 21398},
																						exprs: []interface{}{
																							&charClassMatcher{
																								pos:        position{line: 699, col: 19, offset: 21398},
																								val:        "[\\pNd]",
																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 699, col: 28, offset: 21407},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 699, col: 38, offset: 21417},
																						val:        "[_-\\pL]",
																						chars:      []rune{'_', '-'},
																						classes:    []*unicode.RangeTable{rangeTable("L")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&labeledExpr{
																pos:   position{line: 699, col: 49, offset: 21428},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonMixinCall27,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 2996, col: 36, offset: 104234},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2996, col: 42, offset: 104240},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 711, col: 14, offset: 21845},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 711, col: 14, offset: 21845},
										run: (*parser).callonMixinCall36,
										expr: &labeledExpr{
											pos:   position{line: 711, col: 14, offset: 21845},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 697, col: 10, offset: 21290},
												alternatives: []interface{}{
													&actionExpr{
														pos: position{line: 697, col: 10, offset: 21290},
														run: (*parser).callonMixinCall39,
														expr: &labeledExpr{
															pos:   position{line: 697, col: 10, offset: 21290},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2367, col: 17, offset: 81233},
																exprs: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2367, col: 26, offset: 81242},
																		expr: &charClassMatcher{
																			pos:        position{line: 2350, col: 20, offset: 80988},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 699, col: 5, offset: 21384},
														run: (*parser).callonMixinCall45,
														expr: &seqExpr{
															pos: position{line: 699, col: 5, offset: 21384},
															exprs: []interface{}{
																&labeledExpr{
																	pos:   position{line: 699, col: 5, offset: 21384},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 699, col: 13, offset: 21392},
																		exprs: []interface{}{
																			&zeroOrOneExpr{
																				pos: position{line: 699, col: 13, offset: 21392},
																				expr: &litMatcher{
																					pos:        position{line: 699, col: 13, offset: 21392},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 699, col: 18, offset: 21397},
																				expr: &choiceExpr{
																					pos: position{line: 699, col: 19, offset: 21398},
																					alternatives: []interface{}{
																						&seqExpr{
																							pos: position{line: 699, col: 19, offset: 21398},
																							exprs: []interface{}{
																								&charClassMatcher{
																									pos:        position{line: 699, col: 19, offset: 21398},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 699, col: 28, offset: 21407},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 699, col: 38, offset: 21417},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 699, col: 49, offset: 21428},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3737, col: 8, offset: 128286},
																		run: (*parser).callonMixinCall58,
																		expr: &choiceExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			alternatives: []interface{}{
																				&andExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					expr: &anyMatcher{
																						line: 3737, col: 10, offset: 128288,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3737, col: 14, offset: 128292},
																					expr: &anyMatcher{
																						line: 3737, col: 15, offset: 128293,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 713, col: 5, offset: 21887},
										run: (*parser).callonMixinCall64,
										expr: &seqExpr{
											pos: position{line: 713, col: 5, offset: 21887},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 713, col: 5, offset: 21887},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonMixinCall67,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
												&andExpr{
													pos: position{line: 713, col: 14, offset: 21896},
													expr: &choiceExpr{
														pos: position{line: 713, col: 16, offset: 21898},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 12, offset: 128237},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 713, col: 22, offset: 21904},
																val:        "[:!=(]",
																chars:      []rune{':', '!', '=', '('},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 724, col: 5, offset: 22230},
										run: (*parser).callonMixinCall86,
										expr: &seqExpr{
											pos: position{line: 724, col: 5, offset: 22230},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 724, col: 5, offset: 22230},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 724, col: 12, offset: 22237},
														expr: &charClassMatcher{
															pos:        position{line: 724, col: 12, offset: 22237},
															val:        "[^ \\t\\r\\n:!=(]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 724, col: 28, offset: 22253},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonMixinCall92,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2996, col: 58, offset: 104256},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 2996, col: 64, offset: 104262},
								expr: &ruleRefExpr{
									pos:  position{line: 2996, col: 64, offset: 104262},
									name: "mixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 2996, col: 78, offset: 104276},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 2996, col: 84, offset: 104282},
								name: "mixinCallBody",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineMixinCall",
			pos:  position{line: 3008, col: 1, offset: 104576},
			expr: &actionExpr{
				pos: position{line: 3008, col: 20, offset: 104595},
				run: (*parser).callonInlineMixinCall1,
				expr: &seqExpr{
					pos: position{line: 3008, col: 20, offset: 104595},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 3008, col: 20, offset: 104595},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 3008, col: 24, offset: 104599},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3008, col: 35, offset: 104610},
								expr: &seqExpr{
									pos: position{line: 3008, col: 36, offset: 104611},
									exprs: []interface{}{
										&choiceExpr{
											pos: position{line: 697, col: 10, offset: 21290},
											alternatives: []interface{}{
												&actionExpr{
													pos: position{line: 697, col: 10, offset: 21290},
													run: (*parser).callonInlineMixinCall8,
													expr: &labeledExpr{
														pos:   position{line: 697, col: 10, offset: 21290},
														label: "identI",
														expr: &seqExpr{
															pos: position{line: 2367, col: 17, offset: 81233},
															exprs: []interface{}{
																&charClassMatcher{
																	pos:        position{line: 2350, col: 20, offset: 80988},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2367, col: 26, offset: 81242},
																	expr: &charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 699, col: 5, offset: 21384},
													run: (*parser).callonInlineMixinCall14,
													expr: &seqExpr{
														pos: position{line: 699, col: 5, offset: 21384},
														exprs: []interface{}{
															&labeledExpr{
																pos:   position{line: 699, col: 5, offset: 21384},
																label: "identI",
																expr: &seqExpr{
																	pos: position{line: 699, col: 13, offset: 21392},
																	exprs: []interface{}{
																		&zeroOrOneExpr{
																			pos: position{line: 699, col: 13, offset: 21392},
																			expr: &litMatcher{
																				pos:        position{line: 699, col: 13, offset: 21392},
																				val:        "$",
																				ignoreCase: false,
																				want:       "\"$\"",
																			},
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 699, col: 18, offset: 21397},
																			expr: &choiceExpr{
																				pos: position{line: 699, col: 19, offset: 21398},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 699, col: 19, offset: 21398},
																						exprs: []interface{}{
																							&charClassMatcher{
																								pos:        position{line: 699, col: 19, offset: 21398},
																								val:        "[\\pNd]",
																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 699, col: 28, offset: 21407},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 699, col: 38, offset: 21417},
																						val:        "[_-\\pL]",
																						chars:      []rune{'_', '-'},
																						classes:    []*unicode.RangeTable{rangeTable("L")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&labeledExpr{
																pos:   position{line: 699, col: 49, offset: 21428},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonInlineMixinCall27,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 3008, col: 42, offset: 104617},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3008, col: 48, offset: 104623},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 711, col: 14, offset: 21845},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 711, col: 14, offset: 21845},
										run: (*parser).callonInlineMixinCall36,
										expr: &labeledExpr{
											pos:   position{line: 711, col: 14, offset: 21845},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 697, col: 10, offset: 21290},
												alternatives: []interface{}{
													&actionExpr{
														pos: position{line: 697, col: 10, offset: 21290},
														run: (*parser).callonInlineMixinCall39,
														expr: &labeledExpr{
															pos:   position{line: 697, col: 10, offset: 21290},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2367, col: 17, offset: 81233},
																exprs: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2367, col: 26, offset: 81242},
																		expr: &charClassMatcher{
																			pos:        position{line: 2350, col: 20, offset: 80988},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 699, col: 5, offset: 21384},
														run: (*parser).callonInlineMixinCall45,
														expr: &seqExpr{
															pos: position{line: 699, col: 5, offset: 21384},
															exprs: []interface{}{
																&labeledExpr{
																	pos:   position{line: 699, col: 5, offset: 21384},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 699, col: 13, offset: 21392},
																		exprs: []interface{}{
																			&zeroOrOneExpr{
																				pos: position{line: 699, col: 13, offset: 21392},
																				expr: &litMatcher{
																					pos:        position{line: 699, col: 13, offset: 21392},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 699, col: 18, offset: 21397},
																				expr: &choiceExpr{
																					pos: position{line: 699, col: 19, offset: 21398},
																					alternatives: []interface{}{
																						&seqExpr{
																							pos: position{line: 699, col: 19, offset: 21398},
																							exprs: []interface{}{
																								&charClassMatcher{
																									pos:        position{line: 699, col: 19, offset: 21398},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 699, col: 28, offset: 21407},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 699, col: 38, offset: 21417},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 699, col: 49, offset: 21428},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3737, col: 8, offset: 128286},
																		run: (*parser).callonInlineMixinCall58,
																		expr: &choiceExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			alternatives: []interface{}{
																				&andExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					expr: &anyMatcher{
																						line: 3737, col: 10, offset: 128288,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3737, col: 14, offset: 128292},
																					expr: &anyMatcher{
																						line: 3737, col: 15, offset: 128293,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 713, col: 5, offset: 21887},
										run: (*parser).callonInlineMixinCall64,
										expr: &seqExpr{
											pos: position{line: 713, col: 5, offset: 21887},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 713, col: 5, offset: 21887},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonInlineMixinCall67,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
												&andExpr{
													pos: position{line: 713, col: 14, offset: 21896},
													expr: &choiceExpr{
														pos: position{line: 713, col: 16, offset: 21898},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 12, offset: 128237},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 713, col: 22, offset: 21904},
																val:        "[:!=(]",
																chars:      []rune{':', '!', '=', '('},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 724, col: 5, offset: 22230},
										run: (*parser).callonInlineMixinCall86,
										expr: &seqExpr{
											pos: position{line: 724, col: 5, offset: 22230},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 724, col: 5, offset: 22230},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 724, col: 12, offset: 22237},
														expr: &charClassMatcher{
															pos:        position{line: 724, col: 12, offset: 22237},
															val:        "[^ \\t\\r\\n:!=(]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 724, col: 28, offset: 22253},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonInlineMixinCall92,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3008, col: 64, offset: 104639},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3008, col: 70, offset: 104645},
								expr: &ruleRefExpr{
									pos:  position{line: 3008, col: 70, offset: 104645},
									name: "singleLineMixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3008, col: 94, offset: 104669},
							label: "bodyI",
							expr: &ruleRefExpr{
								pos:  position{line: 3008, col: 100, offset: 104675},
								name: "singleLineMixinCallBody",
							},
						},
					},
				},
			},
		},
		{
			name: "mixinArgList",
			pos:  position{line: 3020, col: 1, offset: 104979},
			expr: &choiceExpr{
				pos: position{line: 3020, col: 17, offset: 104995},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3020, col: 17, offset: 104995},
						run: (*parser).callonmixinArgList2,
						expr: &seqExpr{
							pos: position{line: 3020, col: 17, offset: 104995},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3020, col: 17, offset: 104995},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3020, col: 21, offset: 104999},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3020, col: 25, offset: 105003},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3020, col: 31, offset: 105009},
										expr: &ruleRefExpr{
											pos:  position{line: 3020, col: 31, offset: 105009},
											name: "mixinArgs",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3020, col: 42, offset: 105020},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3020, col: 45, offset: 105023},
									expr: &seqExpr{
										pos: position{line: 3020, col: 46, offset: 105024},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 3020, col: 46, offset: 105024},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 3020, col: 50, offset: 105028},
												expr: &choiceExpr{
													pos: position{line: 3750, col: 20, offset: 128702},
													alternatives: []interface{}{
														&charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
														&seqExpr{
															pos: position{line: 3747, col: 36, offset: 128625},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3747, col: 36, offset: 128625},
																	expr: &litMatcher{
																		pos:        position{line: 3747, col: 36, offset: 128625},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3747, col: 42, offset: 128631},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3020, col: 56, offset: 105034},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonmixinArgList28,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3026, col: 5, offset: 105233},
						run: (*parser).callonmixinArgList30,
						expr: &seqExpr{
							pos: position{line: 3026, col: 5, offset: 105233},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3026, col: 5, offset: 105233},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3026, col: 9, offset: 105237},
									expr: &choiceExpr{
										pos: position{line: 3750, col: 20, offset: 128702},
										alternatives: []interface{}{
											&charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
											&seqExpr{
												pos: position{line: 3747, col: 36, offset: 128625},
												exprs: []interface{}{
													&zeroOrOneExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														expr: &litMatcher{
															pos:        position{line: 3747, col: 36, offset: 128625},
															val:        "\r",
															ignoreCase: false,
															want:       "\"\\r\"",
														},
													},
													&litMatcher{
														pos:        position{line: 3747, col: 42, offset: 128631},
														val:        "\n",
														ignoreCase: false,
														want:       "\"\\n\"",
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3026, col: 13, offset: 105241},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3026, col: 19, offset: 105247},
										expr: &ruleRefExpr{
											pos:  position{line: 3026, col: 19, offset: 105247},
											name: "mixinArgs",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3026, col: 30, offset: 105258},
									expr: &seqExpr{
										pos: position{line: 3026, col: 31, offset: 105259},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 3026, col: 31, offset: 105259},
												expr: &charClassMatcher{
													pos:        position{line: 3746, col: 36, offset: 128584},
													val:        "[ \\t]",
													chars:      []rune{' ', '\t'},
													ignoreCase: false,
													inverted:   false,
												},
											},
											&litMatcher{
												pos:        position{line: 3026, col: 34, offset: 105262},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3026, col: 40, offset: 105268},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonmixinArgList49,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinArgList",
			pos:  position{line: 3044, col: 1, offset: 105808},
			expr: &choiceExpr{
				pos: position{line: 3044, col: 27, offset: 105834},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3044, col: 27, offset: 105834},
						run: (*parser).callonsingleLineMixinArgList2,
						expr: &seqExpr{
							pos: position{line: 3044, col: 27, offset: 105834},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3044, col: 27, offset: 105834},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3044, col: 31, offset: 105838},
									expr: &litMatcher{
										pos:        position{line: 3044, col: 31, offset: 105838},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3044, col: 36, offset: 105843},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3044, col: 42, offset: 105849},
										expr: &ruleRefExpr{
											pos:  position{line: 3044, col: 42, offset: 105849},
											name: "singleLineMixinArgs",
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3044, col: 63, offset: 105870},
									expr: &litMatcher{
										pos:        position{line: 3044, col: 63, offset: 105870},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3044, col: 68, offset: 105875},
									expr: &seqExpr{
										pos: position{line: 3044, col: 69, offset: 105876},
										exprs: []interface{}{
											&litMatcher{
												pos:        position{line: 3044, col: 69, offset: 105876},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 3044, col: 73, offset: 105880},
												expr: &litMatcher{
													pos:        position{line: 3044, col: 73, offset: 105880},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3044, col: 80, offset: 105887},
									label: "rParenPosI",
									expr: &actionExpr{
										pos: position{line: 3757, col: 12, offset: 128960},
										run: (*parser).callonsingleLineMixinArgList18,
										expr: &litMatcher{
											pos:        position{line: 3757, col: 12, offset: 128960},
											val:        ")",
											ignoreCase: false,
											want:       "\")\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3050, col: 5, offset: 106086},
						run: (*parser).callonsingleLineMixinArgList20,
						expr: &seqExpr{
							pos: position{line: 3050, col: 5, offset: 106086},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3050, col: 5, offset: 106086},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3050, col: 9, offset: 106090},
									expr: &litMatcher{
										pos:        position{line: 3050, col: 9, offset: 106090},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3050, col: 14, offset: 106095},
									label: "argsI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3050, col: 20, offset: 106101},
										expr: &ruleRefExpr{
											pos:  position{line: 3050, col: 20, offset: 106101},
											name: "singleLineMixinArgs",
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3050, col: 41, offset: 106122},
									expr: &seqExpr{
										pos: position{line: 3050, col: 42, offset: 106123},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 3050, col: 42, offset: 106123},
												expr: &litMatcher{
													pos:        position{line: 3050, col: 42, offset: 106123},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 3050, col: 47, offset: 106128},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3050, col: 53, offset: 106134},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonsingleLineMixinArgList34,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinArgs",
			pos:  position{line: 3069, col: 1, offset: 106675},
			expr: &actionExpr{
				pos: position{line: 3069, col: 14, offset: 106688},
				run: (*parser).callonmixinArgs1,
				expr: &seqExpr{
					pos: position{line: 3069, col: 14, offset: 106688},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3069, col: 14, offset: 106688},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 3069, col: 21, offset: 106695},
								name: "mixinArg",
							},
						},
						&labeledExpr{
							pos:   position{line: 3069, col: 30, offset: 106704},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3069, col: 36, offset: 106710},
								expr: &seqExpr{
									pos: position{line: 3069, col: 37, offset: 106711},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3069, col: 37, offset: 106711},
											expr: &charClassMatcher{
												pos:        position{line: 3746, col: 36, offset: 128584},
												val:        "[ \\t]",
												chars:      []rune{' ', '\t'},
												ignoreCase: false,
												inverted:   false,
											},
										},
										&litMatcher{
											pos:        position{line: 3069, col: 40, offset: 106714},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 3069, col: 44, offset: 106718},
											expr: &choiceExpr{
												pos: position{line: 3750, col: 20, offset: 128702},
												alternatives: []interface{}{
													&charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														exprs: []interface{}{
															&zeroOrOneExpr{
																pos: position{line: 3747, col: 36, offset: 128625},
																expr: &litMatcher{
																	pos:        position{line: 3747, col: 36, offset: 128625},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3747, col: 42, offset: 128631},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3069, col: 48, offset: 106722},
											name: "mixinArg",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinArgs",
			pos:  position{line: 3079, col: 1, offset: 106983},
			expr: &actionExpr{
				pos: position{line: 3079, col: 24, offset: 107006},
				run: (*parser).callonsingleLineMixinArgs1,
				expr: &seqExpr{
					pos: position{line: 3079, col: 24, offset: 107006},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3079, col: 24, offset: 107006},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 3079, col: 31, offset: 107013},
								name: "singleLineMixinArg",
							},
						},
						&labeledExpr{
							pos:   position{line: 3079, col: 50, offset: 107032},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3079, col: 56, offset: 107038},
								expr: &seqExpr{
									pos: position{line: 3079, col: 57, offset: 107039},
									exprs: []interface{}{
										&zeroOrMoreExpr{
											pos: position{line: 3079, col: 57, offset: 107039},
											expr: &litMatcher{
												pos:        position{line: 3079, col: 57, offset: 107039},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&litMatcher{
											pos:        position{line: 3079, col: 62, offset: 107044},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 3079, col: 66, offset: 107048},
											expr: &litMatcher{
												pos:        position{line: 3079, col: 66, offset: 107048},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3079, col: 71, offset: 107053},
											name: "singleLineMixinArg",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinArg",
			pos:  position{line: 3090, col: 1, offset: 107325},
			expr: &choiceExpr{
				pos: position{line: 3090, col: 13, offset: 107337},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3090, col: 13, offset: 107337},
						run: (*parser).callonmixinArg2,
						expr: &seqExpr{
							pos: position{line: 3090, col: 13, offset: 107337},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3090, col: 13, offset: 107337},
									label: "nameI",
									expr: &choiceExpr{
										pos: position{line: 711, col: 14, offset: 21845},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 711, col: 14, offset: 21845},
												run: (*parser).callonmixinArg6,
												expr: &labeledExpr{
													pos:   position{line: 711, col: 14, offset: 21845},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 697, col: 10, offset: 21290},
														alternatives: []interface{}{
															&actionExpr{
																pos: position{line: 697, col: 10, offset: 21290},
																run: (*parser).callonmixinArg9,
																expr: &labeledExpr{
																	pos:   position{line: 697, col: 10, offset: 21290},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 2367, col: 17, offset: 81233},
																		exprs: []interface{}{
																			&charClassMatcher{
																				pos:        position{line: 2350, col: 20, offset: 80988},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2367, col: 26, offset: 81242},
																				expr: &charClassMatcher{
																					pos:        position{line: 2350, col: 20, offset: 80988},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 699, col: 5, offset: 21384},
																run: (*parser).callonmixinArg15,
																expr: &seqExpr{
																	pos: position{line: 699, col: 5, offset: 21384},
																	exprs: []interface{}{
																		&labeledExpr{
																			pos:   position{line: 699, col: 5, offset: 21384},
																			label: "identI",
																			expr: &seqExpr{
																				pos: position{line: 699, col: 13, offset: 21392},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 699, col: 13, offset: 21392},
																						expr: &litMatcher{
																							pos:        position{line: 699, col: 13, offset: 21392},
																							val:        "$",
																							ignoreCase: false,
																							want:       "\"$\"",
																						},
																					},
																					&oneOrMoreExpr{
																						pos: position{line: 699, col: 18, offset: 21397},
																						expr: &choiceExpr{
																							pos: position{line: 699, col: 19, offset: 21398},
																							alternatives: []interface{}{
																								&seqExpr{
																									pos: position{line: 699, col: 19, offset: 21398},
																									exprs: []interface{}{
																										&charClassMatcher{
																											pos:        position{line: 699, col: 19, offset: 21398},
																											val:        "[\\pNd]",
																											classes:    []*unicode.RangeTable{rangeTable("Nd")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 699, col: 28, offset: 21407},
																											val:        "[_-\\pL]",
																											chars:      []rune{'_', '-'},
																											classes:    []*unicode.RangeTable{rangeTable("L")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 699, col: 38, offset: 21417},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 699, col: 49, offset: 21428},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonmixinArg28,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 713, col: 5, offset: 21887},
												run: (*parser).callonmixinArg34,
												expr: &seqExpr{
													pos: position{line: 713, col: 5, offset: 21887},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 713, col: 5, offset: 21887},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonmixinArg37,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&andExpr{
															pos: position{line: 713, col: 14, offset: 21896},
															expr: &choiceExpr{
																pos: position{line: 713, col: 16, offset: 21898},
																alternatives: []interface{}{
																	&seqExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		exprs: []interface{}{
																			&zeroOrMoreExpr{
																				pos: position{line: 3734, col: 12, offset: 128237},
																				expr: &charClassMatcher{
																					pos:        position{line: 3746, col: 36, offset: 128584},
																					val:        "[ \\t]",
																					chars:      []rune{' ', '\t'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&choiceExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						exprs: []interface{}{
																							&zeroOrOneExpr{
																								pos: position{line: 3734, col: 16, offset: 128241},
																								expr: &litMatcher{
																									pos:        position{line: 3734, col: 16, offset: 128241},
																									val:        "\r",
																									ignoreCase: false,
																									want:       "\"\\r\"",
																								},
																							},
																							&litMatcher{
																								pos:        position{line: 3734, col: 22, offset: 128247},
																								val:        "\n",
																								ignoreCase: false,
																								want:       "\"\\n\"",
																							},
																						},
																					},
																					&notExpr{
																						pos: position{line: 3733, col: 12, offset: 128223},
																						expr: &anyMatcher{
																							line: 3733, col: 13, offset: 128224,
																						},
																					},
																				},
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 713, col: 22, offset: 21904},
																		val:        "[:!=(]",
																		chars:      []rune{':', '!', '=', '('},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 724, col: 5, offset: 22230},
												run: (*parser).callonmixinArg56,
												expr: &seqExpr{
													pos: position{line: 724, col: 5, offset: 22230},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 724, col: 5, offset: 22230},
															label: "identI",
															expr: &oneOrMoreExpr{
																pos: position{line: 724, col: 12, offset: 22237},
																expr: &charClassMatcher{
																	pos:        position{line: 724, col: 12, offset: 22237},
																	val:        "[^ \\t\\r\\n:!=(]",
																	chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 724, col: 28, offset: 22253},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonmixinArg62,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3090, col: 29, offset: 107353},
									expr: &litMatcher{
										pos:        position{line: 3090, col: 29, offset: 107353},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 3090, col: 34, offset: 107358},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3090, col: 38, offset: 107362},
									expr: &litMatcher{
										pos:        position{line: 3090, col: 38, offset: 107362},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3090, col: 43, offset: 107367},
									label: "valI",
									expr: &ruleRefExpr{
										pos:  position{line: 3090, col: 48, offset: 107372},
										name: "Expression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3095, col: 5, offset: 107499},
						run: (*parser).callonmixinArg75,
						expr: &seqExpr{
							pos: position{line: 3095, col: 5, offset: 107499},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3095, col: 5, offset: 107499},
									label: "nameI",
									expr: &choiceExpr{
										pos: position{line: 711, col: 14, offset: 21845},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 711, col: 14, offset: 21845},
												run: (*parser).callonmixinArg79,
												expr: &labeledExpr{
													pos:   position{line: 711, col: 14, offset: 21845},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 697, col: 10, offset: 21290},
														alternatives: []interface{}{
															&actionExpr{
																pos: position{line: 697, col: 10, offset: 21290},
																run: (*parser).callonmixinArg82,
																expr: &labeledExpr{
																	pos:   position{line: 697, col: 10, offset: 21290},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 2367, col: 17, offset: 81233},
																		exprs: []interface{}{
																			&charClassMatcher{
																				pos:        position{line: 2350, col: 20, offset: 80988},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2367, col: 26, offset: 81242},
																				expr: &charClassMatcher{
																					pos:        position{line: 2350, col: 20, offset: 80988},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 699, col: 5, offset: 21384},
																run: (*parser).callonmixinArg88,
																expr: &seqExpr{
																	pos: position{line: 699, col: 5, offset: 21384},
																	exprs: []interface{}{
																		&labeledExpr{
																			pos:   position{line: 699, col: 5, offset: 21384},
																			label: "identI",
																			expr: &seqExpr{
																				pos: position{line: 699, col: 13, offset: 21392},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 699, col: 13, offset: 21392},
																						expr: &litMatcher{
																							pos:        position{line: 699, col: 13, offset: 21392},
																							val:        "$",
																							ignoreCase: false,
																							want:       "\"$\"",
																						},
																					},
																					&oneOrMoreExpr{
																						pos: position{line: 699, col: 18, offset: 21397},
																						expr: &choiceExpr{
																							pos: position{line: 699, col: 19, offset: 21398},
																							alternatives: []interface{}{
																								&seqExpr{
																									pos: position{line: 699, col: 19, offset: 21398},
																									exprs: []interface{}{
																										&charClassMatcher{
																											pos:        position{line: 699, col: 19, offset: 21398},
																											val:        "[\\pNd]",
																											classes:    []*unicode.RangeTable{rangeTable("Nd")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 699, col: 28, offset: 21407},
																											val:        "[_-\\pL]",
																											chars:      []rune{'_', '-'},
																											classes:    []*unicode.RangeTable{rangeTable("L")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 699, col: 38, offset: 21417},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 699, col: 49, offset: 21428},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonmixinArg101,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 713, col: 5, offset: 21887},
												run: (*parser).callonmixinArg107,
												expr: &seqExpr{
													pos: position{line: 713, col: 5, offset: 21887},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 713, col: 5, offset: 21887},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonmixinArg110,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&andExpr{
															pos: position{line: 713, col: 14, offset: 21896},
															expr: &choiceExpr{
																pos: position{line: 713, col: 16, offset: 21898},
																alternatives: []interface{}{
																	&seqExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		exprs: []interface{}{
																			&zeroOrMoreExpr{
																				pos: position{line: 3734, col: 12, offset: 128237},
																				expr: &charClassMatcher{
																					pos:        position{line: 3746, col: 36, offset: 128584},
																					val:        "[ \\t]",
																					chars:      []rune{' ', '\t'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&choiceExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						exprs: []interface{}{
																							&zeroOrOneExpr{
																								pos: position{line: 3734, col: 16, offset: 128241},
																								expr: &litMatcher{
																									pos:        position{line: 3734, col: 16, offset: 128241},
																									val:        "\r",
																									ignoreCase: false,
																									want:       "\"\\r\"",
																								},
																							},
																							&litMatcher{
																								pos:        position{line: 3734, col: 22, offset: 128247},
																								val:        "\n",
																								ignoreCase: false,
																								want:       "\"\\n\"",
																							},
																						},
																					},
																					&notExpr{
																						pos: position{line: 3733, col: 12, offset: 128223},
																						expr: &anyMatcher{
																							line: 3733, col: 13, offset: 128224,
																						},
																					},
																				},
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 713, col: 22, offset: 21904},
																		val:        "[:!=(]",
																		chars:      []rune{':', '!', '=', '('},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 724, col: 5, offset: 22230},
												run: (*parser).callonmixinArg129,
												expr: &seqExpr{
													pos: position{line: 724, col: 5, offset: 22230},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 724, col: 5, offset: 22230},
															label: "identI",
															expr: &oneOrMoreExpr{
																pos: position{line: 724, col: 12, offset: 22237},
																expr: &charClassMatcher{
																	pos:        position{line: 724, col: 12, offset: 22237},
																	val:        "[^ \\t\\r\\n:!=(]",
																	chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 724, col: 28, offset: 22253},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonmixinArg135,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3095, col: 21, offset: 107515},
									expr: &seqExpr{
										pos: position{line: 3095, col: 22, offset: 107516},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 3095, col: 22, offset: 107516},
												expr: &litMatcher{
													pos:        position{line: 3095, col: 22, offset: 107516},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 3095, col: 27, offset: 107521},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3095, col: 33, offset: 107527},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonmixinArg147,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "singleLineMixinArg",
			pos:  position{line: 3110, col: 1, offset: 108021},
			expr: &choiceExpr{
				pos: position{line: 3110, col: 23, offset: 108043},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3110, col: 23, offset: 108043},
						run: (*parser).callonsingleLineMixinArg2,
						expr: &seqExpr{
							pos: position{line: 3110, col: 23, offset: 108043},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3110, col: 23, offset: 108043},
									label: "nameI",
									expr: &choiceExpr{
										pos: position{line: 711, col: 14, offset: 21845},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 711, col: 14, offset: 21845},
												run: (*parser).callonsingleLineMixinArg6,
												expr: &labeledExpr{
													pos:   position{line: 711, col: 14, offset: 21845},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 697, col: 10, offset: 21290},
														alternatives: []interface{}{
															&actionExpr{
																pos: position{line: 697, col: 10, offset: 21290},
																run: (*parser).callonsingleLineMixinArg9,
																expr: &labeledExpr{
																	pos:   position{line: 697, col: 10, offset: 21290},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 2367, col: 17, offset: 81233},
																		exprs: []interface{}{
																			&charClassMatcher{
																				pos:        position{line: 2350, col: 20, offset: 80988},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2367, col: 26, offset: 81242},
																				expr: &charClassMatcher{
																					pos:        position{line: 2350, col: 20, offset: 80988},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 699, col: 5, offset: 21384},
																run: (*parser).callonsingleLineMixinArg15,
																expr: &seqExpr{
																	pos: position{line: 699, col: 5, offset: 21384},
																	exprs: []interface{}{
																		&labeledExpr{
																			pos:   position{line: 699, col: 5, offset: 21384},
																			label: "identI",
																			expr: &seqExpr{
																				pos: position{line: 699, col: 13, offset: 21392},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 699, col: 13, offset: 21392},
																						expr: &litMatcher{
																							pos:        position{line: 699, col: 13, offset: 21392},
																							val:        "$",
																							ignoreCase: false,
																							want:       "\"$\"",
																						},
																					},
																					&oneOrMoreExpr{
																						pos: position{line: 699, col: 18, offset: 21397},
																						expr: &choiceExpr{
																							pos: position{line: 699, col: 19, offset: 21398},
																							alternatives: []interface{}{
																								&seqExpr{
																									pos: position{line: 699, col: 19, offset: 21398},
																									exprs: []interface{}{
																										&charClassMatcher{
																											pos:        position{line: 699, col: 19, offset: 21398},
																											val:        "[\\pNd]",
																											classes:    []*unicode.RangeTable{rangeTable("Nd")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 699, col: 28, offset: 21407},
																											val:        "[_-\\pL]",
																											chars:      []rune{'_', '-'},
																											classes:    []*unicode.RangeTable{rangeTable("L")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 699, col: 38, offset: 21417},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 699, col: 49, offset: 21428},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonsingleLineMixinArg28,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 713, col: 5, offset: 21887},
												run: (*parser).callonsingleLineMixinArg34,
												expr: &seqExpr{
													pos: position{line: 713, col: 5, offset: 21887},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 713, col: 5, offset: 21887},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonsingleLineMixinArg37,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&andExpr{
															pos: position{line: 713, col: 14, offset: 21896},
															expr: &choiceExpr{
																pos: position{line: 713, col: 16, offset: 21898},
																alternatives: []interface{}{
																	&seqExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		exprs: []interface{}{
																			&zeroOrMoreExpr{
																				pos: position{line: 3734, col: 12, offset: 128237},
																				expr: &charClassMatcher{
																					pos:        position{line: 3746, col: 36, offset: 128584},
																					val:        "[ \\t]",
																					chars:      []rune{' ', '\t'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&choiceExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						exprs: []interface{}{
																							&zeroOrOneExpr{
																								pos: position{line: 3734, col: 16, offset: 128241},
																								expr: &litMatcher{
																									pos:        position{line: 3734, col: 16, offset: 128241},
																									val:        "\r",
																									ignoreCase: false,
																									want:       "\"\\r\"",
																								},
																							},
																							&litMatcher{
																								pos:        position{line: 3734, col: 22, offset: 128247},
																								val:        "\n",
																								ignoreCase: false,
																								want:       "\"\\n\"",
																							},
																						},
																					},
																					&notExpr{
																						pos: position{line: 3733, col: 12, offset: 128223},
																						expr: &anyMatcher{
																							line: 3733, col: 13, offset: 128224,
																						},
																					},
																				},
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 713, col: 22, offset: 21904},
																		val:        "[:!=(]",
																		chars:      []rune{':', '!', '=', '('},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 724, col: 5, offset: 22230},
												run: (*parser).callonsingleLineMixinArg56,
												expr: &seqExpr{
													pos: position{line: 724, col: 5, offset: 22230},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 724, col: 5, offset: 22230},
															label: "identI",
															expr: &oneOrMoreExpr{
																pos: position{line: 724, col: 12, offset: 22237},
																expr: &charClassMatcher{
																	pos:        position{line: 724, col: 12, offset: 22237},
																	val:        "[^ \\t\\r\\n:!=(]",
																	chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 724, col: 28, offset: 22253},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonsingleLineMixinArg62,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3110, col: 39, offset: 108059},
									expr: &litMatcher{
										pos:        position{line: 3110, col: 39, offset: 108059},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&litMatcher{
									pos:        position{line: 3110, col: 44, offset: 108064},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3110, col: 48, offset: 108068},
									expr: &litMatcher{
										pos:        position{line: 3110, col: 48, offset: 108068},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3110, col: 53, offset: 108073},
									label: "valI",
									expr: &ruleRefExpr{
										pos:  position{line: 3110, col: 58, offset: 108078},
										name: "SingleLineExpression",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3115, col: 5, offset: 108215},
						run: (*parser).callonsingleLineMixinArg75,
						expr: &seqExpr{
							pos: position{line: 3115, col: 5, offset: 108215},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3115, col: 5, offset: 108215},
									label: "nameI",
									expr: &choiceExpr{
										pos: position{line: 711, col: 14, offset: 21845},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 711, col: 14, offset: 21845},
												run: (*parser).callonsingleLineMixinArg79,
												expr: &labeledExpr{
													pos:   position{line: 711, col: 14, offset: 21845},
													label: "identI",
													expr: &choiceExpr{
														pos: position{line: 697, col: 10, offset: 21290},
														alternatives: []interface{}{
															&actionExpr{
																pos: position{line: 697, col: 10, offset: 21290},
																run: (*parser).callonsingleLineMixinArg82,
																expr: &labeledExpr{
																	pos:   position{line: 697, col: 10, offset: 21290},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 2367, col: 17, offset: 81233},
																		exprs: []interface{}{
																			&charClassMatcher{
																				pos:        position{line: 2350, col: 20, offset: 80988},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2367, col: 26, offset: 81242},
																				expr: &charClassMatcher{
																					pos:        position{line: 2350, col: 20, offset: 80988},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 699, col: 5, offset: 21384},
																run: (*parser).callonsingleLineMixinArg88,
																expr: &seqExpr{
																	pos: position{line: 699, col: 5, offset: 21384},
																	exprs: []interface{}{
																		&labeledExpr{
																			pos:   position{line: 699, col: 5, offset: 21384},
																			label: "identI",
																			expr: &seqExpr{
																				pos: position{line: 699, col: 13, offset: 21392},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 699, col: 13, offset: 21392},
																						expr: &litMatcher{
																							pos:        position{line: 699, col: 13, offset: 21392},
																							val:        "$",
																							ignoreCase: false,
																							want:       "\"$\"",
																						},
																					},
																					&oneOrMoreExpr{
																						pos: position{line: 699, col: 18, offset: 21397},
																						expr: &choiceExpr{
																							pos: position{line: 699, col: 19, offset: 21398},
																							alternatives: []interface{}{
																								&seqExpr{
																									pos: position{line: 699, col: 19, offset: 21398},
																									exprs: []interface{}{
																										&charClassMatcher{
																											pos:        position{line: 699, col: 19, offset: 21398},
																											val:        "[\\pNd]",
																											classes:    []*unicode.RangeTable{rangeTable("Nd")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 699, col: 28, offset: 21407},
																											val:        "[_-\\pL]",
																											chars:      []rune{'_', '-'},
																											classes:    []*unicode.RangeTable{rangeTable("L")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 699, col: 38, offset: 21417},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 699, col: 49, offset: 21428},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonsingleLineMixinArg101,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 713, col: 5, offset: 21887},
												run: (*parser).callonsingleLineMixinArg107,
												expr: &seqExpr{
													pos: position{line: 713, col: 5, offset: 21887},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 713, col: 5, offset: 21887},
															label: "posI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonsingleLineMixinArg110,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
														&andExpr{
															pos: position{line: 713, col: 14, offset: 21896},
															expr: &choiceExpr{
																pos: position{line: 713, col: 16, offset: 21898},
																alternatives: []interface{}{
																	&seqExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		exprs: []interface{}{
																			&zeroOrMoreExpr{
																				pos: position{line: 3734, col: 12, offset: 128237},
																				expr: &charClassMatcher{
																					pos:        position{line: 3746, col: 36, offset: 128584},
																					val:        "[ \\t]",
																					chars:      []rune{' ', '\t'},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																			&choiceExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						exprs: []interface{}{
																							&zeroOrOneExpr{
																								pos: position{line: 3734, col: 16, offset: 128241},
																								expr: &litMatcher{
																									pos:        position{line: 3734, col: 16, offset: 128241},
																									val:        "\r",
																									ignoreCase: false,
																									want:       "\"\\r\"",
																								},
																							},
																							&litMatcher{
																								pos:        position{line: 3734, col: 22, offset: 128247},
																								val:        "\n",
																								ignoreCase: false,
																								want:       "\"\\n\"",
																							},
																						},
																					},
																					&notExpr{
																						pos: position{line: 3733, col: 12, offset: 128223},
																						expr: &anyMatcher{
																							line: 3733, col: 13, offset: 128224,
																						},
																					},
																				},
																			},
																		},
																	},
																	&charClassMatcher{
																		pos:        position{line: 713, col: 22, offset: 21904},
																		val:        "[:!=(]",
																		chars:      []rune{':', '!', '=', '('},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 724, col: 5, offset: 22230},
												run: (*parser).callonsingleLineMixinArg129,
												expr: &seqExpr{
													pos: position{line: 724, col: 5, offset: 22230},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 724, col: 5, offset: 22230},
															label: "identI",
															expr: &oneOrMoreExpr{
																pos: position{line: 724, col: 12, offset: 22237},
																expr: &charClassMatcher{
																	pos:        position{line: 724, col: 12, offset: 22237},
																	val:        "[^ \\t\\r\\n:!=(]",
																	chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
																	ignoreCase: false,
																	inverted:   true,
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 724, col: 28, offset: 22253},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonsingleLineMixinArg135,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3115, col: 21, offset: 108231},
									expr: &seqExpr{
										pos: position{line: 3115, col: 22, offset: 108232},
										exprs: []interface{}{
											&zeroOrMoreExpr{
												pos: position{line: 3115, col: 22, offset: 108232},
												expr: &litMatcher{
													pos:        position{line: 3115, col: 22, offset: 108232},
													val:        " ",
													ignoreCase: false,
													want:       "\" \"",
												},
											},
											&litMatcher{
												pos:        position{line: 3115, col: 27, offset: 108237},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3115, col: 33, offset: 108243},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonsingleLineMixinArg147,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallBody",
			pos:  position{line: 3131, col: 1, offset: 108738},
			expr: &choiceExpr{
				pos: position{line: 3131, col: 18, offset: 108755},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3131, col: 18, offset: 108755},
						run: (*parser).callonmixinCallBody2,
						expr: &labeledExpr{
							pos:   position{line: 3131, col: 18, offset: 108755},
							label: "shI",
							expr: &ruleRefExpr{
								pos:  position{line: 3131, col: 22, offset: 108759},
								name: "MixinMainBlockShorthand",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 3133, col: 5, offset: 108852},
						name: "Beaitb",
					},
				},
			},
		},
		{
			name: "singleLineMixinCallBody",
			pos:  position{line: 3134, col: 1, offset: 108859},
			expr: &ruleRefExpr{
				pos:  position{line: 3134, col: 28, offset: 108886},
				name: "Beait",
			},
		},
		{
			name: "MixinMainBlockShorthand",
			pos:  position{line: 3140, col: 1, offset: 109094},
			expr: &choiceExpr{
				pos: position{line: 3140, col: 28, offset: 109121},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3140, col: 28, offset: 109121},
						run: (*parser).callonMixinMainBlockShorthand2,
						expr: &seqExpr{
							pos: position{line: 3140, col: 28, offset: 109121},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3140, col: 28, offset: 109121},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 3140, col: 33, offset: 109126},
									expr: &actionExpr{
										pos: position{line: 1251, col: 21, offset: 40099},
										run: (*parser).callonMixinMainBlockShorthand6,
										expr: &oneOrMoreExpr{
											pos: position{line: 1251, col: 21, offset: 40099},
											expr: &charClassMatcher{
												pos:        position{line: 3735, col: 12, offset: 128270},
												val:        "[^\\r\\n]",
												chars:      []rune{'\r', '\n'},
												ignoreCase: false,
												inverted:   true,
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3140, col: 55, offset: 109148},
									label: "bodyI",
									expr: &ruleRefExpr{
										pos:  position{line: 3140, col: 61, offset: 109154},
										name: "Body",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3145, col: 5, offset: 109277},
						run: (*parser).callonMixinMainBlockShorthand20,
						expr: &seqExpr{
							pos: position{line: 3145, col: 5, offset: 109277},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3145, col: 5, offset: 109277},
									val:        "\\",
									ignoreCase: false,
									want:       "\"\\\\\"",
								},
								&zeroOrOneExpr{
									pos: position{line: 3145, col: 10, offset: 109282},
									expr: &actionExpr{
										pos: position{line: 1251, col: 21, offset: 40099},
										run: (*parser).callonMixinMainBlockShorthand24,
										expr: &oneOrMoreExpr{
											pos: position{line: 1251, col: 21, offset: 40099},
											expr: &charClassMatcher{
												pos:        position{line: 3735, col: 12, offset: 128270},
												val:        "[^\\r\\n]",
												chars:      []rune{'\r', '\n'},
												ignoreCase: false,
												inverted:   true,
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3145, col: 28, offset: 109300},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonMixinMainBlockShorthand28,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Func",
			pos:  position{line: 3346, col: 1, offset: 115223},
			expr: &choiceExpr{
				pos: position{line: 3346, col: 9, offset: 115231},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3346, col: 9, offset: 115231},
						run: (*parser).callonFunc2,
						expr: &seqExpr{
							pos: position{line: 3346, col: 9, offset: 115231},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3346, col: 9, offset: 115231},
									val:        "func",
									ignoreCase: false,
									want:       "\"func\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 3346, col: 16, offset: 115238},
									expr: &litMatcher{
										pos:        position{line: 3346, col: 16, offset: 115238},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3346, col: 21, offset: 115243},
									label: "nameI",
									expr: &choiceExpr{
										pos: position{line: 2319, col: 12, offset: 79887},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 2319, col: 12, offset: 79887},
												run: (*parser).callonFunc9,
												expr: &labeledExpr{
													pos:   position{line: 2319, col: 12, offset: 79887},
													label: "ident",
													expr: &seqExpr{
														pos: position{line: 2367, col: 17, offset: 81233},
														exprs: []interface{}{
															&charClassMatcher{
																pos:        position{line: 2350, col: 20, offset: 80988},
																val:        "[_\\pL]",
																chars:      []rune{'_'},
																classes:    []*unicode.RangeTable{rangeTable("L")},
																ignoreCase: false,
																inverted:   false,
															},
															&zeroOrMoreExpr{
																pos: position{line: 2367, col: 26, offset: 81242},
																expr: &charClassMatcher{
																	pos:        position{line: 2350, col: 20, offset: 80988},
																	val:        "[_\\pL\\pNd]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 2321, col: 5, offset: 79981},
												run: (*parser).callonFunc15,
												expr: &seqExpr{
													pos: position{line: 2321, col: 5, offset: 79981},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 2321, col: 5, offset: 79981},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2321, col: 13, offset: 79989},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 2321, col: 13, offset: 79989},
																		expr: &litMatcher{
																			pos:        position{line: 2321, col: 13, offset: 79989},
																			val:        "$",
																			ignoreCase: false,
																			want:       "\"$\"",
																		},
																	},
																	&oneOrMoreExpr{
																		pos: position{line: 2321, col: 18, offset: 79994},
																		expr: &choiceExpr{
																			pos: position{line: 2321, col: 19, offset: 79995},
																			alternatives: []interface{}{
																				&seqExpr{
																					pos: position{line: 2321, col: 19, offset: 79995},
																					exprs: []interface{}{
																						&charClassMatcher{
																							pos:        position{line: 2321, col: 19, offset: 79995},
																							val:        "[\\pNd]",
																							classes:    []*unicode.RangeTable{rangeTable("Nd")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&charClassMatcher{
																							pos:        position{line: 2321, col: 28, offset: 80004},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																				&charClassMatcher{
																					pos:        position{line: 2321, col: 38, offset: 80014},
																					val:        "[_-\\pL]",
																					chars:      []rune{'_', '-'},
																					classes:    []*unicode.RangeTable{rangeTable("L")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 2321, col: 49, offset: 80025},
															label: "endPosI",
															expr: &actionExpr{
																pos: position{line: 3737, col: 8, offset: 128286},
																run: (*parser).callonFunc28,
																expr: &choiceExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	alternatives: []interface{}{
																		&andExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			expr: &anyMatcher{
																				line: 3737, col: 10, offset: 128288,
																			},
																		},
																		&notExpr{
																			pos: position{line: 3737, col: 14, offset: 128292},
																			expr: &anyMatcher{
																				line: 3737, col: 15, offset: 128293,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3346, col: 35, offset: 115257},
									label: "paramsI",
									expr: &choiceExpr{
										pos: position{line: 3347, col: 5, offset: 115271},
										alternatives: []interface{}{
											&actionExpr{
												pos: position{line: 3347, col: 5, offset: 115271},
												run: (*parser).callonFunc36,
												expr: &seqExpr{
													pos: position{line: 3347, col: 5, offset: 115271},
													exprs: []interface{}{
														&labeledExpr{
															pos:   position{line: 3347, col: 5, offset: 115271},
															label: "lParenPosI",
															expr: &actionExpr{
																pos: position{line: 3756, col: 12, offset: 128922},
																run: (*parser).callonFunc39,
																expr: &litMatcher{
																	pos:        position{line: 3756, col: 12, offset: 128922},
																	val:        "(",
																	ignoreCase: false,
																	want:       "\"(\"",
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 3347, col: 24, offset: 115290},
															label: "paramsI",
															expr: &choiceExpr{
																pos: position{line: 3348, col: 9, offset: 115308},
																alternatives: []interface{}{
																	&actionExpr{
																		pos: position{line: 3348, col: 9, offset: 115308},
																		run: (*parser).callonFunc43,
																		expr: &seqExpr{
																			pos: position{line: 3348, col: 9, offset: 115308},
																			exprs: []interface{}{
																				&zeroOrMoreExpr{
																					pos: position{line: 3348, col: 9, offset: 115308},
																					expr: &choiceExpr{
																						pos: position{line: 3750, col: 20, offset: 128702},
																						alternatives: []interface{}{
																							&charClassMatcher{
																								pos:        position{line: 3746, col: 36, offset: 128584},
																								val:        "[ \\t]",
																								chars:      []rune{' ', '\t'},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&seqExpr{
																								pos: position{line: 3747, col: 36, offset: 128625},
																								exprs: []interface{}{
																									&zeroOrOneExpr{
																										pos: position{line: 3747, col: 36, offset: 128625},
																										expr: &litMatcher{
																											pos:        position{line: 3747, col: 36, offset: 128625},
																											val:        "\r",
																											ignoreCase: false,
																											want:       "\"\\r\"",
																										},
																									},
																									&litMatcher{
																										pos:        position{line: 3747, col: 42, offset: 128631},
																										val:        "\n",
																										ignoreCase: false,
																										want:       "\"\\n\"",
																									},
																								},
																							},
																						},
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 3348, col: 13, offset: 115312},
																					label: "paramsI",
																					expr: &zeroOrOneExpr{
																						pos: position{line: 3348, col: 21, offset: 115320},
																						expr: &ruleRefExpr{
																							pos:  position{line: 3348, col: 21, offset: 115320},
																							name: "funcParamList",
																						},
																					},
																				},
																				&zeroOrMoreExpr{
																					pos: position{line: 3348, col: 36, offset: 115335},
																					expr: &litMatcher{
																						pos:        position{line: 3348, col: 36, offset: 115335},
																						val:        " ",
																						ignoreCase: false,
																						want:       "\" \"",
																					},
																				},
																				&zeroOrOneExpr{
																					pos: position{line: 3348, col: 41, offset: 115340},
																					expr: &seqExpr{
																						pos: position{line: 3348, col: 42, offset: 115341},
																						exprs: []interface{}{
																							&litMatcher{
																								pos:        position{line: 3348, col: 42, offset: 115341},
																								val:        ",",
																								ignoreCase: false,
																								want:       "\",\"",
																							},
																							&zeroOrMoreExpr{
																								pos: position{line: 3348, col: 46, offset: 115345},
																								expr: &choiceExpr{
																									pos: position{line: 3750, col: 20, offset: 128702},
																									alternatives: []interface{}{
																										&charClassMatcher{
																											pos:        position{line: 3746, col: 36, offset: 128584},
																											val:        "[ \\t]",
																											chars:      []rune{' ', '\t'},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&seqExpr{
																											pos: position{line: 3747, col: 36, offset: 128625},
																											exprs: []interface{}{
																												&zeroOrOneExpr{
																													pos: position{line: 3747, col: 36, offset: 128625},
																													expr: &litMatcher{
																														pos:        position{line: 3747, col: 36, offset: 128625},
																														val:        "\r",
																														ignoreCase: false,
																														want:       "\"\\r\"",
																													},
																												},
																												&litMatcher{
																													pos:        position{line: 3747, col: 42, offset: 128631},
																													val:        "\n",
																													ignoreCase: false,
																													want:       "\"\\n\"",
																												},
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																	&actionExpr{
																		pos: position{line: 3350, col: 13, offset: 115429},
																		run: (*parser).callonFunc67,
																		expr: &seqExpr{
																			pos: position{line: 3350, col: 13, offset: 115429},
																			exprs: []interface{}{
																				&zeroOrMoreExpr{
																					pos: position{line: 3350, col: 13, offset: 115429},
																					expr: &charClassMatcher{
																						pos:        position{line: 3350, col: 13, offset: 115429},
																						val:        "[^)]",
																						chars:      []rune{')'},
																						ignoreCase: false,
																						inverted:   true,
																					},
																				},
																				&labeledExpr{
																					pos:   position{line: 3350, col: 19, offset: 115435},
																					label: "endPosI",
																					expr: &actionExpr{
																						pos: position{line: 3737, col: 8, offset: 128286},
																						run: (*parser).callonFunc72,
																						expr: &choiceExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							alternatives: []interface{}{
																								&andExpr{
																									pos: position{line: 3737, col: 9, offset: 128287},
																									expr: &anyMatcher{
																										line: 3737, col: 10, offset: 128288,
																									},
																								},
																								&notExpr{
																									pos: position{line: 3737, col: 14, offset: 128292},
																									expr: &anyMatcher{
																										line: 3737, col: 15, offset: 128293,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														&labeledExpr{
															pos:   position{line: 3360, col: 7, offset: 115828},
															label: "rParenPosI",
															expr: &actionExpr{
																pos: position{line: 3757, col: 12, offset: 128960},
																run: (*parser).callonFunc79,
																expr: &litMatcher{
																	pos:        position{line: 3757, col: 12, offset: 128960},
																	val:        ")",
																	ignoreCase: false,
																	want:       "\")\"",
																},
															},
														},
													},
												},
											},
											&actionExpr{
												pos: position{line: 3366, col: 9, offset: 116048},
												run: (*parser).callonFunc81,
												expr: &zeroOrMoreExpr{
													pos: position{line: 3366, col: 9, offset: 116048},
													expr: &charClassMatcher{
														pos:        position{line: 3735, col: 12, offset: 128270},
														val:        "[^\\r\\n]",
														chars:      []rune{'\r', '\n'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3385, col: 5, offset: 116592},
						run: (*parser).callonFunc93,
						expr: &seqExpr{
							pos: position{line: 3385, col: 5, offset: 116592},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3385, col: 5, offset: 116592},
									val:        "func",
									ignoreCase: false,
									want:       "\"func\"",
								},
								&labeledExpr{
									pos:   position{line: 3385, col: 12, offset: 116599},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonFunc97,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "funcParamList",
			pos:  position{line: 3397, col: 1, offset: 116948},
			expr: &choiceExpr{
				pos: position{line: 3397, col: 18, offset: 116965},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 3397, col: 18, offset: 116965},
						name: "funcOtherParamList",
					},
					&ruleRefExpr{
						pos:  position{line: 3397, col: 39, offset: 116986},
						name: "funcOnlyVariadicParamList",
					},
				},
			},
		},
		{
			name: "funcOnlyVariadicParamList",
			pos:  position{line: 3398, col: 1, offset: 117012},
			expr: &actionExpr{
				pos: position{line: 3398, col: 30, offset: 117041},
				run: (*parser).callonfuncOnlyVariadicParamList1,
				expr: &labeledExpr{
					pos:   position{line: 3398, col: 30, offset: 117041},
					label: "variadicI",
					expr: &ruleRefExpr{
						pos:  position{line: 3398, col: 40, offset: 117051},
						name: "funcVariadicParam",
					},
				},
			},
		},
		{
			name: "funcOtherParamList",
			pos:  position{line: 3401, col: 1, offset: 117134},
			expr: &actionExpr{
				pos: position{line: 3401, col: 23, offset: 117156},
				run: (*parser).callonfuncOtherParamList1,
				expr: &seqExpr{
					pos: position{line: 3401, col: 23, offset: 117156},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3401, col: 23, offset: 117156},
							label: "firstI",
							expr: &ruleRefExpr{
								pos:  position{line: 3401, col: 30, offset: 117163},
								name: "funcParam",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3401, col: 40, offset: 117173},
							expr: &litMatcher{
								pos:        position{line: 3401, col: 40, offset: 117173},
								val:        " ",
								ignoreCase: false,
								want:       "\" \"",
							},
						},
						&labeledExpr{
							pos:   position{line: 3401, col: 45, offset: 117178},
							label: "restI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3401, col: 51, offset: 117184},
								expr: &seqExpr{
									pos: position{line: 3401, col: 52, offset: 117185},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 3401, col: 52, offset: 117185},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 3401, col: 56, offset: 117189},
											expr: &choiceExpr{
												pos: position{line: 3750, col: 20, offset: 128702},
												alternatives: []interface{}{
													&charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														exprs: []interface{}{
															&zeroOrOneExpr{
																pos: position{line: 3747, col: 36, offset: 128625},
																expr: &litMatcher{
																	pos:        position{line: 3747, col: 36, offset: 128625},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3747, col: 42, offset: 128631},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3401, col: 60, offset: 117193},
											name: "funcParam",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3401, col: 72, offset: 117205},
							label: "variadicI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3401, col: 82, offset: 117215},
								expr: &seqExpr{
									pos: position{line: 3401, col: 83, offset: 117216},
									exprs: []interface{}{
										&litMatcher{
											pos:        position{line: 3401, col: 83, offset: 117216},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
										&zeroOrMoreExpr{
											pos: position{line: 3401, col: 87, offset: 117220},
											expr: &choiceExpr{
												pos: position{line: 3750, col: 20, offset: 128702},
												alternatives: []interface{}{
													&charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
													&seqExpr{
														pos: position{line: 3747, col: 36, offset: 128625},
														exprs: []interface{}{
															&zeroOrOneExpr{
																pos: position{line: 3747, col: 36, offset: 128625},
																expr: &litMatcher{
																	pos:        position{line: 3747, col: 36, offset: 128625},
																	val:        "\r",
																	ignoreCase: false,
																	want:       "\"\\r\"",
																},
															},
															&litMatcher{
																pos:        position{line: 3747, col: 42, offset: 128631},
																val:        "\n",
																ignoreCase: false,
																want:       "\"\\n\"",
															},
														},
													},
												},
											},
										},
										&ruleRefExpr{
											pos:  position{line: 3401, col: 91, offset: 117224},
											name: "funcVariadicParam",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "funcParam",
			pos:  position{line: 3422, col: 1, offset: 117675},
			expr: &choiceExpr{
				pos: position{line: 3422, col: 14, offset: 117688},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3422, col: 14, offset: 117688},
						run: (*parser).callonfuncParam2,
						expr: &seqExpr{
							pos: position{line: 3422, col: 14, offset: 117688},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3422, col: 14, offset: 117688},
									label: "namesI",
									expr: &actionExpr{
										pos: position{line: 3445, col: 18, offset: 118268},
										run: (*parser).callonfuncParam5,
										expr: &seqExpr{
											pos: position{line: 3445, col: 18, offset: 118268},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 3445, col: 18, offset: 118268},
													label: "firstI",
													expr: &choiceExpr{
														pos: position{line: 2319, col: 12, offset: 79887},
														alternatives: []interface{}{
															&actionExpr{
																pos: position{line: 2319, col: 12, offset: 79887},
																run: (*parser).callonfuncParam9,
																expr: &labeledExpr{
																	pos:   position{line: 2319, col: 12, offset: 79887},
																	label: "ident",
																	expr: &seqExpr{
																		pos: position{line: 2367, col: 17, offset: 81233},
																		exprs: []interface{}{
																			&charClassMatcher{
																				pos:        position{line: 2350, col: 20, offset: 80988},
																				val:        "[_\\pL]",
																				chars:      []rune{'_'},
																				classes:    []*unicode.RangeTable{rangeTable("L")},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&zeroOrMoreExpr{
																				pos: position{line: 2367, col: 26, offset: 81242},
																				expr: &charClassMatcher{
																					pos:        position{line: 2350, col: 20, offset: 80988},
																					val:        "[_\\pL\\pNd]",
																					chars:      []rune{'_'},
																					classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																					ignoreCase: false,
																					inverted:   false,
																				},
																			},
																		},
																	},
																},
															},
															&actionExpr{
																pos: position{line: 2321, col: 5, offset: 79981},
																run: (*parser).callonfuncParam15,
																expr: &seqExpr{
																	pos: position{line: 2321, col: 5, offset: 79981},
																	exprs: []interface{}{
																		&labeledExpr{
																			pos:   position{line: 2321, col: 5, offset: 79981},
																			label: "identI",
																			expr: &seqExpr{
																				pos: position{line: 2321, col: 13, offset: 79989},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 2321, col: 13, offset: 79989},
																						expr: &litMatcher{
																							pos:        position{line: 2321, col: 13, offset: 79989},
																							val:        "$",
																							ignoreCase: false,
																							want:       "\"$\"",
																						},
																					},
																					&oneOrMoreExpr{
																						pos: position{line: 2321, col: 18, offset: 79994},
																						expr: &choiceExpr{
																							pos: position{line: 2321, col: 19, offset: 79995},
																							alternatives: []interface{}{
																								&seqExpr{
																									pos: position{line: 2321, col: 19, offset: 79995},
																									exprs: []interface{}{
																										&charClassMatcher{
																											pos:        position{line: 2321, col: 19, offset: 79995},
																											val:        "[\\pNd]",
																											classes:    []*unicode.RangeTable{rangeTable("Nd")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																										&charClassMatcher{
																											pos:        position{line: 2321, col: 28, offset: 80004},
																											val:        "[_-\\pL]",
																											chars:      []rune{'_', '-'},
																											classes:    []*unicode.RangeTable{rangeTable("L")},
																											ignoreCase: false,
																											inverted:   false,
																										},
																									},
																								},
																								&charClassMatcher{
																									pos:        position{line: 2321, col: 38, offset: 80014},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		&labeledExpr{
																			pos:   position{line: 2321, col: 49, offset: 80025},
																			label: "endPosI",
																			expr: &actionExpr{
																				pos: position{line: 3737, col: 8, offset: 128286},
																				run: (*parser).callonfuncParam28,
																				expr: &choiceExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					alternatives: []interface{}{
																						&andExpr{
																							pos: position{line: 3737, col: 9, offset: 128287},
																							expr: &anyMatcher{
																								line: 3737, col: 10, offset: 128288,
																							},
																						},
																						&notExpr{
																							pos: position{line: 3737, col: 14, offset: 128292},
																							expr: &anyMatcher{
																								line: 3737, col: 15, offset: 128293,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 3445, col: 33, offset: 118283},
													label: "restI",
													expr: &zeroOrMoreExpr{
														pos: position{line: 3445, col: 39, offset: 118289},
														expr: &seqExpr{
															pos: position{line: 3445, col: 40, offset: 118290},
															exprs: []interface{}{
																&zeroOrMoreExpr{
																	pos: position{line: 3445, col: 40, offset: 118290},
																	expr: &litMatcher{
																		pos:        position{line: 3445, col: 40, offset: 118290},
																		val:        " ",
																		ignoreCase: false,
																		want:       "\" \"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3445, col: 45, offset: 118295},
																	val:        ",",
																	ignoreCase: false,
																	want:       "\",\"",
																},
																&zeroOrMoreExpr{
																	pos: position{line: 3445, col: 49, offset: 118299},
																	expr: &choiceExpr{
																		pos: position{line: 3750, col: 20, offset: 128702},
																		alternatives: []interface{}{
																			&charClassMatcher{
																				pos:        position{line: 3746, col: 36, offset: 128584},
																				val:        "[ \\t]",
																				chars:      []rune{' ', '\t'},
																				ignoreCase: false,
																				inverted:   false,
																			},
																			&seqExpr{
																				pos: position{line: 3747, col: 36, offset: 128625},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3747, col: 36, offset: 128625},
																						expr: &litMatcher{
																							pos:        position{line: 3747, col: 36, offset: 128625},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3747, col: 42, offset: 128631},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																		},
																	},
																},
																&choiceExpr{
																	pos: position{line: 2319, col: 12, offset: 79887},
																	alternatives: []interface{}{
																		&actionExpr{
																			pos: position{line: 2319, col: 12, offset: 79887},
																			run: (*parser).callonfuncParam48,
																			expr: &labeledExpr{
																				pos:   position{line: 2319, col: 12, offset: 79887},
																				label: "ident",
																				expr: &seqExpr{
																					pos: position{line: 2367, col: 17, offset: 81233},
																					exprs: []interface{}{
																						&charClassMatcher{
																							pos:        position{line: 2350, col: 20, offset: 80988},
																							val:        "[_\\pL]",
																							chars:      []rune{'_'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																						&zeroOrMoreExpr{
																							pos: position{line: 2367, col: 26, offset: 81242},
																							expr: &charClassMatcher{
																								pos:        position{line: 2350, col: 20, offset: 80988},
																								val:        "[_\\pL\\pNd]",
																								chars:      []rune{'_'},
																								classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																				},
																			},
																		},
																		&actionExpr{
																			pos: position{line: 2321, col: 5, offset: 79981},
																			run: (*parser).callonfuncParam54,
																			expr: &seqExpr{
																				pos: position{line: 2321, col: 5, offset: 79981},
																				exprs: []interface{}{
																					&labeledExpr{
																						pos:   position{line: 2321, col: 5, offset: 79981},
																						label: "identI",
																						expr: &seqExpr{
																							pos: position{line: 2321, col: 13, offset: 79989},
																							exprs: []interface{}{
																								&zeroOrOneExpr{
																									pos: position{line: 2321, col: 13, offset: 79989},
																									expr: &litMatcher{
																										pos:        position{line: 2321, col: 13, offset: 79989},
																										val:        "$",
																										ignoreCase: false,
																										want:       "\"$\"",
																									},
																								},
																								&oneOrMoreExpr{
																									pos: position{line: 2321, col: 18, offset: 79994},
																									expr: &choiceExpr{
																										pos: position{line: 2321, col: 19, offset: 79995},
																										alternatives: []interface{}{
																											&seqExpr{
																												pos: position{line: 2321, col: 19, offset: 79995},
																												exprs: []interface{}{
																													&charClassMatcher{
																														pos:        position{line: 2321, col: 19, offset: 79995},
																														val:        "[\\pNd]",
																														classes:    []*unicode.RangeTable{rangeTable("Nd")},
																														ignoreCase: false,
																														inverted:   false,
																													},
																													&charClassMatcher{
																														pos:        position{line: 2321, col: 28, offset: 80004},
																														val:        "[_-\\pL]",
																														chars:      []rune{'_', '-'},
																														classes:    []*unicode.RangeTable{rangeTable("L")},
																														ignoreCase: false,
																														inverted:   false,
																													},
																												},
																											},
																											&charClassMatcher{
																												pos:        position{line: 2321, col: 38, offset: 80014},
																												val:        "[_-\\pL]",
																												chars:      []rune{'_', '-'},
																												classes:    []*unicode.RangeTable{rangeTable("L")},
																												ignoreCase: false,
																												inverted:   false,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																					&labeledExpr{
																						pos:   position{line: 2321, col: 49, offset: 80025},
																						label: "endPosI",
																						expr: &actionExpr{
																							pos: position{line: 3737, col: 8, offset: 128286},
																							run: (*parser).callonfuncParam67,
																							expr: &choiceExpr{
																								pos: position{line: 3737, col: 9, offset: 128287},
																								alternatives: []interface{}{
																									&andExpr{
																										pos: position{line: 3737, col: 9, offset: 128287},
																										expr: &anyMatcher{
																											line: 3737, col: 10, offset: 128288,
																										},
																									},
																									&notExpr{
																										pos: position{line: 3737, col: 14, offset: 128292},
																										expr: &anyMatcher{
																											line: 3737, col: 15, offset: 128293,
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&oneOrMoreExpr{
									pos: position{line: 3422, col: 35, offset: 117709},
									expr: &litMatcher{
										pos:        position{line: 3422, col: 35, offset: 117709},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3422, col: 40, offset: 117714},
									label: "typeI",
									expr: &ruleRefExpr{
										pos:  position{line: 3422, col: 46, offset: 117720},
										name: "funcType",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3427, col: 5, offset: 117848},
						run: (*parser).callonfuncParam77,
						expr: &labeledExpr{
							pos:   position{line: 3427, col: 5, offset: 117848},
							label: "typeI",
							expr: &ruleRefExpr{
								pos:  position{line: 3427, col: 11, offset: 117854},
								name: "funcType",
							},
						},
					},
				},
			},
		},
		{
			name: "funcVariadicParam",
			pos:  position{line: 3432, col: 1, offset: 117940},
			expr: &actionExpr{
				pos: position{line: 3432, col: 22, offset: 117961},
				run: (*parser).callonfuncVariadicParam1,
				expr: &seqExpr{
					pos: position{line: 3432, col: 22, offset: 117961},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3432, col: 22, offset: 117961},
							label: "nameI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3432, col: 28, offset: 117967},
								expr: &seqExpr{
									pos: position{line: 3432, col: 29, offset: 117968},
									exprs: []interface{}{
										&choiceExpr{
											pos: position{line: 2319, col: 12, offset: 79887},
											alternatives: []interface{}{
												&actionExpr{
													pos: position{line: 2319, col: 12, offset: 79887},
													run: (*parser).callonfuncVariadicParam7,
													expr: &labeledExpr{
														pos:   position{line: 2319, col: 12, offset: 79887},
														label: "ident",
														expr: &seqExpr{
															pos: position{line: 2367, col: 17, offset: 81233},
															exprs: []interface{}{
																&charClassMatcher{
																	pos:        position{line: 2350, col: 20, offset: 80988},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2367, col: 26, offset: 81242},
																	expr: &charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 2321, col: 5, offset: 79981},
													run: (*parser).callonfuncVariadicParam13,
													expr: &seqExpr{
														pos: position{line: 2321, col: 5, offset: 79981},
														exprs: []interface{}{
															&labeledExpr{
																pos:   position{line: 2321, col: 5, offset: 79981},
																label: "identI",
																expr: &seqExpr{
																	pos: position{line: 2321, col: 13, offset: 79989},
																	exprs: []interface{}{
																		&zeroOrOneExpr{
																			pos: position{line: 2321, col: 13, offset: 79989},
																			expr: &litMatcher{
																				pos:        position{line: 2321, col: 13, offset: 79989},
																				val:        "$",
																				ignoreCase: false,
																				want:       "\"$\"",
																			},
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 2321, col: 18, offset: 79994},
																			expr: &choiceExpr{
																				pos: position{line: 2321, col: 19, offset: 79995},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 2321, col: 19, offset: 79995},
																						exprs: []interface{}{
																							&charClassMatcher{
																								pos:        position{line: 2321, col: 19, offset: 79995},
																								val:        "[\\pNd]",
																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 2321, col: 28, offset: 80004},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 2321, col: 38, offset: 80014},
																						val:        "[_-\\pL]",
																						chars:      []rune{'_', '-'},
																						classes:    []*unicode.RangeTable{rangeTable("L")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&labeledExpr{
																pos:   position{line: 2321, col: 49, offset: 80025},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonfuncVariadicParam26,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&oneOrMoreExpr{
											pos: position{line: 3432, col: 37, offset: 117976},
											expr: &litMatcher{
												pos:        position{line: 3432, col: 37, offset: 117976},
												val:        " ",
												ignoreCase: false,
												want:       "\" \"",
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 3432, col: 44, offset: 117983},
							val:        "...",
							ignoreCase: false,
							want:       "\"...\"",
						},
						&labeledExpr{
							pos:   position{line: 3432, col: 50, offset: 117989},
							label: "typeI",
							expr: &ruleRefExpr{
								pos:  position{line: 3432, col: 56, offset: 117995},
								name: "funcType",
							},
						},
					},
				},
			},
		},
		{
			name: "funcType",
			pos:  position{line: 3457, col: 1, offset: 118574},
			expr: &choiceExpr{
				pos: position{line: 3457, col: 13, offset: 118586},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 3457, col: 13, offset: 118586},
						name: "GoType",
					},
					&actionExpr{
						pos: position{line: 3457, col: 22, offset: 118595},
						run: (*parser).callonfuncType3,
						expr: &seqExpr{
							pos: position{line: 3457, col: 22, offset: 118595},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3457, col: 22, offset: 118595},
									label: "typeI",
									expr: &oneOrMoreExpr{
										pos: position{line: 3457, col: 28, offset: 118601},
										expr: &charClassMatcher{
											pos:        position{line: 3457, col: 28, offset: 118601},
											val:        "[^,)]",
											chars:      []rune{',', ')'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3457, col: 35, offset: 118608},
									label: "endPosI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonfuncType9,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Assign",
			pos:  position{line: 3475, col: 1, offset: 119121},
			expr: &choiceExpr{
				pos: position{line: 3475, col: 11, offset: 119131},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3475, col: 11, offset: 119131},
						run: (*parser).callonAssign2,
						expr: &seqExpr{
							pos: position{line: 3475, col: 11, offset: 119131},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3475, col: 11, offset: 119131},
									label: "noEscapeI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3475, col: 21, offset: 119141},
										expr: &litMatcher{
											pos:        position{line: 3475, col: 21, offset: 119141},
											val:        "!",
											ignoreCase: false,
											want:       "\"!\"",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 3475, col: 26, offset: 119146},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&oneOrMoreExpr{
									pos: position{line: 3475, col: 30, offset: 119150},
									expr: &litMatcher{
										pos:        position{line: 3475, col: 30, offset: 119150},
										val:        " ",
										ignoreCase: false,
										want:       "\" \"",
									},
								},
								&labeledExpr{
									pos:   position{line: 3475, col: 35, offset: 119155},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 3475, col: 41, offset: 119161},
										name: "Expression",
									},
								},
								&zeroOrOneExpr{
									pos: position{line: 3475, col: 52, offset: 119172},
									expr: &actionExpr{
										pos: position{line: 1251, col: 21, offset: 40099},
										run: (*parser).callonAssign13,
										expr: &oneOrMoreExpr{
											pos: position{line: 1251, col: 21, offset: 40099},
											expr: &charClassMatcher{
												pos:        position{line: 3735, col: 12, offset: 128270},
												val:        "[^\\r\\n]",
												chars:      []rune{'\r', '\n'},
												ignoreCase: false,
												inverted:   true,
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3481, col: 5, offset: 119342},
						run: (*parser).callonAssign25,
						expr: &seqExpr{
							pos: position{line: 3481, col: 5, offset: 119342},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3481, col: 5, offset: 119342},
									label: "noEscapeI",
									expr: &zeroOrOneExpr{
										pos: position{line: 3481, col: 15, offset: 119352},
										expr: &litMatcher{
											pos:        position{line: 3481, col: 15, offset: 119352},
											val:        "!",
											ignoreCase: false,
											want:       "\"!\"",
										},
									},
								},
								&litMatcher{
									pos:        position{line: 3481, col: 20, offset: 119357},
									val:        "=",
									ignoreCase: false,
									want:       "\"=\"",
								},
								&labeledExpr{
									pos:   position{line: 3481, col: 24, offset: 119361},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonAssign32,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineText",
			pos:  position{line: 3500, col: 1, offset: 119931},
			expr: &actionExpr{
				pos: position{line: 3500, col: 15, offset: 119945},
				run: (*parser).callonInlineText1,
				expr: &seqExpr{
					pos: position{line: 3500, col: 15, offset: 119945},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 3500, col: 15, offset: 119945},
							val:        " ",
							ignoreCase: false,
							want:       "\" \"",
						},
						&labeledExpr{
							pos:   position{line: 3500, col: 19, offset: 119949},
							label: "lineI",
							expr: &ruleRefExpr{
								pos:  position{line: 3500, col: 25, offset: 119955},
								name: "TextLine",
							},
						},
					},
				},
			},
		},
		{
			name: "ArrowBlock",
			pos:  position{line: 3510, col: 1, offset: 120231},
			expr: &choiceExpr{
				pos: position{line: 3510, col: 15, offset: 120245},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3510, col: 15, offset: 120245},
						run: (*parser).callonArrowBlock2,
						expr: &seqExpr{
							pos: position{line: 3510, col: 15, offset: 120245},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3510, col: 15, offset: 120245},
									val:        "> ",
									ignoreCase: false,
									want:       "\"> \"",
								},
								&labeledExpr{
									pos:   position{line: 3510, col: 20, offset: 120250},
									label: "firstLineI",
									expr: &choiceExpr{
										pos: position{line: 3510, col: 32, offset: 120262},
										alternatives: []interface{}{
											&ruleRefExpr{
												pos:  position{line: 3510, col: 32, offset: 120262},
												name: "TextLine",
											},
											&seqExpr{
												pos: position{line: 3734, col: 12, offset: 128237},
												exprs: []interface{}{
													&zeroOrMoreExpr{
														pos: position{line: 3734, col: 12, offset: 128237},
														expr: &charClassMatcher{
															pos:        position{line: 3746, col: 36, offset: 128584},
															val:        "[ \\t]",
															chars:      []rune{' ', '\t'},
															ignoreCase: false,
															inverted:   false,
														},
													},
													&choiceExpr{
														pos: position{line: 3734, col: 16, offset: 128241},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 16, offset: 128241},
																exprs: []interface{}{
																	&zeroOrOneExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		expr: &litMatcher{
																			pos:        position{line: 3734, col: 16, offset: 128241},
																			val:        "\r",
																			ignoreCase: false,
																			want:       "\"\\r\"",
																		},
																	},
																	&litMatcher{
																		pos:        position{line: 3734, col: 22, offset: 128247},
																		val:        "\n",
																		ignoreCase: false,
																		want:       "\"\\n\"",
																	},
																},
															},
															&notExpr{
																pos: position{line: 3733, col: 12, offset: 128223},
																expr: &anyMatcher{
																	line: 3733, col: 13, offset: 128224,
																},
															},
														},
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3510, col: 48, offset: 120278},
									label: "additionalLinesI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3510, col: 65, offset: 120295},
										expr: &seqExpr{
											pos: position{line: 3510, col: 66, offset: 120296},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3510, col: 66, offset: 120296},
													expr: &oneOrMoreExpr{
														pos: position{line: 3748, col: 36, offset: 128671},
														expr: &seqExpr{
															pos: position{line: 3748, col: 37, offset: 128672},
															exprs: []interface{}{
																&zeroOrMoreExpr{
																	pos: position{line: 3748, col: 37, offset: 128672},
																	expr: &charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&zeroOrOneExpr{
																	pos: position{line: 3747, col: 36, offset: 128625},
																	expr: &litMatcher{
																		pos:        position{line: 3747, col: 36, offset: 128625},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3747, col: 42, offset: 128631},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
													},
												},
												&ruleRefExpr{
													pos:  position{line: 3510, col: 75, offset: 120305},
													name: "INDENTATION2",
												},
												&ruleRefExpr{
													pos:  position{line: 3510, col: 88, offset: 120318},
													name: "TextLine",
												},
											},
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3531, col: 5, offset: 120833},
						run: (*parser).callonArrowBlock31,
						expr: &seqExpr{
							pos: position{line: 3531, col: 5, offset: 120833},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3531, col: 5, offset: 120833},
									val:        ">",
									ignoreCase: false,
									want:       "\">\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineArrowBlock",
			pos:  position{line: 3535, col: 1, offset: 120896},
			expr: &choiceExpr{
				pos: position{line: 3535, col: 21, offset: 120916},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3535, col: 21, offset: 120916},
						run: (*parser).callonInlineArrowBlock2,
						expr: &seqExpr{
							pos: position{line: 3535, col: 21, offset: 120916},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3535, col: 21, offset: 120916},
									val:        "> ",
									ignoreCase: false,
									want:       "\"> \"",
								},
								&labeledExpr{
									pos:   position{line: 3535, col: 26, offset: 120921},
									label: "lineI",
									expr: &ruleRefExpr{
										pos:  position{line: 3535, col: 32, offset: 120927},
										name: "TextLine",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3540, col: 5, offset: 121062},
						run: (*parser).callonInlineArrowBlock7,
						expr: &seqExpr{
							pos: position{line: 3540, col: 5, offset: 121062},
							exprs: []interface{}{
								&litMatcher{
									pos:        position{line: 3540, col: 5, offset: 121062},
									val:        ">",
									ignoreCase: false,
									want:       "\">\"",
								},
								&labeledExpr{
									pos:   position{line: 3540, col: 9, offset: 121066},
									label: "posI",
									expr: &actionExpr{
										pos: position{line: 3737, col: 8, offset: 128286},
										run: (*parser).callonInlineArrowBlock11,
										expr: &choiceExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											alternatives: []interface{}{
												&andExpr{
													pos: position{line: 3737, col: 9, offset: 128287},
													expr: &anyMatcher{
														line: 3737, col: 10, offset: 128288,
													},
												},
												&notExpr{
													pos: position{line: 3737, col: 14, offset: 128292},
													expr: &anyMatcher{
														line: 3737, col: 15, offset: 128293,
													},
												},
											},
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3540, col: 18, offset: 121075},
									label: "lineI",
									expr: &ruleRefExpr{
										pos:  position{line: 3540, col: 24, offset: 121081},
										name: "TextLine",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TextLine",
			pos:  position{line: 3558, col: 1, offset: 121661},
			expr: &actionExpr{
				pos: position{line: 3558, col: 13, offset: 121673},
				run: (*parser).callonTextLine1,
				expr: &seqExpr{
					pos: position{line: 3558, col: 13, offset: 121673},
					exprs: []interface{}{
						&labeledExpr{
							pos:   position{line: 3558, col: 13, offset: 121673},
							label: "itemsI",
							expr: &oneOrMoreExpr{
								pos: position{line: 3558, col: 20, offset: 121680},
								expr: &ruleRefExpr{
									pos:  position{line: 3558, col: 20, offset: 121680},
									name: "TextItem",
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 3734, col: 12, offset: 128237},
							expr: &charClassMatcher{
								pos:        position{line: 3746, col: 36, offset: 128584},
								val:        "[ \\t]",
								chars:      []rune{' ', '\t'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&choiceExpr{
							pos: position{line: 3734, col: 16, offset: 128241},
							alternatives: []interface{}{
								&seqExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									exprs: []interface{}{
										&zeroOrOneExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											expr: &litMatcher{
												pos:        position{line: 3734, col: 16, offset: 128241},
												val:        "\r",
												ignoreCase: false,
												want:       "\"\\r\"",
											},
										},
										&litMatcher{
											pos:        position{line: 3734, col: 22, offset: 128247},
											val:        "\n",
											ignoreCase: false,
											want:       "\"\\n\"",
										},
									},
								},
								&notExpr{
									pos: position{line: 3733, col: 12, offset: 128223},
									expr: &anyMatcher{
										line: 3733, col: 13, offset: 128224,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TextItem",
			pos:  position{line: 3566, col: 1, offset: 121947},
			expr: &choiceExpr{
				pos: position{line: 3566, col: 13, offset: 121959},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3572, col: 9, offset: 122168},
						run: (*parser).callonTextItem2,
						expr: &labeledExpr{
							pos:   position{line: 3572, col: 9, offset: 122168},
							label: "textI",
							expr: &oneOrMoreExpr{
								pos: position{line: 3572, col: 15, offset: 122174},
								expr: &choiceExpr{
									pos: position{line: 3572, col: 16, offset: 122175},
									alternatives: []interface{}{
										&oneOrMoreExpr{
											pos: position{line: 3572, col: 16, offset: 122175},
											expr: &seqExpr{
												pos: position{line: 3572, col: 17, offset: 122176},
												exprs: []interface{}{
													&notExpr{
														pos: position{line: 3572, col: 17, offset: 122176},
														expr: &seqExpr{
															pos: position{line: 3734, col: 12, offset: 128237},
															exprs: []interface{}{
																&zeroOrMoreExpr{
																	pos: position{line: 3734, col: 12, offset: 128237},
																	expr: &charClassMatcher{
																		pos:        position{line: 3746, col: 36, offset: 128584},
																		val:        "[ \\t]",
																		chars:      []rune{' ', '\t'},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
																&choiceExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	alternatives: []interface{}{
																		&seqExpr{
																			pos: position{line: 3734, col: 16, offset: 128241},
																			exprs: []interface{}{
																				&zeroOrOneExpr{
																					pos: position{line: 3734, col: 16, offset: 128241},
																					expr: &litMatcher{
																						pos:        position{line: 3734, col: 16, offset: 128241},
																						val:        "\r",
																						ignoreCase: false,
																						want:       "\"\\r\"",
																					},
																				},
																				&litMatcher{
																					pos:        position{line: 3734, col: 22, offset: 128247},
																					val:        "\n",
																					ignoreCase: false,
																					want:       "\"\\n\"",
																				},
																			},
																		},
																		&notExpr{
																			pos: position{line: 3733, col: 12, offset: 128223},
																			expr: &anyMatcher{
																				line: 3733, col: 13, offset: 128224,
																			},
																		},
																	},
																},
															},
														},
													},
													&charClassMatcher{
														pos:        position{line: 3572, col: 22, offset: 122181},
														val:        "[^#]",
														chars:      []rune{'#'},
														ignoreCase: false,
														inverted:   true,
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 3572, col: 31, offset: 122190},
											val:        "##",
											ignoreCase: false,
											want:       "\"##\"",
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 3566, col: 20, offset: 121966},
						name: "Interpolation",
					},
				},
			},
		},
		{
			name: "Interpolation",
			pos:  position{line: 3583, col: 1, offset: 122478},
			expr: &choiceExpr{
				pos: position{line: 3583, col: 18, offset: 122495},
				alternatives: []interface{}{
					&ruleRefExpr{
						pos:  position{line: 3583, col: 18, offset: 122495},
						name: "SimpleInterpolation",
					},
					&ruleRefExpr{
						pos:  position{line: 3583, col: 40, offset: 122517},
						name: "ElementInterpolation",
					},
					&ruleRefExpr{
						pos:  position{line: 3583, col: 63, offset: 122540},
						name: "MixinCallInterpolation",
					},
					&actionExpr{
						pos: position{line: 3585, col: 21, offset: 122603},
						run: (*parser).callonInterpolation5,
						expr: &litMatcher{
							pos:        position{line: 3585, col: 21, offset: 122603},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
					},
				},
			},
		},
		{
			name: "SimpleInterpolation",
			pos:  position{line: 3609, col: 1, offset: 123450},
			expr: &actionExpr{
				pos: position{line: 3609, col: 24, offset: 123473},
				run: (*parser).callonSimpleInterpolation1,
				expr: &seqExpr{
					pos: position{line: 3609, col: 24, offset: 123473},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 3609, col: 24, offset: 123473},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&labeledExpr{
							pos:   position{line: 3609, col: 28, offset: 123477},
							label: "noEscapeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3609, col: 38, offset: 123487},
								expr: &litMatcher{
									pos:        position{line: 3609, col: 38, offset: 123487},
									val:        "!",
									ignoreCase: false,
									want:       "\"!\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3609, col: 43, offset: 123492},
							label: "valueI",
							expr: &choiceExpr{
								pos: position{line: 3609, col: 51, offset: 123500},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 3699, col: 27, offset: 126966},
										run: (*parser).callonSimpleInterpolation9,
										expr: &seqExpr{
											pos: position{line: 3699, col: 27, offset: 126966},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 3699, col: 27, offset: 126966},
													label: "lBracketPosI",
													expr: &actionExpr{
														pos: position{line: 3762, col: 14, offset: 129078},
														run: (*parser).callonSimpleInterpolation12,
														expr: &litMatcher{
															pos:        position{line: 3762, col: 14, offset: 129078},
															val:        "[",
															ignoreCase: false,
															want:       "\"[\"",
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 3699, col: 50, offset: 126989},
													label: "textI",
													expr: &zeroOrMoreExpr{
														pos: position{line: 3699, col: 56, offset: 126995},
														expr: &charClassMatcher{
															pos:        position{line: 3699, col: 56, offset: 126995},
															val:        "[^]\\r\\n]",
															chars:      []rune{']', '\r', '\n'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 3699, col: 67, offset: 127006},
													label: "rBracketPosI",
													expr: &actionExpr{
														pos: position{line: 3763, col: 14, offset: 129118},
														run: (*parser).callonSimpleInterpolation18,
														expr: &litMatcher{
															pos:        position{line: 3763, col: 14, offset: 129118},
															val:        "]",
															ignoreCase: false,
															want:       "\"]\"",
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 3705, col: 5, offset: 127217},
										run: (*parser).callonSimpleInterpolation20,
										expr: &seqExpr{
											pos: position{line: 3705, col: 5, offset: 127217},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 3705, col: 5, offset: 127217},
													label: "lBracketPosI",
													expr: &actionExpr{
														pos: position{line: 3762, col: 14, offset: 129078},
														run: (*parser).callonSimpleInterpolation23,
														expr: &litMatcher{
															pos:        position{line: 3762, col: 14, offset: 129078},
															val:        "[",
															ignoreCase: false,
															want:       "\"[\"",
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 3705, col: 28, offset: 127240},
													label: "textI",
													expr: &zeroOrMoreExpr{
														pos: position{line: 3705, col: 34, offset: 127246},
														expr: &charClassMatcher{
															pos:        position{line: 3705, col: 34, offset: 127246},
															val:        "[^]\\r\\n]",
															chars:      []rune{']', '\r', '\n'},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&zeroOrMoreExpr{
													pos: position{line: 3734, col: 12, offset: 128237},
													expr: &charClassMatcher{
														pos:        position{line: 3746, col: 36, offset: 128584},
														val:        "[ \\t]",
														chars:      []rune{' ', '\t'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&choiceExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													alternatives: []interface{}{
														&seqExpr{
															pos: position{line: 3734, col: 16, offset: 128241},
															exprs: []interface{}{
																&zeroOrOneExpr{
																	pos: position{line: 3734, col: 16, offset: 128241},
																	expr: &litMatcher{
																		pos:        position{line: 3734, col: 16, offset: 128241},
																		val:        "\r",
																		ignoreCase: false,
																		want:       "\"\\r\"",
																	},
																},
																&litMatcher{
																	pos:        position{line: 3734, col: 22, offset: 128247},
																	val:        "\n",
																	ignoreCase: false,
																	want:       "\"\\n\"",
																},
															},
														},
														&notExpr{
															pos: position{line: 3733, col: 12, offset: 128223},
															expr: &anyMatcher{
																line: 3733, col: 13, offset: 128224,
															},
														},
													},
												},
											},
										},
									},
									&ruleRefExpr{
										pos:  position{line: 3609, col: 76, offset: 123525},
										name: "expressionInterpolationValue",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ElementInterpolation",
			pos:  position{line: 3621, col: 1, offset: 123914},
			expr: &actionExpr{
				pos: position{line: 3621, col: 25, offset: 123938},
				run: (*parser).callonElementInterpolation1,
				expr: &seqExpr{
					pos: position{line: 3621, col: 25, offset: 123938},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 3621, col: 25, offset: 123938},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&labeledExpr{
							pos:   position{line: 3621, col: 29, offset: 123942},
							label: "noEscapeI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3621, col: 39, offset: 123952},
								expr: &litMatcher{
									pos:        position{line: 3621, col: 39, offset: 123952},
									val:        "!",
									ignoreCase: false,
									want:       "\"!\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3621, col: 44, offset: 123957},
							label: "elPosI",
							expr: &actionExpr{
								pos: position{line: 3737, col: 8, offset: 128286},
								run: (*parser).callonElementInterpolation8,
								expr: &choiceExpr{
									pos: position{line: 3737, col: 9, offset: 128287},
									alternatives: []interface{}{
										&andExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											expr: &anyMatcher{
												line: 3737, col: 10, offset: 128288,
											},
										},
										&notExpr{
											pos: position{line: 3737, col: 14, offset: 128292},
											expr: &anyMatcher{
												line: 3737, col: 15, offset: 128293,
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3621, col: 55, offset: 123968},
							label: "nameI",
							expr: &oneOrMoreExpr{
								pos: position{line: 2836, col: 16, offset: 98915},
								expr: &charClassMatcher{
									pos:        position{line: 2822, col: 27, offset: 98255},
									val:        "[09A-Za-z]",
									chars:      []rune{'0', '9'},
									ranges:     []rune{'A', 'Z', 'a', 'z'},
									ignoreCase: false,
									inverted:   false,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3621, col: 73, offset: 123986},
							label: "attrsI",
							expr: &zeroOrMoreExpr{
								pos: position{line: 3621, col: 80, offset: 123993},
								expr: &ruleRefExpr{
									pos:  position{line: 3621, col: 80, offset: 123993},
									name: "SingleLineAttributeCollection",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3621, col: 111, offset: 124024},
							label: "valueI",
							expr: &ruleRefExpr{
								pos:  position{line: 3621, col: 118, offset: 124031},
								name: "elementInterpolationValue",
							},
						},
					},
				},
			},
		},
		{
			name: "elementInterpolationValue",
			pos:  position{line: 3635, col: 1, offset: 124459},
			expr: &choiceExpr{
				pos: position{line: 3635, col: 30, offset: 124488},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3699, col: 27, offset: 126966},
						run: (*parser).callonelementInterpolationValue2,
						expr: &seqExpr{
							pos: position{line: 3699, col: 27, offset: 126966},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3699, col: 27, offset: 126966},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3762, col: 14, offset: 129078},
										run: (*parser).callonelementInterpolationValue5,
										expr: &litMatcher{
											pos:        position{line: 3762, col: 14, offset: 129078},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3699, col: 50, offset: 126989},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3699, col: 56, offset: 126995},
										expr: &charClassMatcher{
											pos:        position{line: 3699, col: 56, offset: 126995},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3699, col: 67, offset: 127006},
									label: "rBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3763, col: 14, offset: 129118},
										run: (*parser).callonelementInterpolationValue11,
										expr: &litMatcher{
											pos:        position{line: 3763, col: 14, offset: 129118},
											val:        "]",
											ignoreCase: false,
											want:       "\"]\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3705, col: 5, offset: 127217},
						run: (*parser).callonelementInterpolationValue13,
						expr: &seqExpr{
							pos: position{line: 3705, col: 5, offset: 127217},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3705, col: 5, offset: 127217},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3762, col: 14, offset: 129078},
										run: (*parser).callonelementInterpolationValue16,
										expr: &litMatcher{
											pos:        position{line: 3762, col: 14, offset: 129078},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3705, col: 28, offset: 127240},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3705, col: 34, offset: 127246},
										expr: &charClassMatcher{
											pos:        position{line: 3705, col: 34, offset: 127246},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 3635, col: 55, offset: 124513},
						name: "expressionInterpolationValue",
					},
					&actionExpr{
						pos: position{line: 3635, col: 86, offset: 124544},
						run: (*parser).callonelementInterpolationValue31,
						expr: &litMatcher{
							pos:        position{line: 3635, col: 86, offset: 124544},
							val:        "/",
							ignoreCase: false,
							want:       "\"/\"",
						},
					},
					&actionExpr{
						pos: position{line: 3637, col: 5, offset: 124574},
						run: (*parser).callonelementInterpolationValue33,
						expr: &andExpr{
							pos: position{line: 3637, col: 5, offset: 124574},
							expr: &choiceExpr{
								pos: position{line: 3637, col: 7, offset: 124576},
								alternatives: []interface{}{
									&anyMatcher{
										line: 3637, col: 7, offset: 124576,
									},
									&notExpr{
										pos: position{line: 3637, col: 11, offset: 124580},
										expr: &anyMatcher{
											line: 3637, col: 12, offset: 124581,
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "MixinCallInterpolation",
			pos:  position{line: 3659, col: 1, offset: 125433},
			expr: &actionExpr{
				pos: position{line: 3659, col: 27, offset: 125459},
				run: (*parser).callonMixinCallInterpolation1,
				expr: &seqExpr{
					pos: position{line: 3659, col: 27, offset: 125459},
					exprs: []interface{}{
						&litMatcher{
							pos:        position{line: 3659, col: 27, offset: 125459},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&labeledExpr{
							pos:   position{line: 3659, col: 31, offset: 125463},
							label: "noEscapeI",
							expr: &litMatcher{
								pos:        position{line: 3659, col: 41, offset: 125473},
								val:        "!",
								ignoreCase: false,
								want:       "\"!\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 3659, col: 45, offset: 125477},
							label: "mcPosI",
							expr: &actionExpr{
								pos: position{line: 3737, col: 8, offset: 128286},
								run: (*parser).callonMixinCallInterpolation7,
								expr: &choiceExpr{
									pos: position{line: 3737, col: 9, offset: 128287},
									alternatives: []interface{}{
										&andExpr{
											pos: position{line: 3737, col: 9, offset: 128287},
											expr: &anyMatcher{
												line: 3737, col: 10, offset: 128288,
											},
										},
										&notExpr{
											pos: position{line: 3737, col: 14, offset: 128292},
											expr: &anyMatcher{
												line: 3737, col: 15, offset: 128293,
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 3659, col: 56, offset: 125488},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&labeledExpr{
							pos:   position{line: 3659, col: 60, offset: 125492},
							label: "namespaceI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3659, col: 71, offset: 125503},
								expr: &seqExpr{
									pos: position{line: 3659, col: 72, offset: 125504},
									exprs: []interface{}{
										&choiceExpr{
											pos: position{line: 697, col: 10, offset: 21290},
											alternatives: []interface{}{
												&actionExpr{
													pos: position{line: 697, col: 10, offset: 21290},
													run: (*parser).callonMixinCallInterpolation18,
													expr: &labeledExpr{
														pos:   position{line: 697, col: 10, offset: 21290},
														label: "identI",
														expr: &seqExpr{
															pos: position{line: 2367, col: 17, offset: 81233},
															exprs: []interface{}{
																&charClassMatcher{
																	pos:        position{line: 2350, col: 20, offset: 80988},
																	val:        "[_\\pL]",
																	chars:      []rune{'_'},
																	classes:    []*unicode.RangeTable{rangeTable("L")},
																	ignoreCase: false,
																	inverted:   false,
																},
																&zeroOrMoreExpr{
																	pos: position{line: 2367, col: 26, offset: 81242},
																	expr: &charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL\\pNd]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																},
															},
														},
													},
												},
												&actionExpr{
													pos: position{line: 699, col: 5, offset: 21384},
													run: (*parser).callonMixinCallInterpolation24,
													expr: &seqExpr{
														pos: position{line: 699, col: 5, offset: 21384},
														exprs: []interface{}{
															&labeledExpr{
																pos:   position{line: 699, col: 5, offset: 21384},
																label: "identI",
																expr: &seqExpr{
																	pos: position{line: 699, col: 13, offset: 21392},
																	exprs: []interface{}{
																		&zeroOrOneExpr{
																			pos: position{line: 699, col: 13, offset: 21392},
																			expr: &litMatcher{
																				pos:        position{line: 699, col: 13, offset: 21392},
																				val:        "$",
																				ignoreCase: false,
																				want:       "\"$\"",
																			},
																		},
																		&oneOrMoreExpr{
																			pos: position{line: 699, col: 18, offset: 21397},
																			expr: &choiceExpr{
																				pos: position{line: 699, col: 19, offset: 21398},
																				alternatives: []interface{}{
																					&seqExpr{
																						pos: position{line: 699, col: 19, offset: 21398},
																						exprs: []interface{}{
																							&charClassMatcher{
																								pos:        position{line: 699, col: 19, offset: 21398},
																								val:        "[\\pNd]",
																								classes:    []*unicode.RangeTable{rangeTable("Nd")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																							&charClassMatcher{
																								pos:        position{line: 699, col: 28, offset: 21407},
																								val:        "[_-\\pL]",
																								chars:      []rune{'_', '-'},
																								classes:    []*unicode.RangeTable{rangeTable("L")},
																								ignoreCase: false,
																								inverted:   false,
																							},
																						},
																					},
																					&charClassMatcher{
																						pos:        position{line: 699, col: 38, offset: 21417},
																						val:        "[_-\\pL]",
																						chars:      []rune{'_', '-'},
																						classes:    []*unicode.RangeTable{rangeTable("L")},
																						ignoreCase: false,
																						inverted:   false,
																					},
																				},
																			},
																		},
																	},
																},
															},
															&labeledExpr{
																pos:   position{line: 699, col: 49, offset: 21428},
																label: "endPosI",
																expr: &actionExpr{
																	pos: position{line: 3737, col: 8, offset: 128286},
																	run: (*parser).callonMixinCallInterpolation37,
																	expr: &choiceExpr{
																		pos: position{line: 3737, col: 9, offset: 128287},
																		alternatives: []interface{}{
																			&andExpr{
																				pos: position{line: 3737, col: 9, offset: 128287},
																				expr: &anyMatcher{
																					line: 3737, col: 10, offset: 128288,
																				},
																			},
																			&notExpr{
																				pos: position{line: 3737, col: 14, offset: 128292},
																				expr: &anyMatcher{
																					line: 3737, col: 15, offset: 128293,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
										&litMatcher{
											pos:        position{line: 3659, col: 78, offset: 125510},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3659, col: 84, offset: 125516},
							label: "nameI",
							expr: &choiceExpr{
								pos: position{line: 711, col: 14, offset: 21845},
								alternatives: []interface{}{
									&actionExpr{
										pos: position{line: 711, col: 14, offset: 21845},
										run: (*parser).callonMixinCallInterpolation46,
										expr: &labeledExpr{
											pos:   position{line: 711, col: 14, offset: 21845},
											label: "identI",
											expr: &choiceExpr{
												pos: position{line: 697, col: 10, offset: 21290},
												alternatives: []interface{}{
													&actionExpr{
														pos: position{line: 697, col: 10, offset: 21290},
														run: (*parser).callonMixinCallInterpolation49,
														expr: &labeledExpr{
															pos:   position{line: 697, col: 10, offset: 21290},
															label: "identI",
															expr: &seqExpr{
																pos: position{line: 2367, col: 17, offset: 81233},
																exprs: []interface{}{
																	&charClassMatcher{
																		pos:        position{line: 2350, col: 20, offset: 80988},
																		val:        "[_\\pL]",
																		chars:      []rune{'_'},
																		classes:    []*unicode.RangeTable{rangeTable("L")},
																		ignoreCase: false,
																		inverted:   false,
																	},
																	&zeroOrMoreExpr{
																		pos: position{line: 2367, col: 26, offset: 81242},
																		expr: &charClassMatcher{
																			pos:        position{line: 2350, col: 20, offset: 80988},
																			val:        "[_\\pL\\pNd]",
																			chars:      []rune{'_'},
																			classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("Nd")},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																},
															},
														},
													},
													&actionExpr{
														pos: position{line: 699, col: 5, offset: 21384},
														run: (*parser).callonMixinCallInterpolation55,
														expr: &seqExpr{
															pos: position{line: 699, col: 5, offset: 21384},
															exprs: []interface{}{
																&labeledExpr{
																	pos:   position{line: 699, col: 5, offset: 21384},
																	label: "identI",
																	expr: &seqExpr{
																		pos: position{line: 699, col: 13, offset: 21392},
																		exprs: []interface{}{
																			&zeroOrOneExpr{
																				pos: position{line: 699, col: 13, offset: 21392},
																				expr: &litMatcher{
																					pos:        position{line: 699, col: 13, offset: 21392},
																					val:        "$",
																					ignoreCase: false,
																					want:       "\"$\"",
																				},
																			},
																			&oneOrMoreExpr{
																				pos: position{line: 699, col: 18, offset: 21397},
																				expr: &choiceExpr{
																					pos: position{line: 699, col: 19, offset: 21398},
																					alternatives: []interface{}{
																						&seqExpr{
																							pos: position{line: 699, col: 19, offset: 21398},
																							exprs: []interface{}{
																								&charClassMatcher{
																									pos:        position{line: 699, col: 19, offset: 21398},
																									val:        "[\\pNd]",
																									classes:    []*unicode.RangeTable{rangeTable("Nd")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																								&charClassMatcher{
																									pos:        position{line: 699, col: 28, offset: 21407},
																									val:        "[_-\\pL]",
																									chars:      []rune{'_', '-'},
																									classes:    []*unicode.RangeTable{rangeTable("L")},
																									ignoreCase: false,
																									inverted:   false,
																								},
																							},
																						},
																						&charClassMatcher{
																							pos:        position{line: 699, col: 38, offset: 21417},
																							val:        "[_-\\pL]",
																							chars:      []rune{'_', '-'},
																							classes:    []*unicode.RangeTable{rangeTable("L")},
																							ignoreCase: false,
																							inverted:   false,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																&labeledExpr{
																	pos:   position{line: 699, col: 49, offset: 21428},
																	label: "endPosI",
																	expr: &actionExpr{
																		pos: position{line: 3737, col: 8, offset: 128286},
																		run: (*parser).callonMixinCallInterpolation68,
																		expr: &choiceExpr{
																			pos: position{line: 3737, col: 9, offset: 128287},
																			alternatives: []interface{}{
																				&andExpr{
																					pos: position{line: 3737, col: 9, offset: 128287},
																					expr: &anyMatcher{
																						line: 3737, col: 10, offset: 128288,
																					},
																				},
																				&notExpr{
																					pos: position{line: 3737, col: 14, offset: 128292},
																					expr: &anyMatcher{
																						line: 3737, col: 15, offset: 128293,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 713, col: 5, offset: 21887},
										run: (*parser).callonMixinCallInterpolation74,
										expr: &seqExpr{
											pos: position{line: 713, col: 5, offset: 21887},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 713, col: 5, offset: 21887},
													label: "posI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonMixinCallInterpolation77,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
												&andExpr{
													pos: position{line: 713, col: 14, offset: 21896},
													expr: &choiceExpr{
														pos: position{line: 713, col: 16, offset: 21898},
														alternatives: []interface{}{
															&seqExpr{
																pos: position{line: 3734, col: 12, offset: 128237},
																exprs: []interface{}{
																	&zeroOrMoreExpr{
																		pos: position{line: 3734, col: 12, offset: 128237},
																		expr: &charClassMatcher{
																			pos:        position{line: 3746, col: 36, offset: 128584},
																			val:        "[ \\t]",
																			chars:      []rune{' ', '\t'},
																			ignoreCase: false,
																			inverted:   false,
																		},
																	},
																	&choiceExpr{
																		pos: position{line: 3734, col: 16, offset: 128241},
																		alternatives: []interface{}{
																			&seqExpr{
																				pos: position{line: 3734, col: 16, offset: 128241},
																				exprs: []interface{}{
																					&zeroOrOneExpr{
																						pos: position{line: 3734, col: 16, offset: 128241},
																						expr: &litMatcher{
																							pos:        position{line: 3734, col: 16, offset: 128241},
																							val:        "\r",
																							ignoreCase: false,
																							want:       "\"\\r\"",
																						},
																					},
																					&litMatcher{
																						pos:        position{line: 3734, col: 22, offset: 128247},
																						val:        "\n",
																						ignoreCase: false,
																						want:       "\"\\n\"",
																					},
																				},
																			},
																			&notExpr{
																				pos: position{line: 3733, col: 12, offset: 128223},
																				expr: &anyMatcher{
																					line: 3733, col: 13, offset: 128224,
																				},
																			},
																		},
																	},
																},
															},
															&charClassMatcher{
																pos:        position{line: 713, col: 22, offset: 21904},
																val:        "[:!=(]",
																chars:      []rune{':', '!', '=', '('},
																ignoreCase: false,
																inverted:   false,
															},
														},
													},
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 724, col: 5, offset: 22230},
										run: (*parser).callonMixinCallInterpolation96,
										expr: &seqExpr{
											pos: position{line: 724, col: 5, offset: 22230},
											exprs: []interface{}{
												&labeledExpr{
													pos:   position{line: 724, col: 5, offset: 22230},
													label: "identI",
													expr: &oneOrMoreExpr{
														pos: position{line: 724, col: 12, offset: 22237},
														expr: &charClassMatcher{
															pos:        position{line: 724, col: 12, offset: 22237},
															val:        "[^ \\t\\r\\n:!=(]",
															chars:      []rune{' ', '\t', '\r', '\n', ':', '!', '=', '('},
															ignoreCase: false,
															inverted:   true,
														},
													},
												},
												&labeledExpr{
													pos:   position{line: 724, col: 28, offset: 22253},
													label: "endPosI",
													expr: &actionExpr{
														pos: position{line: 3737, col: 8, offset: 128286},
														run: (*parser).callonMixinCallInterpolation102,
														expr: &choiceExpr{
															pos: position{line: 3737, col: 9, offset: 128287},
															alternatives: []interface{}{
																&andExpr{
																	pos: position{line: 3737, col: 9, offset: 128287},
																	expr: &anyMatcher{
																		line: 3737, col: 10, offset: 128288,
																	},
																},
																&notExpr{
																	pos: position{line: 3737, col: 14, offset: 128292},
																	expr: &anyMatcher{
																		line: 3737, col: 15, offset: 128293,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3659, col: 100, offset: 125532},
							label: "argsI",
							expr: &zeroOrOneExpr{
								pos: position{line: 3659, col: 106, offset: 125538},
								expr: &ruleRefExpr{
									pos:  position{line: 3659, col: 106, offset: 125538},
									name: "singleLineMixinArgList",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 3659, col: 130, offset: 125562},
							label: "valueI",
							expr: &ruleRefExpr{
								pos:  position{line: 3659, col: 137, offset: 125569},
								name: "mixinCallInterpolationValue",
							},
						},
					},
				},
			},
		},
		{
			name: "mixinCallInterpolationValue",
			pos:  position{line: 3675, col: 1, offset: 126062},
			expr: &choiceExpr{
				pos: position{line: 3675, col: 32, offset: 126093},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3699, col: 27, offset: 126966},
						run: (*parser).callonmixinCallInterpolationValue2,
						expr: &seqExpr{
							pos: position{line: 3699, col: 27, offset: 126966},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3699, col: 27, offset: 126966},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3762, col: 14, offset: 129078},
										run: (*parser).callonmixinCallInterpolationValue5,
										expr: &litMatcher{
											pos:        position{line: 3762, col: 14, offset: 129078},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3699, col: 50, offset: 126989},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3699, col: 56, offset: 126995},
										expr: &charClassMatcher{
											pos:        position{line: 3699, col: 56, offset: 126995},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3699, col: 67, offset: 127006},
									label: "rBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3763, col: 14, offset: 129118},
										run: (*parser).callonmixinCallInterpolationValue11,
										expr: &litMatcher{
											pos:        position{line: 3763, col: 14, offset: 129118},
											val:        "]",
											ignoreCase: false,
											want:       "\"]\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3705, col: 5, offset: 127217},
						run: (*parser).callonmixinCallInterpolationValue13,
						expr: &seqExpr{
							pos: position{line: 3705, col: 5, offset: 127217},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3705, col: 5, offset: 127217},
									label: "lBracketPosI",
									expr: &actionExpr{
										pos: position{line: 3762, col: 14, offset: 129078},
										run: (*parser).callonmixinCallInterpolationValue16,
										expr: &litMatcher{
											pos:        position{line: 3762, col: 14, offset: 129078},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3705, col: 28, offset: 127240},
									label: "textI",
									expr: &zeroOrMoreExpr{
										pos: position{line: 3705, col: 34, offset: 127246},
										expr: &charClassMatcher{
											pos:        position{line: 3705, col: 34, offset: 127246},
											val:        "[^]\\r\\n]",
											chars:      []rune{']', '\r', '\n'},
											ignoreCase: false,
											inverted:   true,
										},
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 3675, col: 57, offset: 126118},
						name: "expressionInterpolationValue",
					},
					&actionExpr{
						pos: position{line: 3675, col: 88, offset: 126149},
						run: (*parser).callonmixinCallInterpolationValue31,
						expr: &andExpr{
							pos: position{line: 3675, col: 88, offset: 126149},
							expr: &choiceExpr{
								pos: position{line: 3675, col: 90, offset: 126151},
								alternatives: []interface{}{
									&anyMatcher{
										line: 3675, col: 90, offset: 126151,
									},
									&notExpr{
										pos: position{line: 3675, col: 94, offset: 126155},
										expr: &anyMatcher{
											line: 3675, col: 95, offset: 126156,
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "expressionInterpolationValue",
			pos:  position{line: 3716, col: 1, offset: 127474},
			expr: &choiceExpr{
				pos: position{line: 3716, col: 33, offset: 127506},
				alternatives: []interface{}{
					&actionExpr{
						pos: position{line: 3716, col: 33, offset: 127506},
						run: (*parser).callonexpressionInterpolationValue2,
						expr: &seqExpr{
							pos: position{line: 3716, col: 33, offset: 127506},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3716, col: 33, offset: 127506},
									label: "lBracePosI",
									expr: &actionExpr{
										pos: position{line: 3759, col: 12, offset: 128999},
										run: (*parser).callonexpressionInterpolationValue5,
										expr: &litMatcher{
											pos:        position{line: 3759, col: 12, offset: 128999},
											val:        "{",
											ignoreCase: false,
											want:       "\"{\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3716, col: 52, offset: 127525},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 3716, col: 58, offset: 127531},
										name: "SingleLineExpression",
									},
								},
								&labeledExpr{
									pos:   position{line: 3716, col: 79, offset: 127552},
									label: "rBracePosI",
									expr: &actionExpr{
										pos: position{line: 3760, col: 12, offset: 129037},
										run: (*parser).callonexpressionInterpolationValue10,
										expr: &litMatcher{
											pos:        position{line: 3760, col: 12, offset: 129037},
											val:        "}",
											ignoreCase: false,
											want:       "\"}\"",
										},
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 3722, col: 5, offset: 127773},
						run: (*parser).callonexpressionInterpolationValue12,
						expr: &seqExpr{
							pos: position{line: 3722, col: 5, offset: 127773},
							exprs: []interface{}{
								&labeledExpr{
									pos:   position{line: 3722, col: 5, offset: 127773},
									label: "lBracePosI",
									expr: &actionExpr{
										pos: position{line: 3762, col: 14, offset: 129078},
										run: (*parser).callonexpressionInterpolationValue15,
										expr: &litMatcher{
											pos:        position{line: 3762, col: 14, offset: 129078},
											val:        "[",
											ignoreCase: false,
											want:       "\"[\"",
										},
									},
								},
								&labeledExpr{
									pos:   position{line: 3722, col: 26, offset: 127794},
									label: "exprI",
									expr: &ruleRefExpr{
										pos:  position{line: 3722, col: 32, offset: 127800},
										name: "SingleLineExpression",
									},
								},
								&zeroOrMoreExpr{
									pos: position{line: 3734, col: 12, offset: 128237},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
								&choiceExpr{
									pos: position{line: 3734, col: 16, offset: 128241},
									alternatives: []interface{}{
										&seqExpr{
											pos: position{line: 3734, col: 16, offset: 128241},
											exprs: []interface{}{
												&zeroOrOneExpr{
													pos: position{line: 3734, col: 16, offset: 128241},
													expr: &litMatcher{
														pos:        position{line: 3734, col: 16, offset: 128241},
														val:        "\r",
														ignoreCase: false,
														want:       "\"\\r\"",
													},
												},
												&litMatcher{
													pos:        position{line: 3734, col: 22, offset: 128247},
													val:        "\n",
													ignoreCase: false,
													want:       "\"\\n\"",
												},
											},
										},
										&notExpr{
											pos: position{line: 3733, col: 12, offset: 128223},
											expr: &anyMatcher{
												line: 3733, col: 13, offset: 128224,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "INDENTATION_IGNORE_ADDITIONAL",
			pos:  position{line: 4053, col: 1, offset: 141959},
			expr: &choiceExpr{
				pos: position{line: 4053, col: 34, offset: 141992},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 4053, col: 34, offset: 141992},
						exprs: []interface{}{
							&andCodeExpr{
								pos: position{line: 4053, col: 34, offset: 141992},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL3,
							},
							&actionExpr{
								pos: position{line: 3835, col: 17, offset: 132478},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL4,
								expr: &zeroOrMoreExpr{
									pos: position{line: 3835, col: 17, offset: 132478},
									expr: &charClassMatcher{
										pos:        position{line: 3746, col: 36, offset: 128584},
										val:        "[ \\t]",
										chars:      []rune{' ', '\t'},
										ignoreCase: false,
										inverted:   false,
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 3835, col: 41, offset: 132502},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL7,
							},
							&choiceExpr{
								pos: position{line: 3887, col: 5, offset: 134412},
								alternatives: []interface{}{
									&andCodeExpr{
										pos: position{line: 3887, col: 5, offset: 134412},
										run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL9,
									},
									&seqExpr{
										pos: position{line: 3889, col: 9, offset: 134495},
										exprs: []interface{}{
											&andCodeExpr{
												pos: position{line: 3889, col: 9, offset: 134495},
												run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL11,
											},
											&stateCodeExpr{
												pos: position{line: 3891, col: 7, offset: 134599},
												run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL12,
											},
										},
									},
									&seqExpr{
										pos: position{line: 3898, col: 9, offset: 134935},
										exprs: []interface{}{
											&andCodeExpr{
												pos: position{line: 3898, col: 9, offset: 134935},
												run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL14,
											},
											&choiceExpr{
												pos: position{line: 3951, col: 9, offset: 137270},
												alternatives: []interface{}{
													&seqExpr{
														pos: position{line: 3951, col: 9, offset: 137270},
														exprs: []interface{}{
															&andCodeExpr{
																pos: position{line: 3951, col: 9, offset: 137270},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL17,
															},
															&andCodeExpr{
																pos: position{line: 3955, col: 11, offset: 137520},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL18,
															},
															&stateCodeExpr{
																pos: position{line: 4021, col: 11, offset: 140726},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL19,
															},
														},
													},
													&seqExpr{
														pos: position{line: 4029, col: 13, offset: 141079},
														exprs: []interface{}{
															&andCodeExpr{
																pos: position{line: 4029, col: 13, offset: 141079},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL21,
															},
															&andCodeExpr{
																pos: position{line: 4033, col: 11, offset: 141334},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL22,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					&seqExpr{
						pos: position{line: 4057, col: 5, offset: 142143},
						exprs: []interface{}{
							&choiceExpr{
								pos: position{line: 4058, col: 9, offset: 142153},
								alternatives: []interface{}{
									&seqExpr{
										pos: position{line: 4058, col: 9, offset: 142153},
										exprs: []interface{}{
											&andCodeExpr{
												pos: position{line: 4058, col: 9, offset: 142153},
												run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL26,
											},
											&choiceExpr{
												pos: position{line: 4063, col: 13, offset: 142417},
												alternatives: []interface{}{
													&seqExpr{
														pos: position{line: 4063, col: 13, offset: 142417},
														exprs: []interface{}{
															&andExpr{
																pos: position{line: 4063, col: 13, offset: 142417},
																expr: &charClassMatcher{
																	pos:        position{line: 3746, col: 36, offset: 128584},
																	val:        "[ \\t]",
																	chars:      []rune{' ', '\t'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&andCodeExpr{
																pos: position{line: 4063, col: 16, offset: 142420},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL31,
															},
														},
													},
													&seqExpr{
														pos: position{line: 4074, col: 17, offset: 142814},
														exprs: []interface{}{
															&notExpr{
																pos: position{line: 4074, col: 17, offset: 142814},
																expr: &charClassMatcher{
																	pos:        position{line: 3746, col: 36, offset: 128584},
																	val:        "[ \\t]",
																	chars:      []rune{' ', '\t'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
															&andCodeExpr{
																pos: position{line: 4074, col: 20, offset: 142817},
																run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL35,
															},
														},
													},
												},
											},
											&stateCodeExpr{
												pos: position{line: 4139, col: 11, offset: 146048},
												run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL36,
											},
										},
									},
									&seqExpr{
										pos: position{line: 4146, col: 13, offset: 146370},
										exprs: []interface{}{
											&andCodeExpr{
												pos: position{line: 4146, col: 13, offset: 146370},
												run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL38,
											},
											&andCodeExpr{
												pos: position{line: 4150, col: 11, offset: 146625},
												run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL39,
											},
										},
									},
								},
							},
							&stateCodeExpr{
								pos: position{line: 4155, col: 7, offset: 146806},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL40,
							},
						},
					},
					&seqExpr{
						pos: position{line: 4159, col: 5, offset: 146883},
						exprs: []interface{}{
							&labeledExpr{
								pos:   position{line: 4159, col: 5, offset: 146883},
								label: "spaceI",
								expr: &charClassMatcher{
									pos:        position{line: 3746, col: 36, offset: 128584},
									val:        "[ \\t]",
									chars:      []rune{' ', '\t'},
									ignoreCase: false,
									inverted:   false,
								},
							},
							&andCodeExpr{
								pos: position{line: 4159, col: 14, offset: 146892},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL44,
							},
							&stateCodeExpr{
								pos: position{line: 4209, col: 3, offset: 148724},
								run: (*parser).callonINDENTATION_IGNORE_ADDITIONAL45,
							},
							&ruleRefExpr{
								pos:  position{line: 4212, col: 3, offset: 148826},
								name: "INDENTATION_IGNORE_ADDITIONAL",
							},
						},
					},
				},
			},
		},
		{
			name: "INDENTATION2",
			pos:  position{line: 4231, col: 1, offset: 149479},
			expr: &choiceExpr{
				pos: position{line: 4231, col: 17, offset: 149495},
				alternatives: []interface{}{
					&seqExpr{
						pos: position{line: 4231, col: 17, offset: 149495},
						exprs: []interface{}{
							&andCodeExpr{
								pos: position{line: 4231, col: 17, offset: 149495},
								run: (*parser).callonINDENTATION23,
							},
							&litMatcher{
								pos:        position{line: 4233, col: 3, offset: 149556},
								val:        "  ",
								ignoreCase: false,
								want:       "\"  \"",
							},
						},
					},
					&seqExpr{
						pos: position{line: 4233, col: 10, offset: 149563},
						exprs: []interface{}{
							&ruleRefExpr{
								pos:  position{line: 4233, col: 10, offset: 149563},
								name: "INDENTATION_IGNORE_ADDITIONAL",
							},
							&litMatcher{
								pos:        position{line: 4233, col: 40, offset: 149593},
								val:        "  ",
								ignoreCase: false,
								want:       "\"  \"",
							},
						},
					},
				},
			},
		},
	},
}

func (c *current) onFile3() error {
	c.state["Indentation.Level"] = 0       // the lvl we are in rn
	c.state["Indentation.Char"] = byte(0)  // the char used for indentation
	c.state["Indentation.Repetitions"] = 0 // num of repetitions of char per lvl
	c.state["Indentation.RefLine"] = 0     // the line no where we got char and repetitions from

	// a stack containing the actual number of repetitions of char per lvl
	// used to recover from inconsistent indentations errs
	c.state["Indentation.ActualRepetitions"] = stack.Stack[int]{}
	c.state["Indentation.TotalRepetitions"] = 0 // sum of the stack above

	// used by INDENTATION_NO_INCREASE to count how many chars it has found
	c.state["Indentation.CharCount"] = 0
	return nil
}

func (p *parser) callonFile3() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile3()
}

func (c *current) onFile34(strI interface{}) (interface{}, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonFile34() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile34(stack["strI"])
}

func (c *current) onFile41(strI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonFile41() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile41(stack["strI"])
}

func (c *current) onFile73() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonFile73() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile73()
}

func (c *current) onFile86() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonFile86() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile86()
}

func (c *current) onFile107() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonFile107() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile107()
}

func (c *current) onFile130() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonFile130() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile130()
}

func (c *current) onFile141() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonFile141() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile141()
}

func (c *current) onFile148() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonFile148() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile148()
}

func (c *current) onFile153() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonFile153() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile153()
}

func (c *current) onFile58(strI interface{}) (interface{}, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonFile58() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile58(stack["strI"])
}

func (c *current) onFile174() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonFile174() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile174()
}

func (c *current) onFile187() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonFile187() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile187()
}

func (c *current) onFile208() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonFile208() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile208()
}

func (c *current) onFile231() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonFile231() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile231()
}

func (c *current) onFile242() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonFile242() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile242()
}

func (c *current) onFile249() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonFile249() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile249()
}

func (c *current) onFile254() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonFile254() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile254()
}

func (c *current) onFile260() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonFile260() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile260()
}

func (c *current) onFile159(strI, endPosI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonFile159() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile159(stack["strI"], stack["endPosI"])
}

func (c *current) onFile285() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonFile285() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile285()
}

func (c *current) onFile277(strI, endPosI interface{}) (interface{}, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonFile277() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile277(stack["strI"], stack["endPosI"])
}

func (c *current) onFile291(pathI interface{}) (interface{}, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonFile291() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile291(stack["pathI"])
}

func (c *current) onFile25(extendI interface{}) (interface{}, error) {
	return file.Extend{Path: extendI.(file.String), Position: pos(c)}, nil
}

func (p *parser) callonFile25() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile25(stack["extendI"])
}

func (c *current) onFile378() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonFile378() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile378()
}

func (c *current) onFile374(startPosI interface{}) (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			ToEOL:      true,
			Annotation: "doctypes other than the HTML5 doctype are not supported",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonFile374() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile374(stack["startPosI"])
}

func (c *current) onFile395() (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected `html`",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonFile395() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile395()
}

func (c *current) onFile359() (interface{}, error) {
	return file.Doctype{Position: pos(c)}, nil
}

func (p *parser) callonFile359() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile359()
}

func (c *current) onFile429() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonFile429() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile429()
}

func (c *current) onFile425(startPosI interface{}) (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			ToEOL:      true,
			Annotation: "doctypes other than the HTML5 doctype are not supported",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonFile425() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile425(stack["startPosI"])
}

func (c *current) onFile446() (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected `html`",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonFile446() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile446()
}

func (c *current) onFile410() (interface{}, error) {
	return file.Doctype{Position: pos(c)}, &corgierr.Error{
		Message: "the corgi doctype directive does not start with a `!`",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "remove this",
		}),
		ShouldBe: "`doctype html`",
	}
}

func (p *parser) callonFile410() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile410()
}

func (c *current) onFile1(extendComments, extendI, importsAndCommentsI, usesAndCommentsI, globalCodeAndFuncI, doctypeCommentsI, doctypeI, scopeI interface{}) (interface{}, error) {
	var f file.File

	f.TopLevelComments = append(f.TopLevelComments, castedOrZero[[]file.CorgiComment](extendComments)...)

	f.Extend = ptrOrNil[file.Extend](extendI)

	if importsAndCommentsI != nil {
		f.Imports = getTuple[[]file.Import](importsAndCommentsI, 0)
		f.TopLevelComments = append(f.TopLevelComments, getTuple[[]file.CorgiComment](importsAndCommentsI, 1)...)
	}

	if usesAndCommentsI != nil {
		f.Uses = getTuple[[]file.Use](usesAndCommentsI, 0)
		f.TopLevelComments = append(f.TopLevelComments, getTuple[[]file.CorgiComment](usesAndCommentsI, 1)...)
	}

	if globalCodeAndFuncI != nil {
		partFile := globalCodeAndFuncI.(file.File)

		f.TopLevelComments = append(f.TopLevelComments, partFile.TopLevelComments...)
		f.GlobalCode = partFile.GlobalCode
		f.Func = partFile.Func
	}

	f.Scope = castedOrZero[file.Scope](scopeI)

	if doctypeI != nil {
		f.Scope = append(file.Scope{doctypeI.(file.Doctype)}, f.Scope...)
	}

	if doctypeCommentsI != nil {
		comments := doctypeCommentsI.([]file.CorgiComment)

		commentScope := make(file.Scope, len(comments))
		for i, comment := range comments {
			commentScope[i] = comment
		}

		f.Scope = append(commentScope, f.Scope...)
	}

	return &f, nil
}

func (p *parser) callonFile1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFile1(stack["extendComments"], stack["extendI"], stack["importsAndCommentsI"], stack["usesAndCommentsI"], stack["globalCodeAndFuncI"], stack["doctypeCommentsI"], stack["doctypeI"], stack["scopeI"])
}

func (c *current) onimportsAndComments34() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonimportsAndComments34() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments34()
}

func (c *current) onimportsAndComments46() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonimportsAndComments46() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments46()
}

func (c *current) onimportsAndComments49() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonimportsAndComments49() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments49()
}

func (c *current) onimportsAndComments51() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonimportsAndComments51() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments51()
}

func (c *current) onimportsAndComments53() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0, nil

}

func (p *parser) callonimportsAndComments53() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments53()
}

func (c *current) onimportsAndComments54() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonimportsAndComments54() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments54()
}

func (c *current) onimportsAndComments56() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonimportsAndComments56() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments56()
}

func (c *current) onimportsAndComments59() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonimportsAndComments59() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments59()
}

func (c *current) onimportsAndComments60() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonimportsAndComments60() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments60()
}

func (c *current) onimportsAndComments61() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonimportsAndComments61() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments61()
}

func (c *current) onimportsAndComments63() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonimportsAndComments63() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments63()
}

func (c *current) onimportsAndComments64() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase or decrease of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonimportsAndComments64() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments64()
}

func (c *current) onimportsAndComments71() (interface{}, error) {
	return file.GoIdent{Ident: ".", Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments71() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments71()
}

func (c *current) onimportsAndComments73(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments73() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments73(stack["ident"])
}

func (c *current) onimportsAndComments92() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments92() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments92()
}

func (c *current) onimportsAndComments79(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonimportsAndComments79() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments79(stack["identI"], stack["endPosI"])
}

func (c *current) onimportsAndComments103() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments103() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments103()
}

func (c *current) onimportsAndComments98(endPosI interface{}) (interface{}, error) {
	return file.GoIdent{
			Ident:    string(c.text),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid import alias",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
		}
}

func (p *parser) callonimportsAndComments98() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments98(stack["endPosI"])
}

func (c *current) onimportsAndComments113(strI interface{}) (interface{}, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments113() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments113(stack["strI"])
}

func (c *current) onimportsAndComments120(strI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonimportsAndComments120() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments120(stack["strI"])
}

func (c *current) onimportsAndComments152() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonimportsAndComments152() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments152()
}

func (c *current) onimportsAndComments165() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments165() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments165()
}

func (c *current) onimportsAndComments186() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments186() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments186()
}

func (c *current) onimportsAndComments209() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments209() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments209()
}

func (c *current) onimportsAndComments220() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments220() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments220()
}

func (c *current) onimportsAndComments227() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments227() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments227()
}

func (c *current) onimportsAndComments232() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments232() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments232()
}

func (c *current) onimportsAndComments137(strI interface{}) (interface{}, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments137() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments137(stack["strI"])
}

func (c *current) onimportsAndComments253() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonimportsAndComments253() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments253()
}

func (c *current) onimportsAndComments266() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments266() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments266()
}

func (c *current) onimportsAndComments287() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments287() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments287()
}

func (c *current) onimportsAndComments310() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments310() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments310()
}

func (c *current) onimportsAndComments321() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments321() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments321()
}

func (c *current) onimportsAndComments328() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments328() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments328()
}

func (c *current) onimportsAndComments333() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments333() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments333()
}

func (c *current) onimportsAndComments339() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments339() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments339()
}

func (c *current) onimportsAndComments238(strI, endPosI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonimportsAndComments238() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments238(stack["strI"], stack["endPosI"])
}

func (c *current) onimportsAndComments364() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments364() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments364()
}

func (c *current) onimportsAndComments356(strI, endPosI interface{}) (interface{}, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonimportsAndComments356() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments356(stack["strI"], stack["endPosI"])
}

func (c *current) onimportsAndComments370(pathI interface{}) (interface{}, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonimportsAndComments370() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments370(stack["pathI"])
}

func (c *current) onimportsAndComments65(aliasI, pathI interface{}) (interface{}, error) {
	var spec file.ImportSpec
	spec.Position = pos(c)

	if aliasI != nil {
		alias := getTuple[file.GoIdent](aliasI, 0)
		spec.Alias = &alias
	}

	spec.Path = pathI.(file.String)
	return spec, nil
}

func (p *parser) callonimportsAndComments65() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments65(stack["aliasI"], stack["pathI"])
}

func (c *current) onimportsAndComments383(importsI interface{}) error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonimportsAndComments383() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments383(stack["importsI"])
}

func (c *current) onimportsAndComments32(importsI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.ImportSpec](importsI, -1), nil
}

func (p *parser) callonimportsAndComments32() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments32(stack["importsI"])
}

func (c *current) onimportsAndComments28(specsI interface{}) (interface{}, error) {
	return file.Import{
		Imports:  specsI.([]file.ImportSpec),
		Position: pos(c),
	}, nil
}

func (p *parser) callonimportsAndComments28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments28(stack["specsI"])
}

func (c *current) onimportsAndComments396() (interface{}, error) {
	return file.GoIdent{Ident: ".", Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments396() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments396()
}

func (c *current) onimportsAndComments398(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments398() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments398(stack["ident"])
}

func (c *current) onimportsAndComments417() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments417() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments417()
}

func (c *current) onimportsAndComments404(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonimportsAndComments404() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments404(stack["identI"], stack["endPosI"])
}

func (c *current) onimportsAndComments428() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments428() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments428()
}

func (c *current) onimportsAndComments423(endPosI interface{}) (interface{}, error) {
	return file.GoIdent{
			Ident:    string(c.text),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid import alias",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
		}
}

func (p *parser) callonimportsAndComments423() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments423(stack["endPosI"])
}

func (c *current) onimportsAndComments438(strI interface{}) (interface{}, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments438() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments438(stack["strI"])
}

func (c *current) onimportsAndComments445(strI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonimportsAndComments445() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments445(stack["strI"])
}

func (c *current) onimportsAndComments477() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonimportsAndComments477() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments477()
}

func (c *current) onimportsAndComments490() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments490() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments490()
}

func (c *current) onimportsAndComments511() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments511() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments511()
}

func (c *current) onimportsAndComments534() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments534() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments534()
}

func (c *current) onimportsAndComments545() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments545() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments545()
}

func (c *current) onimportsAndComments552() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments552() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments552()
}

func (c *current) onimportsAndComments557() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments557() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments557()
}

func (c *current) onimportsAndComments462(strI interface{}) (interface{}, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonimportsAndComments462() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments462(stack["strI"])
}

func (c *current) onimportsAndComments578() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonimportsAndComments578() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments578()
}

func (c *current) onimportsAndComments591() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments591() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments591()
}

func (c *current) onimportsAndComments612() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonimportsAndComments612() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments612()
}

func (c *current) onimportsAndComments635() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments635() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments635()
}

func (c *current) onimportsAndComments646() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments646() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments646()
}

func (c *current) onimportsAndComments653() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments653() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments653()
}

func (c *current) onimportsAndComments658() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonimportsAndComments658() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments658()
}

func (c *current) onimportsAndComments664() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments664() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments664()
}

func (c *current) onimportsAndComments563(strI, endPosI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonimportsAndComments563() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments563(stack["strI"], stack["endPosI"])
}

func (c *current) onimportsAndComments689() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments689() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments689()
}

func (c *current) onimportsAndComments681(strI, endPosI interface{}) (interface{}, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonimportsAndComments681() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments681(stack["strI"], stack["endPosI"])
}

func (c *current) onimportsAndComments695(pathI interface{}) (interface{}, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonimportsAndComments695() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments695(stack["pathI"])
}

func (c *current) onimportsAndComments390(aliasI, pathI interface{}) (interface{}, error) {
	var spec file.ImportSpec
	spec.Position = pos(c)

	if aliasI != nil {
		alias := getTuple[file.GoIdent](aliasI, 0)
		spec.Alias = &alias
	}

	spec.Path = pathI.(file.String)
	return spec, nil
}

func (p *parser) callonimportsAndComments390() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments390(stack["aliasI"], stack["pathI"])
}

func (c *current) onimportsAndComments384(specI interface{}) (interface{}, error) {
	return file.Import{
		Imports:  []file.ImportSpec{specI.(file.ImportSpec)},
		Position: pos(c),
	}, nil
}

func (p *parser) callonimportsAndComments384() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments384(stack["specI"])
}

func (c *current) onimportsAndComments712() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonimportsAndComments712() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments712()
}

func (c *current) onimportsAndComments708(posI interface{}) (interface{}, error) {
	return file.Import{Position: pos(c)}, &corgierr.Error{
		Message: "missing import path",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			Annotation:  "expected an import path, optionally preceded by an import alias",
		}),
	}
}

func (p *parser) callonimportsAndComments708() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments708(stack["posI"])
}

func (c *current) onimportsAndComments15(importsI interface{}) (interface{}, error) {
	impTuples := islice(importsI)
	if impTuples == nil {
		return []file.Import(nil), nil
	}

	var imps []file.Import
	for _, impTuple := range impTuples {
		imps = append(imps, getTuple[file.Import](impTuple, 1))
	}

	return imps, nil
}

func (p *parser) callonimportsAndComments15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments15(stack["importsI"])
}

func (c *current) onimportsAndComments1(valsI interface{}) (interface{}, error) {
	tuples := islice(valsI)

	var comments []file.CorgiComment
	var imports []file.Import

	for _, t := range tuples {
		comments = append(comments, castedOrZero[[]file.CorgiComment](islice(t)[0])...)
		imports = append(imports, getTuple[[]file.Import](t, -1)...)
	}

	return []any{imports, comments}, nil
}

func (p *parser) callonimportsAndComments1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onimportsAndComments1(stack["valsI"])
}

func (c *current) onusesAndComments34() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonusesAndComments34() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments34()
}

func (c *current) onusesAndComments46() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonusesAndComments46() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments46()
}

func (c *current) onusesAndComments49() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonusesAndComments49() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments49()
}

func (c *current) onusesAndComments51() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonusesAndComments51() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments51()
}

func (c *current) onusesAndComments53() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0, nil

}

func (p *parser) callonusesAndComments53() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments53()
}

func (c *current) onusesAndComments54() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonusesAndComments54() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments54()
}

func (c *current) onusesAndComments56() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonusesAndComments56() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments56()
}

func (c *current) onusesAndComments59() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonusesAndComments59() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments59()
}

func (c *current) onusesAndComments60() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonusesAndComments60() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments60()
}

func (c *current) onusesAndComments61() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonusesAndComments61() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments61()
}

func (c *current) onusesAndComments63() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonusesAndComments63() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments63()
}

func (c *current) onusesAndComments64() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase or decrease of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonusesAndComments64() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments64()
}

func (c *current) onusesAndComments71() (interface{}, error) {
	return file.Ident{Ident: ".", Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments71() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments71()
}

func (c *current) onusesAndComments73(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments73() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments73(stack["identI"])
}

func (c *current) onusesAndComments92() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments92() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments92()
}

func (c *current) onusesAndComments79(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonusesAndComments79() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments79(stack["identI"], stack["endPosI"])
}

func (c *current) onusesAndComments103() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments103() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments103()
}

func (c *current) onusesAndComments98(endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    string(c.text),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid import alias",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
		}
}

func (p *parser) callonusesAndComments98() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments98(stack["endPosI"])
}

func (c *current) onusesAndComments113(strI interface{}) (interface{}, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments113() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments113(stack["strI"])
}

func (c *current) onusesAndComments120(strI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonusesAndComments120() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments120(stack["strI"])
}

func (c *current) onusesAndComments152() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonusesAndComments152() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments152()
}

func (c *current) onusesAndComments165() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments165() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments165()
}

func (c *current) onusesAndComments186() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments186() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments186()
}

func (c *current) onusesAndComments209() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments209() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments209()
}

func (c *current) onusesAndComments220() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments220() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments220()
}

func (c *current) onusesAndComments227() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments227() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments227()
}

func (c *current) onusesAndComments232() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonusesAndComments232() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments232()
}

func (c *current) onusesAndComments137(strI interface{}) (interface{}, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments137() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments137(stack["strI"])
}

func (c *current) onusesAndComments253() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonusesAndComments253() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments253()
}

func (c *current) onusesAndComments266() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments266() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments266()
}

func (c *current) onusesAndComments287() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments287() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments287()
}

func (c *current) onusesAndComments310() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments310() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments310()
}

func (c *current) onusesAndComments321() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments321() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments321()
}

func (c *current) onusesAndComments328() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments328() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments328()
}

func (c *current) onusesAndComments333() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonusesAndComments333() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments333()
}

func (c *current) onusesAndComments339() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments339() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments339()
}

func (c *current) onusesAndComments238(strI, endPosI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonusesAndComments238() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments238(stack["strI"], stack["endPosI"])
}

func (c *current) onusesAndComments364() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments364() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments364()
}

func (c *current) onusesAndComments356(strI, endPosI interface{}) (interface{}, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonusesAndComments356() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments356(stack["strI"], stack["endPosI"])
}

func (c *current) onusesAndComments370(pathI interface{}) (interface{}, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonusesAndComments370() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments370(stack["pathI"])
}

func (c *current) onusesAndComments65(aliasI, pathI interface{}) (interface{}, error) {
	var spec file.UseSpec
	spec.Position = pos(c)

	if aliasI != nil {
		alias := getTuple[file.Ident](aliasI, 0)
		spec.Alias = &alias
	}

	spec.Path = pathI.(file.String)
	return spec, nil
}

func (p *parser) callonusesAndComments65() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments65(stack["aliasI"], stack["pathI"])
}

func (c *current) onusesAndComments383(usesI interface{}) error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonusesAndComments383() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments383(stack["usesI"])
}

func (c *current) onusesAndComments32(usesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.UseSpec](usesI, -1), nil
}

func (p *parser) callonusesAndComments32() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments32(stack["usesI"])
}

func (c *current) onusesAndComments28(specsI interface{}) (interface{}, error) {
	return file.Use{
		Uses:     specsI.([]file.UseSpec),
		Position: pos(c),
	}, nil
}

func (p *parser) callonusesAndComments28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments28(stack["specsI"])
}

func (c *current) onusesAndComments396() (interface{}, error) {
	return file.Ident{Ident: ".", Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments396() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments396()
}

func (c *current) onusesAndComments398(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments398() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments398(stack["identI"])
}

func (c *current) onusesAndComments417() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments417() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments417()
}

func (c *current) onusesAndComments404(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonusesAndComments404() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments404(stack["identI"], stack["endPosI"])
}

func (c *current) onusesAndComments428() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments428() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments428()
}

func (c *current) onusesAndComments423(endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    string(c.text),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid import alias",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
		}
}

func (p *parser) callonusesAndComments423() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments423(stack["endPosI"])
}

func (c *current) onusesAndComments438(strI interface{}) (interface{}, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments438() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments438(stack["strI"])
}

func (c *current) onusesAndComments445(strI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonusesAndComments445() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments445(stack["strI"])
}

func (c *current) onusesAndComments477() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonusesAndComments477() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments477()
}

func (c *current) onusesAndComments490() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments490() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments490()
}

func (c *current) onusesAndComments511() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments511() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments511()
}

func (c *current) onusesAndComments534() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments534() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments534()
}

func (c *current) onusesAndComments545() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments545() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments545()
}

func (c *current) onusesAndComments552() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments552() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments552()
}

func (c *current) onusesAndComments557() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonusesAndComments557() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments557()
}

func (c *current) onusesAndComments462(strI interface{}) (interface{}, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonusesAndComments462() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments462(stack["strI"])
}

func (c *current) onusesAndComments578() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonusesAndComments578() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments578()
}

func (c *current) onusesAndComments591() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments591() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments591()
}

func (c *current) onusesAndComments612() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonusesAndComments612() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments612()
}

func (c *current) onusesAndComments635() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments635() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments635()
}

func (c *current) onusesAndComments646() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments646() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments646()
}

func (c *current) onusesAndComments653() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonusesAndComments653() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments653()
}

func (c *current) onusesAndComments658() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonusesAndComments658() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments658()
}

func (c *current) onusesAndComments664() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments664() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments664()
}

func (c *current) onusesAndComments563(strI, endPosI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonusesAndComments563() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments563(stack["strI"], stack["endPosI"])
}

func (c *current) onusesAndComments689() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments689() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments689()
}

func (c *current) onusesAndComments681(strI, endPosI interface{}) (interface{}, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonusesAndComments681() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments681(stack["strI"], stack["endPosI"])
}

func (c *current) onusesAndComments695(pathI interface{}) (interface{}, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonusesAndComments695() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments695(stack["pathI"])
}

func (c *current) onusesAndComments390(aliasI, pathI interface{}) (interface{}, error) {
	var spec file.UseSpec
	spec.Position = pos(c)

	if aliasI != nil {
		alias := getTuple[file.Ident](aliasI, 0)
		spec.Alias = &alias
	}

	spec.Path = pathI.(file.String)
	return spec, nil
}

func (p *parser) callonusesAndComments390() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments390(stack["aliasI"], stack["pathI"])
}

func (c *current) onusesAndComments384(specI interface{}) (interface{}, error) {
	return file.Use{
		Uses:     []file.UseSpec{specI.(file.UseSpec)},
		Position: pos(c),
	}, nil
}

func (p *parser) callonusesAndComments384() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments384(stack["specI"])
}

func (c *current) onusesAndComments712() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonusesAndComments712() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments712()
}

func (c *current) onusesAndComments708(posI interface{}) (interface{}, error) {
	return file.Use{Position: pos(c)}, &corgierr.Error{
		Message: "missing use path",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			Annotation:  "expected an use path, optionally preceded by an use alias",
		}),
	}
}

func (p *parser) callonusesAndComments708() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments708(stack["posI"])
}

func (c *current) onusesAndComments15(usesI interface{}) (interface{}, error) {
	useTuples := islice(usesI)
	if useTuples == nil {
		return []file.Use(nil), nil
	}

	var uses []file.Use
	for _, useTuple := range useTuples {
		uses = append(uses, getTuple[file.Use](useTuple, 1))
	}

	return uses, nil
}

func (p *parser) callonusesAndComments15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments15(stack["usesI"])
}

func (c *current) onusesAndComments1(valsI interface{}) (interface{}, error) {
	tuples := islice(valsI)

	var comments []file.CorgiComment
	var uses []file.Use

	for _, t := range tuples {
		comments = append(comments, castedOrZero[[]file.CorgiComment](islice(t)[0])...)
		uses = append(uses, getTuple[[]file.Use](t, -1)...)
	}

	return []any{uses, comments}, nil
}

func (p *parser) callonusesAndComments1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onusesAndComments1(stack["valsI"])
}

func (c *current) oncodesAndComments1(valsI interface{}) (interface{}, error) {
	tuples := islice(valsI)

	var comments []file.CorgiComment
	var codes []file.Code

	for _, t := range tuples {
		comments = append(comments, castedOrZero[[]file.CorgiComment](islice(t)[0])...)
		codes = append(codes, getTuple[[]file.Code](t, -1)...)
	}

	return []any{codes, comments}, nil
}

func (p *parser) calloncodesAndComments1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncodesAndComments1(stack["valsI"])
}

func (c *current) onglobalCodeAndFunc1(codesAndCommentsI, commentsI, funcI interface{}) (interface{}, error) {
	var f file.File

	if codesAndCommentsI != nil {
		f.GlobalCode = getTuple[[]file.Code](codesAndCommentsI, 0)
		f.TopLevelComments = append(f.TopLevelComments, getTuple[[]file.CorgiComment](codesAndCommentsI, 1)...)
	}

	if commentsI != nil {
		f.TopLevelComments = append(f.TopLevelComments, commentsI.([]file.CorgiComment)...)
	}

	fun := funcI.(file.Func)
	f.Func = &fun

	return f, nil
}

func (p *parser) callonglobalCodeAndFunc1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onglobalCodeAndFunc1(stack["codesAndCommentsI"], stack["commentsI"], stack["funcI"])
}

func (c *current) onScope13() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonScope13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope13()
}

func (c *current) onScope16() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonScope16() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope16()
}

func (c *current) onScope18() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonScope18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope18()
}

func (c *current) onScope20() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0, nil

}

func (p *parser) callonScope20() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope20()
}

func (c *current) onScope21() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonScope21() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope21()
}

func (c *current) onScope23() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonScope23() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope23()
}

func (c *current) onScope26() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonScope26() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope26()
}

func (c *current) onScope27() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonScope27() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope27()
}

func (c *current) onScope28() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonScope28() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope28()
}

func (c *current) onScope30() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonScope30() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope30()
}

func (c *current) onScope31() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase or decrease of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonScope31() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope31()
}

func (c *current) onScope1(itemsI interface{}) (interface{}, error) {
	itemTuples := islice(itemsI)

	scope := make(file.Scope, 0, len(itemTuples))
	for _, it := range itemTuples {
		if si, ok := islice(it)[2].(file.ScopeItem); ok {
			scope = append(scope, si)
		}
	}

	return scope, nil
}

func (p *parser) callonScope1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onScope1(stack["itemsI"])
}

func (c *current) onscopeItem27() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonscopeItem27() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem27()
}

func (c *current) onscopeItem41() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonscopeItem41() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem41()
}

func (c *current) onscopeItem44() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonscopeItem44() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem44()
}

func (c *current) onscopeItem46() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonscopeItem46() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem46()
}

func (c *current) onscopeItem48() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0, nil

}

func (p *parser) callonscopeItem48() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem48()
}

func (c *current) onscopeItem49() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonscopeItem49() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem49()
}

func (c *current) onscopeItem51() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonscopeItem51() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem51()
}

func (c *current) onscopeItem54() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonscopeItem54() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem54()
}

func (c *current) onscopeItem55() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonscopeItem55() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem55()
}

func (c *current) onscopeItem56() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonscopeItem56() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem56()
}

func (c *current) onscopeItem58() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonscopeItem58() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem58()
}

func (c *current) onscopeItem59() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase or decrease of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonscopeItem59() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem59()
}

func (c *current) onscopeItem61() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem61() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem61()
}

func (c *current) onscopeItem39(posI, lineI interface{}) (interface{}, error) {
	return file.FilterLine{
		Line:     concat(lineI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonscopeItem39() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem39(stack["posI"], stack["lineI"])
}

func (c *current) onscopeItem79(linesI interface{}) error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonscopeItem79() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem79(stack["linesI"])
}

func (c *current) onscopeItem25(linesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.FilterLine](linesI, -1), nil
}

func (p *parser) callonscopeItem25() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem25(stack["linesI"])
}

func (c *current) onscopeItem11(bodyI interface{}) (interface{}, error) {
	return file.RawFilter{
		Body:     castedOrZero[[]file.FilterLine](bodyI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonscopeItem11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem11(stack["bodyI"])
}

func (c *current) onscopeItem95(strI interface{}) (interface{}, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonscopeItem95() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem95(stack["strI"])
}

func (c *current) onscopeItem102(strI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonscopeItem102() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem102(stack["strI"])
}

func (c *current) onscopeItem134() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonscopeItem134() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem134()
}

func (c *current) onscopeItem147() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem147() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem147()
}

func (c *current) onscopeItem168() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem168() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem168()
}

func (c *current) onscopeItem191() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem191() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem191()
}

func (c *current) onscopeItem202() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem202() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem202()
}

func (c *current) onscopeItem209() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem209() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem209()
}

func (c *current) onscopeItem214() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonscopeItem214() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem214()
}

func (c *current) onscopeItem119(strI interface{}) (interface{}, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonscopeItem119() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem119(stack["strI"])
}

func (c *current) onscopeItem235() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonscopeItem235() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem235()
}

func (c *current) onscopeItem248() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem248() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem248()
}

func (c *current) onscopeItem269() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem269() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem269()
}

func (c *current) onscopeItem292() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem292() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem292()
}

func (c *current) onscopeItem303() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem303() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem303()
}

func (c *current) onscopeItem310() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem310() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem310()
}

func (c *current) onscopeItem315() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonscopeItem315() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem315()
}

func (c *current) onscopeItem321() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem321() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem321()
}

func (c *current) onscopeItem220(strI, endPosI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonscopeItem220() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem220(stack["strI"], stack["endPosI"])
}

func (c *current) onscopeItem346() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem346() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem346()
}

func (c *current) onscopeItem338(strI, endPosI interface{}) (interface{}, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonscopeItem338() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem338(stack["strI"], stack["endPosI"])
}

func (c *current) onscopeItem92(stringI interface{}) (interface{}, error) {
	return file.StringCommandFilterArg(stringI.(file.String)), nil
}

func (p *parser) callonscopeItem92() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem92(stack["stringI"])
}

func (c *current) onscopeItem352(argI interface{}) (interface{}, error) {
	return file.RawCommandFilterArg{Value: concat(argI), Position: pos(c)}, nil
}

func (p *parser) callonscopeItem352() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem352(stack["argI"])
}

func (c *current) onscopeItem369() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonscopeItem369() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem369()
}

func (c *current) onscopeItem383() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonscopeItem383() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem383()
}

func (c *current) onscopeItem386() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonscopeItem386() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem386()
}

func (c *current) onscopeItem388() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonscopeItem388() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem388()
}

func (c *current) onscopeItem390() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0, nil

}

func (p *parser) callonscopeItem390() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem390()
}

func (c *current) onscopeItem391() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonscopeItem391() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem391()
}

func (c *current) onscopeItem393() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonscopeItem393() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem393()
}

func (c *current) onscopeItem396() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonscopeItem396() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem396()
}

func (c *current) onscopeItem397() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonscopeItem397() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem397()
}

func (c *current) onscopeItem398() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonscopeItem398() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem398()
}

func (c *current) onscopeItem400() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonscopeItem400() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem400()
}

func (c *current) onscopeItem401() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase or decrease of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonscopeItem401() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem401()
}

func (c *current) onscopeItem403() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem403() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem403()
}

func (c *current) onscopeItem381(posI, lineI interface{}) (interface{}, error) {
	return file.FilterLine{
		Line:     concat(lineI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonscopeItem381() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem381(stack["posI"], stack["lineI"])
}

func (c *current) onscopeItem421(linesI interface{}) error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonscopeItem421() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem421(stack["linesI"])
}

func (c *current) onscopeItem367(linesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.FilterLine](linesI, -1), nil
}

func (p *parser) callonscopeItem367() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem367(stack["linesI"])
}

func (c *current) onscopeItem80(nameI, argsI, bodyI interface{}) (interface{}, error) {
	return file.CommandFilter{
		Name:     concat(nameI),
		Args:     typedSliceFromTuples[file.CommandFilterArg](argsI, -1),
		Body:     castedOrZero[[]file.FilterLine](bodyI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonscopeItem80() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem80(stack["nameI"], stack["argsI"], stack["bodyI"])
}

func (c *current) onscopeItem438() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonscopeItem438() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem438()
}

func (c *current) onscopeItem452() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonscopeItem452() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem452()
}

func (c *current) onscopeItem455() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonscopeItem455() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem455()
}

func (c *current) onscopeItem457() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonscopeItem457() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem457()
}

func (c *current) onscopeItem459() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0, nil

}

func (p *parser) callonscopeItem459() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem459()
}

func (c *current) onscopeItem460() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonscopeItem460() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem460()
}

func (c *current) onscopeItem462() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonscopeItem462() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem462()
}

func (c *current) onscopeItem465() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonscopeItem465() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem465()
}

func (c *current) onscopeItem466() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonscopeItem466() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem466()
}

func (c *current) onscopeItem467() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonscopeItem467() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem467()
}

func (c *current) onscopeItem469() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonscopeItem469() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem469()
}

func (c *current) onscopeItem470() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase or decrease of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonscopeItem470() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem470()
}

func (c *current) onscopeItem472() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem472() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem472()
}

func (c *current) onscopeItem450(posI, lineI interface{}) (interface{}, error) {
	return file.FilterLine{
		Line:     concat(lineI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonscopeItem450() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem450(stack["posI"], stack["lineI"])
}

func (c *current) onscopeItem490(linesI interface{}) error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonscopeItem490() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem490(stack["linesI"])
}

func (c *current) onscopeItem436(linesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.FilterLine](linesI, -1), nil
}

func (p *parser) callonscopeItem436() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem436(stack["linesI"])
}

func (c *current) onscopeItem422(bodyI interface{}) (interface{}, error) {
	return file.CommandFilter{
			Position: pos(c),
			Body:     castedOrZero[[]file.FilterLine](bodyI),
		}, &corgierr.Error{
			Message: "bad filter",
			ErrorAnnotation: anno(c, annotation{
				Start:       pos(c),
				StartOffset: 1,
				Annotation:  "expected `raw` or a command name",
			}),
		}
}

func (p *parser) callonscopeItem422() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem422(stack["bodyI"])
}

func (c *current) onscopeItem500(strI interface{}) (interface{}, error) {
	return file.String{Quote: '`', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonscopeItem500() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem500(stack["strI"])
}

func (c *current) onscopeItem507(strI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '`',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a ``` somewhere here",
			}),
		}
}

func (p *parser) callonscopeItem507() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem507(stack["strI"])
}

func (c *current) onscopeItem539() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonscopeItem539() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem539()
}

func (c *current) onscopeItem552() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem552() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem552()
}

func (c *current) onscopeItem573() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem573() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem573()
}

func (c *current) onscopeItem596() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem596() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem596()
}

func (c *current) onscopeItem607() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem607() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem607()
}

func (c *current) onscopeItem614() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem614() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem614()
}

func (c *current) onscopeItem619() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonscopeItem619() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem619()
}

func (c *current) onscopeItem524(strI interface{}) (interface{}, error) {
	return file.String{Quote: '"', Contents: concat(strI), Position: pos(c)}, nil
}

func (p *parser) callonscopeItem524() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem524(stack["strI"])
}

func (c *current) onscopeItem640() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonscopeItem640() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem640()
}

func (c *current) onscopeItem653() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem653() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem653()
}

func (c *current) onscopeItem674() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonscopeItem674() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem674()
}

func (c *current) onscopeItem697() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem697() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem697()
}

func (c *current) onscopeItem708() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem708() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem708()
}

func (c *current) onscopeItem715() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonscopeItem715() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem715()
}

func (c *current) onscopeItem720() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonscopeItem720() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem720()
}

func (c *current) onscopeItem726() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem726() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem726()
}

func (c *current) onscopeItem625(strI, endPosI interface{}) (interface{}, error) {
	return file.String{
			Quote:    '"',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				EOLDelta:   1,
				Annotation: "expected a `\"` somewhere here",
			}),
		}
}

func (p *parser) callonscopeItem625() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem625(stack["strI"], stack["endPosI"])
}

func (c *current) onscopeItem751() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem751() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem751()
}

func (c *current) onscopeItem743(strI, endPosI interface{}) (interface{}, error) {
	raw := concat(strI)

	suggestion := corgierr.Suggestion{
		Suggestion: "enclose this string in double quotes or backticks, instead of single quotes",
		Code:       "`" + strconv.Quote(raw) + "` or ``" + raw + "``",
	}
	if strings.Contains(raw, "`") {
		suggestion = corgierr.Suggestion{
			Suggestion: "enclose this string in double quotes, instead of single quotes",
			Code:       "`" + strconv.Quote(raw) + "`",
		}
	}

	return file.String{
			Quote:    '\'',
			Contents: concat(strI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "use of single-quoted string",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "this should be a valid Go string",
			}),
			Suggestions: []corgierr.Suggestion{suggestion},
		}
}

func (p *parser) callonscopeItem743() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem743(stack["strI"], stack["endPosI"])
}

func (c *current) onscopeItem757(pathI interface{}) (interface{}, error) {
	return file.String{Position: pos(c)}, &corgierr.Error{
		Message: "invalid path",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected a path wrapped in quotes",
		}),
		Example: "`\"github.com/mavolin/woof/bark\"`",
	}
}

func (p *parser) callonscopeItem757() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem757(stack["pathI"])
}

func (c *current) onscopeItem491(pathI interface{}) (interface{}, error) {
	return file.Include{
		Path:     pathI.(file.String),
		Position: pos(c),
	}, nil
}

func (p *parser) callonscopeItem491() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem491(stack["pathI"])
}

func (c *current) onscopeItem788() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem788() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem788()
}

func (c *current) onscopeItem784(startPosI interface{}) (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			ToEOL:      true,
			Annotation: "doctypes other than the HTML5 doctype are not supported",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonscopeItem784() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem784(stack["startPosI"])
}

func (c *current) onscopeItem805() (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected `html`",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonscopeItem805() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem805()
}

func (c *current) onscopeItem769() (interface{}, error) {
	return file.Doctype{Position: pos(c)}, nil
}

func (p *parser) callonscopeItem769() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem769()
}

func (c *current) onscopeItem839() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonscopeItem839() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem839()
}

func (c *current) onscopeItem835(startPosI interface{}) (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			ToEOL:      true,
			Annotation: "doctypes other than the HTML5 doctype are not supported",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonscopeItem835() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem835(stack["startPosI"])
}

func (c *current) onscopeItem856() (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "invalid doctype",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected `html`",
		}),
		ShouldBe: "`doctype html`",
	}

}

func (p *parser) callonscopeItem856() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem856()
}

func (c *current) onscopeItem820() (interface{}, error) {
	return file.Doctype{Position: pos(c)}, &corgierr.Error{
		Message: "the corgi doctype directive does not start with a `!`",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "remove this",
		}),
		ShouldBe: "`doctype html`",
	}
}

func (p *parser) callonscopeItem820() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem820()
}

func (c *current) onscopeItem766(doctypeI interface{}) (interface{}, error) {
	return doctypeI, &corgierr.Error{
		Message: "`doctype` not first item",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             pos(c),
			ToEOL:             true,
			Annotation:        "cannot place doctype directive here",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "`doctype`s may only be placed as the first element after the `func` declaration\n" +
					"remove this `doctype` and move it right under the `func` of your file, if there isn't a doctype there already",
			},
		},
	}
}

func (p *parser) callonscopeItem766() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onscopeItem766(stack["doctypeI"])
}

func (c *current) onBody3() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonBody3() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBody3()
}

func (c *current) onBody6(scopeI interface{}) error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonBody6() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBody6(stack["scopeI"])
}

func (c *current) onBody1(scopeI interface{}) (interface{}, error) {
	return scopeI, nil
}

func (p *parser) callonBody1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBody1(stack["scopeI"])
}

func (c *current) onBeaitb9() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonBeaitb9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb9()
}

func (c *current) onBeaitb4(endPosI interface{}) (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start: pos(c),
			End:   endPosI.(file.Position),
			Annotation: "expected a block expansion (`:`), an assign (`=` or `!=`), inline text,\n" +
				"an indented body, or nothing",
		}),
	}

}

func (p *parser) callonBeaitb4() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb4(stack["endPosI"])
}

func (c *current) onBeaitb17(scopeItemI interface{}) (interface{}, error) {
	return file.Scope{scopeItemI.(file.ScopeItem)}, nil

}

func (p *parser) callonBeaitb17() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb17(stack["scopeItemI"])
}

func (c *current) onBeaitb23(bodyI interface{}) (interface{}, error) {
	return bodyI, nil

}

func (p *parser) callonBeaitb23() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb23(stack["bodyI"])
}

func (c *current) onBeaitb36() (interface{}, error) {
	return file.Scope(nil), nil

}

func (p *parser) callonBeaitb36() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb36()
}

func (c *current) onBeaitb1(scopeI interface{}) (interface{}, error) {
	return scopeI, nil
}

func (p *parser) callonBeaitb1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeaitb1(stack["scopeI"])
}

func (c *current) onBeait9() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonBeait9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeait9()
}

func (c *current) onBeait4(endPosI interface{}) (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a block expansion (`:`), an assign (`=` or `!=`), inline text, or nothing",
		}),
	}

}

func (p *parser) callonBeait4() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeait4(stack["endPosI"])
}

func (c *current) onBeait17(scopeItemI interface{}) (interface{}, error) {
	return file.Scope{scopeItemI.(file.ScopeItem)}, nil

}

func (p *parser) callonBeait17() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeait17(stack["scopeItemI"])
}

func (c *current) onBeait23() (interface{}, error) {
	return file.Scope(nil), nil

}

func (p *parser) callonBeait23() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeait23()
}

func (c *current) onBeait1(scopeI interface{}) (interface{}, error) {
	return scopeI, nil
}

func (p *parser) callonBeait1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeait1(stack["scopeI"])
}

func (c *current) onBadItem1(lineI, bodyI interface{}) (interface{}, error) {
	line := concat(lineI)

	firstWordLen := strings.IndexByte(line, ' ')
	if firstWordLen <= 0 {
		firstWordLen = len([]rune(line))
	}

	return file.BadItem{
			Line:     line,
			Body:     castedOrZero[file.Scope](bodyI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unrecognized directive or invalid element name",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Len:        firstWordLen,
				Annotation: "expected a valid corgi directive or an element name",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "if this is supposed to be an element name, make sure it conforms to the HTML spec"},
				{
					Suggestion: "use a valid corgi directive",
					ShouldBe: "a block (`block`, `append`, `prepend`), code (`-`), a conditional (`if`, `else if`, `else`, `switch`),\n" +
						"a loop (`for`), a filter (`:`), an include (`include`), a mixin (`mixin`), a mixin call (`+`),\n" +
						"a Go import (`import`), a corgi use (`use`), the func header (`func`),\n" +
						"an assign (`=`, `!=`), an arrow block (`>`)",
				},
			},
		}
}

func (p *parser) callonBadItem1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBadItem1(stack["lineI"], stack["bodyI"])
}

func (c *current) onBlock18(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonBlock18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock18(stack["identI"])
}

func (c *current) onBlock37() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonBlock37() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock37()
}

func (c *current) onBlock24(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonBlock24() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock24(stack["identI"], stack["endPosI"])
}

func (c *current) onBlock15(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonBlock15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock15(stack["identI"])
}

func (c *current) onBlock46() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonBlock46() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock46()
}

func (c *current) onBlock43(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonBlock43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock43(stack["posI"])
}

func (c *current) onBlock71() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonBlock71() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock71()
}

func (c *current) onBlock65(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonBlock65() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock65(stack["identI"], stack["endPosI"])
}

func (c *current) onBlock9(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonBlock9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock9(stack["identI"])
}

func (c *current) onBlock77() (interface{}, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonBlock77() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock77()
}

func (c *current) onBlock4(nameI interface{}) (interface{}, error) {
	name := nameI.(file.Ident)
	return file.Block{
		Type:     file.BlockTypeBlock,
		Name:     name,
		Position: pos(c),
	}, nil
}

func (p *parser) callonBlock4() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock4(stack["nameI"])
}

func (c *current) onBlock1(blockI, bodyI interface{}) (interface{}, error) {
	block := blockI.(file.Block)
	block.Body = bodyI.(file.Scope)
	return block, nil
}

func (p *parser) callonBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlock1(stack["blockI"], stack["bodyI"])
}

func (c *current) onInlineBlock18(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonInlineBlock18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock18(stack["identI"])
}

func (c *current) onInlineBlock37() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonInlineBlock37() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock37()
}

func (c *current) onInlineBlock24(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonInlineBlock24() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock24(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineBlock15(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonInlineBlock15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock15(stack["identI"])
}

func (c *current) onInlineBlock46() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonInlineBlock46() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock46()
}

func (c *current) onInlineBlock43(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonInlineBlock43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock43(stack["posI"])
}

func (c *current) onInlineBlock71() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonInlineBlock71() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock71()
}

func (c *current) onInlineBlock65(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonInlineBlock65() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock65(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineBlock9(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonInlineBlock9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock9(stack["identI"])
}

func (c *current) onInlineBlock77() (interface{}, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonInlineBlock77() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock77()
}

func (c *current) onInlineBlock4(nameI interface{}) (interface{}, error) {
	name := nameI.(file.Ident)
	return file.Block{
		Type:     file.BlockTypeBlock,
		Name:     name,
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineBlock4() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock4(stack["nameI"])
}

func (c *current) onInlineBlock1(blockI, scopeI interface{}) (interface{}, error) {
	block := blockI.(file.Block)
	block.Body = castedOrZero[file.Scope](scopeI)
	return block, nil
}

func (p *parser) callonInlineBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock1(stack["blockI"], stack["scopeI"])
}

func (c *current) onPrepend18(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonPrepend18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend18(stack["identI"])
}

func (c *current) onPrepend37() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonPrepend37() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend37()
}

func (c *current) onPrepend24(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonPrepend24() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend24(stack["identI"], stack["endPosI"])
}

func (c *current) onPrepend15(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonPrepend15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend15(stack["identI"])
}

func (c *current) onPrepend46() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonPrepend46() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend46()
}

func (c *current) onPrepend43(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonPrepend43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend43(stack["posI"])
}

func (c *current) onPrepend71() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonPrepend71() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend71()
}

func (c *current) onPrepend65(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonPrepend65() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend65(stack["identI"], stack["endPosI"])
}

func (c *current) onPrepend9(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonPrepend9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend9(stack["identI"])
}

func (c *current) onPrepend77() (interface{}, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonPrepend77() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend77()
}

func (c *current) onPrepend4(nameI interface{}) (interface{}, error) {
	name := nameI.(file.Ident)
	return file.Block{
		Type:     file.BlockTypePrepend,
		Name:     name,
		Position: pos(c),
	}, nil
}

func (p *parser) callonPrepend4() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend4(stack["nameI"])
}

func (c *current) onPrepend1(blockI, bodyI interface{}) (interface{}, error) {
	block := blockI.(file.Block)
	block.Body = bodyI.(file.Scope)
	return block, nil
}

func (p *parser) callonPrepend1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrepend1(stack["blockI"], stack["bodyI"])
}

func (c *current) onAppend18(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonAppend18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend18(stack["identI"])
}

func (c *current) onAppend37() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonAppend37() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend37()
}

func (c *current) onAppend24(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonAppend24() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend24(stack["identI"], stack["endPosI"])
}

func (c *current) onAppend15(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonAppend15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend15(stack["identI"])
}

func (c *current) onAppend46() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonAppend46() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend46()
}

func (c *current) onAppend43(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonAppend43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend43(stack["posI"])
}

func (c *current) onAppend71() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonAppend71() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend71()
}

func (c *current) onAppend65(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonAppend65() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend65(stack["identI"], stack["endPosI"])
}

func (c *current) onAppend9(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonAppend9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend9(stack["identI"])
}

func (c *current) onAppend77() (interface{}, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonAppend77() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend77()
}

func (c *current) onAppend4(nameI interface{}) (interface{}, error) {
	name := nameI.(file.Ident)
	return file.Block{
		Type:     file.BlockTypeAppend,
		Name:     name,
		Position: pos(c),
	}, nil
}

func (p *parser) callonAppend4() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend4(stack["nameI"])
}

func (c *current) onAppend1(blockI, bodyI interface{}) (interface{}, error) {
	block := blockI.(file.Block)
	block.Body = bodyI.(file.Scope)
	return block, nil
}

func (p *parser) callonAppend1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAppend1(stack["blockI"], stack["bodyI"])
}

func (c *current) onBlockExpansion2(abI interface{}) (interface{}, error) {
	return file.BlockExpansion{
		Item:     abI.(file.ArrowBlock),
		Position: pos(c),
	}, nil
}

func (p *parser) callonBlockExpansion2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockExpansion2(stack["abI"])
}

func (c *current) onBlockExpansion7(sI interface{}) (interface{}, error) {
	return file.BlockExpansion{
		Item:     sI.(file.ScopeItem),
		Position: pos(c),
	}, nil
}

func (p *parser) callonBlockExpansion7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockExpansion7(stack["sI"])
}

func (c *current) onBlockExpansion14() (interface{}, error) {
	return file.BlockExpansion{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "malformed block expansion",
			ErrorAnnotation: anno(c, annotation{
				Start:       pos(c),
				StartOffset: 2,
				Annotation:  "expected a block directive, an inline element, an inline arrow block, or a mixin call",
			}),
		}
}

func (p *parser) callonBlockExpansion14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockExpansion14()
}

func (c *current) onBlockExpansion30() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonBlockExpansion30() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockExpansion30()
}

func (c *current) onBlockExpansion26(posI, sI interface{}) (interface{}, error) {
	var fromThe string
	switch sI.(type) {
	case file.Block:
		fromThe = "block"
	case file.Element:
		fromThe = "inline element"
	case file.DivShorthand:
		fromThe = "div shorthand"
	case file.MixinCall:
		fromThe = "mixin call"
	default:
		fromThe = "rest"
	}

	return file.BlockExpansion{
			Item:     sI.(file.ScopeItem),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing space",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a space here, separating the `:` from the " + fromThe,
			}),
		}
}

func (p *parser) callonBlockExpansion26() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockExpansion26(stack["posI"], stack["sI"])
}

func (c *current) onblockExpansionItem6(lineI interface{}) (interface{}, error) {
	firstWordLen := strings.IndexByte(string(c.text), ' ')
	if firstWordLen <= 0 {
		firstWordLen = len([]rune(string(c.text)))
	}

	return file.BadItem{
			Line:     concat(lineI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "malformed block expansion",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Len:        firstWordLen,
				Annotation: "expected a block directive, an inline element, an inline arrow block, or a mixin call",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "if this is supposed to be an element name, make sure it conforms to the HTML spec"},
			},
		}
}

func (p *parser) callonblockExpansionItem6() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onblockExpansionItem6(stack["lineI"])
}

func (c *current) onCodes1(codesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.Code](codesI, 1), nil
}

func (p *parser) callonCodes1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCodes1(stack["codesI"])
}

func (c *current) onCode6(code interface{}) (interface{}, error) {
	return file.CodeLine{Code: concat(code), Position: pos(c)}, nil
}

func (p *parser) callonCode6() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode6(stack["code"])
}

func (c *current) onCode32(code interface{}) (interface{}, error) {
	return file.CodeLine{Code: concat(code), Position: pos(c)}, nil
}

func (p *parser) callonCode32() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode32(stack["code"])
}

func (c *current) onCode2(firstLineI, additionalLinesI interface{}) (interface{}, error) {
	additionalLineTuples := islice(additionalLinesI)

	lines := make([]file.CodeLine, 1+len(additionalLineTuples))
	lines[0] = firstLineI.(file.CodeLine)
	for i, lt := range additionalLineTuples {
		lines[i+1] = getTuple[file.CodeLine](lt, -1)
	}

	return file.Code{
		Lines:    lines,
		Position: pos(c),
	}, nil
}

func (p *parser) callonCode2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode2(stack["firstLineI"], stack["additionalLinesI"])
}

func (c *current) onCode50() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonCode50() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode50()
}

func (c *current) onCode46(posI interface{}) (interface{}, error) {
	return file.Code{Position: pos(c)}, &corgierr.Error{
		Message: "empty code block",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected code here",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "either write some code, or delete this line"},
		},
	}
}

func (p *parser) callonCode46() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCode46(stack["posI"])
}

func (c *current) oncondition2(condI interface{}) (interface{}, error) {
	return condI, nil
}

func (p *parser) calloncondition2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition2(stack["condI"])
}

func (c *current) oncondition11() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) calloncondition11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition11()
}

func (c *current) oncondition8(posI interface{}) (interface{}, error) {
	return file.Expression{}, &corgierr.Error{
		Message: "missing condition",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			Annotation:  "expected an expression here",
		}),
	}
}

func (p *parser) calloncondition8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition8(stack["posI"])
}

func (c *current) oncondition30() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) calloncondition30() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition30()
}

func (c *current) oncondition28(posI interface{}) (interface{}, error) {
	return file.Expression{}, &corgierr.Error{
		Message: "missing condition",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an expression here",
		}),
	}
}

func (p *parser) calloncondition28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncondition28(stack["posI"])
}

func (c *current) onthen2(scopeI interface{}) (interface{}, error) {
	return scopeI, nil
}

func (p *parser) callonthen2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen2(stack["scopeI"])
}

func (c *current) onthen15() (interface{}, error) {
	return file.Scope(nil), &corgierr.Error{
		Message: "missing body",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected an indented body or a block expansion",
		}),
	}
}

func (p *parser) callonthen15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen15()
}

func (c *current) onthen27() (interface{}, error) {
	return c.text, nil
}

func (p *parser) callonthen27() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen27()
}

func (c *current) onthen30() (bool, error) {
	return true, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected an indented body or a block expansion",
		}),
	}

}

func (p *parser) callonthen30() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onthen30()
}

func (c *current) onIf1(condI, thenI, elseIfsI, elseI interface{}) (interface{}, error) {
	return file.If{
		Condition: condI.(file.Expression),
		Then:      thenI.(file.Scope),
		ElseIfs:   typedSlice[file.ElseIf](elseIfsI),
		Else:      ptrOrNil[file.Else](elseI),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonIf1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIf1(stack["condI"], stack["thenI"], stack["elseIfsI"], stack["elseI"])
}

func (c *current) onElseIf11() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonElseIf11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf11()
}

func (c *current) onElseIf14() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonElseIf14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf14()
}

func (c *current) onElseIf16() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonElseIf16() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf16()
}

func (c *current) onElseIf18() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0, nil

}

func (p *parser) callonElseIf18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf18()
}

func (c *current) onElseIf19() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonElseIf19() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf19()
}

func (c *current) onElseIf21() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonElseIf21() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf21()
}

func (c *current) onElseIf24() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonElseIf24() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf24()
}

func (c *current) onElseIf25() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonElseIf25() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf25()
}

func (c *current) onElseIf26() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonElseIf26() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf26()
}

func (c *current) onElseIf28() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonElseIf28() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf28()
}

func (c *current) onElseIf29() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase or decrease of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonElseIf29() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf29()
}

func (c *current) onElseIf31() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonElseIf31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf31()
}

func (c *current) onElseIf1(posI, condI, thenI interface{}) (interface{}, error) {
	return file.ElseIf{
		Condition: condI.(file.Expression),
		Then:      thenI.(file.Scope),
		Position:  posI.(file.Position),
	}, nil
}

func (p *parser) callonElseIf1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIf1(stack["posI"], stack["condI"], stack["thenI"])
}

func (c *current) onElse11() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonElse11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse11()
}

func (c *current) onElse14() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonElse14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse14()
}

func (c *current) onElse16() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonElse16() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse16()
}

func (c *current) onElse18() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0, nil

}

func (p *parser) callonElse18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse18()
}

func (c *current) onElse19() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonElse19() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse19()
}

func (c *current) onElse21() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonElse21() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse21()
}

func (c *current) onElse24() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonElse24() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse24()
}

func (c *current) onElse25() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonElse25() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse25()
}

func (c *current) onElse26() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonElse26() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse26()
}

func (c *current) onElse28() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonElse28() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse28()
}

func (c *current) onElse29() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase or decrease of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonElse29() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse29()
}

func (c *current) onElse1(thenI interface{}) (interface{}, error) {
	return file.Else{
		Then:     thenI.(file.Scope),
		Position: pos(c),
	}, nil
}

func (p *parser) callonElse1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElse1(stack["thenI"])
}

func (c *current) onIfBlock15(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonIfBlock15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock15(stack["identI"])
}

func (c *current) onIfBlock34() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIfBlock34() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock34()
}

func (c *current) onIfBlock21(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonIfBlock21() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock21(stack["identI"], stack["endPosI"])
}

func (c *current) onIfBlock12(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonIfBlock12() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock12(stack["identI"])
}

func (c *current) onIfBlock43() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIfBlock43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock43()
}

func (c *current) onIfBlock40(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonIfBlock40() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock40(stack["posI"])
}

func (c *current) onIfBlock68() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIfBlock68() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock68()
}

func (c *current) onIfBlock62(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonIfBlock62() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock62(stack["identI"], stack["endPosI"])
}

func (c *current) onIfBlock6(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonIfBlock6() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock6(stack["identI"])
}

func (c *current) onIfBlock74() (interface{}, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonIfBlock74() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock74()
}

func (c *current) onIfBlock1(nameI, thenI, elseIfsI, elseI interface{}) (interface{}, error) {
	return file.IfBlock{
		Name:     nameI.(file.Ident),
		Then:     thenI.(file.Scope),
		ElseIfs:  typedSlice[file.ElseIfBlock](elseIfsI),
		Else:     ptrOrNil[file.Else](elseI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonIfBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfBlock1(stack["nameI"], stack["thenI"], stack["elseIfsI"], stack["elseI"])
}

func (c *current) onElseIfBlock11() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonElseIfBlock11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock11()
}

func (c *current) onElseIfBlock14() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonElseIfBlock14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock14()
}

func (c *current) onElseIfBlock16() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonElseIfBlock16() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock16()
}

func (c *current) onElseIfBlock18() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0, nil

}

func (p *parser) callonElseIfBlock18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock18()
}

func (c *current) onElseIfBlock19() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonElseIfBlock19() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock19()
}

func (c *current) onElseIfBlock21() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonElseIfBlock21() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock21()
}

func (c *current) onElseIfBlock24() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonElseIfBlock24() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock24()
}

func (c *current) onElseIfBlock25() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonElseIfBlock25() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock25()
}

func (c *current) onElseIfBlock26() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonElseIfBlock26() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock26()
}

func (c *current) onElseIfBlock28() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonElseIfBlock28() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock28()
}

func (c *current) onElseIfBlock29() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase or decrease of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonElseIfBlock29() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock29()
}

func (c *current) onElseIfBlock31() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonElseIfBlock31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock31()
}

func (c *current) onElseIfBlock49(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonElseIfBlock49() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock49(stack["identI"])
}

func (c *current) onElseIfBlock68() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonElseIfBlock68() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock68()
}

func (c *current) onElseIfBlock55(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonElseIfBlock55() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock55(stack["identI"], stack["endPosI"])
}

func (c *current) onElseIfBlock46(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonElseIfBlock46() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock46(stack["identI"])
}

func (c *current) onElseIfBlock77() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonElseIfBlock77() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock77()
}

func (c *current) onElseIfBlock74(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonElseIfBlock74() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock74(stack["posI"])
}

func (c *current) onElseIfBlock102() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonElseIfBlock102() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock102()
}

func (c *current) onElseIfBlock96(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonElseIfBlock96() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock96(stack["identI"], stack["endPosI"])
}

func (c *current) onElseIfBlock40(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonElseIfBlock40() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock40(stack["identI"])
}

func (c *current) onElseIfBlock108() (interface{}, error) {
	return file.Ident{}, &corgierr.Error{
		Message: "missing block name",
		ErrorAnnotation: anno(c, annotation{
			Start:       pos(c),
			StartOffset: 1,
			Annotation:  "expected a block name",
		}),
	}
}

func (p *parser) callonElseIfBlock108() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock108()
}

func (c *current) onElseIfBlock1(posI, nameI, thenI interface{}) (interface{}, error) {
	return file.ElseIfBlock{
		Name:     nameI.(file.Ident),
		Then:     thenI.(file.Scope),
		Position: posI.(file.Position),
	}, nil
}

func (p *parser) callonElseIfBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElseIfBlock1(stack["posI"], stack["nameI"], stack["thenI"])
}

func (c *current) onSwitch1(comparatorI, bodyI interface{}) (interface{}, error) {
	body := bodyI.(file.Switch)

	s := file.Switch{
		Comparator: comparatorI.(*file.Expression),
		Cases:      body.Cases,
		Default:    body.Default,
		Position:   pos(c),
	}

	if len(s.Cases) == 0 {
		return s, &corgierr.Error{
			Message: "switch must have at least one case",
			ErrorAnnotation: anno(c, annotation{
				ContextEndDelta: 1,
				Start:           pos(c),
				ToEOL:           true,
				Annotation:      "expected switch to have at least one non-default case",
			}),
		}
	}

	return s, nil
}

func (p *parser) callonSwitch1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSwitch1(stack["comparatorI"], stack["bodyI"])
}

func (c *current) onswitchComparator2() (interface{}, error) {
	return (*file.Expression)(nil), nil
}

func (p *parser) callonswitchComparator2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchComparator2()
}

func (c *current) onswitchComparator13(compI interface{}) (interface{}, error) {
	comp := compI.(file.Expression)
	return &comp, nil
}

func (p *parser) callonswitchComparator13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchComparator13(stack["compI"])
}

func (c *current) onswitchComparator35() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonswitchComparator35() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchComparator35()
}

func (c *current) onswitchComparator28(compI, startPosI interface{}) (interface{}, error) {
	comp := compI.(file.Expression)
	return &comp, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			Annotation: "expression was terminated here, but should span entire line",
		}),
	}
}

func (p *parser) callonswitchComparator28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchComparator28(stack["compI"], stack["startPosI"])
}

func (c *current) onswitchBody3() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonswitchBody3() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody3()
}

func (c *current) onswitchBody15() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonswitchBody15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody15()
}

func (c *current) onswitchBody18() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonswitchBody18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody18()
}

func (c *current) onswitchBody20() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonswitchBody20() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody20()
}

func (c *current) onswitchBody22() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0, nil

}

func (p *parser) callonswitchBody22() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody22()
}

func (c *current) onswitchBody23() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonswitchBody23() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody23()
}

func (c *current) onswitchBody25() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonswitchBody25() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody25()
}

func (c *current) onswitchBody28() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonswitchBody28() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody28()
}

func (c *current) onswitchBody29() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonswitchBody29() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody29()
}

func (c *current) onswitchBody30() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonswitchBody30() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody30()
}

func (c *current) onswitchBody32() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonswitchBody32() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody32()
}

func (c *current) onswitchBody33() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase or decrease of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonswitchBody33() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody33()
}

func (c *current) onswitchBody35(itms interface{}) error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonswitchBody35() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody35(stack["itms"])
}

func (c *current) onswitchBody1(itms interface{}) (interface{}, error) {
	tupleTuples := islice(itms)

	s := file.Switch{Cases: make([]file.Case, 0, len(tupleTuples))}

	var err error
	for _, tupleTuple := range tupleTuples {
		tuple := islice(tupleTuple)[2]

		switchCase, ok := getTuple[file.Case](tuple, 0), getTuple[bool](tuple, -1)
		if switchCase.Expression != nil || !ok {
			s.Cases = append(s.Cases, switchCase)
		} else {
			if s.Default != nil {
				err = &corgierr.Error{
					Message: "multiple default cases in switch",
					ErrorAnnotation: anno(c, annotation{
						Start:      switchCase.Position,
						Len:        len("default"),
						Annotation: "second default case",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      s.Default.Position,
							Len:        len("default"),
							Annotation: "first default case",
						}),
					},
				}
			} else {
				s.Default = &switchCase
			}
		}
	}

	return s, err
}

func (p *parser) callonswitchBody1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBody1(stack["itms"])
}

func (c *current) onswitchBodyItem2(caseI interface{}) (interface{}, error) {
	return []any{caseI, true}, nil
}

func (p *parser) callonswitchBodyItem2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBodyItem2(stack["caseI"])
}

func (c *current) onswitchBodyItem7(caseI interface{}) (interface{}, error) {
	return []any{caseI, false}, nil
}

func (p *parser) callonswitchBodyItem7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onswitchBodyItem7(stack["caseI"])
}

func (c *current) onCase1(condI, thenI interface{}) (interface{}, error) {
	return file.Case{
		Expression: ptrOrNil[file.Expression](condI),
		Then:       thenI.(file.Scope),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonCase1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCase1(stack["condI"], stack["thenI"])
}

func (c *current) onDefault1(thenI interface{}) (interface{}, error) {
	return file.Case{
		Then:     thenI.(file.Scope),
		Position: pos(c),
	}, nil
}

func (p *parser) callonDefault1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDefault1(stack["thenI"])
}

func (c *current) onBadCase1(bodyI interface{}) (interface{}, error) {
	firstWordLen := strings.IndexByte(string(c.text), ' ')
	if firstWordLen <= 0 {
		firstWordLen = len([]rune(string(c.text)))
	}

	return file.Case{
			Then:     castedOrZero[file.Scope](bodyI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unrecognized directive in switch body",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Len:        firstWordLen,
				Annotation: "expected a case or a default",
			}),
		}
}

func (p *parser) callonBadCase1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBadCase1(stack["bodyI"])
}

func (c *current) onCorgiComments1(commentsI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.CorgiComment](commentsI, -1), nil
}

func (p *parser) callonCorgiComments1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCorgiComments1(stack["commentsI"])
}

func (c *current) onCorgiComment8(linesI interface{}) (interface{}, error) {
	return linesI, nil

}

func (p *parser) callonCorgiComment8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCorgiComment8(stack["linesI"])
}

func (c *current) onCorgiComment25(commentI interface{}) (interface{}, error) {
	return file.CorgiCommentLine{Comment: concat(commentI), Position: pos(c)}, nil
}

func (p *parser) callonCorgiComment25() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCorgiComment25(stack["commentI"])
}

func (c *current) onCorgiComment23(lineI interface{}) (interface{}, error) {
	return []file.CorgiCommentLine{lineI.(file.CorgiCommentLine)}, nil

}

func (p *parser) callonCorgiComment23() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCorgiComment23(stack["lineI"])
}

func (c *current) onCorgiComment1(linesI interface{}) (interface{}, error) {
	return file.CorgiComment{
		Lines:    linesI.([]file.CorgiCommentLine),
		Position: pos(c),
	}, nil
}

func (p *parser) callonCorgiComment1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCorgiComment1(stack["linesI"])
}

func (c *current) oncorgiCommentBlock3() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) calloncorgiCommentBlock3() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentBlock3()
}

func (c *current) oncorgiCommentBlock16(commentI interface{}) (interface{}, error) {
	return file.CorgiCommentLine{Comment: concat(commentI), Position: pos(c)}, nil
}

func (p *parser) calloncorgiCommentBlock16() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentBlock16(stack["commentI"])
}

func (c *current) oncorgiCommentBlock30(linesI interface{}) error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) calloncorgiCommentBlock30() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentBlock30(stack["linesI"])
}

func (c *current) oncorgiCommentBlock1(linesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.CorgiCommentLine](linesI, -1), nil
}

func (p *parser) calloncorgiCommentBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.oncorgiCommentBlock1(stack["linesI"])
}

func (c *current) onHTMLComment6(linesI interface{}) (interface{}, error) {
	return linesI, nil

}

func (p *parser) callonHTMLComment6() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLComment6(stack["linesI"])
}

func (c *current) onHTMLComment21(commentI interface{}) (interface{}, error) {
	return file.HTMLCommentLine{Comment: concat(commentI), Position: pos(c)}, nil
}

func (p *parser) callonHTMLComment21() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLComment21(stack["commentI"])
}

func (c *current) onHTMLComment19(lineI interface{}) (interface{}, error) {
	return []file.HTMLCommentLine{lineI.(file.HTMLCommentLine)}, nil

}

func (p *parser) callonHTMLComment19() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLComment19(stack["lineI"])
}

func (c *current) onHTMLComment1(linesI interface{}) (interface{}, error) {
	return file.HTMLComment{
		Lines:    linesI.([]file.HTMLCommentLine),
		Position: pos(c),
	}, nil
}

func (p *parser) callonHTMLComment1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLComment1(stack["linesI"])
}

func (c *current) onhtmlCommentBlock3() error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) + 1
	return nil
}

func (p *parser) callonhtmlCommentBlock3() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onhtmlCommentBlock3()
}

func (c *current) onhtmlCommentBlock16(commentI interface{}) (interface{}, error) {
	return file.HTMLCommentLine{Comment: concat(commentI), Position: pos(c)}, nil
}

func (p *parser) callonhtmlCommentBlock16() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onhtmlCommentBlock16(stack["commentI"])
}

func (c *current) onhtmlCommentBlock30(linesI interface{}) error {
	c.state["Indentation.Level"] = c.state["Indentation.Level"].(int) - 1

	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	c.state["Indentation.TotalRepetitions"] = c.state["Indentation.TotalRepetitions"].(int) - actualReps.Pop()
	return nil
}

func (p *parser) callonhtmlCommentBlock30() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onhtmlCommentBlock30(stack["linesI"])
}

func (c *current) onhtmlCommentBlock1(linesI interface{}) (interface{}, error) {
	return typedSliceFromTuples[file.HTMLCommentLine](linesI, -1), nil
}

func (p *parser) callonhtmlCommentBlock1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onhtmlCommentBlock1(stack["linesI"])
}

func (c *current) onElement1(nameI, attrsI, voidI, bodyI interface{}) (interface{}, error) {
	return file.Element{
		Name:       concat(nameI),
		Attributes: typedSlice[file.AttributeCollection](attrsI),
		Body:       bodyI.(file.Scope),
		Void:       voidI != nil,
		Position:   pos(c),
	}, nil
}

func (p *parser) callonElement1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElement1(stack["nameI"], stack["attrsI"], stack["voidI"], stack["bodyI"])
}

func (c *current) onInlineElement1(nameI, attrsI, voidI, bodyI interface{}) (interface{}, error) {
	return file.Element{
		Name:       concat(nameI),
		Attributes: typedSlice[file.AttributeCollection](attrsI),
		Body:       bodyI.(file.Scope),
		Void:       voidI != nil,
		Position:   pos(c),
	}, nil
}

func (p *parser) callonInlineElement1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineElement1(stack["nameI"], stack["attrsI"], stack["voidI"], stack["bodyI"])
}

func (c *current) onDivShorthand5(nameI interface{}) (interface{}, error) {
	return file.ClassShorthand{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonDivShorthand5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand5(stack["nameI"])
}

func (c *current) onDivShorthand15() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonDivShorthand15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand15()
}

func (c *current) onDivShorthand11(posI interface{}) (interface{}, error) {
	return file.ClassShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "class shorthand: missing class name",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected a class name here",
		}),
	}
}

func (p *parser) callonDivShorthand11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand11(stack["posI"])
}

func (c *current) onDivShorthand21(idI interface{}) (interface{}, error) {
	return file.IDShorthand{
		ID:       concat(idI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonDivShorthand21() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand21(stack["idI"])
}

func (c *current) onDivShorthand31() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonDivShorthand31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand31()
}

func (c *current) onDivShorthand27(posI interface{}) (interface{}, error) {
	return file.IDShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "id shorthand: missing id",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an id here",
		}),
	}
}

func (p *parser) callonDivShorthand27() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand27(stack["posI"])
}

func (c *current) onDivShorthand1(firstAttrI, moreAttrsI, bodyI interface{}) (interface{}, error) {
	return file.DivShorthand{
		Attributes: append([]file.AttributeCollection{firstAttrI.(file.AttributeCollection)}, typedSlice[file.AttributeCollection](moreAttrsI)...),
		Body:       bodyI.(file.Scope),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonDivShorthand1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDivShorthand1(stack["firstAttrI"], stack["moreAttrsI"], stack["bodyI"])
}

func (c *current) onInlineDivShorthand5(nameI interface{}) (interface{}, error) {
	return file.ClassShorthand{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineDivShorthand5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand5(stack["nameI"])
}

func (c *current) onInlineDivShorthand15() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonInlineDivShorthand15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand15()
}

func (c *current) onInlineDivShorthand11(posI interface{}) (interface{}, error) {
	return file.ClassShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "class shorthand: missing class name",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected a class name here",
		}),
	}
}

func (p *parser) callonInlineDivShorthand11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand11(stack["posI"])
}

func (c *current) onInlineDivShorthand21(idI interface{}) (interface{}, error) {
	return file.IDShorthand{
		ID:       concat(idI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineDivShorthand21() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand21(stack["idI"])
}

func (c *current) onInlineDivShorthand31() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonInlineDivShorthand31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand31()
}

func (c *current) onInlineDivShorthand27(posI interface{}) (interface{}, error) {
	return file.IDShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "id shorthand: missing id",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an id here",
		}),
	}
}

func (p *parser) callonInlineDivShorthand27() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand27(stack["posI"])
}

func (c *current) onInlineDivShorthand1(firstAttrI, moreAttrsI, bodyI interface{}) (interface{}, error) {
	return file.DivShorthand{
		Attributes: append([]file.AttributeCollection{firstAttrI.(file.AttributeCollection)}, typedSlice[file.AttributeCollection](moreAttrsI)...),
		Body:       bodyI.(file.Scope),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonInlineDivShorthand1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDivShorthand1(stack["firstAttrI"], stack["moreAttrsI"], stack["bodyI"])
}

func (c *current) onAnd2(collsI interface{}) (interface{}, error) {
	return file.And{
		Attributes: typedSlice[file.AttributeCollection](collsI),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonAnd2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd2(stack["collsI"])
}

func (c *current) onAnd21() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonAnd21() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd21()
}

func (c *current) onAnd17(posI interface{}) (interface{}, error) {
	return file.And{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "`&` with no attributes",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an attribute here",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "write a class shorthand", Example: "`&.woof`"},
				{Suggestion: "write an id shorthand", Example: "`&#bark`"},
				{Suggestion: "write an attribute list", Example: "`&(src=\"bark/woof\", title=\"howl\")`"},
			},
		}
}

func (p *parser) callonAnd17() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd17(stack["posI"])
}

func (c *current) onAnd43() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonAnd43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd43()
}

func (c *current) onAnd36(collsI, posI interface{}) (interface{}, error) {
	return file.And{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "bad attribute syntax",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "this is not a valid attribute (list)",
			}),
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "if there is, remove any whitespace between class/id shorthands and attribute lists",
					Example:    "`&#bark .woof (title=\"howl\")`",
					ShouldBe:   "`&#bark.woof(title=\"howl\")`",
				},
				{Suggestion: "write a class shorthand", Example: "`&.woof`"},
				{Suggestion: "write an id shorthand", Example: "`&#bark`"},
				{Suggestion: "write an attribute list", Example: "`&(src=\"bark/woof\", title=\"howl\")`"},
			},
		}
}

func (p *parser) callonAnd36() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnd36(stack["collsI"], stack["posI"])
}

func (c *current) onAttributeCollection2(idI interface{}) (interface{}, error) {
	return file.IDShorthand{
		ID:       concat(idI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonAttributeCollection2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection2(stack["idI"])
}

func (c *current) onAttributeCollection12() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonAttributeCollection12() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection12()
}

func (c *current) onAttributeCollection8(posI interface{}) (interface{}, error) {
	return file.IDShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "id shorthand: missing id",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an id here",
		}),
	}
}

func (p *parser) callonAttributeCollection8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection8(stack["posI"])
}

func (c *current) onAttributeCollection18(nameI interface{}) (interface{}, error) {
	return file.ClassShorthand{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonAttributeCollection18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection18(stack["nameI"])
}

func (c *current) onAttributeCollection28() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonAttributeCollection28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection28()
}

func (c *current) onAttributeCollection24(posI interface{}) (interface{}, error) {
	return file.ClassShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "class shorthand: missing class name",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected a class name here",
		}),
	}
}

func (p *parser) callonAttributeCollection24() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeCollection24(stack["posI"])
}

func (c *current) onSingleLineAttributeCollection2(idI interface{}) (interface{}, error) {
	return file.IDShorthand{
		ID:       concat(idI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSingleLineAttributeCollection2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection2(stack["idI"])
}

func (c *current) onSingleLineAttributeCollection12() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineAttributeCollection12() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection12()
}

func (c *current) onSingleLineAttributeCollection8(posI interface{}) (interface{}, error) {
	return file.IDShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "id shorthand: missing id",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected an id here",
		}),
	}
}

func (p *parser) callonSingleLineAttributeCollection8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection8(stack["posI"])
}

func (c *current) onSingleLineAttributeCollection18(nameI interface{}) (interface{}, error) {
	return file.ClassShorthand{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSingleLineAttributeCollection18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection18(stack["nameI"])
}

func (c *current) onSingleLineAttributeCollection28() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineAttributeCollection28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection28()
}

func (c *current) onSingleLineAttributeCollection24(posI interface{}) (interface{}, error) {
	return file.ClassShorthand{Position: pos(c)}, &corgierr.Error{
		Message: "class shorthand: missing class name",
		ErrorAnnotation: anno(c, annotation{
			Start:      posI.(file.Position),
			Annotation: "expected a class name here",
		}),
	}
}

func (p *parser) callonSingleLineAttributeCollection24() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeCollection24(stack["posI"])
}

func (c *current) onAttributeList28() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonAttributeList28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList28()
}

func (c *current) onAttributeList2(attributesI, rParenPosI interface{}) (interface{}, error) {
	return file.AttributeList{
		LParenPos:  pos(c),
		Attributes: castedOrZero[[]file.Attribute](attributesI),
		RParenPos:  rParenPosI.(file.Position),
	}, nil
}

func (p *parser) callonAttributeList2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList2(stack["attributesI"], stack["rParenPosI"])
}

func (c *current) onAttributeList49() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonAttributeList49() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList49()
}

func (c *current) onAttributeList30(attributesI, posI interface{}) (interface{}, error) {
	return file.AttributeList{
			LParenPos:  pos(c),
			Attributes: castedOrZero[[]file.Attribute](attributesI),
		}, &corgierr.Error{
			Message: "attribute list: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonAttributeList30() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList30(stack["attributesI"], stack["posI"])
}

func (c *current) onattributes1(firstI, restI interface{}) (interface{}, error) {
	restIs := islice(restI)
	attributes := make([]file.Attribute, 1+len(restIs))
	attributes[0] = firstI.(file.Attribute)
	for i, ai := range restIs {
		attributes[i+1] = getTuple[file.Attribute](ai, -1)
	}

	return attributes, nil
}

func (p *parser) callonattributes1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onattributes1(stack["firstI"], stack["restI"])
}

func (c *current) onSingleLineAttributeList18() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineAttributeList18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeList18()
}

func (c *current) onSingleLineAttributeList2(attributesI, rParenPosI interface{}) (interface{}, error) {
	return file.AttributeList{
		LParenPos:  pos(c),
		Attributes: castedOrZero[[]file.Attribute](attributesI),
		RParenPos:  rParenPosI.(file.Position),
	}, nil
}

func (p *parser) callonSingleLineAttributeList2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeList2(stack["attributesI"], stack["rParenPosI"])
}

func (c *current) onSingleLineAttributeList34() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineAttributeList34() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeList34()
}

func (c *current) onSingleLineAttributeList20(attributesI, posI interface{}) (interface{}, error) {
	return file.AttributeList{
			LParenPos:  pos(c),
			Attributes: castedOrZero[[]file.Attribute](attributesI),
		}, &corgierr.Error{
			Message: "attribute list: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonSingleLineAttributeList20() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttributeList20(stack["attributesI"], stack["posI"])
}

func (c *current) onsingleLineAttributes1(firstI, restI interface{}) (interface{}, error) {
	restIs := islice(restI)
	attributes := make([]file.Attribute, 1+len(restIs))
	attributes[0] = firstI.(file.Attribute)
	for i, ai := range restIs {
		attributes[i+1] = getTuple[file.Attribute](ai, -1)
	}

	return attributes, nil
}

func (p *parser) callonsingleLineAttributes1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineAttributes1(stack["firstI"], stack["restI"])
}

func (c *current) onAttribute3() (interface{}, error) {
	return file.AndPlaceholder{Position: pos(c)}, nil
}

func (p *parser) callonAttribute3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttribute3()
}

func (c *current) onSingleLineAttribute3() (interface{}, error) {
	return file.AndPlaceholder{Position: pos(c)}, nil
}

func (p *parser) callonSingleLineAttribute3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineAttribute3()
}

func (c *current) onSimpleAttribute3(nameI interface{}) (interface{}, error) {
	return file.SimpleAttribute{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSimpleAttribute3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleAttribute3(stack["nameI"])
}

func (c *current) onSingleLineSimpleAttribute3(nameI interface{}) (interface{}, error) {
	return file.SimpleAttribute{
		Name:     concat(nameI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSingleLineSimpleAttribute3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineSimpleAttribute3(stack["nameI"])
}

func (c *current) onsimpleValueAttribute15() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsimpleValueAttribute15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute15()
}

func (c *current) onsimpleValueAttribute33() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsimpleValueAttribute33() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute33()
}

func (c *current) onsimpleValueAttribute2(nameI, assignPosI, noEscapeI, posI, exprI interface{}) (interface{}, error) {
	return file.SimpleAttribute{
		Name:      concat(nameI),
		NoEscape:  noEscapeI != nil,
		AssignPos: ptr(assignPosI.(file.Position)),
		Value:     ptrOrNil[file.Expression](exprI),
	}, nil
}

func (p *parser) callonsimpleValueAttribute2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute2(stack["nameI"], stack["assignPosI"], stack["noEscapeI"], stack["posI"], stack["exprI"])
}

func (c *current) onsimpleValueAttribute54() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsimpleValueAttribute54() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute54()
}

func (c *current) onsimpleValueAttribute65() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsimpleValueAttribute65() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute65()
}

func (c *current) onsimpleValueAttribute41(nameI, assignPosI, noEscapeI, posI interface{}) (interface{}, error) {
	return file.SimpleAttribute{
			Name:      concat(nameI),
			NoEscape:  noEscapeI != nil,
			AssignPos: ptrOrNil[file.Position](assignPosI),
		}, &corgierr.Error{
			Message: "attribute: missing value expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an expression here",
			}),
		}
}

func (p *parser) callonsimpleValueAttribute41() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsimpleValueAttribute41(stack["nameI"], stack["assignPosI"], stack["noEscapeI"], stack["posI"])
}

func (c *current) onsingleLineSimpleValueAttribute15() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineSimpleValueAttribute15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute15()
}

func (c *current) onsingleLineSimpleValueAttribute2(nameI, assignPosI, noEscapeI, exprI interface{}) (interface{}, error) {
	return file.SimpleAttribute{
		Name:      concat(nameI),
		NoEscape:  noEscapeI != nil,
		AssignPos: ptrOrNil[file.Position](assignPosI),
		Value:     ptrOrNil[file.Expression](exprI),
	}, nil
}

func (p *parser) callonsingleLineSimpleValueAttribute2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute2(stack["nameI"], stack["assignPosI"], stack["noEscapeI"], stack["exprI"])
}

func (c *current) onsingleLineSimpleValueAttribute42() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineSimpleValueAttribute42() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute42()
}

func (c *current) onsingleLineSimpleValueAttribute53() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineSimpleValueAttribute53() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute53()
}

func (c *current) onsingleLineSimpleValueAttribute29(nameI, assignPosI, noEscapeI, posI interface{}) (interface{}, error) {
	return file.SimpleAttribute{
			Name:      concat(nameI),
			NoEscape:  noEscapeI != nil,
			AssignPos: ptrOrNil[file.Position](assignPosI),
		}, &corgierr.Error{
			Message: "attribute: missing value expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an expression or a mixin call here",
			}),
		}
}

func (p *parser) callonsingleLineSimpleValueAttribute29() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineSimpleValueAttribute29(stack["nameI"], stack["assignPosI"], stack["noEscapeI"], stack["posI"])
}

func (c *current) onMixinCallAttribute14() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallAttribute14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallAttribute14()
}

func (c *current) onMixinCallAttribute1(nameI, assignPosI, noEscapeI, callI interface{}) (interface{}, error) {
	call := callI.(file.MixinCallAttribute)
	return file.MixinCallAttribute{
		Name:      concat(nameI),
		NoEscape:  noEscapeI != nil,
		AssignPos: assignPosI.(file.Position),
		MixinCall: call.MixinCall,
		Value:     call.Value,
		Position:  pos(c),
	}, nil
}

func (p *parser) callonMixinCallAttribute1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallAttribute1(stack["nameI"], stack["assignPosI"], stack["noEscapeI"], stack["callI"])
}

func (c *current) onSingleLineMixinCallAttribute14() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineMixinCallAttribute14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineMixinCallAttribute14()
}

func (c *current) onSingleLineMixinCallAttribute1(nameI, assignPosI, noEscapeI, callI interface{}) (interface{}, error) {
	call := callI.(file.MixinCallAttribute)
	return file.MixinCallAttribute{
		Name:      concat(nameI),
		NoEscape:  noEscapeI != nil,
		AssignPos: assignPosI.(file.Position),
		MixinCall: call.MixinCall,
		Value:     call.Value,
		Position:  pos(c),
	}, nil
}

func (p *parser) callonSingleLineMixinCallAttribute1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineMixinCallAttribute1(stack["nameI"], stack["assignPosI"], stack["noEscapeI"], stack["callI"])
}

func (c *current) onmixinCallAttributeCall8(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonmixinCallAttributeCall8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall8(stack["identI"])
}

func (c *current) onmixinCallAttributeCall27() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeCall27() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall27()
}

func (c *current) onmixinCallAttributeCall14(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonmixinCallAttributeCall14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall14(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinCallAttributeCall39(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonmixinCallAttributeCall39() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall39(stack["identI"])
}

func (c *current) onmixinCallAttributeCall58() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeCall58() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall58()
}

func (c *current) onmixinCallAttributeCall45(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonmixinCallAttributeCall45() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall45(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinCallAttributeCall36(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonmixinCallAttributeCall36() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall36(stack["identI"])
}

func (c *current) onmixinCallAttributeCall67() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeCall67() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall67()
}

func (c *current) onmixinCallAttributeCall64(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinCallAttributeCall64() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall64(stack["posI"])
}

func (c *current) onmixinCallAttributeCall92() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeCall92() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall92()
}

func (c *current) onmixinCallAttributeCall86(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinCallAttributeCall86() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall86(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinCallAttributeCall1(namespaceI, nameI, argsI, valueI interface{}) (interface{}, error) {
	args := castedOrZero[file.MixinCall](argsI)
	return file.MixinCallAttribute{
		MixinCall: file.MixinCall{
			Name:      nameI.(file.Ident),
			LParenPos: args.LParenPos,
			Args:      args.Args,
			RParenPos: args.RParenPos,
			Position:  pos(c),
		},
		Value: castedOrZero[file.InterpolationValue](valueI),
	}, nil
}

func (p *parser) callonmixinCallAttributeCall1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["valueI"])
}

func (c *current) onsingleLineMixinCallAttributeCall8(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall8(stack["identI"])
}

func (c *current) onsingleLineMixinCallAttributeCall27() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall27() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall27()
}

func (c *current) onsingleLineMixinCallAttributeCall14(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonsingleLineMixinCallAttributeCall14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall14(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinCallAttributeCall39(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall39() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall39(stack["identI"])
}

func (c *current) onsingleLineMixinCallAttributeCall58() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall58() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall58()
}

func (c *current) onsingleLineMixinCallAttributeCall45(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonsingleLineMixinCallAttributeCall45() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall45(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinCallAttributeCall36(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall36() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall36(stack["identI"])
}

func (c *current) onsingleLineMixinCallAttributeCall67() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall67() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall67()
}

func (c *current) onsingleLineMixinCallAttributeCall64(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonsingleLineMixinCallAttributeCall64() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall64(stack["posI"])
}

func (c *current) onsingleLineMixinCallAttributeCall92() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall92() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall92()
}

func (c *current) onsingleLineMixinCallAttributeCall86(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonsingleLineMixinCallAttributeCall86() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall86(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinCallAttributeCall1(namespaceI, nameI, argsI, valueI interface{}) (interface{}, error) {
	args := castedOrZero[file.MixinCall](argsI)
	return file.MixinCallAttribute{
		MixinCall: file.MixinCall{
			Name:      nameI.(file.Ident),
			LParenPos: args.LParenPos,
			Args:      args.Args,
			RParenPos: args.RParenPos,
			Position:  pos(c),
		},
		Value: castedOrZero[file.InterpolationValue](valueI),
	}, nil
}

func (p *parser) callonsingleLineMixinCallAttributeCall1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinCallAttributeCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["valueI"])
}

func (c *current) onmixinCallAttributeValue5() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeValue5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeValue5()
}

func (c *current) onmixinCallAttributeValue11() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeValue11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeValue11()
}

func (c *current) onmixinCallAttributeValue2(lBracketPosI, textI, rBracketPosI interface{}) (interface{}, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
		RBracketPos: rBracketPosI.(file.Position),
	}, nil
}

func (p *parser) callonmixinCallAttributeValue2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeValue2(stack["lBracketPosI"], stack["textI"], stack["rBracketPosI"])
}

func (c *current) onmixinCallAttributeValue16() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallAttributeValue16() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeValue16()
}

func (c *current) onmixinCallAttributeValue13(lBracketPosI, textI interface{}) (interface{}, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
	}, errors.New("unclosed text interpolation")
}

func (p *parser) callonmixinCallAttributeValue13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallAttributeValue13(stack["lBracketPosI"], stack["textI"])
}

func (c *current) onExpression2(cExprI interface{}) (interface{}, error) {
	return file.Expression{Expressions: []file.ExpressionItem{cExprI.(file.ChainExpression)}}, nil
}

func (p *parser) callonExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExpression2(stack["cExprI"])
}

func (c *current) onSingleLineExpression2(cExprI interface{}) (interface{}, error) {
	return file.Expression{Expressions: []file.ExpressionItem{cExprI.(file.ChainExpression)}}, nil
}

func (p *parser) callonSingleLineExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineExpression2(stack["cExprI"])
}

func (c *current) onGoExpression12() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonGoExpression12() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression12()
}

func (c *current) onGoExpression23() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonGoExpression23() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression23()
}

func (c *current) onGoExpression34() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonGoExpression34() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression34()
}

func (c *current) onGoExpression5(exprI interface{}) (interface{}, error) {
	exprIs := islice(exprI)
	if exprIs[1] == nil {
		return file.GoExpression{
			Expression: concat(exprIs[0]) + concat(exprIs[3]),
			Position:   pos(c),
		}, nil
	}

	expr := exprIs[1].(file.Expression)

	exprs := make([]file.ExpressionItem, len(expr.Expressions)+ /* open/closing paren */ 2)
	copy(exprs[1:], expr.Expressions)
	exprs[0] = file.GoExpression{
		Expression: concat(exprIs[0]),
		Position:   pos(c),
	}
	exprs[len(exprs)-1] = file.GoExpression{
		Expression: concat(exprIs[3]),
		Position:   exprIs[2].(file.Position),
	}

	return exprs, nil

}

func (p *parser) callonGoExpression5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression5(stack["exprI"])
}

func (c *current) onGoExpression46() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonGoExpression46() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression46()
}

func (c *current) onGoExpression41(parenI, startPosI, exprI interface{}) (interface{}, error) {
	openParen := string(char(parenI))

	closeParen := ")"
	if openParen == "[" {
		closeParen = "]"
	} else if openParen == "{" {
		closeParen = "}"
	}

	exprs := append([]file.ExpressionItem{file.GoExpression{
		Expression: openParen,
		Position:   pos(c),
	}}, castedOrZero[file.Expression](exprI).Expressions...)

	return exprs, &corgierr.Error{
		Message: "unclosed `" + openParen + "` in expression",
		ErrorAnnotation: anno(c, annotation{
			ContextLen: 3,
			Start:      startPosI.(file.Position),
			EOLDelta:   1,
			Annotation: "expected a `" + closeParen + "` somewhere here or on a line below",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      pos(c),
				Annotation: "for the `" + openParen + "` you opened here",
			}),
		},
	}

}

func (p *parser) callonGoExpression41() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression41(stack["parenI"], stack["startPosI"], stack["exprI"])
}

func (c *current) onGoExpression56() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonGoExpression56() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression56()
}

func (c *current) onGoExpression72() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonGoExpression72() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression72()
}

func (c *current) onGoExpression93() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonGoExpression93() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression93()
}

func (c *current) onGoExpression125() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonGoExpression125() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression125()
}

func (c *current) onGoExpression132() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression132() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression132()
}

func (c *current) onGoExpression143() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression143() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression143()
}

func (c *current) onGoExpression150() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression150() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression150()
}

func (c *current) onGoExpression155() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonGoExpression155() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression155()
}

func (c *current) onGoExpression173() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonGoExpression173() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression173()
}

func (c *current) onGoExpression194() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonGoExpression194() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression194()
}

func (c *current) onGoExpression226() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonGoExpression226() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression226()
}

func (c *current) onGoExpression233() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression233() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression233()
}

func (c *current) onGoExpression244() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression244() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression244()
}

func (c *current) onGoExpression251() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonGoExpression251() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression251()
}

func (c *current) onGoExpression256() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonGoExpression256() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression256()
}

func (c *current) onGoExpression263() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonGoExpression263() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression263()
}

func (c *current) onGoExpression161(valsI, endPosI interface{}) (interface{}, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonGoExpression161() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression161(stack["valsI"], stack["endPosI"])
}

func (c *current) onGoExpression272() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonGoExpression272() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression272()
}

func (c *current) onGoExpression1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonGoExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoExpression1(stack["exprsI"])
}

func (c *current) ongoSubExpression11() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callongoSubExpression11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression11()
}

func (c *current) ongoSubExpression21() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callongoSubExpression21() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression21()
}

func (c *current) ongoSubExpression31() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callongoSubExpression31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression31()
}

func (c *current) ongoSubExpression5(exprI interface{}) (interface{}, error) {
	exprIs := islice(exprI)
	if exprIs[1] == nil {
		return file.GoExpression{
			Expression: concat(exprIs[0]) + concat(exprIs[3]),
			Position:   pos(c),
		}, nil
	}

	expr := exprIs[1].(file.Expression)

	exprs := make([]file.ExpressionItem, len(expr.Expressions)+ /* open/closing paren */ 2)
	copy(exprs[1:], expr.Expressions)
	exprs[0] = file.GoExpression{
		Expression: concat(exprIs[0]),
		Position:   pos(c),
	}
	exprs[len(exprs)-1] = file.GoExpression{
		Expression: concat(exprIs[3]),
		Position:   exprIs[2].(file.Position),
	}

	return exprs, nil

}

func (p *parser) callongoSubExpression5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression5(stack["exprI"])
}

func (c *current) ongoSubExpression43() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callongoSubExpression43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression43()
}

func (c *current) ongoSubExpression38(parenI, startPosI, exprI interface{}) (interface{}, error) {
	openParen := string(char(parenI))

	closeParen := ")"
	if openParen == "[" {
		closeParen = "]"
	} else if openParen == "{" {
		closeParen = "}"
	}

	exprs := append([]file.ExpressionItem{file.GoExpression{
		Expression: openParen,
		Position:   pos(c),
	}}, castedOrZero[file.Expression](exprI).Expressions...)

	return exprs, &corgierr.Error{
		Message: "unclosed `" + openParen + "` in expression",
		ErrorAnnotation: anno(c, annotation{
			ContextLen: 3,
			Start:      startPosI.(file.Position),
			EOLDelta:   1,
			Annotation: "expected a `" + closeParen + "` somewhere here or on a line below",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      pos(c),
				Annotation: "for the `" + openParen + "` you opened here",
			}),
		},
	}

}

func (p *parser) callongoSubExpression38() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression38(stack["parenI"], stack["startPosI"], stack["exprI"])
}

func (c *current) ongoSubExpression52() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callongoSubExpression52() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression52()
}

func (c *current) ongoSubExpression68() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoSubExpression68() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression68()
}

func (c *current) ongoSubExpression89() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoSubExpression89() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression89()
}

func (c *current) ongoSubExpression121() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callongoSubExpression121() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression121()
}

func (c *current) ongoSubExpression128() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression128() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression128()
}

func (c *current) ongoSubExpression139() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression139() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression139()
}

func (c *current) ongoSubExpression146() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression146() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression146()
}

func (c *current) ongoSubExpression151() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callongoSubExpression151() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression151()
}

func (c *current) ongoSubExpression169() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoSubExpression169() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression169()
}

func (c *current) ongoSubExpression190() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoSubExpression190() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression190()
}

func (c *current) ongoSubExpression222() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callongoSubExpression222() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression222()
}

func (c *current) ongoSubExpression229() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression229() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression229()
}

func (c *current) ongoSubExpression240() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression240() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression240()
}

func (c *current) ongoSubExpression247() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoSubExpression247() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression247()
}

func (c *current) ongoSubExpression252() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callongoSubExpression252() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression252()
}

func (c *current) ongoSubExpression259() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callongoSubExpression259() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression259()
}

func (c *current) ongoSubExpression157(valsI, endPosI interface{}) (interface{}, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callongoSubExpression157() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression157(stack["valsI"], stack["endPosI"])
}

func (c *current) ongoSubExpression268() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callongoSubExpression268() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression268()
}

func (c *current) ongoSubExpression1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callongoSubExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoSubExpression1(stack["exprsI"])
}

func (c *current) onmultiLineGoExpression11() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmultiLineGoExpression11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression11()
}

func (c *current) onmultiLineGoExpression21() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmultiLineGoExpression21() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression21()
}

func (c *current) onmultiLineGoExpression31() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmultiLineGoExpression31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression31()
}

func (c *current) onmultiLineGoExpression5(exprI interface{}) (interface{}, error) {
	exprIs := islice(exprI)
	if exprIs[1] == nil {
		return file.GoExpression{
			Expression: concat(exprIs[0]) + concat(exprIs[3]),
			Position:   pos(c),
		}, nil
	}

	expr := exprIs[1].(file.Expression)

	exprs := make([]file.ExpressionItem, len(expr.Expressions)+ /* open/closing paren */ 2)
	copy(exprs[1:], expr.Expressions)
	exprs[0] = file.GoExpression{
		Expression: concat(exprIs[0]),
		Position:   pos(c),
	}
	exprs[len(exprs)-1] = file.GoExpression{
		Expression: concat(exprIs[3]),
		Position:   exprIs[2].(file.Position),
	}

	return exprs, nil

}

func (p *parser) callonmultiLineGoExpression5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression5(stack["exprI"])
}

func (c *current) onmultiLineGoExpression43() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmultiLineGoExpression43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression43()
}

func (c *current) onmultiLineGoExpression38(parenI, startPosI, exprI interface{}) (interface{}, error) {
	openParen := string(char(parenI))

	closeParen := ")"
	if openParen == "[" {
		closeParen = "]"
	} else if openParen == "{" {
		closeParen = "}"
	}

	exprs := append([]file.ExpressionItem{file.GoExpression{
		Expression: openParen,
		Position:   pos(c),
	}}, castedOrZero[file.Expression](exprI).Expressions...)

	return exprs, &corgierr.Error{
		Message: "unclosed `" + openParen + "` in expression",
		ErrorAnnotation: anno(c, annotation{
			ContextLen: 3,
			Start:      startPosI.(file.Position),
			EOLDelta:   1,
			Annotation: "expected a `" + closeParen + "` somewhere here or on a line below",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      pos(c),
				Annotation: "for the `" + openParen + "` you opened here",
			}),
		},
	}

}

func (p *parser) callonmultiLineGoExpression38() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression38(stack["parenI"], stack["startPosI"], stack["exprI"])
}

func (c *current) onmultiLineGoExpression52() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmultiLineGoExpression52() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression52()
}

func (c *current) onmultiLineGoExpression68() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonmultiLineGoExpression68() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression68()
}

func (c *current) onmultiLineGoExpression89() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonmultiLineGoExpression89() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression89()
}

func (c *current) onmultiLineGoExpression121() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonmultiLineGoExpression121() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression121()
}

func (c *current) onmultiLineGoExpression128() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression128() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression128()
}

func (c *current) onmultiLineGoExpression139() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression139() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression139()
}

func (c *current) onmultiLineGoExpression146() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression146() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression146()
}

func (c *current) onmultiLineGoExpression151() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression151() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression151()
}

func (c *current) onmultiLineGoExpression169() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonmultiLineGoExpression169() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression169()
}

func (c *current) onmultiLineGoExpression190() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonmultiLineGoExpression190() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression190()
}

func (c *current) onmultiLineGoExpression222() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonmultiLineGoExpression222() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression222()
}

func (c *current) onmultiLineGoExpression229() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression229() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression229()
}

func (c *current) onmultiLineGoExpression240() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression240() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression240()
}

func (c *current) onmultiLineGoExpression247() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression247() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression247()
}

func (c *current) onmultiLineGoExpression252() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonmultiLineGoExpression252() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression252()
}

func (c *current) onmultiLineGoExpression259() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmultiLineGoExpression259() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression259()
}

func (c *current) onmultiLineGoExpression157(valsI, endPosI interface{}) (interface{}, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonmultiLineGoExpression157() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression157(stack["valsI"], stack["endPosI"])
}

func (c *current) onmultiLineGoExpression268() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmultiLineGoExpression268() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression268()
}

func (c *current) onmultiLineGoExpression1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonmultiLineGoExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmultiLineGoExpression1(stack["exprsI"])
}

func (c *current) onSingleLineGoExpression11() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineGoExpression11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression11()
}

func (c *current) onSingleLineGoExpression21() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineGoExpression21() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression21()
}

func (c *current) onSingleLineGoExpression31() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineGoExpression31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression31()
}

func (c *current) onSingleLineGoExpression5(exprI interface{}) (interface{}, error) {
	exprIs := islice(exprI)
	if exprIs[1] == nil {
		return file.GoExpression{
			Expression: concat(exprIs[0]) + concat(exprIs[3]),
			Position:   pos(c),
		}, nil
	}

	expr := exprIs[1].(file.Expression)

	exprs := make([]file.ExpressionItem, len(expr.Expressions)+ /* open/closing paren */ 2)
	copy(exprs[1:], expr.Expressions)
	exprs[0] = file.GoExpression{
		Expression: concat(exprIs[0]),
		Position:   pos(c),
	}
	exprs[len(exprs)-1] = file.GoExpression{
		Expression: concat(exprIs[3]),
		Position:   exprIs[2].(file.Position),
	}

	return exprs, nil

}

func (p *parser) callonSingleLineGoExpression5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression5(stack["exprI"])
}

func (c *current) onSingleLineGoExpression43() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineGoExpression43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression43()
}

func (c *current) onSingleLineGoExpression38(parenI, startPosI, exprI interface{}) (interface{}, error) {
	openParen := string(char(parenI))

	closeParen := ")"
	if openParen == "[" {
		closeParen = "]"
	} else if openParen == "{" {
		closeParen = "}"
	}

	exprs := append([]file.ExpressionItem{file.GoExpression{
		Expression: openParen,
		Position:   pos(c),
	}}, castedOrZero[file.Expression](exprI).Expressions...)

	return exprs, &corgierr.Error{
		Message: "unclosed `" + openParen + "` in expression",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			EOLDelta:   1,
			Annotation: "expected a `" + closeParen + "` somewhere here",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      pos(c),
				Annotation: "for the `" + openParen + "` you opened here",
			}),
		},
	}

}

func (p *parser) callonSingleLineGoExpression38() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression38(stack["parenI"], stack["startPosI"], stack["exprI"])
}

func (c *current) onSingleLineGoExpression52() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineGoExpression52() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression52()
}

func (c *current) onSingleLineGoExpression68() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineGoExpression68() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression68()
}

func (c *current) onSingleLineGoExpression89() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineGoExpression89() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression89()
}

func (c *current) onSingleLineGoExpression121() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonSingleLineGoExpression121() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression121()
}

func (c *current) onSingleLineGoExpression128() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression128() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression128()
}

func (c *current) onSingleLineGoExpression139() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression139() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression139()
}

func (c *current) onSingleLineGoExpression146() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression146() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression146()
}

func (c *current) onSingleLineGoExpression151() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression151() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression151()
}

func (c *current) onSingleLineGoExpression169() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineGoExpression169() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression169()
}

func (c *current) onSingleLineGoExpression190() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonSingleLineGoExpression190() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression190()
}

func (c *current) onSingleLineGoExpression222() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonSingleLineGoExpression222() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression222()
}

func (c *current) onSingleLineGoExpression229() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression229() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression229()
}

func (c *current) onSingleLineGoExpression240() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression240() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression240()
}

func (c *current) onSingleLineGoExpression247() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression247() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression247()
}

func (c *current) onSingleLineGoExpression252() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonSingleLineGoExpression252() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression252()
}

func (c *current) onSingleLineGoExpression259() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineGoExpression259() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression259()
}

func (c *current) onSingleLineGoExpression157(valsI, endPosI interface{}) (interface{}, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonSingleLineGoExpression157() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression157(stack["valsI"], stack["endPosI"])
}

func (c *current) onSingleLineGoExpression268() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineGoExpression268() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression268()
}

func (c *current) onSingleLineGoExpression1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonSingleLineGoExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineGoExpression1(stack["exprsI"])
}

func (c *current) onsingleLineGoSubExpression11() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoSubExpression11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression11()
}

func (c *current) onsingleLineGoSubExpression21() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoSubExpression21() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression21()
}

func (c *current) onsingleLineGoSubExpression31() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoSubExpression31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression31()
}

func (c *current) onsingleLineGoSubExpression5(exprI interface{}) (interface{}, error) {
	exprIs := islice(exprI)
	if exprIs[1] == nil {
		return file.GoExpression{
			Expression: concat(exprIs[0]) + concat(exprIs[3]),
			Position:   pos(c),
		}, nil
	}

	expr := exprIs[1].(file.Expression)

	exprs := make([]file.ExpressionItem, len(expr.Expressions)+ /* open/closing paren */ 2)
	copy(exprs[1:], expr.Expressions)
	exprs[0] = file.GoExpression{
		Expression: concat(exprIs[0]),
		Position:   pos(c),
	}
	exprs[len(exprs)-1] = file.GoExpression{
		Expression: concat(exprIs[3]),
		Position:   exprIs[2].(file.Position),
	}

	return exprs, nil

}

func (p *parser) callonsingleLineGoSubExpression5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression5(stack["exprI"])
}

func (c *current) onsingleLineGoSubExpression43() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoSubExpression43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression43()
}

func (c *current) onsingleLineGoSubExpression38(parenI, startPosI, exprI interface{}) (interface{}, error) {
	openParen := string(char(parenI))

	closeParen := ")"
	if openParen == "[" {
		closeParen = "]"
	} else if openParen == "{" {
		closeParen = "}"
	}

	exprs := append([]file.ExpressionItem{file.GoExpression{
		Expression: openParen,
		Position:   pos(c),
	}}, castedOrZero[file.Expression](exprI).Expressions...)

	return exprs, &corgierr.Error{
		Message: "unclosed `" + openParen + "` in expression",
		ErrorAnnotation: anno(c, annotation{
			Start:      startPosI.(file.Position),
			EOLDelta:   1,
			Annotation: "expected a `" + closeParen + "` somewhere here",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      pos(c),
				Annotation: "for the `" + openParen + "` you opened here",
			}),
		},
	}

}

func (p *parser) callonsingleLineGoSubExpression38() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression38(stack["parenI"], stack["startPosI"], stack["exprI"])
}

func (c *current) onsingleLineGoSubExpression52() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoSubExpression52() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression52()
}

func (c *current) onsingleLineGoSubExpression68() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineGoSubExpression68() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression68()
}

func (c *current) onsingleLineGoSubExpression89() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineGoSubExpression89() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression89()
}

func (c *current) onsingleLineGoSubExpression121() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonsingleLineGoSubExpression121() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression121()
}

func (c *current) onsingleLineGoSubExpression128() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression128() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression128()
}

func (c *current) onsingleLineGoSubExpression139() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression139() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression139()
}

func (c *current) onsingleLineGoSubExpression146() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression146() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression146()
}

func (c *current) onsingleLineGoSubExpression151() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression151() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression151()
}

func (c *current) onsingleLineGoSubExpression169() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineGoSubExpression169() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression169()
}

func (c *current) onsingleLineGoSubExpression190() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonsingleLineGoSubExpression190() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression190()
}

func (c *current) onsingleLineGoSubExpression222() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonsingleLineGoSubExpression222() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression222()
}

func (c *current) onsingleLineGoSubExpression229() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression229() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression229()
}

func (c *current) onsingleLineGoSubExpression240() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression240() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression240()
}

func (c *current) onsingleLineGoSubExpression247() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression247() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression247()
}

func (c *current) onsingleLineGoSubExpression252() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonsingleLineGoSubExpression252() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression252()
}

func (c *current) onsingleLineGoSubExpression259() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoSubExpression259() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression259()
}

func (c *current) onsingleLineGoSubExpression157(valsI, endPosI interface{}) (interface{}, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonsingleLineGoSubExpression157() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression157(stack["valsI"], stack["endPosI"])
}

func (c *current) onsingleLineGoSubExpression268() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineGoSubExpression268() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression268()
}

func (c *current) onsingleLineGoSubExpression1(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonsingleLineGoSubExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineGoSubExpression1(stack["exprsI"])
}

func (c *current) onIfExpression2(cExprI interface{}) (interface{}, error) {
	cExpr := cExprI.(file.ChainExpression)
	expr := file.Expression{Expressions: []file.ExpressionItem{cExpr}}
	if cExpr.Default != nil {
		return expr, &corgierr.Error{
			Message: "chain expression with default as conditional",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "here", // todo: span the entire len of the expression
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remove the default"},
			},
		}
	}

	return expr, nil
}

func (p *parser) callonIfExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression2(stack["cExprI"])
}

func (c *current) onIfExpression16() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIfExpression16() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression16()
}

func (c *current) onIfExpression27() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIfExpression27() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression27()
}

func (c *current) onIfExpression38() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIfExpression38() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression38()
}

func (c *current) onIfExpression9(exprI interface{}) (interface{}, error) {
	exprIs := islice(exprI)
	if exprIs[1] == nil {
		return file.GoExpression{
			Expression: concat(exprIs[0]) + concat(exprIs[3]),
			Position:   pos(c),
		}, nil
	}

	expr := exprIs[1].(file.Expression)

	exprs := make([]file.ExpressionItem, len(expr.Expressions)+ /* open/closing paren */ 2)
	copy(exprs[1:], expr.Expressions)
	exprs[0] = file.GoExpression{
		Expression: concat(exprIs[0]),
		Position:   pos(c),
	}
	exprs[len(exprs)-1] = file.GoExpression{
		Expression: concat(exprIs[3]),
		Position:   exprIs[2].(file.Position),
	}

	return exprs, nil

}

func (p *parser) callonIfExpression9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression9(stack["exprI"])
}

func (c *current) onIfExpression50() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIfExpression50() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression50()
}

func (c *current) onIfExpression45(parenI, startPosI, exprI interface{}) (interface{}, error) {
	openParen := string(char(parenI))

	closeParen := ")"
	if openParen == "[" {
		closeParen = "]"
	} else if openParen == "{" {
		closeParen = "}"
	}

	exprs := append([]file.ExpressionItem{file.GoExpression{
		Expression: openParen,
		Position:   pos(c),
	}}, castedOrZero[file.Expression](exprI).Expressions...)

	return exprs, &corgierr.Error{
		Message: "unclosed `" + openParen + "` in expression",
		ErrorAnnotation: anno(c, annotation{
			ContextLen: 3,
			Start:      startPosI.(file.Position),
			EOLDelta:   1,
			Annotation: "expected a `" + closeParen + "` somewhere here or on a line below",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      pos(c),
				Annotation: "for the `" + openParen + "` you opened here",
			}),
		},
	}

}

func (p *parser) callonIfExpression45() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression45(stack["parenI"], stack["startPosI"], stack["exprI"])
}

func (c *current) onIfExpression60() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIfExpression60() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression60()
}

func (c *current) onIfExpression76() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonIfExpression76() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression76()
}

func (c *current) onIfExpression97() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonIfExpression97() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression97()
}

func (c *current) onIfExpression129() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonIfExpression129() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression129()
}

func (c *current) onIfExpression136() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression136() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression136()
}

func (c *current) onIfExpression147() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression147() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression147()
}

func (c *current) onIfExpression154() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression154() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression154()
}

func (c *current) onIfExpression159() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonIfExpression159() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression159()
}

func (c *current) onIfExpression177() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonIfExpression177() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression177()
}

func (c *current) onIfExpression198() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonIfExpression198() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression198()
}

func (c *current) onIfExpression230() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonIfExpression230() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression230()
}

func (c *current) onIfExpression237() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression237() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression237()
}

func (c *current) onIfExpression248() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression248() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression248()
}

func (c *current) onIfExpression255() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonIfExpression255() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression255()
}

func (c *current) onIfExpression260() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonIfExpression260() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression260()
}

func (c *current) onIfExpression267() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIfExpression267() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression267()
}

func (c *current) onIfExpression165(valsI, endPosI interface{}) (interface{}, error) {
	valIs := islice(valsI)
	return c.text, &corgierr.Error{
		Message: "rune literals may not contain multiple or zero characters",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "should contain only a single character or escape sequence",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "use a single character or escape sequence",
				Example: func() string {
					if len(valIs) > 0 {
						return "''" + concat(valIs[0]) + "'"
					}
					return "`'a'` or `'\\u1234'`"
				}(),
			},
			{
				Suggestion: "make this a string, if the context allows it",
				Code:       strconv.Quote(string(c.text[1 : len(c.text)-1])),
			},
		},
	}

}

func (p *parser) callonIfExpression165() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression165(stack["valsI"], stack["endPosI"])
}

func (c *current) onIfExpression276() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIfExpression276() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression276()
}

func (c *current) onIfExpression5(exprsI interface{}) (interface{}, error) {
	return combineExpressions(exprsI)
}

func (p *parser) callonIfExpression5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfExpression5(stack["exprsI"])
}

func (c *current) onInterpretedStringExpression2(contentsI interface{}) (interface{}, error) {
	return file.StringExpression{
		Quote:    '"',
		Contents: typedSlice[file.StringExpressionItem](contentsI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInterpretedStringExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpression2(stack["contentsI"])
}

func (c *current) onInterpretedStringExpression13() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonInterpretedStringExpression13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpression13()
}

func (c *current) onInterpretedStringExpression9(startPosI, contentsI interface{}) (interface{}, error) {
	return file.StringExpression{
			Quote:    '"',
			Contents: typedSlice[file.StringExpressionItem](contentsI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				ToEOL:      true,
				Annotation: "expected a `\"` somewhere here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the string literal started here",
				}),
			},
		}
}

func (p *parser) callonInterpretedStringExpression9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpression9(stack["startPosI"], stack["contentsI"])
}

func (c *current) onRawStringExpression2(contentsI interface{}) (interface{}, error) {
	return file.StringExpression{
		Quote:    '`',
		Contents: typedSlice[file.StringExpressionItem](contentsI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonRawStringExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawStringExpression2(stack["contentsI"])
}

func (c *current) onRawStringExpression13() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonRawStringExpression13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawStringExpression13()
}

func (c *current) onRawStringExpression9(startPosI, contentsI interface{}) (interface{}, error) {
	return file.StringExpression{
			Quote:    '`',
			Contents: typedSlice[file.StringExpressionItem](contentsI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "unclosed string literal",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				ToEOL:      true,
				Annotation: "expected a ``` somewhere here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the string literal started here",
				}),
			},
		}
}

func (p *parser) callonRawStringExpression9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawStringExpression9(stack["startPosI"], stack["contentsI"])
}

func (c *current) onInterpretedStringExpressionItem16() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonInterpretedStringExpressionItem16() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem16()
}

func (c *current) onInterpretedStringExpressionItem37() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callonInterpretedStringExpressionItem37() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem37()
}

func (c *current) onInterpretedStringExpressionItem69() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callonInterpretedStringExpressionItem69() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem69()
}

func (c *current) onInterpretedStringExpressionItem76() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonInterpretedStringExpressionItem76() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem76()
}

func (c *current) onInterpretedStringExpressionItem87() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonInterpretedStringExpressionItem87() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem87()
}

func (c *current) onInterpretedStringExpressionItem94() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callonInterpretedStringExpressionItem94() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem94()
}

func (c *current) onInterpretedStringExpressionItem99() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callonInterpretedStringExpressionItem99() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem99()
}

func (c *current) onInterpretedStringExpressionItem2() (interface{}, error) {
	return file.StringExpressionText{
		Text:     string(c.text),
		Position: pos(c),
	}, nil
}

func (p *parser) callonInterpretedStringExpressionItem2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpretedStringExpressionItem2()
}

func (c *current) onRawStringExpressionItem2() (interface{}, error) {
	return file.StringExpressionText{
		Text:     string(c.text),
		Position: pos(c),
	}, nil
}

func (p *parser) callonRawStringExpressionItem2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onRawStringExpressionItem2()
}

func (c *current) onStringExpressionInterpolation28() (interface{}, error) {
	return []byte(nil), &corgierr.Error{
		Message: "missing format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected a formatting verb here",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation28()
}

func (c *current) onStringExpressionInterpolation31() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "this is not a valid verb",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation31()
}

func (c *current) onStringExpressionInterpolation11() (interface{}, error) {
	return string(c.text[1:]), nil
}

func (p *parser) callonStringExpressionInterpolation11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation11()
}

func (c *current) onStringExpressionInterpolation39() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation39() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation39()
}

func (c *current) onStringExpressionInterpolation33(endPosI interface{}) (interface{}, error) {
	return string(c.text[1:]), &corgierr.Error{
		Message: "invalid formatter",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "invalid formatter",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      file.Position{Line: pos(c).Line, Col: pos(c).Col - 1},
				Annotation: "for this string interpolation",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on how to write a formatting placeholder"},
			{Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation33() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation33(stack["endPosI"])
}

func (c *current) onStringExpressionInterpolation2(noEscapeI, fmtDirectiveI, exprI interface{}) (interface{}, error) {
	return file.StringExpressionInterpolation{
		NoEscape:        noEscapeI != nil,
		FormatDirective: concat(fmtDirectiveI),
		Expression:      exprI.(file.Expression),
		Position:        pos(c),
	}, nil
}

func (p *parser) callonStringExpressionInterpolation2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation2(stack["noEscapeI"], stack["fmtDirectiveI"], stack["exprI"])
}

func (c *current) onStringExpressionInterpolation74() (interface{}, error) {
	return []byte(nil), &corgierr.Error{
		Message: "missing format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected a formatting verb here",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation74() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation74()
}

func (c *current) onStringExpressionInterpolation77() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "this is not a valid verb",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation77() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation77()
}

func (c *current) onStringExpressionInterpolation57() (interface{}, error) {
	return string(c.text[1:]), nil
}

func (p *parser) callonStringExpressionInterpolation57() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation57()
}

func (c *current) onStringExpressionInterpolation85() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation85() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation85()
}

func (c *current) onStringExpressionInterpolation79(endPosI interface{}) (interface{}, error) {
	return string(c.text[1:]), &corgierr.Error{
		Message: "invalid formatter",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "invalid formatter",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      file.Position{Line: pos(c).Line, Col: pos(c).Col - 1},
				Annotation: "for this string interpolation",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on how to write a formatting placeholder"},
			{Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation79() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation79(stack["endPosI"])
}

func (c *current) onStringExpressionInterpolation92() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation92() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation92()
}

func (c *current) onStringExpressionInterpolation49(noEscapeI, fmtDirectiveI, parenPosI interface{}) (interface{}, error) {
	return file.StringExpressionInterpolation{
			NoEscape:        noEscapeI != nil,
			FormatDirective: concat(fmtDirectiveI),
			Position:        pos(c),
		}, &corgierr.Error{
			Message: "interpolation is missing an expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      parenPosI.(file.Position),
				Annotation: "expected a `" + lbrace + "` here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the interpolation started here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "add an expression enclosed in braces",
					Code:       "`" + string(c.text) + "{1+1}`",
				},
				{
					Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation",
					Code:       "`#" + string(c.text) + "`",
				},
			},
		}
}

func (p *parser) callonStringExpressionInterpolation49() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation49(stack["noEscapeI"], stack["fmtDirectiveI"], stack["parenPosI"])
}

func (c *current) onStringExpressionInterpolation123() (interface{}, error) {
	return []byte(nil), &corgierr.Error{
		Message: "missing format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "expected a formatting verb here",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation123() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation123()
}

func (c *current) onStringExpressionInterpolation126() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid format verb",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "this is not a valid verb",
		}),
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on valid formatting verbs"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#` before this error by writing `##`"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation126() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation126()
}

func (c *current) onStringExpressionInterpolation106() (interface{}, error) {
	return string(c.text[1:]), nil
}

func (p *parser) callonStringExpressionInterpolation106() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation106()
}

func (c *current) onStringExpressionInterpolation134() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation134() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation134()
}

func (c *current) onStringExpressionInterpolation128(endPosI interface{}) (interface{}, error) {
	return string(c.text[1:]), &corgierr.Error{
		Message: "invalid formatter",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "invalid formatter",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      file.Position{Line: pos(c).Line, Col: pos(c).Col - 1},
				Annotation: "for this string interpolation",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "consult the docs of the Go built-in package `fmt` on how to write a formatting placeholder"},
			{Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation"},
		},
	}
}

func (p *parser) callonStringExpressionInterpolation128() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation128(stack["endPosI"])
}

func (c *current) onStringExpressionInterpolation141() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation141() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation141()
}

func (c *current) onStringExpressionInterpolation149() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonStringExpressionInterpolation149() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation149()
}

func (c *current) onStringExpressionInterpolation98(noEscapeI, fmtDirectiveI, parenPosI, startPosI, exprI interface{}) (interface{}, error) {
	return file.StringExpressionInterpolation{
			NoEscape:        noEscapeI != nil,
			FormatDirective: concat(fmtDirectiveI),
			Expression:      exprI.(file.Expression),
			Position:        pos(c),
		}, &corgierr.Error{
			Message: "unclosed string interpolation",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				EOLDelta:   1,
				Annotation: "expected a `" + rbrace + "` somewhere here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					End:        startPosI.(file.Position),
					Annotation: "for the interpolation started here",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "add the missing `" + rbrace + "`"},
				{
					Suggestion: "escape the `#` by writing `##`, if you didn't mean to start an interpolation",
					Code:       "`#" + string(c.text) + "`",
				},
			},
		}
}

func (p *parser) callonStringExpressionInterpolation98() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStringExpressionInterpolation98(stack["noEscapeI"], stack["fmtDirectiveI"], stack["parenPosI"], stack["startPosI"], stack["exprI"])
}

func (c *current) onTernaryExpression51() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression51() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression51()
}

func (c *current) onTernaryExpression2(conditionI, ifTrueI, ifFalseI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
		Condition: conditionI.(file.Expression),
		IfTrue:    ifTrueI.(file.Expression),
		IfFalse:   ifFalseI.(file.Expression),
		RParenPos: rParenPosI.(file.Position),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonTernaryExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression2(stack["conditionI"], stack["ifTrueI"], stack["ifFalseI"], stack["rParenPosI"])
}

func (c *current) onTernaryExpression57() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression57() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression57()
}

func (c *current) onTernaryExpression71() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression71() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression71()
}

func (c *current) onTernaryExpression53(startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected a condition, an if-true value, and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonTernaryExpression53() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression53(stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onTernaryExpression93() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression93() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression93()
}

func (c *current) onTernaryExpression87(posI interface{}) (interface{}, error) {
	return posI, nil
}

func (p *parser) callonTernaryExpression87() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression87(stack["posI"])
}

func (c *current) onTernaryExpression109() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression109() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression109()
}

func (c *current) onTernaryExpression106(posI interface{}) (interface{}, error) {
	return posI, nil
}

func (p *parser) callonTernaryExpression106() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression106(stack["posI"])
}

func (c *current) onTernaryExpression118() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression118() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression118()
}

func (c *current) onTernaryExpression73(conditionI, startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-true value and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonTernaryExpression73() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression73(stack["conditionI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onTernaryExpression152() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression152() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression152()
}

func (c *current) onTernaryExpression146(posI interface{}) (interface{}, error) {
	return posI, nil
}

func (p *parser) callonTernaryExpression146() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression146(stack["posI"])
}

func (c *current) onTernaryExpression168() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression168() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression168()
}

func (c *current) onTernaryExpression165(posI interface{}) (interface{}, error) {
	return posI, nil
}

func (p *parser) callonTernaryExpression165() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression165(stack["posI"])
}

func (c *current) onTernaryExpression177() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonTernaryExpression177() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression177()
}

func (c *current) onTernaryExpression120(conditionI, ifTrueI, startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			IfTrue:    ifTrueI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonTernaryExpression120() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTernaryExpression120(stack["conditionI"], stack["ifTrueI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression31() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression31()
}

func (c *current) onSingleLineTernaryExpression2(conditionI, ifTrueI, ifFalseI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
		Condition: conditionI.(file.Expression),
		IfTrue:    ifTrueI.(file.Expression),
		IfFalse:   ifFalseI.(file.Expression),
		RParenPos: rParenPosI.(file.Position),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonSingleLineTernaryExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression2(stack["conditionI"], stack["ifTrueI"], stack["ifFalseI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression37() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression37() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression37()
}

func (c *current) onSingleLineTernaryExpression51() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression51() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression51()
}

func (c *current) onSingleLineTernaryExpression33(startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected a condition, an if-true value, and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonSingleLineTernaryExpression33() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression33(stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression73() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression73() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression73()
}

func (c *current) onSingleLineTernaryExpression67(posI interface{}) (interface{}, error) {
	return posI, nil
}

func (p *parser) callonSingleLineTernaryExpression67() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression67(stack["posI"])
}

func (c *current) onSingleLineTernaryExpression89() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression89() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression89()
}

func (c *current) onSingleLineTernaryExpression86(posI interface{}) (interface{}, error) {
	return posI, nil
}

func (p *parser) callonSingleLineTernaryExpression86() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression86(stack["posI"])
}

func (c *current) onSingleLineTernaryExpression98() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression98() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression98()
}

func (c *current) onSingleLineTernaryExpression53(conditionI, startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-true value and an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonSingleLineTernaryExpression53() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression53(stack["conditionI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onSingleLineTernaryExpression132() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression132() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression132()
}

func (c *current) onSingleLineTernaryExpression126(posI interface{}) (interface{}, error) {
	return posI, nil
}

func (p *parser) callonSingleLineTernaryExpression126() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression126(stack["posI"])
}

func (c *current) onSingleLineTernaryExpression148() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression148() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression148()
}

func (c *current) onSingleLineTernaryExpression145(posI interface{}) (interface{}, error) {
	return posI, nil
}

func (p *parser) callonSingleLineTernaryExpression145() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression145(stack["posI"])
}

func (c *current) onSingleLineTernaryExpression157() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineTernaryExpression157() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression157()
}

func (c *current) onSingleLineTernaryExpression100(conditionI, ifTrueI, startPosI, rParenPosI interface{}) (interface{}, error) {
	return file.TernaryExpression{
			Condition: conditionI.(file.Expression),
			IfTrue:    ifTrueI.(file.Expression),
			RParenPos: rParenPosI.(file.Position),
			Position:  pos(c),
		}, &corgierr.Error{
			Message: "malformed ternary expression",
			ErrorAnnotation: anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        rParenPosI.(file.Position),
				Annotation: "expected an if-false value here",
			}),
			ShouldBe: "`?(condition, valueIfTrue, valueIfFalse)`",
			Example:  "`?(num % 2 == 0, \"num is even\", \"num is uneven\")`",
		}
}

func (p *parser) callonSingleLineTernaryExpression100() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineTernaryExpression100(stack["conditionI"], stack["ifTrueI"], stack["startPosI"], stack["rParenPosI"])
}

func (c *current) onChainExpression20() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression20() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression20()
}

func (c *current) onChainExpression36() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression36() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression36()
}

func (c *current) onChainExpression63(derefsI, rootI, checkRootI, chainI, defaultI, endPosI interface{}) (bool, error) {
	return checkRootI != nil || len(islice(chainI)) > 0 || defaultI != nil, nil
}

func (p *parser) callonChainExpression63() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression63(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onChainExpression2(derefsI, rootI, checkRootI, chainI, defaultI, endPosI interface{}) (interface{}, error) {
	expr := file.ChainExpression{
		Root:       rootI.(file.GoExpression),
		CheckRoot:  checkRootI != nil,
		Chain:      typedSlice[file.ChainExpressionItem](chainI),
		DerefCount: len(islice(derefsI)),
		Position:   pos(c),
	}
	if defaultI != nil {
		defaultOpPos := getTuple[file.Position](defaultI, 1)
		expr.DefaultOpPos = &defaultOpPos
		defaultVal := getTuple[file.Expression](defaultI, -1)
		expr.Default = &defaultVal
	}

	return expr, nil
}

func (p *parser) callonChainExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression2(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onChainExpression66() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression66() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression66()
}

func (c *current) onChainExpression83() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression83() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression83()
}

func (c *current) onChainExpression89(startPosI, derefsI, rootI, checkRootI, chainI, endPosI interface{}) (bool, error) {
	return checkRootI != nil || len(islice(chainI)) > 0, nil
}

func (p *parser) callonChainExpression89() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression89(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"])
}

func (c *current) onChainExpression91() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression91() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression91()
}

func (c *current) onChainExpression99() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpression99() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression99()
}

func (c *current) onChainExpression105(startPosI, derefsI, rootI, checkRootI, chainI, endPosI, malStartPosI, malEndPosI interface{}) (bool, error) {
	var multiline string
	if malEndPosI.(file.Position).Line > malStartPosI.(file.Position).Line {
		multiline += " and the lines below"
	}

	return false, &corgierr.Error{
		Message: "malformed chain expression",
		ErrorAnnotation: anno(c, annotation{
			Start:      malStartPosI.(file.Position),
			End:        malEndPosI.(file.Position),
			Annotation: "unable to parse this" + multiline + " as part of a chain expression",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        malStartPosI.(file.Position),
				Annotation: "that you started here",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "did you mean to put a default here? default values start with the `~` operator",
				Example:    "`woof?.bark[12?] ~ someDefault`",
			},
			{
				Suggestion: "remember that chain expressions cannot be used as part of a Go expression;\n" +
					"you can either write a chain expression, or a Go expression",
			},
		},
	}
}

func (p *parser) callonChainExpression105() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpression105(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"], stack["malStartPosI"], stack["malEndPosI"])
}

func (c *current) onchainExpressionRoot2() (interface{}, error) {
	return file.GoExpression{
		Expression: string(c.text),
		Position:   pos(c),
	}, nil
}

func (p *parser) callonchainExpressionRoot2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onchainExpressionRoot2()
}

func (c *current) onchainExpressionRoot11(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonchainExpressionRoot11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onchainExpressionRoot11(stack["ident"])
}

func (c *current) onchainExpressionRoot30() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonchainExpressionRoot30() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onchainExpressionRoot30()
}

func (c *current) onchainExpressionRoot17(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonchainExpressionRoot17() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onchainExpressionRoot17(stack["identI"], stack["endPosI"])
}

func (c *current) onchainExpressionRoot8(identI interface{}) (interface{}, error) {
	ident := identI.(file.GoIdent)
	return file.GoExpression{
		Expression: ident.Ident,
		Position:   ident.Position,
	}, nil
}

func (p *parser) callonchainExpressionRoot8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onchainExpressionRoot8(stack["identI"])
}

func (c *current) onSingleLineChainExpression20() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression20() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression20()
}

func (c *current) onSingleLineChainExpression31() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression31()
}

func (c *current) onSingleLineChainExpression54(derefsI, rootI, checkRootI, chainI, defaultI, endPosI interface{}) (bool, error) {
	return checkRootI != nil || len(islice(chainI)) > 0 || defaultI != nil, nil
}

func (p *parser) callonSingleLineChainExpression54() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression54(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpression2(derefsI, rootI, checkRootI, chainI, defaultI, endPosI interface{}) (interface{}, error) {
	expr := file.ChainExpression{
		Root:       rootI.(file.GoExpression),
		CheckRoot:  checkRootI != nil,
		Chain:      typedSlice[file.ChainExpressionItem](chainI),
		DerefCount: len(islice(derefsI)),
		Position:   pos(c),
	}
	if defaultI != nil {
		defaultOpPos := getTuple[file.Position](defaultI, 1)
		expr.DefaultOpPos = &defaultOpPos
		defaultVal := getTuple[file.Expression](defaultI, -1)
		expr.Default = &defaultVal
	}

	return expr, nil
}

func (p *parser) callonSingleLineChainExpression2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression2(stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["defaultI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpression57() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression57() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression57()
}

func (c *current) onSingleLineChainExpression74() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression74() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression74()
}

func (c *current) onSingleLineChainExpression80(startPosI, derefsI, rootI, checkRootI, chainI, endPosI interface{}) (bool, error) {
	return checkRootI != nil || len(islice(chainI)) > 0, nil
}

func (p *parser) callonSingleLineChainExpression80() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression80(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpression82() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression82() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression82()
}

func (c *current) onSingleLineChainExpression90() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpression90() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression90()
}

func (c *current) onSingleLineChainExpression96(startPosI, derefsI, rootI, checkRootI, chainI, endPosI, malStartPosI, malEndPosI interface{}) (bool, error) {
	return false, &corgierr.Error{
		Message: "malformed chain expression",
		ErrorAnnotation: anno(c, annotation{
			Start:      malStartPosI.(file.Position),
			End:        malEndPosI.(file.Position),
			Annotation: "unable to parse this as part of a chain expression",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:      startPosI.(file.Position),
				End:        malStartPosI.(file.Position),
				Annotation: "that you started here",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "did you mean to put a default here? default values start with the `~` operator",
				Example:    "`woof?.bark[12?] ~ someDefault`",
			},
			{
				Suggestion: "remember that chain expressions cannot be used as part of a Go expression;\n" +
					"you can either write a chain expression, or a Go expression",
			},
		},
	}
}

func (p *parser) callonSingleLineChainExpression96() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpression96(stack["startPosI"], stack["derefsI"], stack["rootI"], stack["checkRootI"], stack["chainI"], stack["endPosI"], stack["malStartPosI"], stack["malEndPosI"])
}

func (c *current) onChainExpressionItem15(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonChainExpressionItem15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem15(stack["ident"])
}

func (c *current) onChainExpressionItem34() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpressionItem34() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem34()
}

func (c *current) onChainExpressionItem21(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonChainExpressionItem21() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem21(stack["identI"], stack["endPosI"])
}

func (c *current) onChainExpressionItem3(identI, checkI interface{}) (interface{}, error) {
	return file.DotIdentExpression{
		Ident:    identI.(file.GoIdent),
		Check:    checkI != nil,
		Position: pos(c),
	}, nil
}

func (p *parser) callonChainExpressionItem3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem3(stack["identI"], stack["checkI"])
}

func (c *current) onChainExpressionItem50(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonChainExpressionItem50() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem50(stack["ident"])
}

func (c *current) onChainExpressionItem69() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpressionItem69() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem69()
}

func (c *current) onChainExpressionItem56(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonChainExpressionItem56() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem56(stack["identI"], stack["endPosI"])
}

func (c *current) onChainExpressionItem78(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonChainExpressionItem78() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem78(stack["ident"])
}

func (c *current) onChainExpressionItem97() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpressionItem97() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem97()
}

func (c *current) onChainExpressionItem84(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonChainExpressionItem84() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem84(stack["identI"], stack["endPosI"])
}

func (c *current) onChainExpressionItem104() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonChainExpressionItem104() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem104()
}

func (c *current) onChainExpressionItem43(packageI, typeI, rParenPosI, checkI interface{}) (interface{}, error) {
	var packageIdent *file.GoIdent
	if packageI != nil {
		packageIdentVal := getTuple[file.GoIdent](packageI, 0)
		packageIdent = &packageIdentVal
	}

	return file.TypeAssertionExpression{
		Package:   packageIdent,
		Type:      typeI.(file.GoIdent),
		RParenPos: rParenPosI.(file.Position),
		Check:     checkI != nil,
	}, nil
}

func (p *parser) callonChainExpressionItem43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChainExpressionItem43(stack["packageI"], stack["typeI"], stack["rParenPosI"], stack["checkI"])
}

func (c *current) onSingleLineChainExpressionItem10(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonSingleLineChainExpressionItem10() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem10(stack["ident"])
}

func (c *current) onSingleLineChainExpressionItem29() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpressionItem29() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem29()
}

func (c *current) onSingleLineChainExpressionItem16(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonSingleLineChainExpressionItem16() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem16(stack["identI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpressionItem3(identI, checkI interface{}) (interface{}, error) {
	return file.DotIdentExpression{
		Ident:    identI.(file.GoIdent),
		Check:    checkI != nil,
		Position: pos(c),
	}, nil
}

func (p *parser) callonSingleLineChainExpressionItem3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem3(stack["identI"], stack["checkI"])
}

func (c *current) onSingleLineChainExpressionItem45(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonSingleLineChainExpressionItem45() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem45(stack["ident"])
}

func (c *current) onSingleLineChainExpressionItem64() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpressionItem64() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem64()
}

func (c *current) onSingleLineChainExpressionItem51(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonSingleLineChainExpressionItem51() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem51(stack["identI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpressionItem73(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonSingleLineChainExpressionItem73() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem73(stack["ident"])
}

func (c *current) onSingleLineChainExpressionItem92() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpressionItem92() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem92()
}

func (c *current) onSingleLineChainExpressionItem79(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonSingleLineChainExpressionItem79() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem79(stack["identI"], stack["endPosI"])
}

func (c *current) onSingleLineChainExpressionItem99() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineChainExpressionItem99() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem99()
}

func (c *current) onSingleLineChainExpressionItem38(packageI, typeI, rParenPosI, checkI interface{}) (interface{}, error) {
	var packageIdent *file.GoIdent
	if packageI != nil {
		packageIdentVal := getTuple[file.GoIdent](packageI, 0)
		packageIdent = &packageIdentVal
	}

	return file.TypeAssertionExpression{
		Package:   packageIdent,
		Type:      typeI.(file.GoIdent),
		RParenPos: rParenPosI.(file.Position),
		Check:     checkI != nil,
	}, nil
}

func (p *parser) callonSingleLineChainExpressionItem38() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineChainExpressionItem38(stack["packageI"], stack["typeI"], stack["rParenPosI"], stack["checkI"])
}

func (c *current) onIndexExpression3() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIndexExpression3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIndexExpression3()
}

func (c *current) onIndexExpression29() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonIndexExpression29() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIndexExpression29()
}

func (c *current) onIndexExpression1(exprI, checkIndexI, rBracePosI, checkValueI interface{}) (interface{}, error) {
	return file.IndexExpression{
		LBracePos:  pos(c),
		Index:      exprI.(file.Expression),
		RBracePos:  rBracePosI.(file.Position),
		CheckIndex: checkIndexI != nil,
		CheckValue: checkValueI != nil,
	}, nil
}

func (p *parser) callonIndexExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIndexExpression1(stack["exprI"], stack["checkIndexI"], stack["rBracePosI"], stack["checkValueI"])
}

func (c *current) onSingleLineIndexExpression3() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineIndexExpression3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIndexExpression3()
}

func (c *current) onSingleLineIndexExpression24() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineIndexExpression24() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIndexExpression24()
}

func (c *current) onSingleLineIndexExpression1(exprI, checkIndexI, rBracePosI, checkValueI interface{}) (interface{}, error) {
	return file.IndexExpression{
		LBracePos:  pos(c),
		Index:      exprI.(file.Expression),
		RBracePos:  rBracePosI.(file.Position),
		CheckIndex: checkIndexI != nil,
		CheckValue: checkValueI != nil,
	}, nil
}

func (p *parser) callonSingleLineIndexExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineIndexExpression1(stack["exprI"], stack["checkIndexI"], stack["rBracePosI"], stack["checkValueI"])
}

func (c *current) onParenExpression3() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonParenExpression3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onParenExpression3()
}

func (c *current) onParenExpression23() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonParenExpression23() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onParenExpression23()
}

func (c *current) onParenExpression1(argsI, rParenPosI, checkI interface{}) (interface{}, error) {
	return file.ParenExpression{
		LParenPos: pos(c),
		Args:      castedOrZero[[]file.Expression](argsI),
		RParenPos: pos(c),
		Check:     checkI != nil,
	}, nil
}

func (p *parser) callonParenExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onParenExpression1(stack["argsI"], stack["rParenPosI"], stack["checkI"])
}

func (c *current) onparenExpressionArgs1(firstI, restI interface{}) (interface{}, error) {
	restTuples := islice(restI)

	args := make([]file.Expression, 1+len(restTuples))
	args[0] = firstI.(file.Expression)
	for i, at := range restTuples {
		args[i+1] = getTuple[file.Expression](at, -1)
	}

	return args, nil
}

func (p *parser) callonparenExpressionArgs1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onparenExpressionArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onSingleLineParenExpression3() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineParenExpression3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineParenExpression3()
}

func (c *current) onSingleLineParenExpression18() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSingleLineParenExpression18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineParenExpression18()
}

func (c *current) onSingleLineParenExpression1(argsI, rParenPosI, checkI interface{}) (interface{}, error) {
	return file.ParenExpression{
		LParenPos: pos(c),
		Args:      castedOrZero[[]file.Expression](argsI),
		RParenPos: pos(c),
		Check:     checkI != nil,
	}, nil
}

func (p *parser) callonSingleLineParenExpression1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineParenExpression1(stack["argsI"], stack["rParenPosI"], stack["checkI"])
}

func (c *current) onsingleLinearenExpressionArgs1(firstI, restI interface{}) (interface{}, error) {
	restTuples := islice(restI)

	args := make([]file.Expression, 1+len(restTuples))
	args[0] = firstI.(file.Expression)
	for i, at := range restTuples {
		args[i+1] = getTuple[file.Expression](at, -1)
	}

	return args, nil
}

func (p *parser) callonsingleLinearenExpressionArgs1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLinearenExpressionArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onGoType1(goTypeI interface{}) (interface{}, error) {
	return file.GoType{Type: concat(goTypeI), Position: pos(c)}, nil
}

func (p *parser) callonGoType1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onGoType1(stack["goTypeI"])
}

func (c *current) ongoFieldDecl33() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "unclosed string literal",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			EOLDelta:   1,
			Annotation: "expected a ``` somewhere here",
		}),
	}
}

func (p *parser) callongoFieldDecl33() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl33()
}

func (c *current) ongoFieldDecl57() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoFieldDecl57() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl57()
}

func (c *current) ongoFieldDecl78() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoFieldDecl78() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl78()
}

func (c *current) ongoFieldDecl110() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callongoFieldDecl110() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl110()
}

func (c *current) ongoFieldDecl117() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl117() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl117()
}

func (c *current) ongoFieldDecl128() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl128() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl128()
}

func (c *current) ongoFieldDecl135() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl135() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl135()
}

func (c *current) ongoFieldDecl140() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl140() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl140()
}

func (c *current) ongoFieldDecl157() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
	})

	return c.text, &corgierr.Error{
		Message: "invalid little u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        6,
			Annotation: "expected `\\u`, followed by four hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoFieldDecl157() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl157()
}

func (c *current) ongoFieldDecl178() (interface{}, error) {
	suggestions := []corgierr.Suggestion{
		{
			Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
			Code:       "`\\\\" + string(c.text[1:]) + "`",
		},
	}
	if len(c.text) >= 4 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a two digit hex escape",
			Code:       "`\\x" + string(c.text[2:4]) + "`",
		})
	}
	if len(c.text) >= 6 {
		suggestions = append(suggestions, corgierr.Suggestion{
			Suggestion: "make this a little u escape",
			Code:       "`\\u" + string(c.text[2:6]) + "`",
		})
	}
	suggestions = append(suggestions, corgierr.Suggestion{
		Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
		Example:    "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
	})
	return c.text, &corgierr.Error{
		Message: "invalid big u escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        10,
			Annotation: "expected `\\U`, followed by eight hex digits",
		}),
		Example:     "`\\u1a7f`",
		Suggestions: suggestions,
	}

}

func (p *parser) callongoFieldDecl178() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl178()
}

func (c *current) ongoFieldDecl210() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid hex byte escape",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        4,
			Annotation: "expected `\\x`, followed by two hex digits",
		}),
		Example: "`\\x1f`",
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
				Code:       "`\\\\" + string(c.text[1:]) + "`",
			},
		},
	}

}

func (p *parser) callongoFieldDecl210() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl210()
}

func (c *current) ongoFieldDecl217() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a big U escape",
				Code:       "`\\U" + string(c.text[1:9]) + "`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl217() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl217()
}

func (c *current) ongoFieldDecl228() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a little u escape",
				Code:       "`\\u" + string(c.text[1:5]) + "`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl228() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl228()
}

func (c *current) ongoFieldDecl235() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			}, {
				Suggestion: "make this a hex escape",
				Code:       "`\\x" + string(c.text[1:3]) + "`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl235() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl235()
}

func (c *current) ongoFieldDecl240() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "invalid escape sequence",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Len:        2,
			Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "if you didn't mean to write an escape, escape the `\\`",
				Code:       "`\\\\`",
			},
		},
	}
}

func (p *parser) callongoFieldDecl240() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl240()
}

func (c *current) ongoFieldDecl146() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "unclosed string literal",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			EOLDelta:   1,
			Annotation: "expected a `\"` somewhere here",
		}),
	}

}

func (p *parser) callongoFieldDecl146() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.ongoFieldDecl146()
}

func (c *current) onMixin12(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonMixin12() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin12(stack["identI"])
}

func (c *current) onMixin31() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixin31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin31()
}

func (c *current) onMixin18(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonMixin18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin18(stack["identI"], stack["endPosI"])
}

func (c *current) onMixin9(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonMixin9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin9(stack["identI"])
}

func (c *current) onMixin40() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixin40() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin40()
}

func (c *current) onMixin37(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixin37() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin37(stack["posI"])
}

func (c *current) onMixin65() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixin65() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin65()
}

func (c *current) onMixin59(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixin59() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin59(stack["identI"], stack["endPosI"])
}

func (c *current) onMixin2(nameI, paramsI, bodyI interface{}) (interface{}, error) {
	params := castedOrZero[file.Mixin](paramsI)
	return file.Mixin{
		Name:      nameI.(file.Ident),
		LParenPos: params.LParenPos,
		Params:    params.Params,
		RParenPos: params.RParenPos,
		Body:      bodyI.(file.Scope),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonMixin2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin2(stack["nameI"], stack["paramsI"], stack["bodyI"])
}

func (c *current) onMixin80() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixin80() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin80()
}

func (c *current) onMixin76(posI, bodyI interface{}) (interface{}, error) {
	return file.Mixin{
			Body:     bodyI.(file.Scope),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "mixin: missing name",
			ErrorAnnotation: anno(c, annotation{
				Start:       posI.(file.Position),
				StartOffset: 1,
				Annotation:  "expected the name of the mixin here",
			}),
			Example: "`mixin woof\n" +
				"  > bark`",
		}
}

func (p *parser) callonMixin76() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixin76(stack["posI"], stack["bodyI"])
}

func (c *current) onmixinParamList28() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParamList28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamList28()
}

func (c *current) onmixinParamList2(paramsI, rParenPosI interface{}) (interface{}, error) {
	return file.Mixin{
		LParenPos: ptr(pos(c)),
		Params:    castedOrZero[[]file.MixinParam](paramsI),
		RParenPos: ptr(rParenPosI.(file.Position)),
	}, nil
}

func (p *parser) callonmixinParamList2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamList2(stack["paramsI"], stack["rParenPosI"])
}

func (c *current) onmixinParamList49() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParamList49() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamList49()
}

func (c *current) onmixinParamList30(paramsI, posI interface{}) (interface{}, error) {
	return file.Mixin{
			LParenPos: ptr(pos(c)),
			Params:    castedOrZero[[]file.MixinParam](paramsI),
		}, &corgierr.Error{
			Message: "mixin parameters: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonmixinParamList30() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamList30(stack["paramsI"], stack["posI"])
}

func (c *current) onmixinParams1(firstI, restI interface{}) (interface{}, error) {
	restIs := islice(restI)
	mixinParams := make([]file.MixinParam, 1+len(restIs))
	mixinParams[0] = firstI.(file.MixinParam)
	for i, ai := range restIs {
		mixinParams[i+1] = getTuple[file.MixinParam](ai, -1)
	}

	return mixinParams, nil
}

func (p *parser) callonmixinParams1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParams1(stack["firstI"], stack["restI"])
}

func (c *current) onmixinParam8(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonmixinParam8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam8(stack["identI"])
}

func (c *current) onmixinParam27() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParam27() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam27()
}

func (c *current) onmixinParam14(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonmixinParam14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam14(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinParam5(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonmixinParam5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam5(stack["identI"])
}

func (c *current) onmixinParam36() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParam36() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam36()
}

func (c *current) onmixinParam33(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinParam33() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam33(stack["posI"])
}

func (c *current) onmixinParam61() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParam61() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam61()
}

func (c *current) onmixinParam55(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinParam55() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam55(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinParam68() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParam68() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam68()
}

func (c *current) onmixinParam1(nameI, posI, typeI, defaultI interface{}) (interface{}, error) {
	defaultTuple := islice(defaultI)
	var paramDefault file.MixinParam
	if len(defaultTuple) == 2 {
		paramDefault = defaultTuple[1].(file.MixinParam)
	}

	typeTuple := islice(typeI)
	var paramType *file.GoType
	if len(typeTuple) == 2 {
		paramType = ptr(typeTuple[1].(file.GoType))
	}

	p := file.MixinParam{
		Name:      nameI.(file.Ident),
		Type:      paramType,
		AssignPos: paramDefault.AssignPos,
		Default:   paramDefault.Default,
		Position:  pos(c),
	}
	if p.Type == nil && p.Default == nil {
		return p, &corgierr.Error{
			Message: "mixin param: need either a type or a default",
			ErrorAnnotation: anno(c, annotation{
				Start:       posI.(file.Position),
				StartOffset: 1,
				Annotation:  "expected either a type or a default here",
			}),
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "give this param a type", Code: "`" + p.Name.Ident + " string`"},
				{Suggestion: "give this param a default with an inferrable type", Code: "`" + p.Name.Ident + "=\"woof\"`"},
			},
		}
	}

	return p, nil
}

func (p *parser) callonmixinParam1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParam1(stack["nameI"], stack["posI"], stack["typeI"], stack["defaultI"])
}

func (c *current) onmixinParamDefault2(exprI interface{}) (interface{}, error) {
	return file.MixinParam{
		AssignPos: ptr(pos(c)),
		Default:   ptrOrNil[file.Expression](exprI),
	}, nil
}

func (p *parser) callonmixinParamDefault2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamDefault2(stack["exprI"])
}

func (c *current) onmixinParamDefault13() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinParamDefault13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamDefault13()
}

func (c *current) onmixinParamDefault9(posI interface{}) (interface{}, error) {
	return file.MixinParam{
			AssignPos: ptr(pos(c)),
		}, &corgierr.Error{
			Message: "mixin param: missing default",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "here",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "because of this `=`",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remove the `=`, if you didn't mean to define a default"},
			},
		}
}

func (p *parser) callonmixinParamDefault9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinParamDefault9(stack["posI"])
}

func (c *current) onReturn8() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "here",
		}),
	}
}

func (p *parser) callonReturn8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onReturn8()
}

func (c *current) onReturn1(errExprI interface{}) (interface{}, error) {
	return file.Return{
		Err:      ptrOrNil[file.Expression](errExprI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonReturn1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onReturn1(stack["errExprI"])
}

func (c *current) onMixinCall8(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonMixinCall8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall8(stack["identI"])
}

func (c *current) onMixinCall27() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCall27() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall27()
}

func (c *current) onMixinCall14(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonMixinCall14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall14(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCall39(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonMixinCall39() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall39(stack["identI"])
}

func (c *current) onMixinCall58() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCall58() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall58()
}

func (c *current) onMixinCall45(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonMixinCall45() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall45(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCall36(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonMixinCall36() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall36(stack["identI"])
}

func (c *current) onMixinCall67() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCall67() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall67()
}

func (c *current) onMixinCall64(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixinCall64() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall64(stack["posI"])
}

func (c *current) onMixinCall92() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCall92() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall92()
}

func (c *current) onMixinCall86(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixinCall86() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall86(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCall1(namespaceI, nameI, argsI, bodyI interface{}) (interface{}, error) {
	args := castedOrZero[file.MixinCall](argsI)
	return file.MixinCall{
		Name:      nameI.(file.Ident),
		LParenPos: args.LParenPos,
		Args:      args.Args,
		RParenPos: args.RParenPos,
		Body:      bodyI.(file.Scope),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonMixinCall1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["bodyI"])
}

func (c *current) onInlineMixinCall8(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonInlineMixinCall8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall8(stack["identI"])
}

func (c *current) onInlineMixinCall27() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonInlineMixinCall27() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall27()
}

func (c *current) onInlineMixinCall14(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonInlineMixinCall14() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall14(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineMixinCall39(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonInlineMixinCall39() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall39(stack["identI"])
}

func (c *current) onInlineMixinCall58() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonInlineMixinCall58() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall58()
}

func (c *current) onInlineMixinCall45(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonInlineMixinCall45() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall45(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineMixinCall36(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonInlineMixinCall36() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall36(stack["identI"])
}

func (c *current) onInlineMixinCall67() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonInlineMixinCall67() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall67()
}

func (c *current) onInlineMixinCall64(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonInlineMixinCall64() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall64(stack["posI"])
}

func (c *current) onInlineMixinCall92() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonInlineMixinCall92() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall92()
}

func (c *current) onInlineMixinCall86(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonInlineMixinCall86() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall86(stack["identI"], stack["endPosI"])
}

func (c *current) onInlineMixinCall1(namespaceI, nameI, argsI, bodyI interface{}) (interface{}, error) {
	args := castedOrZero[file.MixinCall](argsI)
	return file.MixinCall{
		Name:      nameI.(file.Ident),
		LParenPos: args.LParenPos,
		Args:      args.Args,
		RParenPos: args.RParenPos,
		Body:      bodyI.(file.Scope),
		Position:  pos(c),
	}, nil
}

func (p *parser) callonInlineMixinCall1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineMixinCall1(stack["namespaceI"], stack["nameI"], stack["argsI"], stack["bodyI"])
}

func (c *current) onmixinArgList28() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArgList28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgList28()
}

func (c *current) onmixinArgList2(argsI, rParenPosI interface{}) (interface{}, error) {
	return file.MixinCall{
		LParenPos: ptr(pos(c)),
		Args:      castedOrZero[[]file.MixinArg](argsI),
		RParenPos: ptr(rParenPosI.(file.Position)),
	}, nil
}

func (p *parser) callonmixinArgList2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgList2(stack["argsI"], stack["rParenPosI"])
}

func (c *current) onmixinArgList49() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArgList49() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgList49()
}

func (c *current) onmixinArgList30(argsI, posI interface{}) (interface{}, error) {
	return file.MixinCall{
			LParenPos: ptr(pos(c)),
			Args:      castedOrZero[[]file.MixinArg](argsI),
		}, &corgierr.Error{
			Message: "mixin argeters: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonmixinArgList30() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgList30(stack["argsI"], stack["posI"])
}

func (c *current) onsingleLineMixinArgList18() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArgList18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgList18()
}

func (c *current) onsingleLineMixinArgList2(argsI, rParenPosI interface{}) (interface{}, error) {
	return file.MixinCall{
		LParenPos: ptr(pos(c)),
		Args:      castedOrZero[[]file.MixinArg](argsI),
		RParenPos: ptr(rParenPosI.(file.Position)),
	}, nil
}

func (p *parser) callonsingleLineMixinArgList2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgList2(stack["argsI"], stack["rParenPosI"])
}

func (c *current) onsingleLineMixinArgList34() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArgList34() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgList34()
}

func (c *current) onsingleLineMixinArgList20(argsI, posI interface{}) (interface{}, error) {
	return file.MixinCall{
			LParenPos: ptr(pos(c)),
			Args:      castedOrZero[[]file.MixinArg](argsI),
		}, &corgierr.Error{
			Message: "mixin argeters: unclosed `(`",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a `)`",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					Start:      pos(c),
					Annotation: "for the `(` you opened here",
				}),
			},
		}
}

func (p *parser) callonsingleLineMixinArgList20() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgList20(stack["argsI"], stack["posI"])
}

func (c *current) onmixinArgs1(firstI, restI interface{}) (interface{}, error) {
	restIs := islice(restI)
	mixinArgs := make([]file.MixinArg, 1+len(restIs))
	mixinArgs[0] = firstI.(file.MixinArg)
	for i, ai := range restIs {
		mixinArgs[i+1] = getTuple[file.MixinArg](ai, -1)
	}

	return mixinArgs, nil
}

func (p *parser) callonmixinArgs1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onsingleLineMixinArgs1(firstI, restI interface{}) (interface{}, error) {
	restIs := islice(restI)
	mixinArgs := make([]file.MixinArg, 1+len(restIs))
	mixinArgs[0] = firstI.(file.MixinArg)
	for i, ai := range restIs {
		mixinArgs[i+1] = getTuple[file.MixinArg](ai, -1)
	}

	return mixinArgs, nil
}

func (p *parser) callonsingleLineMixinArgs1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArgs1(stack["firstI"], stack["restI"])
}

func (c *current) onmixinArg9(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonmixinArg9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg9(stack["identI"])
}

func (c *current) onmixinArg28() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg28()
}

func (c *current) onmixinArg15(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonmixinArg15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg15(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinArg6(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonmixinArg6() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg6(stack["identI"])
}

func (c *current) onmixinArg37() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg37() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg37()
}

func (c *current) onmixinArg34(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinArg34() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg34(stack["posI"])
}

func (c *current) onmixinArg62() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg62() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg62()
}

func (c *current) onmixinArg56(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinArg56() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg56(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinArg2(nameI, valI interface{}) (interface{}, error) {
	return file.MixinArg{
		Name:  nameI.(file.Ident),
		Value: valI.(file.Expression),
	}, nil
}

func (p *parser) callonmixinArg2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg2(stack["nameI"], stack["valI"])
}

func (c *current) onmixinArg82(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonmixinArg82() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg82(stack["identI"])
}

func (c *current) onmixinArg101() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg101() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg101()
}

func (c *current) onmixinArg88(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonmixinArg88() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg88(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinArg79(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonmixinArg79() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg79(stack["identI"])
}

func (c *current) onmixinArg110() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg110() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg110()
}

func (c *current) onmixinArg107(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinArg107() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg107(stack["posI"])
}

func (c *current) onmixinArg135() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg135() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg135()
}

func (c *current) onmixinArg129(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonmixinArg129() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg129(stack["identI"], stack["endPosI"])
}

func (c *current) onmixinArg147() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinArg147() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg147()
}

func (c *current) onmixinArg75(nameI, posI interface{}) (interface{}, error) {
	return file.MixinArg{
			Name: nameI.(file.Ident),
		}, &corgierr.Error{
			Message: "missing mixin argument value",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a value here",
			}),
			Example: "`argName=123`",
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remember that you always need to write the name of the arg before it's value"},
			},
		}
}

func (p *parser) callonmixinArg75() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinArg75(stack["nameI"], stack["posI"])
}

func (c *current) onsingleLineMixinArg9(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonsingleLineMixinArg9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg9(stack["identI"])
}

func (c *current) onsingleLineMixinArg28() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg28()
}

func (c *current) onsingleLineMixinArg15(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonsingleLineMixinArg15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg15(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinArg6(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonsingleLineMixinArg6() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg6(stack["identI"])
}

func (c *current) onsingleLineMixinArg37() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg37() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg37()
}

func (c *current) onsingleLineMixinArg34(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonsingleLineMixinArg34() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg34(stack["posI"])
}

func (c *current) onsingleLineMixinArg62() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg62() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg62()
}

func (c *current) onsingleLineMixinArg56(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonsingleLineMixinArg56() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg56(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinArg2(nameI, valI interface{}) (interface{}, error) {
	return file.MixinArg{
		Name:  nameI.(file.Ident),
		Value: valI.(file.Expression),
	}, nil
}

func (p *parser) callonsingleLineMixinArg2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg2(stack["nameI"], stack["valI"])
}

func (c *current) onsingleLineMixinArg82(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonsingleLineMixinArg82() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg82(stack["identI"])
}

func (c *current) onsingleLineMixinArg101() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg101() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg101()
}

func (c *current) onsingleLineMixinArg88(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonsingleLineMixinArg88() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg88(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinArg79(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonsingleLineMixinArg79() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg79(stack["identI"])
}

func (c *current) onsingleLineMixinArg110() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg110() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg110()
}

func (c *current) onsingleLineMixinArg107(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonsingleLineMixinArg107() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg107(stack["posI"])
}

func (c *current) onsingleLineMixinArg135() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg135() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg135()
}

func (c *current) onsingleLineMixinArg129(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonsingleLineMixinArg129() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg129(stack["identI"], stack["endPosI"])
}

func (c *current) onsingleLineMixinArg147() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonsingleLineMixinArg147() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg147()
}

func (c *current) onsingleLineMixinArg75(nameI, posI interface{}) (interface{}, error) {
	return file.MixinArg{
			Name: nameI.(file.Ident),
		}, &corgierr.Error{
			Message: "missing mixin argument value",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a value here",
			}),
			Example: "`argName=123`",
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "remember that you always need to write the name of the arg before it's value"},
			},
		}
}

func (p *parser) callonsingleLineMixinArg75() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onsingleLineMixinArg75(stack["nameI"], stack["posI"])
}

func (c *current) onmixinCallBody2(shI interface{}) (interface{}, error) {
	return file.Scope{shI.(file.MixinMainBlockShorthand)}, nil
}

func (p *parser) callonmixinCallBody2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallBody2(stack["shI"])
}

func (c *current) onMixinMainBlockShorthand6() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "here",
		}),
	}
}

func (p *parser) callonMixinMainBlockShorthand6() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand6()
}

func (c *current) onMixinMainBlockShorthand2(bodyI interface{}) (interface{}, error) {
	return file.MixinMainBlockShorthand{
		Body:     bodyI.(file.Scope),
		Position: pos(c),
	}, nil
}

func (p *parser) callonMixinMainBlockShorthand2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand2(stack["bodyI"])
}

func (c *current) onMixinMainBlockShorthand24() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "here",
		}),
	}
}

func (p *parser) callonMixinMainBlockShorthand24() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand24()
}

func (c *current) onMixinMainBlockShorthand28() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixinMainBlockShorthand28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand28()
}

func (c *current) onMixinMainBlockShorthand20(posI interface{}) (interface{}, error) {
	return file.MixinMainBlockShorthand{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing body",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an indented body",
			}),
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "if you want the `_` block to write nothing,\n" +
						"use a block directive inside the body of the mixin call",
					Example: "`+woof\n" +
						"  block _`",
				},
			},
		}
}

func (p *parser) callonMixinMainBlockShorthand20() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinMainBlockShorthand20(stack["posI"])
}

func (c *current) onFunc9(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonFunc9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc9(stack["ident"])
}

func (c *current) onFunc28() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonFunc28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc28()
}

func (c *current) onFunc15(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonFunc15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc15(stack["identI"], stack["endPosI"])
}

func (c *current) onFunc39() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonFunc39() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc39()
}

func (c *current) onFunc43(paramsI interface{}) (interface{}, error) {
	return castedOrZero[[]file.FuncParam](paramsI), nil

}

func (p *parser) callonFunc43() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc43(stack["paramsI"])
}

func (c *current) onFunc72() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonFunc72() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc72()
}

func (c *current) onFunc67(endPosI interface{}) (interface{}, error) {
	return ([]file.FuncParam)(nil), &corgierr.Error{
		Message: "invalid parameter list",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "this is not correct, maybe a missing comma?",
		}),
	}

}

func (p *parser) callonFunc67() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc67(stack["endPosI"])
}

func (c *current) onFunc79() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonFunc79() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc79()
}

func (c *current) onFunc36(lParenPosI, paramsI, rParenPosI interface{}) (interface{}, error) {
	return file.Func{
		LParenPos: lParenPosI.(file.Position),
		Params:    paramsI.([]file.FuncParam),
		RParenPos: rParenPosI.(file.Position),
	}, nil

}

func (p *parser) callonFunc36() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc36(stack["lParenPosI"], stack["paramsI"], stack["rParenPosI"])
}

func (c *current) onFunc81() (interface{}, error) {
	return file.Func{}, &corgierr.Error{
		Message: "missing `(` or `)` or invalid param list",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "here",
		}),
	}

}

func (p *parser) callonFunc81() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc81()
}

func (c *current) onFunc2(nameI, paramsI interface{}) (interface{}, error) {
	params := paramsI.(file.Func)
	return file.Func{
		Name:      nameI.(file.GoIdent),
		LParenPos: params.LParenPos,
		Params:    params.Params,
		RParenPos: params.RParenPos,
		Position:  pos(c),
	}, nil
}

func (p *parser) callonFunc2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc2(stack["nameI"], stack["paramsI"])
}

func (c *current) onFunc97() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonFunc97() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc97()
}

func (c *current) onFunc93(posI interface{}) (interface{}, error) {
	return file.Func{Position: pos(c)}, &corgierr.Error{
		Message: "missing func name",
		ErrorAnnotation: anno(c, annotation{
			Start:       posI.(file.Position),
			StartOffset: 1,
			ToEOL:       true,
			Annotation:  "expected an identifier followed by a parameter list",
		}),
	}
}

func (p *parser) callonFunc93() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFunc93(stack["posI"])
}

func (c *current) onfuncOnlyVariadicParamList1(variadicI interface{}) (interface{}, error) {
	return []file.FuncParam{variadicI.(file.FuncParam)}, nil
}

func (p *parser) callonfuncOnlyVariadicParamList1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncOnlyVariadicParamList1(stack["variadicI"])
}

func (c *current) onfuncOtherParamList1(firstI, restI, variadicI interface{}) (interface{}, error) {
	restTuples := islice(restI)

	n := 1 + len(restTuples)
	if variadicI != nil {
		n++
	}
	params := make([]file.FuncParam, 1, n)
	params[0] = firstI.(file.FuncParam)

	for _, t := range restTuples {
		params = append(params, getTuple[file.FuncParam](t, -1))
	}

	if variadicI != nil {
		params = append(params, getTuple[file.FuncParam](variadicI, -1))
	}

	return params, nil
}

func (p *parser) callonfuncOtherParamList1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncOtherParamList1(stack["firstI"], stack["restI"], stack["variadicI"])
}

func (c *current) onfuncParam9(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonfuncParam9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam9(stack["ident"])
}

func (c *current) onfuncParam28() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonfuncParam28() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam28()
}

func (c *current) onfuncParam15(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonfuncParam15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam15(stack["identI"], stack["endPosI"])
}

func (c *current) onfuncParam48(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonfuncParam48() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam48(stack["ident"])
}

func (c *current) onfuncParam67() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonfuncParam67() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam67()
}

func (c *current) onfuncParam54(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonfuncParam54() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam54(stack["identI"], stack["endPosI"])
}

func (c *current) onfuncParam5(firstI, restI interface{}) (interface{}, error) {
	restTuples := islice(restI)
	idents := make([]file.GoIdent, 1, 1+len(restTuples))
	idents[0] = firstI.(file.GoIdent)

	for _, t := range restTuples {
		idents = append(idents, getTuple[file.GoIdent](t, -1))
	}

	return idents, nil
}

func (p *parser) callonfuncParam5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam5(stack["firstI"], stack["restI"])
}

func (c *current) onfuncParam2(namesI, typeI interface{}) (interface{}, error) {
	return file.FuncParam{
		Names: namesI.([]file.GoIdent),
		Type:  typeI.(file.GoType),
	}, nil
}

func (p *parser) callonfuncParam2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam2(stack["namesI"], stack["typeI"])
}

func (c *current) onfuncParam77(typeI interface{}) (interface{}, error) {
	return file.FuncParam{
		Type: typeI.(file.GoType),
	}, nil
}

func (p *parser) callonfuncParam77() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncParam77(stack["typeI"])
}

func (c *current) onfuncVariadicParam7(ident interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(ident), Position: pos(c)}, nil
}

func (p *parser) callonfuncVariadicParam7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncVariadicParam7(stack["ident"])
}

func (c *current) onfuncVariadicParam26() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonfuncVariadicParam26() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncVariadicParam26()
}

func (c *current) onfuncVariadicParam13(identI, endPosI interface{}) (interface{}, error) {
	return file.GoIdent{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
	}
}

func (p *parser) callonfuncVariadicParam13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncVariadicParam13(stack["identI"], stack["endPosI"])
}

func (c *current) onfuncVariadicParam1(nameI, typeI interface{}) (interface{}, error) {
	var names []file.GoIdent
	if nameI != nil {
		names = []file.GoIdent{getTuple[file.GoIdent](nameI, 0)}
	}

	return file.FuncParam{
		Names:    names,
		Variadic: true,
		Type:     typeI.(file.GoType),
	}, nil
}

func (p *parser) callonfuncVariadicParam1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncVariadicParam1(stack["nameI"], stack["typeI"])
}

func (c *current) onfuncType9() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonfuncType9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncType9()
}

func (c *current) onfuncType3(typeI, endPosI interface{}) (interface{}, error) {
	return file.GoType{
			Type:     concat(typeI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid type",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "not a valid Go type",
			}),
		}
}

func (p *parser) callonfuncType3() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onfuncType3(stack["typeI"], stack["endPosI"])
}

func (c *current) onAssign13() (interface{}, error) {
	return c.text, &corgierr.Error{
		Message: "unexpected tokens",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			ToEOL:      true,
			Annotation: "here",
		}),
	}
}

func (p *parser) callonAssign13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAssign13()
}

func (c *current) onAssign2(noEscapeI, exprI interface{}) (interface{}, error) {
	return file.Assign{
		Expression: exprI.(file.Expression),
		NoEscape:   noEscapeI != nil,
		Position:   pos(c),
	}, nil
}

func (p *parser) callonAssign2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAssign2(stack["noEscapeI"], stack["exprI"])
}

func (c *current) onAssign32() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonAssign32() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAssign32()
}

func (c *current) onAssign25(noEscapeI, posI interface{}) (interface{}, error) {
	return file.Assign{
			NoEscape: noEscapeI != nil,
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing expression",
			ErrorAnnotation: anno(c, annotation{
				Start:       posI.(file.Position),
				StartOffset: 1,
				Annotation:  "expected an expression here",
			}),
			Example: "`= 1 + 2`",
		}
}

func (p *parser) callonAssign25() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAssign25(stack["noEscapeI"], stack["posI"])
}

func (c *current) onInlineText1(lineI interface{}) (interface{}, error) {
	return file.InlineText{
		Text: lineI.(file.TextLine),
	}, nil
}

func (p *parser) callonInlineText1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineText1(stack["lineI"])
}

func (c *current) onArrowBlock2(firstLineI, additionalLinesI interface{}) (interface{}, error) {
	firstLine, firstLineOk := firstLineI.(file.TextLine)
	additionalLineTuples := islice(additionalLinesI)

	n := len(additionalLineTuples)
	if firstLineOk {
		n++
	}

	lines := make([]file.TextLine, 0, n)
	if firstLineOk {
		lines = append(lines, firstLine)
	}
	for _, lt := range additionalLineTuples {
		lines = append(lines, getTuple[file.TextLine](lt, -1))
	}

	return file.ArrowBlock{
		Lines:    lines,
		Position: pos(c),
	}, nil
}

func (p *parser) callonArrowBlock2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onArrowBlock2(stack["firstLineI"], stack["additionalLinesI"])
}

func (c *current) onArrowBlock31() (interface{}, error) {
	return file.ArrowBlock{Position: pos(c)}, nil
}

func (p *parser) callonArrowBlock31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onArrowBlock31()
}

func (c *current) onInlineArrowBlock2(lineI interface{}) (interface{}, error) {
	return file.ArrowBlock{
		Lines:    []file.TextLine{lineI.(file.TextLine)},
		Position: pos(c),
	}, nil
}

func (p *parser) callonInlineArrowBlock2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineArrowBlock2(stack["lineI"])
}

func (c *current) onInlineArrowBlock11() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonInlineArrowBlock11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineArrowBlock11()
}

func (c *current) onInlineArrowBlock7(posI, lineI interface{}) (interface{}, error) {
	return file.ArrowBlock{
			Lines:    []file.TextLine{lineI.(file.TextLine)},
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing space",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected a space here, separating the `>` from the text",
			}),
			Example: "`> woof`",
		}
}

func (p *parser) callonInlineArrowBlock7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineArrowBlock7(stack["posI"], stack["lineI"])
}

func (c *current) onTextLine1(itemsI interface{}) (interface{}, error) {
	return file.TextLine(typedSlice[file.TextItem](itemsI)), nil
}

func (p *parser) callonTextLine1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTextLine1(stack["itemsI"])
}

func (c *current) onTextItem2(textI interface{}) (interface{}, error) {
	return file.Text{
		Text:     concat(textI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonTextItem2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTextItem2(stack["textI"])
}

func (c *current) onInterpolation5() (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "bad interpolation",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "start of interpolation",
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				Start:       pos(c),
				StartOffset: 1,
				Annotation:  "expected a `#`, `[`, `" + lbrace + "`, a mixin call, or an element name here",
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
		},
	}
}

func (p *parser) callonInterpolation5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInterpolation5()
}

func (c *current) onSimpleInterpolation12() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSimpleInterpolation12() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation12()
}

func (c *current) onSimpleInterpolation18() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSimpleInterpolation18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation18()
}

func (c *current) onSimpleInterpolation9(lBracketPosI, textI, rBracketPosI interface{}) (interface{}, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
		RBracketPos: rBracketPosI.(file.Position),
	}, nil
}

func (p *parser) callonSimpleInterpolation9() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation9(stack["lBracketPosI"], stack["textI"], stack["rBracketPosI"])
}

func (c *current) onSimpleInterpolation23() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonSimpleInterpolation23() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation23()
}

func (c *current) onSimpleInterpolation20(lBracketPosI, textI interface{}) (interface{}, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
	}, errors.New("unclosed text interpolation")
}

func (p *parser) callonSimpleInterpolation20() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation20(stack["lBracketPosI"], stack["textI"])
}

func (c *current) onSimpleInterpolation1(noEscapeI, valueI interface{}) (interface{}, error) {
	return file.SimpleInterpolation{
		NoEscape: noEscapeI != nil,
		Value:    valueI.(file.InterpolationValue),
		Position: pos(c),
	}, nil
}

func (p *parser) callonSimpleInterpolation1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSimpleInterpolation1(stack["noEscapeI"], stack["valueI"])
}

func (c *current) onElementInterpolation8() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonElementInterpolation8() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElementInterpolation8()
}

func (c *current) onElementInterpolation1(noEscapeI, elPosI, nameI, attrsI, valueI interface{}) (interface{}, error) {
	return file.ElementInterpolation{
		NoEscape: noEscapeI != nil,
		Element: file.Element{
			Name:       concat(nameI),
			Attributes: typedSlice[file.AttributeCollection](attrsI),
			Void:       valueI == nil,
			Position:   elPosI.(file.Position),
		},
		Value:    castedOrZero[file.InterpolationValue](valueI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonElementInterpolation1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElementInterpolation1(stack["noEscapeI"], stack["elPosI"], stack["nameI"], stack["attrsI"], stack["valueI"])
}

func (c *current) onelementInterpolationValue5() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonelementInterpolationValue5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue5()
}

func (c *current) onelementInterpolationValue11() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonelementInterpolationValue11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue11()
}

func (c *current) onelementInterpolationValue2(lBracketPosI, textI, rBracketPosI interface{}) (interface{}, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
		RBracketPos: rBracketPosI.(file.Position),
	}, nil
}

func (p *parser) callonelementInterpolationValue2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue2(stack["lBracketPosI"], stack["textI"], stack["rBracketPosI"])
}

func (c *current) onelementInterpolationValue16() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonelementInterpolationValue16() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue16()
}

func (c *current) onelementInterpolationValue13(lBracketPosI, textI interface{}) (interface{}, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
	}, errors.New("unclosed text interpolation")
}

func (p *parser) callonelementInterpolationValue13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue13(stack["lBracketPosI"], stack["textI"])
}

func (c *current) onelementInterpolationValue31() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonelementInterpolationValue31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue31()
}

func (c *current) onelementInterpolationValue33() (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "missing interpolation value",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "here",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "write a text or expression interpolation",
				Example:    "`#strong{1+1}` or `#strong[woof]`",
			},
			{Suggestion: "write a void indicator, to indicate this is a void element", Example: "`#img(src=\"woof\")/`"},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
		},
	}
}

func (p *parser) callonelementInterpolationValue33() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onelementInterpolationValue33()
}

func (c *current) onMixinCallInterpolation7() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallInterpolation7() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation7()
}

func (c *current) onMixinCallInterpolation18(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonMixinCallInterpolation18() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation18(stack["identI"])
}

func (c *current) onMixinCallInterpolation37() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallInterpolation37() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation37()
}

func (c *current) onMixinCallInterpolation24(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonMixinCallInterpolation24() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation24(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCallInterpolation49(identI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, nil
}

func (p *parser) callonMixinCallInterpolation49() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation49(stack["identI"])
}

func (c *current) onMixinCallInterpolation68() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallInterpolation68() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation68()
}

func (c *current) onMixinCallInterpolation55(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{Ident: concat(identI), Position: pos(c)}, &corgierr.Error{
		Message: "invalid identifier",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			End:        endPosI.(file.Position),
			Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
		}),
		Example: "`woofBark`",
	}
}

func (p *parser) callonMixinCallInterpolation55() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation55(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCallInterpolation46(identI interface{}) (interface{}, error) {
	return identI, nil
}

func (p *parser) callonMixinCallInterpolation46() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation46(stack["identI"])
}

func (c *current) onMixinCallInterpolation77() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallInterpolation77() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation77()
}

func (c *current) onMixinCallInterpolation74(posI interface{}) (interface{}, error) {
	return file.Ident{
			Position: pos(c),
		}, &corgierr.Error{
			Message: "missing identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      posI.(file.Position),
				Annotation: "expected an identifier",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixinCallInterpolation74() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation74(stack["posI"])
}

func (c *current) onMixinCallInterpolation102() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonMixinCallInterpolation102() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation102()
}

func (c *current) onMixinCallInterpolation96(identI, endPosI interface{}) (interface{}, error) {
	return file.Ident{
			Ident:    concat(identI),
			Position: pos(c),
		}, &corgierr.Error{
			Message: "invalid identifier",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				End:        endPosI.(file.Position),
				Annotation: "expected a letter, or `_`, optionally followed by `_`s, letters, and numbers",
			}),
			Example: "`woofBark`",
		}
}

func (p *parser) callonMixinCallInterpolation96() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation96(stack["identI"], stack["endPosI"])
}

func (c *current) onMixinCallInterpolation1(noEscapeI, mcPosI, namespaceI, nameI, argsI, valueI interface{}) (interface{}, error) {
	args := castedOrZero[file.MixinCall](argsI)
	return file.MixinCallInterpolation{
		NoEscape: noEscapeI != nil,
		MixinCall: file.MixinCall{
			Name:      nameI.(file.Ident),
			LParenPos: args.LParenPos,
			Args:      args.Args,
			RParenPos: args.RParenPos,
			Position:  mcPosI.(file.Position),
		},
		Value:    castedOrZero[file.InterpolationValue](valueI),
		Position: pos(c),
	}, nil
}

func (p *parser) callonMixinCallInterpolation1() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMixinCallInterpolation1(stack["noEscapeI"], stack["mcPosI"], stack["namespaceI"], stack["nameI"], stack["argsI"], stack["valueI"])
}

func (c *current) onmixinCallInterpolationValue5() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallInterpolationValue5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallInterpolationValue5()
}

func (c *current) onmixinCallInterpolationValue11() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallInterpolationValue11() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallInterpolationValue11()
}

func (c *current) onmixinCallInterpolationValue2(lBracketPosI, textI, rBracketPosI interface{}) (interface{}, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
		RBracketPos: rBracketPosI.(file.Position),
	}, nil
}

func (p *parser) callonmixinCallInterpolationValue2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallInterpolationValue2(stack["lBracketPosI"], stack["textI"], stack["rBracketPosI"])
}

func (c *current) onmixinCallInterpolationValue16() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonmixinCallInterpolationValue16() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallInterpolationValue16()
}

func (c *current) onmixinCallInterpolationValue13(lBracketPosI, textI interface{}) (interface{}, error) {
	return file.TextInterpolationValue{
		LBracketPos: lBracketPosI.(file.Position),
		Text:        concat(textI),
	}, errors.New("unclosed text interpolation")
}

func (p *parser) callonmixinCallInterpolationValue13() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallInterpolationValue13(stack["lBracketPosI"], stack["textI"])
}

func (c *current) onmixinCallInterpolationValue31() (interface{}, error) {
	return nil, &corgierr.Error{
		Message: "missing interpolation value",
		ErrorAnnotation: anno(c, annotation{
			Start:      pos(c),
			Annotation: "here",
		}),
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "write a text or expression interpolation",
				Example:    "`#+woof(bark=\"loud\"){1+1}` or `#+woof(bark=\"loud\")[woof]`",
			},
			{Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
		},
	}
}

func (p *parser) callonmixinCallInterpolationValue31() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onmixinCallInterpolationValue31()
}

func (c *current) onexpressionInterpolationValue5() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonexpressionInterpolationValue5() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue5()
}

func (c *current) onexpressionInterpolationValue10() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonexpressionInterpolationValue10() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue10()
}

func (c *current) onexpressionInterpolationValue2(lBracePosI, exprI, rBracePosI interface{}) (interface{}, error) {
	return file.ExpressionInterpolationValue{
		LBracePos:  lBracePosI.(file.Position),
		Expression: exprI.(file.Expression),
		RBracePos:  rBracePosI.(file.Position),
	}, nil
}

func (p *parser) callonexpressionInterpolationValue2() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue2(stack["lBracePosI"], stack["exprI"], stack["rBracePosI"])
}

func (c *current) onexpressionInterpolationValue15() (interface{}, error) {
	return pos(c), nil
}

func (p *parser) callonexpressionInterpolationValue15() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue15()
}

func (c *current) onexpressionInterpolationValue12(lBracePosI, exprI interface{}) (interface{}, error) {
	return file.ExpressionInterpolationValue{
		LBracePos:  lBracePosI.(file.Position),
		Expression: exprI.(file.Expression),
	}, errors.New("unclosed expression interpolation")
}

func (p *parser) callonexpressionInterpolationValue12() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onexpressionInterpolationValue12(stack["lBracePosI"], stack["exprI"])
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL3() (bool, error) {
	// this is our first ever indentation, INDENTATION will handle it
	return c.state["Indentation.Char"].(byte) == 0, nil
}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL3() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL3()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL4() (interface{}, error) {
	return nil, nil
}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL4() (interface{}, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL4()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL7() (bool, error) {
	// preliminary checks that there is no mix of tabs and spaces

	lvl := c.state["Indentation.Level"].(int)
	if len(c.text) == 0 {
		return lvl == 0, nil
	}

	firstChar := c.text[0]

	for i, ws := range c.text[1:] {
		if byte(ws) != firstChar {
			if firstChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: i + 2},
						Annotation: "this is a tab",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							Start:      file.Position{Line: c.pos.line, Col: 1},
							Annotation: "this is a space",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: i + 2},
					Annotation: "this is a space",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Annotation: "this is a tab",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil
}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL7()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL9() (bool, error) {
	// lvl == 0
	return c.state["Indentation.Level"].(int) == 0, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL9() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL9()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL11() (bool, error) {
	// this is our first indentation
	return c.state["Indentation.RefLine"].(int) == 0, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL11() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL11()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL12() error {
	c.state["Indentation.Char"] = c.text[0]
	c.state["Indentation.Repetitions"] = len(c.text)
	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(len(c.text))
	c.state["Indentation.TotalRepetitions"] = len(c.text)
	c.state["Indentation.RefLine"] = c.pos.line
	return nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL12() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL12()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL14() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	for _, space := range c.text {
		if space != indentChar {
			if indentChar == ' ' {
				panic(&corgierr.Error{
					Message: "mix of tabs and spaces for indentation",
					ErrorAnnotation: anno(c, annotation{
						Start:      file.Position{Line: c.pos.line, Col: 1},
						Len:        len(c.text),
						Annotation: "but these are tabs",
					}),
					HintAnnotations: []corgierr.Annotation{
						anno(c, annotation{
							ContextStartDelta: -1,
							Start:             file.Position{Line: refLine, Col: 1},
							Len:               refReps,
							Annotation:        "these are spaces",
						}),
					},
					Suggestions: []corgierr.Suggestion{
						{Suggestion: "use only tabs OR spaces for indentation, but not both"},
					},
				})
			}

			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      file.Position{Line: c.pos.line, Col: 1},
					Len:        len(c.text),
					Annotation: "but these are spaces",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        "these are tabs",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}
	}

	return true, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL14()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL17() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL17() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL17()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL18() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	actualCount := len(c.text)

	if actualCount <= totalReps { // indentation didn't increase
		return false, nil
	}

	if (actualCount - totalReps) != refReps {
		if indentChar == ' ' {
			return true, &corgierr.Error{
				Message: "inconsistent indentation",
				ErrorAnnotation: anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
					Len:               actualCount - totalReps,
					Annotation:        fmt.Sprintf("however, here you used %d spaces", actualCount-totalReps),
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               refReps,
						Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{
						Suggestion: "be consistent in your indentation:\n" +
							"if you use two spaces for a single indentation, use four for a two-level indentation",
					},
				},
			}
		}

		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               actualCount - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d tabs", actualCount-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
				},
			},
		}
	}

	return true, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL18() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL18()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL19() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	actualCount := len(c.text)

	actualReps.Push(actualCount - totalReps)
	c.state["Indentation.TotalRepetitions"] = actualCount
	return nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL19() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL19()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL21() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL21() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL21()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL22() (bool, error) {
	actualCount := len(c.text)
	expectCount := c.state["Indentation.TotalRepetitions"].(int)
	if actualCount == expectCount {
		return true, nil
	}

	panic(&corgierr.Error{
		Message: "unexpected increase or decrease of indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: 1},
			Len:               actualCount,
			Annotation:        "here",
		}),
	})

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL22() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL22()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL26() (bool, error) {
	// if this is the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() < lvl, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL26() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL26()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL31() (bool, error) {
	refReps := c.state["Indentation.Repetitions"].(int)
	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	want := totalReps + refReps
	have := c.state["Indentation.CharCount"].(int)
	if want == have {
		return true, nil
	}

	return false, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL31() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL31()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL35() (bool, error) {
	indentChar := c.state["Indentation.Char"].(byte)
	refReps := c.state["Indentation.Repetitions"].(int)
	refLine := c.state["Indentation.RefLine"].(int)

	totalReps := c.state["Indentation.TotalRepetitions"].(int)

	have := c.state["Indentation.CharCount"].(int)
	want := totalReps + refReps
	if have == want {
		return true, nil
	} else if have <= totalReps {
		return false, nil
	}

	if indentChar == ' ' {
		return true, &corgierr.Error{
			Message: "inconsistent indentation",
			ErrorAnnotation: anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
				Len:               have - totalReps,
				Annotation:        fmt.Sprintf("however, here you used %d spaces", have-totalReps),
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               refReps,
					Annotation:        fmt.Sprintf("this line uses %d spaces to indent a single level", refReps),
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{
					Suggestion: "be consistent in your indentation:\n" +
						"if you use two spaces for a single indentation, use four for a two-level indentation",
				},
			},
		}
	}

	return true, &corgierr.Error{
		Message: "inconsistent indentation",
		ErrorAnnotation: anno(c, annotation{
			ContextStartDelta: -1,
			Start:             file.Position{Line: c.pos.line, Col: totalReps + 1},
			Len:               have - totalReps,
			Annotation:        fmt.Sprintf("however, here you used %d tabs", have-totalReps),
		}),
		HintAnnotations: []corgierr.Annotation{
			anno(c, annotation{
				ContextStartDelta: -1,
				Start:             file.Position{Line: refLine, Col: 1},
				Len:               refReps,
				Annotation:        fmt.Sprintf("this line uses %d tabs to indent a single level", refReps),
			}),
		},
		Suggestions: []corgierr.Suggestion{
			{
				Suggestion: "be consistent in your indentation:\n" +
					"if you use two tabs for a single indentation, use four for a two-level indentation, ...",
			},
		},
	}

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL35() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL35()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL36() error {
	totalReps := c.state["Indentation.TotalRepetitions"].(int)
	have := c.state["Indentation.CharCount"].(int)

	c.state["Indentation.ActualRepetitions"].(*stack.Stack[int]).Push(have - totalReps)
	c.state["Indentation.TotalRepetitions"] = have
	return nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL36() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL36()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL38() (bool, error) {
	// if this is NOT the first INDENTATION after INDENT
	actualReps := c.state["Indentation.ActualRepetitions"].(*stack.Stack[int])
	lvl := c.state["Indentation.Level"].(int)
	return actualReps.Len() == lvl, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL38() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL38()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL39() (bool, error) {
	want := c.state["Indentation.TotalRepetitions"].(int)
	have := c.state["Indentation.CharCount"].(int)
	return want == have, nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL39() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL39()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL40() error {
	c.state["Indentation.CharCount"] = 0
	return nil

}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL40() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL40()
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL44(spaceI interface{}) (bool, error) {
	space := byte(char(spaceI))

	indentChar := c.state["Indentation.Char"].(byte)
	if indentChar != space {
		refLine := c.state["Indentation.RefLine"].(int)
		reps := c.state["Indentation.Repetitions"].(int)

		if indentChar == ' ' {
			panic(&corgierr.Error{
				Message: "mix of tabs and spaces for indentation",
				ErrorAnnotation: anno(c, annotation{
					Start:      pos(c),
					Annotation: "this is a tab",
				}),
				HintAnnotations: []corgierr.Annotation{
					anno(c, annotation{
						ContextStartDelta: -1,
						Start:             file.Position{Line: refLine, Col: 1},
						Len:               reps,
						Annotation:        "these are spaces",
					}),
				},
				Suggestions: []corgierr.Suggestion{
					{Suggestion: "use only tabs OR spaces for indentation, but not both"},
				},
			})
		}

		panic(&corgierr.Error{
			Message: "mix of tabs and spaces for indentation",
			ErrorAnnotation: anno(c, annotation{
				Start:      pos(c),
				Annotation: "this is a space",
			}),
			HintAnnotations: []corgierr.Annotation{
				anno(c, annotation{
					ContextStartDelta: -1,
					Start:             file.Position{Line: refLine, Col: 1},
					Len:               reps,
					Annotation:        "these are tabs",
				}),
			},
			Suggestions: []corgierr.Suggestion{
				{Suggestion: "use only tabs OR spaces for indentation, but not both"},
			},
		})
	}

	return true, nil
}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL44() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL44(stack["spaceI"])
}

func (c *current) onINDENTATION_IGNORE_ADDITIONAL45(spaceI interface{}) error {
	c.state["Indentation.CharCount"] = c.state["Indentation.CharCount"].(int) + 1
	return nil
}

func (p *parser) callonINDENTATION_IGNORE_ADDITIONAL45() error {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION_IGNORE_ADDITIONAL45(stack["spaceI"])
}

func (c *current) onINDENTATION23() (bool, error) {
	return c.state["Indentation.Level"].(int) == 0, nil
}

func (p *parser) callonINDENTATION23() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onINDENTATION23()
}

var (
	// errNoRule is returned when the grammar to parse has no rule.
	errNoRule = errors.New("grammar has no rule")

	// errInvalidEntrypoint is returned when the specified entrypoint rule
	// does not exit.
	errInvalidEntrypoint = errors.New("invalid entrypoint")

	// errInvalidEncoding is returned when the source is not properly
	// utf8-encoded.
	errInvalidEncoding = errors.New("invalid encoding")

	// errMaxExprCnt is used to signal that the maximum number of
	// expressions have been parsed.
	errMaxExprCnt = errors.New("max number of expresssions parsed")
)

// Option is a function that can set an option on the parser. It returns
// the previous setting as an Option.
type Option func(*parser) Option

// MaxExpressions creates an Option to stop parsing after the provided
// number of expressions have been parsed, if the value is 0 then the parser will
// parse for as many steps as needed (possibly an infinite number).
//
// The default for maxExprCnt is 0.
func MaxExpressions(maxExprCnt uint64) Option {
	return func(p *parser) Option {
		oldMaxExprCnt := p.maxExprCnt
		p.maxExprCnt = maxExprCnt
		return MaxExpressions(oldMaxExprCnt)
	}
}

// Entrypoint creates an Option to set the rule name to use as entrypoint.
// The rule name must have been specified in the -alternate-entrypoints
// if generating the parser with the -optimize-grammar flag, otherwise
// it may have been optimized out. Passing an empty string sets the
// entrypoint to the first rule in the grammar.
//
// The default is to start parsing at the first rule in the grammar.
func Entrypoint(ruleName string) Option {
	return func(p *parser) Option {
		oldEntrypoint := p.entrypoint
		p.entrypoint = ruleName
		if ruleName == "" {
			p.entrypoint = g.rules[0].name
		}
		return Entrypoint(oldEntrypoint)
	}
}

// AllowInvalidUTF8 creates an Option to allow invalid UTF-8 bytes.
// Every invalid UTF-8 byte is treated as a utf8.RuneError (U+FFFD)
// by character class matchers and is matched by the any matcher.
// The returned matched value, c.text and c.offset are NOT affected.
//
// The default is false.
func AllowInvalidUTF8(b bool) Option {
	return func(p *parser) Option {
		old := p.allowInvalidUTF8
		p.allowInvalidUTF8 = b
		return AllowInvalidUTF8(old)
	}
}

// Recover creates an Option to set the recover flag to b. When set to
// true, this causes the parser to recover from panics and convert it
// to an error. Setting it to false can be useful while debugging to
// access the full stack trace.
//
// The default is true.
func Recover(b bool) Option {
	return func(p *parser) Option {
		old := p.recover
		p.recover = b
		return Recover(old)
	}
}

// GlobalStore creates an Option to set a key to a certain value in
// the globalStore.
func GlobalStore(key string, value interface{}) Option {
	return func(p *parser) Option {
		old := p.cur.globalStore[key]
		p.cur.globalStore[key] = value
		return GlobalStore(key, old)
	}
}

// InitState creates an Option to set a key to a certain value in
// the global "state" store.
func InitState(key string, value interface{}) Option {
	return func(p *parser) Option {
		old := p.cur.state[key]
		p.cur.state[key] = value
		return InitState(key, old)
	}
}

// ParseFile parses the file identified by filename.
func ParseFile(filename string, opts ...Option) (i interface{}, err error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer func() {
		if closeErr := f.Close(); closeErr != nil {
			err = closeErr
		}
	}()
	return ParseReader(filename, f, opts...)
}

// ParseReader parses the data from r using filename as information in the
// error messages.
func ParseReader(filename string, r io.Reader, opts ...Option) (interface{}, error) {
	b, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}

	return Parse(filename, b, opts...)
}

// Parse parses the data from b using filename as information in the
// error messages.
func Parse(filename string, b []byte, opts ...Option) (interface{}, error) {
	return newParser(filename, b, opts...).parse(g)
}

// position records a position in the text.
type position struct {
	line, col, offset int
}

func (p position) String() string {
	return strconv.Itoa(p.line) + ":" + strconv.Itoa(p.col) + " [" + strconv.Itoa(p.offset) + "]"
}

// savepoint stores all state required to go back to this point in the
// parser.
type savepoint struct {
	position
	rn rune
	w  int
}

type current struct {
	pos  position // start position of the match
	text []byte   // raw text of the match

	// state is a store for arbitrary key,value pairs that the user wants to be
	// tied to the backtracking of the parser.
	// This is always rolled back if a parsing rule fails.
	state storeDict

	// globalStore is a general store for the user to store arbitrary key-value
	// pairs that they need to manage and that they do not want tied to the
	// backtracking of the parser. This is only modified by the user and never
	// rolled back by the parser. It is always up to the user to keep this in a
	// consistent state.
	globalStore storeDict
}

type storeDict map[string]interface{}

// the AST types...

type grammar struct {
	pos   position
	rules []*rule
}

type rule struct {
	pos         position
	name        string
	displayName string
	expr        interface{}
}

type choiceExpr struct {
	pos          position
	alternatives []interface{}
}

type actionExpr struct {
	pos  position
	expr interface{}
	run  func(*parser) (interface{}, error)
}

type recoveryExpr struct {
	pos          position
	expr         interface{}
	recoverExpr  interface{}
	failureLabel []string
}

type seqExpr struct {
	pos   position
	exprs []interface{}
}

type throwExpr struct {
	pos   position
	label string
}

type labeledExpr struct {
	pos   position
	label string
	expr  interface{}
}

type expr struct {
	pos  position
	expr interface{}
}

type andExpr expr
type notExpr expr
type zeroOrOneExpr expr
type zeroOrMoreExpr expr
type oneOrMoreExpr expr

type ruleRefExpr struct {
	pos  position
	name string
}

type stateCodeExpr struct {
	pos position
	run func(*parser) error
}

type andCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type notCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type litMatcher struct {
	pos        position
	val        string
	ignoreCase bool
	want       string
}

type charClassMatcher struct {
	pos             position
	val             string
	basicLatinChars [128]bool
	chars           []rune
	ranges          []rune
	classes         []*unicode.RangeTable
	ignoreCase      bool
	inverted        bool
}

type anyMatcher position

// errList cumulates the errors found by the parser.
type errList []error

func (e *errList) add(err error) {
	*e = append(*e, err)
}

func (e errList) err() error {
	if len(e) == 0 {
		return nil
	}
	e.dedupe()
	return e
}

func (e *errList) dedupe() {
	var cleaned []error
	set := make(map[string]bool)
	for _, err := range *e {
		if msg := err.Error(); !set[msg] {
			set[msg] = true
			cleaned = append(cleaned, err)
		}
	}
	*e = cleaned
}

func (e errList) Error() string {
	switch len(e) {
	case 0:
		return ""
	case 1:
		return e[0].Error()
	default:
		var buf bytes.Buffer

		for i, err := range e {
			if i > 0 {
				buf.WriteRune('\n')
			}
			buf.WriteString(err.Error())
		}
		return buf.String()
	}
}

// parserError wraps an error with a prefix indicating the rule in which
// the error occurred. The original error is stored in the Inner field.
type parserError struct {
	Inner    error
	pos      position
	prefix   string
	expected []string
}

// Error returns the error message.
func (p *parserError) Error() string {
	return p.prefix + ": " + p.Inner.Error()
}

// newParser creates a parser with the specified input source and options.
func newParser(filename string, b []byte, opts ...Option) *parser {
	stats := Stats{
		ChoiceAltCnt: make(map[string]map[string]int),
	}

	p := &parser{
		filename: filename,
		errs:     new(errList),
		data:     b,
		pt:       savepoint{position: position{line: 1}},
		recover:  true,
		cur: current{
			state:       make(storeDict),
			globalStore: make(storeDict),
		},
		maxFailPos:      position{col: 1, line: 1},
		maxFailExpected: make([]string, 0, 20),
		Stats:           &stats,
		// start rule is rule [0] unless an alternate entrypoint is specified
		entrypoint: g.rules[0].name,
	}
	p.setOptions(opts)

	if p.maxExprCnt == 0 {
		p.maxExprCnt = math.MaxUint64
	}

	return p
}

// setOptions applies the options to the parser.
func (p *parser) setOptions(opts []Option) {
	for _, opt := range opts {
		opt(p)
	}
}

type resultTuple struct {
	v   interface{}
	b   bool
	end savepoint
}

const choiceNoMatch = -1

// Stats stores some statistics, gathered during parsing
type Stats struct {
	// ExprCnt counts the number of expressions processed during parsing
	// This value is compared to the maximum number of expressions allowed
	// (set by the MaxExpressions option).
	ExprCnt uint64

	// ChoiceAltCnt is used to count for each ordered choice expression,
	// which alternative is used how may times.
	// These numbers allow to optimize the order of the ordered choice expression
	// to increase the performance of the parser
	//
	// The outer key of ChoiceAltCnt is composed of the name of the rule as well
	// as the line and the column of the ordered choice.
	// The inner key of ChoiceAltCnt is the number (one-based) of the matching alternative.
	// For each alternative the number of matches are counted. If an ordered choice does not
	// match, a special counter is incremented. The name of this counter is set with
	// the parser option Statistics.
	// For an alternative to be included in ChoiceAltCnt, it has to match at least once.
	ChoiceAltCnt map[string]map[string]int
}

type parser struct {
	filename string
	pt       savepoint
	cur      current

	data []byte
	errs *errList

	depth   int
	recover bool

	// rules table, maps the rule identifier to the rule node
	rules map[string]*rule
	// variables stack, map of label to value
	vstack []map[string]interface{}
	// rule stack, allows identification of the current rule in errors
	rstack []*rule

	// parse fail
	maxFailPos            position
	maxFailExpected       []string
	maxFailInvertExpected bool

	// max number of expressions to be parsed
	maxExprCnt uint64
	// entrypoint for the parser
	entrypoint string

	allowInvalidUTF8 bool

	*Stats

	choiceNoMatch string
	// recovery expression stack, keeps track of the currently available recovery expression, these are traversed in reverse
	recoveryStack []map[string]interface{}
}

// push a variable set on the vstack.
func (p *parser) pushV() {
	if cap(p.vstack) == len(p.vstack) {
		// create new empty slot in the stack
		p.vstack = append(p.vstack, nil)
	} else {
		// slice to 1 more
		p.vstack = p.vstack[:len(p.vstack)+1]
	}

	// get the last args set
	m := p.vstack[len(p.vstack)-1]
	if m != nil && len(m) == 0 {
		// empty map, all good
		return
	}

	m = make(map[string]interface{})
	p.vstack[len(p.vstack)-1] = m
}

// pop a variable set from the vstack.
func (p *parser) popV() {
	// if the map is not empty, clear it
	m := p.vstack[len(p.vstack)-1]
	if len(m) > 0 {
		// GC that map
		p.vstack[len(p.vstack)-1] = nil
	}
	p.vstack = p.vstack[:len(p.vstack)-1]
}

// push a recovery expression with its labels to the recoveryStack
func (p *parser) pushRecovery(labels []string, expr interface{}) {
	if cap(p.recoveryStack) == len(p.recoveryStack) {
		// create new empty slot in the stack
		p.recoveryStack = append(p.recoveryStack, nil)
	} else {
		// slice to 1 more
		p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)+1]
	}

	m := make(map[string]interface{}, len(labels))
	for _, fl := range labels {
		m[fl] = expr
	}
	p.recoveryStack[len(p.recoveryStack)-1] = m
}

// pop a recovery expression from the recoveryStack
func (p *parser) popRecovery() {
	// GC that map
	p.recoveryStack[len(p.recoveryStack)-1] = nil

	p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)-1]
}

func (p *parser) addErr(err error) {
	p.addErrAt(err, p.pt.position, []string{})
}

func (p *parser) addErrAt(err error, pos position, expected []string) {
	var buf bytes.Buffer
	if p.filename != "" {
		buf.WriteString(p.filename)
	}
	if buf.Len() > 0 {
		buf.WriteString(":")
	}
	buf.WriteString(fmt.Sprintf("%d:%d (%d)", pos.line, pos.col, pos.offset))
	if len(p.rstack) > 0 {
		if buf.Len() > 0 {
			buf.WriteString(": ")
		}
		rule := p.rstack[len(p.rstack)-1]
		if rule.displayName != "" {
			buf.WriteString("rule " + rule.displayName)
		} else {
			buf.WriteString("rule " + rule.name)
		}
	}
	pe := &parserError{Inner: err, pos: pos, prefix: buf.String(), expected: expected}
	p.errs.add(pe)
}

func (p *parser) failAt(fail bool, pos position, want string) {
	// process fail if parsing fails and not inverted or parsing succeeds and invert is set
	if fail == p.maxFailInvertExpected {
		if pos.offset < p.maxFailPos.offset {
			return
		}

		if pos.offset > p.maxFailPos.offset {
			p.maxFailPos = pos
			p.maxFailExpected = p.maxFailExpected[:0]
		}

		if p.maxFailInvertExpected {
			want = "!" + want
		}
		p.maxFailExpected = append(p.maxFailExpected, want)
	}
}

// read advances the parser to the next rune.
func (p *parser) read() {
	p.pt.offset += p.pt.w
	rn, n := utf8.DecodeRune(p.data[p.pt.offset:])
	p.pt.rn = rn
	p.pt.w = n
	p.pt.col++
	if rn == '\n' {
		p.pt.line++
		p.pt.col = 0
	}

	if rn == utf8.RuneError && n == 1 { // see utf8.DecodeRune
		if !p.allowInvalidUTF8 {
			p.addErr(errInvalidEncoding)
		}
	}
}

// restore parser position to the savepoint pt.
func (p *parser) restore(pt savepoint) {
	if pt.offset == p.pt.offset {
		return
	}
	p.pt = pt
}

// Cloner is implemented by any value that has a Clone method, which returns a
// copy of the value. This is mainly used for types which are not passed by
// value (e.g map, slice, chan) or structs that contain such types.
//
// This is used in conjunction with the global state feature to create proper
// copies of the state to allow the parser to properly restore the state in
// the case of backtracking.
type Cloner interface {
	Clone() interface{}
}

var statePool = &sync.Pool{
	New: func() interface{} { return make(storeDict) },
}

func (sd storeDict) Discard() {
	for k := range sd {
		delete(sd, k)
	}
	statePool.Put(sd)
}

// clone and return parser current state.
func (p *parser) cloneState() storeDict {

	state := statePool.Get().(storeDict)
	for k, v := range p.cur.state {
		if c, ok := v.(Cloner); ok {
			state[k] = c.Clone()
		} else {
			state[k] = v
		}
	}
	return state
}

// restore parser current state to the state storeDict.
// every restoreState should applied only one time for every cloned state
func (p *parser) restoreState(state storeDict) {
	p.cur.state.Discard()
	p.cur.state = state
}

// get the slice of bytes from the savepoint start to the current position.
func (p *parser) sliceFrom(start savepoint) []byte {
	return p.data[start.position.offset:p.pt.position.offset]
}

func (p *parser) buildRulesTable(g *grammar) {
	p.rules = make(map[string]*rule, len(g.rules))
	for _, r := range g.rules {
		p.rules[r.name] = r
	}
}

func (p *parser) parse(g *grammar) (val interface{}, err error) {
	if len(g.rules) == 0 {
		p.addErr(errNoRule)
		return nil, p.errs.err()
	}

	// TODO : not super critical but this could be generated
	p.buildRulesTable(g)

	if p.recover {
		// panic can be used in action code to stop parsing immediately
		// and return the panic as an error.
		defer func() {
			if e := recover(); e != nil {
				val = nil
				switch e := e.(type) {
				case error:
					p.addErr(e)
				default:
					p.addErr(fmt.Errorf("%v", e))
				}
				err = p.errs.err()
			}
		}()
	}

	startRule, ok := p.rules[p.entrypoint]
	if !ok {
		p.addErr(errInvalidEntrypoint)
		return nil, p.errs.err()
	}

	p.read() // advance to first rune
	val, ok = p.parseRule(startRule)
	if !ok {
		if len(*p.errs) == 0 {
			// If parsing fails, but no errors have been recorded, the expected values
			// for the farthest parser position are returned as error.
			maxFailExpectedMap := make(map[string]struct{}, len(p.maxFailExpected))
			for _, v := range p.maxFailExpected {
				maxFailExpectedMap[v] = struct{}{}
			}
			expected := make([]string, 0, len(maxFailExpectedMap))
			eof := false
			if _, ok := maxFailExpectedMap["!."]; ok {
				delete(maxFailExpectedMap, "!.")
				eof = true
			}
			for k := range maxFailExpectedMap {
				expected = append(expected, k)
			}
			sort.Strings(expected)
			if eof {
				expected = append(expected, "EOF")
			}
			p.addErrAt(errors.New("no match found, expected: "+listJoin(expected, ", ", "or")), p.maxFailPos, expected)
		}

		return nil, p.errs.err()
	}
	return val, p.errs.err()
}

func listJoin(list []string, sep string, lastSep string) string {
	switch len(list) {
	case 0:
		return ""
	case 1:
		return list[0]
	default:
		return strings.Join(list[:len(list)-1], sep) + " " + lastSep + " " + list[len(list)-1]
	}
}

func (p *parser) parseRule(rule *rule) (interface{}, bool) {
	p.rstack = append(p.rstack, rule)
	p.pushV()
	val, ok := p.parseExpr(rule.expr)
	p.popV()
	p.rstack = p.rstack[:len(p.rstack)-1]
	return val, ok
}

func (p *parser) parseExpr(expr interface{}) (interface{}, bool) {

	p.ExprCnt++
	if p.ExprCnt > p.maxExprCnt {
		panic(errMaxExprCnt)
	}

	var val interface{}
	var ok bool
	switch expr := expr.(type) {
	case *actionExpr:
		val, ok = p.parseActionExpr(expr)
	case *andCodeExpr:
		val, ok = p.parseAndCodeExpr(expr)
	case *andExpr:
		val, ok = p.parseAndExpr(expr)
	case *anyMatcher:
		val, ok = p.parseAnyMatcher(expr)
	case *charClassMatcher:
		val, ok = p.parseCharClassMatcher(expr)
	case *choiceExpr:
		val, ok = p.parseChoiceExpr(expr)
	case *labeledExpr:
		val, ok = p.parseLabeledExpr(expr)
	case *litMatcher:
		val, ok = p.parseLitMatcher(expr)
	case *notCodeExpr:
		val, ok = p.parseNotCodeExpr(expr)
	case *notExpr:
		val, ok = p.parseNotExpr(expr)
	case *oneOrMoreExpr:
		val, ok = p.parseOneOrMoreExpr(expr)
	case *recoveryExpr:
		val, ok = p.parseRecoveryExpr(expr)
	case *ruleRefExpr:
		val, ok = p.parseRuleRefExpr(expr)
	case *seqExpr:
		val, ok = p.parseSeqExpr(expr)
	case *stateCodeExpr:
		val, ok = p.parseStateCodeExpr(expr)
	case *throwExpr:
		val, ok = p.parseThrowExpr(expr)
	case *zeroOrMoreExpr:
		val, ok = p.parseZeroOrMoreExpr(expr)
	case *zeroOrOneExpr:
		val, ok = p.parseZeroOrOneExpr(expr)
	default:
		panic(fmt.Sprintf("unknown expression type %T", expr))
	}
	return val, ok
}

func (p *parser) parseActionExpr(act *actionExpr) (interface{}, bool) {
	start := p.pt
	val, ok := p.parseExpr(act.expr)
	if ok {
		p.cur.pos = start.position
		p.cur.text = p.sliceFrom(start)
		state := p.cloneState()
		actVal, err := act.run(p)
		if err != nil {
			p.addErrAt(err, start.position, []string{})
		}
		p.restoreState(state)

		val = actVal
	}
	return val, ok
}

func (p *parser) parseAndCodeExpr(and *andCodeExpr) (interface{}, bool) {
	state := p.cloneState()

	ok, err := and.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, ok
}

func (p *parser) parseAndExpr(and *andExpr) (interface{}, bool) {
	pt := p.pt
	state := p.cloneState()
	p.pushV()
	_, ok := p.parseExpr(and.expr)
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, ok
}

func (p *parser) parseAnyMatcher(any *anyMatcher) (interface{}, bool) {
	if p.pt.rn == utf8.RuneError && p.pt.w == 0 {
		// EOF - see utf8.DecodeRune
		p.failAt(false, p.pt.position, ".")
		return nil, false
	}
	start := p.pt
	p.read()
	p.failAt(true, start.position, ".")
	return p.sliceFrom(start), true
}

func (p *parser) parseCharClassMatcher(chr *charClassMatcher) (interface{}, bool) {
	cur := p.pt.rn
	start := p.pt

	// can't match EOF
	if cur == utf8.RuneError && p.pt.w == 0 { // see utf8.DecodeRune
		p.failAt(false, start.position, chr.val)
		return nil, false
	}

	if chr.ignoreCase {
		cur = unicode.ToLower(cur)
	}

	// try to match in the list of available chars
	for _, rn := range chr.chars {
		if rn == cur {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of ranges
	for i := 0; i < len(chr.ranges); i += 2 {
		if cur >= chr.ranges[i] && cur <= chr.ranges[i+1] {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of Unicode classes
	for _, cl := range chr.classes {
		if unicode.Is(cl, cur) {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	if chr.inverted {
		p.read()
		p.failAt(true, start.position, chr.val)
		return p.sliceFrom(start), true
	}
	p.failAt(false, start.position, chr.val)
	return nil, false
}

func (p *parser) parseChoiceExpr(ch *choiceExpr) (interface{}, bool) {
	for altI, alt := range ch.alternatives {
		// dummy assignment to prevent compile error if optimized
		_ = altI

		state := p.cloneState()

		p.pushV()
		val, ok := p.parseExpr(alt)
		p.popV()
		if ok {
			return val, ok
		}
		p.restoreState(state)
	}
	return nil, false
}

func (p *parser) parseLabeledExpr(lab *labeledExpr) (interface{}, bool) {
	p.pushV()
	val, ok := p.parseExpr(lab.expr)
	p.popV()
	if ok && lab.label != "" {
		m := p.vstack[len(p.vstack)-1]
		m[lab.label] = val
	}
	return val, ok
}

func (p *parser) parseLitMatcher(lit *litMatcher) (interface{}, bool) {
	start := p.pt
	for _, want := range lit.val {
		cur := p.pt.rn
		if lit.ignoreCase {
			cur = unicode.ToLower(cur)
		}
		if cur != want {
			p.failAt(false, start.position, lit.want)
			p.restore(start)
			return nil, false
		}
		p.read()
	}
	p.failAt(true, start.position, lit.want)
	return p.sliceFrom(start), true
}

func (p *parser) parseNotCodeExpr(not *notCodeExpr) (interface{}, bool) {
	state := p.cloneState()

	ok, err := not.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, !ok
}

func (p *parser) parseNotExpr(not *notExpr) (interface{}, bool) {
	pt := p.pt
	state := p.cloneState()
	p.pushV()
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	_, ok := p.parseExpr(not.expr)
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, !ok
}

func (p *parser) parseOneOrMoreExpr(expr *oneOrMoreExpr) (interface{}, bool) {
	var vals []interface{}

	for {
		p.pushV()
		val, ok := p.parseExpr(expr.expr)
		p.popV()
		if !ok {
			if len(vals) == 0 {
				// did not match once, no match
				return nil, false
			}
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseRecoveryExpr(recover *recoveryExpr) (interface{}, bool) {

	p.pushRecovery(recover.failureLabel, recover.recoverExpr)
	val, ok := p.parseExpr(recover.expr)
	p.popRecovery()

	return val, ok
}

func (p *parser) parseRuleRefExpr(ref *ruleRefExpr) (interface{}, bool) {
	if ref.name == "" {
		panic(fmt.Sprintf("%s: invalid rule: missing name", ref.pos))
	}

	rule := p.rules[ref.name]
	if rule == nil {
		p.addErr(fmt.Errorf("undefined rule: %s", ref.name))
		return nil, false
	}
	return p.parseRule(rule)
}

func (p *parser) parseSeqExpr(seq *seqExpr) (interface{}, bool) {
	vals := make([]interface{}, 0, len(seq.exprs))

	pt := p.pt
	state := p.cloneState()
	for _, expr := range seq.exprs {
		val, ok := p.parseExpr(expr)
		if !ok {
			p.restoreState(state)
			p.restore(pt)
			return nil, false
		}
		vals = append(vals, val)
	}
	return vals, true
}

func (p *parser) parseStateCodeExpr(state *stateCodeExpr) (interface{}, bool) {
	err := state.run(p)
	if err != nil {
		p.addErr(err)
	}
	return nil, true
}

func (p *parser) parseThrowExpr(expr *throwExpr) (interface{}, bool) {

	for i := len(p.recoveryStack) - 1; i >= 0; i-- {
		if recoverExpr, ok := p.recoveryStack[i][expr.label]; ok {
			if val, ok := p.parseExpr(recoverExpr); ok {
				return val, ok
			}
		}
	}

	return nil, false
}

func (p *parser) parseZeroOrMoreExpr(expr *zeroOrMoreExpr) (interface{}, bool) {
	var vals []interface{}

	for {
		p.pushV()
		val, ok := p.parseExpr(expr.expr)
		p.popV()
		if !ok {
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseZeroOrOneExpr(expr *zeroOrOneExpr) (interface{}, bool) {
	p.pushV()
	val, _ := p.parseExpr(expr.expr)
	p.popV()
	// whether it matched or not, consider it a match
	return val, true
}

func rangeTable(class string) *unicode.RangeTable {
	if rt, ok := unicode.Categories[class]; ok {
		return rt
	}
	if rt, ok := unicode.Properties[class]; ok {
		return rt
	}
	if rt, ok := unicode.Scripts[class]; ok {
		return rt
	}

	// cannot happen
	panic(fmt.Sprintf("invalid Unicode class: %s", class))
}
