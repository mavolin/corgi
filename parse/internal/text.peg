// ============================================================================
// Arrow Block
// ======================================================================================

ArrowBlock <- INDENTATION_REF "> " firstI:(ArrowBlockLine / EOL) restI:(EMPTY_LINE* INDENTATION2 ArrowBlockLine)* {
    first, firstOk := firstI.(file.TextLine)
    restTuples := slice(restI)

    n := len(restTuples)
    if firstOk {
        n++
    }

    lines := make([]file.TextLine, 0, n)
    if firstOk {
        lines = append(lines, first)
    }
    for _, lt := range restTuples {
        lines = append(lines, getTuple[file.TextLine](lt, -1))
    }

    return file.ArrowBlock{
        Lines:    lines,
        Position: pos(c),
    }, nil
} / ">" EOL {
    return file.ArrowBlock{Position: pos(c)}, nil
}

// ============================================================================
// Bracket Text
// ======================================================================================

BracketText <- L_BRACKET WS* btI:BracketTextLine* WS* rBracketI:R_BRACKET EOC {
    return file.BracketText{
        LBracket: pos(c),
        Lines:    sliceOf[file.TextLine](btI),
        RBracket: rBracketI.(file.Position),
    }, nil
} / L_BRACKET btI:BracketTextLine* .* EOF {
    return file.BracketText{
        LBracket: pos(c),
        Lines:    sliceOf[file.TextLine](btI),
    }, &fileerr.Error{
        Message: "unclosed bracket text",
        ErrorAnnotation: anno(c, annotation{
            Start: pos(c),
            Annotation: "`[` opened, but never closed",
        }),
    }
}

// ============================================================================
// TextLine
// ======================================================================================

ArrowBlockLine <- itemsI:ArrowBlockTextItem+ EOL {
    return file.TextLine(sliceOf[file.TextItem](itemsI)), nil
}
BracketTextLine <- WS* itemsI:BracketTextTextItem+ EOL? {
    return file.TextLine(sliceOf[file.TextItem](itemsI)), nil
}
InterpolationValueLine <- itemsI:InterpolationValueTextItem* {
    return file.TextLine(sliceOf[file.TextItem](itemsI)), nil
}

// ============================================================================
// TextItem
// ======================================================================================

ArrowBlockTextItem         <- ArrowBlockText / Interpolation
BracketTextTextItem        <- BracketTextText / Interpolation
InterpolationValueTextItem <- InterpolationValueText / Interpolation

// ============================================================================
// Text
// ======================================================================================

ArrowBlockText <- textI:((!EOL [^#])+ / "##")+ {
    return file.Text{
        Text:     string(c.text),
        Position: pos(c),
    }, nil
}

BracketTextText <- textI:((!(EOL / _* R_BRACKET EOC) [^#\]])+ / "##" / R_BRACKET !EOC)+ {
    return file.Text{
        Text:     string(c.text),
        Position: pos(c),
    }, nil
}

InterpolationValueText <- textI:((!EOL [^#\]])+ / "##")+ {
    return file.Text{
        Text:     string(c.text),
        Position: pos(c),
    }, nil
}

// ============================================================================
// Interpolation
// ======================================================================================

Interpolation <- interpolationStart interpI:(ExpressionInterpolation / ElementInterpolation / ComponentCallInterpolation / BadInterpolation) {
    return interpI, nil
}

interpolationStart <- pushStart '#'

interpolationExpressionStart <- pushStart L_BRACE { return pos(c), nil }
expressionInterpolationEnd <- R_BRACE popStart popStart {
    return pos(c), nil
} / POS {
    braceStart := popStart(c)
    hashStart := popStart(c)
    return pos(c), &fileerr.Error{
        Message: "unclosed interpolation",
        ErrorAnnotation: anno(c, annotation{
            Start:       braceStart,
            StartOffset: 1,
            EOLDelta:    1,
            Annotation:  "expected a `}` somewhere here",
        }),
        HintAnnotations: []fileerr.Annotation{
            anno(c, annotation{
                Start:      hashStart,
                End:        braceStart,
                EndOffset:  1,
                Annotation: "for the interpolation started here",
            }),
        },
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "add the missing `}`"},
            {Suggestion: "if you didn't mean to start an interpolation, escape the `#` by writing `##`"},
        },
    }
}

interpolationTextStart <- pushStart L_BRACKET { return pos(c), nil }
textInterpolationEnd <- R_BRACKET popStart popStart {
    return pos(c), nil
} / POS {
    bracketStart := popStart(c)
    hashStart := popStart(c)
    return pos(c), &fileerr.Error{
        Message: "unclosed interpolation",
        ErrorAnnotation: anno(c, annotation{
            Start:       bracketStart,
            StartOffset: 1,
            EOLDelta:    1,
            Annotation:  "expected a `]` somewhere here",
        }),
        HintAnnotations: []fileerr.Annotation{
            anno(c, annotation{
                Start:      hashStart,
                End:        bracketStart,
                EndOffset:  1,
                Annotation: "for the interpolation started here",
            }),
        },
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "add the missing `]`"},
            {Suggestion: "if you didn't mean to start an interpolation, escape the `#` by writing `##`"},
        },
    }
}

// ============================================================================
// Expression Interpolation
// ======================================================================================

ExpressionInterpolation <- fmtDirectiveI:fmtDirective? lBraceI:interpolationExpressionStart inlineStart exprI:Expression inlineEnd rBraceI:expressionInterpolationEnd {
    return file.ExpressionInterpolation{
        FormatDirective: optCast[string](fmtDirectiveI),
        LBrace:          lBraceI.(file.Position),
        Expression:      optCast[file.Expression](exprI),
        RBrace:          rBraceI.(file.Position),
        Position:        peekStart(c, 1),
    }, nil
}

// ============================================================================
// Text Interpolation
// ======================================================================================

TextInterpolation <- noEscape:'!'? valI:InterpolationValue {
    return file.TextInterpolation{
        NoEscape: noEscape != nil,
        Value:    valI.(file.InterpolationValue),
        Position: peekStart(c, 1),
    }, nil
}

// ============================================================================
// ElementInterpolation
// ======================================================================================

ElementInterpolation <- elementInterpolation / voidElementInterpolation

elementInterpolation <- nameI:htmlTagName inlineStart attrsI:AttributeCollection* inlineEnd valI:(InterpolationValue / popStart) {
    return file.ElementInterpolation{
        Element: file.Element{
            Name:       concat(nameI),
            Attributes: sliceOf[file.AttributeCollection](attrsI),
            Position:   pos(c),
        },
        Value:    optCast[file.InterpolationValue](valI),
        Position: peekStart(c, 1),
    }, nil
}

voidElementInterpolation <- nameI:htmlTagName '/' inlineStart attrsI:AttributeCollection* inlineEnd popStart {
    return file.ElementInterpolation{
        Element: file.Element{
            Name:       concat(nameI),
            Attributes: sliceOf[file.AttributeCollection](attrsI),
            Void:       true,
            Position:   pos(c),
        },
        Position: peekStart(c, 1),
    }, nil
}

// ============================================================================
// ComponentCallInterpolation
// ======================================================================================

ComponentCallInterpolation <- '+' inlineStart callI:ComponentCallHeader inlineEnd valI:(InterpolationValue / popStart) {
    call := callI.(file.ComponentCall)
    call.Position = pos(c)

    return file.ComponentCallInterpolation{
        ComponentCall: call,
        Value:         optCast[file.InterpolationValue](valI),
        Position:      pos(c),
    }, nil
}

// ============================================================================
// InterpolationValue
// ======================================================================================

InterpolationValue <- interpolationTextStart valI:InterpolationValueLine rBracketI:textInterpolationEnd {
    return file.InterpolationValue{
        LBracket: pos(c),
        Text:     valI.(file.TextLine),
        RBracket: rBracketI.(file.Position),
    }, nil
}

// ============================================================================
// Bad Interpolation
// ======================================================================================

BadInterpolation <- '#' {
    return file.BadInterpolation{Position: pos(c)}, &fileerr.Error{
        Message: "bad interpolation",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Annotation: "start of interpolation",
        }),
        HintAnnotations: []fileerr.Annotation{
            anno(c, annotation{
                Start: pos(c),
                StartOffset: 1,
                Annotation: "expected an expression interpolation, text interpolation, a component call,\n" +
                    "or an element interpolation",
            }),
        },
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
        },
    }
}
