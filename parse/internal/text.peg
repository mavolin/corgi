// ============================================================================
// Arrow Block
// ======================================================================================

ArrowBlock <- INDENTATION_REF "> " firstI:(ArrowBlockLine / EOL) restI:(EMPTY_LINE* INDENTATION2 ArrowBlockLine)* {
    first, firstOk := firstI.(ast.TextLine)
    restTuples := slice(restI)

    n := len(restTuples)
    if firstOk {
        n++
    }

    lines := make([]ast.TextLine, 0, n)
    if firstOk {
        lines = append(lines, first)
    }
    for _, lt := range restTuples {
        lines = append(lines, getTuple[ast.TextLine](lt, -1))
    }

    return &ast.ArrowBlock{
        Lines:    lines,
        Position: pos(c),
    }, nil
} / ">" EOL {
    return ast.ArrowBlock{Position: pos(c)}, nil
}

// ============================================================================
// Bracket Text
// ======================================================================================

BracketText <- L_BRACKET WS* btI:BracketTextLine* WS* rBracketI:R_BRACKET EOC {
    return &ast.BracketText{
        LBracket: pos(c),
        Lines:    sliceOf[ast.TextLine](btI),
        RBracket: rBracketI.(*ast.Position),
    }, nil
} / L_BRACKET btI:BracketTextLine* .* EOF {
    return &ast.BracketText{
        LBracket: pos(c),
        Lines:    sliceOf[ast.TextLine](btI),
    }, &fileerr.Error{
        Message: "unclosed bracket text",
        ErrorAnnotation: anno(c, annotation{
            Start: pos(c),
            Annotation: "`[` opened, but never closed",
        }),
    }
}

// ============================================================================
// TextLine
// ======================================================================================

ArrowBlockLine <- itemsI:ArrowBlockTextItem+ EOL {
    return ast.TextLine(sliceOf[ast.TextItem](itemsI)), nil
}
BracketTextLine <- WS* itemsI:BracketTextTextItem+ EOL? {
    return ast.TextLine(sliceOf[ast.TextItem](itemsI)), nil
}
InterpolationValueLine <- itemsI:InterpolationValueTextItem* {
    return ast.TextLine(sliceOf[ast.TextItem](itemsI)), nil
}

// ============================================================================
// TextItem
// ======================================================================================

ArrowBlockTextItem         <- ArrowBlockText / Interpolation
BracketTextTextItem        <- BracketTextText / Interpolation
InterpolationValueTextItem <- InterpolationValueText / Interpolation

// ============================================================================
// Text
// ======================================================================================

ArrowBlockText <- textI:((!EOL [^#])+ / "##")+ {
    return &ast.Text{
        Text:     string(c.text),
        Position: pos(c),
    }, nil
}

BracketTextText <- textI:((!(EOL / _* R_BRACKET EOC) [^#\]])+ / "##" / R_BRACKET !EOC)+ {
    return &ast.Text{
        Text:     string(c.text),
        Position: pos(c),
    }, nil
}

InterpolationValueText <- textI:((!EOL [^#\]])+ / "##")+ {
    return &ast.Text{
        Text:     string(c.text),
        Position: pos(c),
    }, nil
}

// ============================================================================
// Interpolation
// ======================================================================================

Interpolation <- interpolationStart interpI:(ExpressionInterpolation / ElementInterpolation / ComponentCallInterpolation / BadInterpolation) interpolationEnd {
    return interpI, nil
}

interpolationStart <- pushStart startI:POS '#' { return startI.(*ast.Position), nil }
interpolationEnd   <- endI:POS popStart { return endI.(*ast.Position), nil }

interpolationExpressionStart <- pushStart lBraceI:L_BRACE { return lBraceI.(*ast.Position), nil }
interpolationExpressionEnd <- rBrace:R_BRACE popStart {
    return lBraceI.(*ast.Position), nil
} / posI:POS {
    braceStart := popStart(c)
    hashStart := peekStart(c, 0)
    return posI.(*ast.Position), &fileerr.Error{
        Message: "unclosed interpolation",
        ErrorAnnotation: anno(c, annotation{
            Start:       braceStart,
            StartOffset: 1,
            EOLDelta:    1,
            Annotation:  "expected a `}` somewhere here",
        }),
        HintAnnotations: []fileerr.Annotation{
            anno(c, annotation{
                Start:      hashStart,
                End:        braceStart,
                EndOffset:  1,
                Annotation: "for the interpolation started here",
            }),
        },
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "add the missing `}`"},
            {Suggestion: "if you didn't mean to start an interpolation, escape the `#` by writing `##`"},
        },
    }
}

interpolationTextStart <- pushStart lBracketI:L_BRACKET { return lBracketI.(*ast.Position), nil }
interpolationTextEnd <- rBracketI:R_BRACKET popStart {
    return rBracketI.(*ast.Position), nil
} / posI:POS {
    bracketStart := popStart(c)
    hashStart := peekStart(c, 0)
    return posI.(*ast.Position), &fileerr.Error{
        Message: "unclosed interpolation",
        ErrorAnnotation: anno(c, annotation{
            Start:       bracketStart,
            StartOffset: 1,
            EOLDelta:    1,
            Annotation:  "expected a `]` somewhere here",
        }),
        HintAnnotations: []fileerr.Annotation{
            anno(c, annotation{
                Start:      hashStart,
                End:        bracketStart,
                EndOffset:  1,
                Annotation: "for the interpolation started here",
            }),
        },
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "add the missing `]`"},
            {Suggestion: "if you didn't mean to start an interpolation, escape the `#` by writing `##`"},
        },
    }
}

// ============================================================================
// Expression Interpolation
// ======================================================================================

ExpressionInterpolation <- fmtDirectiveI:fmtDirective? lBraceI:interpolationExpressionStart inlineStart exprI:Expression inlineEnd rBraceI:interpolationExpressionEnd {
    return &ast.ExpressionInterpolation{
        FormatDirective: optCast[string](fmtDirectiveI),
        LBrace:          lBraceI.(*ast.Position),
        Expression:      optCast[ast.Expression](exprI),
        RBrace:          rBraceI.(*ast.Position),
        Position:        peekStart(c),
    }, nil
}

// ============================================================================
// Text Interpolation
// ======================================================================================

TextInterpolation <- '!' valI:onlyTextInterpolationValue {
    return &ast.TextInterpolation{
        Value:    valI.(*ast.InterpolationValue),
        NoEscape: true,
        Position: peekStart(c),
    }, nil
} / valI:InterpolationValue {
    return &ast.TextInterpolation{
        Value:    valI.(*ast.InterpolationValue),
        Position: peekStart(c),
    }, nil
}

onlyTextInterpolationValue <- interpolationTextStart txtI:onlyTextInterpolationContent rBracketI:interpolationTextEnd {
    return &ast.InterpolationValue{
        LBracket: pos(c),
        Text:     ast.TextLine{txtI.(*ast.Text)},
        RBracket: rBracketI.(*ast.Position),
    }, nil
}
onlyTextInterpolationContent <- [^\]\r\n]* {
    return ast.Text{
        Text:     string(c.text),
        Position: pos(c),
    }, nil
}

// ============================================================================
// ElementInterpolation
// ======================================================================================

ElementInterpolation <- elementInterpolation / voidElementInterpolation

elementInterpolation <- nameI:htmlTagName inlineStart attrsI:AttributeCollection* inlineEnd valI:InterpolationValue? {
    return &ast.ElementInterpolation{
        Element: ast.Element{
            Name:       concat(nameI),
            Attributes: sliceOf[ast.AttributeCollection](attrsI),
            Position:   pos(c),
        },
        Value:    optDeref[ast.InterpolationValue](valI),
        Position: peekStart(c),
    }, nil
}

voidElementInterpolation <- nameI:htmlTagName '/' inlineStart attrsI:AttributeCollection* inlineEnd {
    return &ast.ElementInterpolation{
        Element: ast.Element{
            Name:       concat(nameI),
            Attributes: sliceOf[ast.AttributeCollection](attrsI),
            Void:       true,
            Position:   pos(c),
        },
        Position: peekStart(c),
    }, nil
}

// ============================================================================
// ComponentCallInterpolation
// ======================================================================================

ComponentCallInterpolation <- '+' inlineStart callI:ComponentCallHeader inlineEnd valI:(InterpolationValue / popStart) {
    call := deref[ast.ComponentCall](callI)
    call.Position = pos(c)

    return &ast.ComponentCallInterpolation{
        ComponentCall: call,
        Value:         optCast[*ast.InterpolationValue](valI),
        Position:      pos(c),
    }, nil
}

// ============================================================================
// InterpolationValue
// ======================================================================================

InterpolationValue <- interpolationTextStart valI:InterpolationValueLine rBracketI:interpolationTextEnd {
    return &ast.InterpolationValue{
        LBracket: pos(c),
        Text:     valI.(ast.TextLine),
        RBracket: rBracketI.(*ast.Position),
    }, nil
}

// ============================================================================
// Bad Interpolation
// ======================================================================================

BadInterpolation <- '#' {
    return &ast.BadInterpolation{Position: pos(c)}, &fileerr.Error{
        Message: "bad interpolation",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Annotation: "start of interpolation",
        }),
        HintAnnotations: []fileerr.Annotation{
            anno(c, annotation{
                Start:       pos(c),
                StartOffset: 1,
                Annotation:  "expected an expression interpolation, text interpolation, a component call,\n" +
                    "or an element interpolation",
            }),
        },
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "if you didn't mean to start an interpolation, escape the `#`", Code: "`##`"},
        },
    }
}
