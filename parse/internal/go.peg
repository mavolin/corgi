// ============================================================================
// Tokens Taken From the Language Specification
// ======================================================================================

//
// Characters
//

goNewline       <- '\n'
goUnicodeChar   <- [^\n]
goUnicodeLetter <- [\pL]
goUnicodeDigit  <- [\p{Nd}]

//
// Letters and digits
//

goLetter       <- goUnicodeLetter / '_'
goDecimalDigit <- [0-9]
goBinaryDigit  <- [0-1]
goOctalDigit   <- [0-7]
goHexDigit     <- [0-9A-Fa-f]

//
// Identifiers
//

goIdentifier <- goLetter (goLetter / goUnicodeDigit)*

//
// Integer literals
//

goIntLit     <- goDecimalLit / goBinaryLit / goOctalLit / goHexLit
goDecimalLit <- '0' / [0-9] ('_'? goDecimalDigits)?
goBinaryLit  <- '0' [bB] '_'? goBinaryDigits
goOctalLit   <- '0' [oO] '_'? goOctalDigits
goHexLit     <- '0' [xX] '_'? goHexDigits

goDecimalDigits <- goDecimalDigit ('_'? goDecimalDigit)*
goBinaryDigits  <- goBinaryDigit ('_'? goBinaryDigit)*
goOctalDigits   <- goOctalDigit ('_'? goOctalDigit)*
goHexDigits     <- goHexDigit ('_'? goHexDigit)*

goQualifiedIdent <- goPackageName _* '.' _* goIdentifier
goPackageName    <- goIdentifier

//
// Floating-point literals
//

goFloatLit <- goDecimalFloatLit / goHexFloatLit

goDecimalFloatLit <- goDecimalDigits '.' goDecimalDigits? goDecimalExponent? /
                     goDecimalDigits goDecimalExponent /
                     '.' goDecimalDigits goDecimalExponent?
goDecimalExponent <- [eE] [+-]? goDecimalDigits

goHexFloatLit     <- '0' [xX] goHexMantissa goHexExponent
goHexMantissa     <- '_'? goHexDigits '.' goHexDigits? /
                     '_'? goHexDigits /
                     '.' goHexDigits
goHexExponent     <- [pP] [+-]? goDecimalDigits

//
// Imaginary literals
//

goImaginaryLit <- (goDecimalDigits / goIntLit / goFloatLit) 'i'

//
// Rune literals
//

goRuneLit <- '\'' (goRuneUnicodeValue / goByteValue / goRecoverRuneEscape) '\'' /
    '\'' valsI:(goRuneUnicodeValue / goByteValue / goRecoverRuneEscape)* '\'' endPosI:POS {
        valIs := slice(valsI)
        return c.text, &fileerr.Error{
            Message: "rune literals may not contain multiple or zero characters",
            ErrorAnnotation: anno(c, annotation{
                Start: pos(c),
                End: endPosI.(file.Position),
                Annotation: "should contain only a single character or escape sequence",
            }),
            Suggestions: []fileerr.Suggestion{
                {
                    Suggestion: "use a single character or escape sequence",
                    Example: func() string {
                        if len(valIs) > 0 {
                            return  "''" + concat(valIs[0]) + "'"
                        }
                        return "`'a'` or `'\\u1234'`"
                    }(),
                },
                {
                    Suggestion: "make this a string, if the context allows it",
                    Code: strconv.Quote(string(c.text[1:len(c.text)-1])),
                },
            },
        }
    }
goRuneUnicodeValue  <- goLittleUValue / goBigUValue / goRuneEscapedChar / [^'\\\n] // modified order; excluded ' and \ from allowed matches
goByteValue         <- goOctalByteValue / goHexByteValue
goOctalByteValue    <- '\\' goOctalDigit goOctalDigit goOctalDigit
goHexByteValue      <- '\\' 'x' goHexDigit goHexDigit /
    '\\' 'x' goHexDigit? goHexDigit? {
        return c.text, &fileerr.Error{
            Message: "invalid hex byte escape",
            ErrorAnnotation: anno(c, annotation{
                Start: pos(c),
                Len: 4,
                Annotation: "expected `\\x`, followed by two hex digits",
            }),
            Example: "`\\x1f`",
            Suggestions: []fileerr.Suggestion{
                {
                    Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
                    Code: "`\\\\" + string(c.text[1:]) + "`",
                },
            },
        }
    }
goLittleUValue <- '\\' 'u' goHexDigit goHexDigit goHexDigit goHexDigit /
    '\\' 'u' goHexDigit? goHexDigit? goHexDigit? goHexDigit? {
        suggestions := []fileerr.Suggestion{
            {
                Suggestion: "if you didn't mean to write a hex escape, escape the `\\`",
                Code: "`\\\\" + string(c.text[1:]) + "`",
            },
        }
        if len(c.text) >= 4 {
            suggestions = append(suggestions, fileerr.Suggestion{
                Suggestion: "make this a two digit hex escape",
                Code: "`\\x" + string(c.text[2:4]) + "`",
            })
        }
        suggestions = append(suggestions, fileerr.Suggestion{
            Suggestion: fmt.Sprint("append the missing ", 6-len(c.text), " hex digit(s)"),
            Example: "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 6-len(c.text)) + "`",
        })

        return c.text, &fileerr.Error{
            Message: "invalid little u escape",
            ErrorAnnotation: anno(c, annotation{
                Start: pos(c),
                Len: 6,
                Annotation: "expected `\\u`, followed by four hex digits",
            }),
            Example: "`\\u1a7f`",
            Suggestions: suggestions,
        }
    }
goBigUValue <- '\\' 'U' goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit /
    '\\' 'U' goHexDigit? goHexDigit? goHexDigit? goHexDigit? goHexDigit? goHexDigit? goHexDigit? goHexDigit? {
        suggestions := []fileerr.Suggestion{
            {
                Suggestion: "if you didn't mean to write a big U escape, escape the `\\`",
                Code: "`\\\\" + string(c.text[1:]) + "`",
            },
        }
        if len(c.text) >= 4 {
            suggestions = append(suggestions, fileerr.Suggestion{
                Suggestion: "make this a two digit hex escape",
                Code: "`\\x" + string(c.text[2:4]) + "`",
            })
        }
        if len(c.text) >= 6 {
            suggestions = append(suggestions, fileerr.Suggestion{
                Suggestion: "make this a little u escape",
                Code: "`\\u" + string(c.text[2:6]) + "`",
            })
        }
        suggestions = append(suggestions, fileerr.Suggestion{
            Suggestion: fmt.Sprint("append the missing ", 10-len(c.text), " hex digit(s)"),
            Example: "`\\U" + string(c.text[2:4]) + strings.Repeat("f", 10-len(c.text)) + "`",
        })
        return c.text, &fileerr.Error{
            Message: "invalid big u escape",
            ErrorAnnotation: anno(c, annotation{
                Start: pos(c),
                Len: 10,
                Annotation: "expected `\\U`, followed by eight hex digits",
            }),
            Example: "`\\u1a7f`",
            Suggestions: suggestions,
        }
    }
goRuneEscapedChar   <- '\\' [abfnrtv\\'] // altered from escaped_char to exclude "
goRecoverRuneEscape <- '\\' goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit {
    return c.text, &fileerr.Error{
        Message: "invalid escape sequence",
        ErrorAnnotation: anno(c, annotation{
            Start: pos(c),
            Len: 2,
            Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
        }),
        Suggestions: []fileerr.Suggestion{
            {
                Suggestion: "if you didn't mean to write an escape, escape the `\\`",
                Code: "`\\\\`",
            }, {
                Suggestion: "make this a big U escape",
                Code: "`\\U" + string(c.text[1:9]) + "`",
            }, {
                Suggestion: "make this a little u escape",
                Code: "`\\u" + string(c.text[1:5]) + "`",
            }, {
                Suggestion: "make this a hex escape",
                Code: "`\\x" + string(c.text[1:3]) + "`",
            },
        },
    }
} / '\\' goHexDigit goHexDigit goHexDigit goHexDigit {
    return c.text, &fileerr.Error{
        Message: "invalid escape sequence",
        ErrorAnnotation: anno(c, annotation{
            Start: pos(c),
            Len: 2,
            Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
        }),
        Suggestions: []fileerr.Suggestion{
            {
                Suggestion: "if you didn't mean to write an escape, escape the `\\`",
                Code: "`\\\\`",
            }, {
                Suggestion: "make this a little u escape",
                Code: "`\\u" + string(c.text[1:5]) + "`",
            }, {
                Suggestion: "make this a hex escape",
                Code: "`\\x" + string(c.text[1:3]) + "`",
            },
        },
    }
} / '\\' goHexDigit goHexDigit {
    return c.text, &fileerr.Error{
        Message: "invalid escape sequence",
        ErrorAnnotation: anno(c, annotation{
            Start: pos(c),
            Len: 2,
            Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, `\\u`, an octal escape, or `\\U`",
        }),
        Suggestions: []fileerr.Suggestion{
            {
                Suggestion: "if you didn't mean to write an escape, escape the `\\`",
                Code: "`\\\\`",
            }, {
                Suggestion: "make this a hex escape",
                Code: "`\\x" + string(c.text[1:3]) + "`",
            },
        },
    }
} / '\\' {
    return c.text, &fileerr.Error{
        Message: "invalid escape sequence",
        ErrorAnnotation: anno(c, annotation{
            Start: pos(c),
            Len: 2,
            Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\'`, `\\x`, an octal escape, `\\u`, or `\\U`",
        }),
        Suggestions: []fileerr.Suggestion{
            {
                Suggestion: "if you didn't mean to write an escape, escape the `\\`",
                Code: "`\\\\`",
            },
        },
    }
}
goRecoverInterpretedStringEscape <- '\\' goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit goHexDigit {
    return c.text, &fileerr.Error{
        Message: "invalid escape sequence",
        ErrorAnnotation: anno(c, annotation{
            Start: pos(c),
            Len: 2,
            Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
        }),
        Suggestions: []fileerr.Suggestion{
            {
                Suggestion: "if you didn't mean to write an escape, escape the `\\`",
                Code: "`\\\\`",
            }, {
                Suggestion: "make this a big U escape",
                Code: "`\\U" + string(c.text[1:9]) + "`",
            }, {
                Suggestion: "make this a little u escape",
                Code: "`\\u" + string(c.text[1:5]) + "`",
            }, {
                Suggestion: "make this a hex escape",
                Code: "`\\x" + string(c.text[1:3]) + "`",
            },
        },
    }
} / '\\' goHexDigit goHexDigit goHexDigit goHexDigit {
    return c.text, &fileerr.Error{
        Message: "invalid escape sequence",
        ErrorAnnotation: anno(c, annotation{
            Start: pos(c),
            Len: 2,
            Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
        }),
        Suggestions: []fileerr.Suggestion{
            {
                Suggestion: "if you didn't mean to write an escape, escape the `\\`",
                Code: "`\\\\`",
            }, {
                Suggestion: "make this a little u escape",
                Code: "`\\u" + string(c.text[1:5]) + "`",
            }, {
                Suggestion: "make this a hex escape",
                Code: "`\\x" + string(c.text[1:3]) + "`",
            },
        },
    }
} / '\\' goHexDigit goHexDigit {
    return c.text, &fileerr.Error{
        Message: "invalid escape sequence",
        ErrorAnnotation: anno(c, annotation{
            Start: pos(c),
            Len: 2,
            Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, `\\u`, an octal escape, or `\\U`",
        }),
        Suggestions: []fileerr.Suggestion{
            {
                Suggestion: "if you didn't mean to write an escape, escape the `\\`",
                Code: "`\\\\`",
            }, {
                Suggestion: "make this a hex escape",
                Code: "`\\x" + string(c.text[1:3]) + "`",
            },
        },
    }
} / '\\' {
    return c.text, &fileerr.Error{
        Message: "invalid escape sequence",
        ErrorAnnotation: anno(c, annotation{
            Start: pos(c),
            Len: 2,
            Annotation: "expected `\\a`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\`, `\\\"`, `\\x`, an octal escape, `\\u`, or `\\U`",
        }),
        Suggestions: []fileerr.Suggestion{
            {
                Suggestion: "if you didn't mean to write an escape, escape the `\\`",
                Code: "`\\\\`",
            },
        },
    }
}

//
// String literals
//

goStringLit <- goRawStringLit / goInterpretedStringLit

goRawStringLit <- '`' goRawStringUnicodeChar* '`' /
    '`' goRawStringUnicodeChar* EOL {
        return c.text, &fileerr.Error{
            Message: "unclosed string literal",
            ErrorAnnotation: anno(c, annotation{
                Start: pos(c),
                EOLDelta: 1,
                Annotation: "expected a ``` somewhere here",
            }),
        }
}
goRawStringUnicodeChar <- [^`]

goInterpretedStringLit <- '"' (goInterpretedStringUnicodeValue / goByteValue / goRecoverInterpretedStringEscape)* '"' /
    '"' (goInterpretedStringUnicodeValue / goByteValue / goRecoverInterpretedStringEscape)* EOF {
        return c.text, &fileerr.Error{
            Message: "unclosed string literal",
            ErrorAnnotation: anno(c, annotation{
                Start: pos(c),
                EOLDelta: 1,
                Annotation: "expected a `\"` somewhere here",
            }),
        }
    }
goInterpretedStringUnicodeValue <- goLittleUValue / goBigUValue /
    goInterpretedStringEscapedChar / [^"\\\n] // modified version of goRuneUnicodeValue, but for string lits

goInterpretedStringEscapedChar  <- '\\' [abfnrtv\\"] // altered from escaped_char to exclude '

//
// Types
//

goType     <- (goTypeName (_* goTypeArgs)?) / goTypeLit / '(' _* goType _* ')'
goTypeName <- goQualifiedIdent / goIdentifier
goTypeArgs <- '[' _* goTypeList _* (',' _*)? ']'
goTypeList <- goType _* (',' _* goType)*
goTypeLit  <- (goArrayType / goStructType / goPointerType / goFunctionType / goInterfaceType / goSliceType / goMapType / goChannelType)

//
// Array types
//

goArrayType   <- '[' _* goArrayLength _* ']' _* goElementType
goArrayLength <- [0-9]+ (_* ("<<" / ">>" / '+' / '-' / '*' / '/') _* goArrayLength)? // heavily simplified, because i don't want to put the entire go grammar in here
goElementType <- goType

//
// Slice types
//

goSliceType <- "[]" _* goElementType

//
// Struct types
//

goStructType    <- "struct" _* '{' (WS* goFieldDecl* (';' / VERT_WS))* WS* '}'
goFieldDecl     <- (goIdentifierList _* goType / goEmbeddedField) goTag?
goEmbeddedField <- '*'? _* goTypeName _* goTypeArgs?
goTag           <- goStringLit

//
// Pointer types
//

goPointerType <- '*' _* goBaseType
goBaseType    <- goType

//
// Function types
//

goFunctionType  <- "func" _* goSignature
goSignature     <- goParameters _* goResult?
goResult        <- goParameters / goType
goParameters    <- '(' WS* (goParameterList _* (',' WS*)?)? ')'
goParameterList <- goParameterDecl _* (',' WS* goParameterDecl)*
goParameterDecl <- goIdentifierList? _* "..."? _* goType

//
// Interface types
//

goInterfaceType  <- "interface" _* '{' (WS* goInterfaceElem _* (';' / EMPTY_LINE*))* WS* '}'
goInterfaceElem  <- goMethodElem / goTypeElem
goMethodElem     <- goMethodName goSignature
goMethodName     <- goIdentifier
goTypeElem       <- goTypeTerm (_* '|' WS* goTypeTerm)*
goTypeTerm       <- goType / goUnderlyingType
goUnderlyingType <- '~' goType

//
// Map types
//

goMapType <- "map" _* '[' _* goKeyType _* ']' _* goElementType
goKeyType <- goType

//
// Channel types
//

goChannelType <- ("<-" _*)? "chan" _* ("<-" _*)? goElementType

//
// Constant declarations
//

goIdentifierList <- goIdentifier _* (',' WS* goIdentifier)*
