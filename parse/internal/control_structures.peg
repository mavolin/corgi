missingCondition <- posI:POS {
    return nil, &fileerr.Error{
        Message: "missing condition",
        ErrorAnnotation: anno(c, annotation{
            Start: posI.(file.Position),
            StartOffset: 1,
            Annotation: "expected an expression",
        }),
    }
}

// ============================================================================
// If
// ======================================================================================

If <- "if" condI:ifCondition thenI:Body elseIfsI:ElseIf* elseI:Else? {
    return file.If{
        Condition: condI.(file.IfExpression),
        Then:      optCast[file.Body](thenI),
        ElseIfs:   sliceOf[file.ElseIf](elseIfsI),
        Else:      optCastPtr[file.Else](elseI),
        Position:  pos(c),
    }, nil
}

ElseIf <- WS* "else" _* "if" condI:ifCondition _* thenI:Body {
    return file.ElseIf{
        Condition: condI.(file.IfExpression),
        Then:      optCast[file.Body](thenI),
        Position:  pos(c),
    }, nil
}

Else <- WS* "else" _* thenI:Body {
    return file.Else{
        Then:     optCast[file.Body](thenI),
        Position: pos(c),
    }, nil
}

ifCondition <- _+ condI:IfExpression {
    return condI, nil
} / missingCondition {
    return file.IfExpression{}, nil
}

// ============================================================================
// Switch
// ======================================================================================

Switch <- "switch" comparatorI:switchComparator endI:POS casesI:switchCases {
    s := file.Switch{
        Comparator: comparatorI.(*file.GoCode),
        Cases:      casesI.([]file.Case),
        Position:   pos(c),
    }

    for _, c := range s.Cases {
        if c.Expression != nil {
            return s, nil
        }
    }

    return s, &fileerr.Error{
        Message: "switch: no cases",
        ErrorAnnotation: anno(c, annotation{
            ContextEndDelta: 1,
            Start:           pos(c),
            End:             endI.(file.Position),
            Annotation:      "expected switch to have at least one non-default case",
        }),
    }
}

switchComparator <- _* &'{' {
    return (*file.GoCode)(nil), nil
} / _+ compI:ConditionalGoExpression _* &'{' {
    return ptr(compI.(file.GoCode)), nil
} / _+ compI:ConditionalGoExpression startI:POS [^\r\n{]+ endI:POS {
    return ptr(compI.(file.GoCode)),
        newUnexpectedTokensErr(c, startI.(file.Position), endI.(file.Position), "switch comparator terminated early")
}

switchCases <- scopeStart WS* preFirstCase? itms:switchCase* WS* endI:scopeEnd {
    cases := sliceOf[file.Case](itms)

    var firstDefault *file.Case
    for _, ca := range cases {
        if ca.Expression != nil {
            continue
        }
        if firstDefault == nil {
            firstDefault = &ca
            continue
        }

        return cases, &fileerr.Error{
            Message: "multiple default cases in switch",
            ErrorAnnotation: anno(c, annotation{
                Start:      ca.Position,
                Len:        len("default"),
                Annotation: "second default case",
            }),
            HintAnnotations: []fileerr.Annotation{
                anno(c, annotation{
                    Start:      firstDefault.Position,
                    Len:        len("default"),
                    Annotation: "first default case",
                }),
            },
        }
    }

    return cases, nil
}

preFirstCase <- (!("case" / "default") [^{}] / '{' preFirstCase '}'?)+ {
    return nil, &fileerr.Error{
        Message: "switch: unexpected tokens",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Annotation: "expected a `case` or `default`",
        }),
    }
}

switchCase <- WS* caseI:(Case / Default) {
    return caseI, nil
}

Case <- "case" _+ condI:caseCondition _* colonI:switchColon thenI:switchThen? {
    return file.Case{
        Expression: condI.(file.Expression),
        Colon:      colonI.(file.Position),
        Then:       optCast[file.Scope](thenI),
        Position:   pos(c),
    }, nil
}

Default <- "default" _* colonI:switchColon thenI:switchThen? {
    return file.Case{
        Colon:    colonI.(file.Position),
        Then:     optCast[file.Scope](thenI),
        Position: pos(c),
    }, nil
}

switchColon <- ':' {
    return pos(c), nil
} / POS {
    return pos(c), &fileerr.Error{
        Message: "switch case: missing colon",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Annotation: "expected a colon",
        }),
    }
}

caseCondition <- _+ condI:Expression {
    return condI, nil
} / missingCondition {
    return nil, nil
}

switchThen <- itmsI:switchScopeItem+ {
    return file.Scope{Items: sliceOf[file.ScopeItem](itmsI)}, nil
}

switchScopeItem <- !('}' / "case" _+ / "default" _* ':') itmI:scopeItem {
    return itmI, nil
}

// ============================================================================
// For
// ======================================================================================

For <- "for" exprI:forExpression? _* bodyI:Body {
    return file.For{
        Expression: optCast[file.ForExpression](exprI),
        Body:       optCast[file.Body](bodyI),
        Position:   pos(c),
    }, nil
}

forExpression <- _+ condI:ForExpression {
    return condI, nil
}

