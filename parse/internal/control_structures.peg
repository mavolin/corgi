missingCondition <- posI:POS {
    return nil, &fileerr.Error{
        Message: "missing condition",
        ErrorAnnotation: anno(c, annotation{
            Start:       *posI.(*ast.Position),
            StartOffset: 1,
            Annotation:  "expected an expression",
        }),
    }
}

// ============================================================================
// If
// ======================================================================================

If <- "if" condI:ifCondition thenI:Body elseIfsI:ElseIf* elseI:Else? {
    return &ast.If{
        Condition: condI.(*ast.IfExpression),
        Then:      optCast[ast.Body](thenI),
        ElseIfs:   sliceOf[*ast.ElseIf](elseIfsI),
        Else:      optCast[*ast.Else](elseI),
        Position:  pos(c),
    }, nil
}

ElseIf <- WS* "else" _* "if" condI:ifCondition _* thenI:Body {
    return &ast.ElseIf{
        Condition: condI.(*ast.IfExpression),
        Then:      optCast[ast.Body](thenI),
        Position:  pos(c),
    }, nil
}

Else <- WS* "else" _* thenI:Body {
    return &ast.Else{
        Then:     optCast[ast.Body](thenI),
        Position: pos(c),
    }, nil
}

ifCondition <- _+ condI:IfExpression {
    return condI, nil
} / missingCondition {
    return (*ast.IfExpression)(nil), nil
}

// ============================================================================
// Switch
// ======================================================================================

Switch <- "switch" comparatorI:switchComparator endI:POS casesI:switchCases {
    s := ast.Switch{
        Comparator: comparatorI.(*ast.GoCode),
        Cases:      casesI.([]*ast.Case),
        Position:   pos(c),
    }

    for _, c := range s.Cases {
        if c.Expression != nil {
            return s, nil
        }
    }

    return s, &fileerr.Error{
        Message: "switch: no cases",
        ErrorAnnotation: anno(c, annotation{
            ContextEndDelta: 1,
            Start:           pos(c),
            End:             *endI.(*ast.Position),
            Annotation:      "expected switch to have at least one non-default case",
        }),
    }
}

switchComparator <- _* &'{' {
    return (*ast.GoCode)(nil), nil
} / _+ compI:ConditionalGoExpression _* &'{' {
    return compI.(*ast.GoCode), nil
} / _+ compI:ConditionalGoExpression startI:POS [^\r\n{]+ endI:POS {
    return compI.(*ast.GoCode),
        newUnexpectedTokensErr(c, *startI.(*ast.Position), *endI.(*ast.Position), "switch comparator terminated early")
}

switchCases <- scopeStart WS* preFirstCase? itms:switchCase* WS* endI:scopeEnd {
    cases := sliceOf[*ast.Case](itms)

    var firstDefault *ast.Case
    for _, ca := range cases {
        if ca.Expression != nil {
            continue
        }
        if firstDefault == nil {
            firstDefault = ca
            continue
        }

        return cases, &fileerr.Error{
            Message: "multiple default cases in switch",
            ErrorAnnotation: anno(c, annotation{
                Start:      ca.Position,
                Len:        len("default"),
                Annotation: "second default case",
            }),
            HintAnnotations: []fileerr.Annotation{
                anno(c, annotation{
                    Start:      firstDefault.Position,
                    Len:        len("default"),
                    Annotation: "first default case",
                }),
            },
        }
    }

    return cases, nil
}

preFirstCase <- (!("case" / "default") [^{}] / '{' preFirstCase '}'?)+ {
    return nil, &fileerr.Error{
        Message: "switch: unexpected tokens",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Annotation: "expected a `case` or `default`",
        }),
    }
}

switchCase <- WS* caseI:(Case / Default) {
    return caseI, nil
}

Case <- "case" _+ condI:caseCondition _* colonI:switchColon thenI:switchThen? {
    return &ast.Case{
        Expression: optCast[ast.Expression](condI),
        Colon:      colonI.(*ast.Position),
        Then:       optCast[ast.Body](thenI),
        Position:   pos(c),
    }, nil
}

Default <- "default" _* colonI:switchColon thenI:switchThen? {
    return &ast.Case{
        Colon:    colonI.(*ast.Position),
        Then:     optCast[ast.Body](thenI),
        Position: pos(c),
    }, nil
}

switchColon <- ':' {
    return pos(c), nil
} / POS {
    return pos(c), &fileerr.Error{
        Message: "switch case: missing colon",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Annotation: "expected a colon",
        }),
    }
}

caseCondition <- _+ condI:Expression {
    return condI, nil
} / missingCondition {
    return nil, nil
}

switchThen <- itmsI:switchScopeItem+ {
    return &ast.Scope{Items: sliceOf[ast.ScopeItem](itmsI)}, nil
}

switchScopeItem <- !('}' / "case" _+ / "default" _* ':') itmI:ScopeItem {
    return itmI, nil
}

// ============================================================================
// For
// ======================================================================================

For <- "for" exprI:forExpression? _* bodyI:Body {
    return &ast.For{
        Expression: optCast[ast.ForExpression](exprI),
        Body:       optCast[ast.Body](bodyI),
        Position:   pos(c),
    }, nil
}

forExpression <- _+ condI:ForExpression {
    return condI, nil
}

