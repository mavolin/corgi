Expression    <- ChainExpression / GoExpression
ForExpression <- RangeExpression / ChainExpression / GoExpression

IfExpression <- stmtI:goIfConditionStatement? condI:(ChainExpression / ConditionalGoExpression) {
    return file.IfExpression{
        Statement: optCastPtr[file.GoCode](stmtI),
        Condition: optCast[file.Expression](condI),
    }, nil
}
goIfConditionStatement <- !([^;\r\n{[]* [{[]) stmtI:GoStatement EOC WS* {
    return stmtI, nil
}

// ============================================================================
// Range Expression
// ======================================================================================

RangeExpression <- varsI:rangeExpressionVars? orderedI:("ordered" _+)? "range" _+ exprI:Expression {
    e := optCast[file.RangeExpression](varsI)
    e.Ordered = orderedI != nil
    e.RangeExpression = optCast[file.Expression](exprI)
    e.Position = pos(c)
    return e, nil
}

rangeExpressionVars <- var1I:Ident var2I:(_* ',' _* Ident)? _* eqPosI:POS declaresI:':'? '=' _* {
    return file.RangeExpression{
        Var1:      ptr(var1I.(file.Ident)),
        Var2:      optGetTuplePtr[file.Ident](var2I, -1),
        EqualSign: eqPosI.(file.Position),
        Declares:  declaresI != nil,
    }, nil
}

// ============================================================================
// Chain Expression
// ======================================================================================

ChainExpression <- derefsI:chainExpressionDerefs rootI:chainExpressionRoot checkRootI:'?'? chainI:ChainExpressionItem*
                   defaultI:chainExpressionDefault? endPosI:POS _* &{
    return checkRootI != nil || chainExprItmsCheck(sliceOf[file.ChainExpressionItem](chainI)) || defaultI != nil, nil
} chainExpressionTrail {
    expr := optCast[file.ChainExpression](defaultI)
    expr.Root = rootI.(file.RawGoCode)
    expr.CheckRoot = checkRootI != nil
    expr.Chain = sliceOf[file.ChainExpressionItem](chainI)
    expr.DerefCount = derefsI.(int)
    expr.Position = pos(c)
    return expr, nil
}
chainExpressionTrail <- !GoExpression / GoExpression endI:POS {
    return nil, &fileerr.Error{
        Message: "malformed chain expression",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            End:        endI.(file.Position),
            Annotation: "unable to parse this line or the lines below",
        }),
        HintAnnotations: []fileerr.Annotation{
            anno(c, annotation{
                Start:      pos(c),
                End:        endI.(file.Position),
                Annotation: "this is valid",
            }),
        },
        Suggestions: []fileerr.Suggestion{
            {
                Suggestion: "did you mean to put a default? default values start with the `~` operator",
                Example: "`woof?.bark[12?] ~ someDefault`",
            },
            {
                Suggestion: "remember that chain expressions cannot be embedded in Go expressions;\n" +
                    "you can either write a chain expression or a Go expression",
            },
        },
    }
}

chainExpressionDerefs <- '*'* {
    return len(c.text), nil
}

chainExpressionRoot <- (goIdentifier / '(' chainExpressionRootParenContent+ ')') {
    return file.RawGoCode{
        Code:     string(c.text),
        Position: pos(c),
    }, nil
}

chainExpressionRootParenContent <- '(' chainExpressionRootParenContent ')' /
                                   '[' chainExpressionRootParenContent ']' /
                                   '{' chainExpressionRootParenContent '}' /
                                   [^({[\]})]+

chainExpressionDefault <- '~' WS* exprI:GoExpression {
    return file.ChainExpression{
        DefaultOperator: ptr(pos(c)),
        Default:         ptr(exprI.(file.GoCode)),
    }, nil
}

//
// Chain Expression Item
//

ChainExpressionItem <- IndexExpression / DotIdentExpression / ParenExpression / TypeAssertionExpression

IndexExpression <- indexStart exprI:GoExpression checkIndexI:'?'? rBracketI:indexExpressionEnd checkValueI:'?'? {
    return file.IndexExpression{
        LBracket:   pos(c),
        Index:      exprI.(file.GoCode),
        RBracket:   rBracketI.(file.Position),
        CheckIndex: checkIndexI != nil,
        CheckValue: checkValueI != nil,
    }, nil
}
indexExpressionEnd <- indexEnd / POS {
    return unclosedIndex(c, "index")
}

DotIdentExpression <- '.' WS* identI:Ident checkI:'?'? {
    return file.DotIdentExpression{
        Ident:    identI.(file.Ident),
        Check:    checkI != nil,
        Position: pos(c),
    }, nil
}

ParenExpression <- listStart argsI:parenExpressionArgs? rParen:parenExpressionEnd checkI:'?'? {
    return file.ParenExpression{
        LParen: pos(c),
        Args:   optCast[[]file.GoCode](argsI),
        RParen: rParen.(file.Position),
        Check:  checkI != nil,
    }, nil
}
parenExpressionEnd <- listEnd / POS {
    return unclosedList(c, "parentheses")
}
parenExpressionArgs <- firstI:GoExpression restI:(_* ',' WS* GoExpression)* {
    return collectList[file.GoCode](firstI, restI, -1), nil
}

TypeAssertionExpression <- '.' lParenI:L_PAREN _* ptrsI:'*'* _* packageI:Namespace? typeI:Ident _* rParenI:R_PAREN checkI:'?'? {
    return file.TypeAssertionExpression{
        LParen:       lParenI.(file.Position),
        PointerCount: len(slice(ptrsI)),
        Package:      optCastPtr[file.Ident](packageI),
        Type:         typeI.(file.Ident),
        RParen:       rParenI.(file.Position),
        Check:        checkI != nil,
    }, nil
}
