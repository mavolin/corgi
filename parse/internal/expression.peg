Expression    <- ChainExpression / GoExpression
ForExpression <- RangeExpression / ChainExpression / GoExpression

IfExpression <- stmtI:goIfConditionStatement? condI:(ChainExpression / ConditionalGoExpression) {
    return &ast.IfExpression{
        Statement: optCast[*ast.GoCode](stmtI),
        Condition: optCast[ast.Expression](condI),
    }, nil
}
goIfConditionStatement <- !([^;\r\n{[]* [{[]) stmtI:GoStatement EOC WS* {
    return stmtI, nil
}

// ============================================================================
// Range Expression
// ======================================================================================

RangeExpression <- varsI:rangeExpressionVars? orderedI:("ordered" _+)? "range" _+ exprI:Expression {
    e := optCast[ast.RangeExpression](varsI)
    e.Ordered = orderedI != nil
    e.RangeExpression = optCast[ast.Expression](exprI)
    e.Position = pos(c)
    return &e, nil
}

rangeExpressionVars <- var1I:Ident var2I:(_* ',' _* Ident)? _* eqPosI:POS declaresI:':'? '=' _* {
    return ast.RangeExpression{
        Var1:      var1I.(*ast.Ident),
        Var2:      optGetTuple[*ast.Ident](var2I, -1),
        EqualSign: eqPosI.(*ast.Position),
        Declares:  declaresI != nil,
    }, nil
}

// ============================================================================
// Chain Expression
// ======================================================================================

ChainExpression <- derefsI:chainExpressionDerefs rootI:chainExpressionRoot checkRootI:'?'? chainI:ChainExpressionItem*
                   defaultI:chainExpressionDefault? endPosI:POS _* &{
    return checkRootI != nil || chainExprItmsCheck(sliceOf[ast.ChainExpressionItem](chainI)) || defaultI != nil, nil
} chainExpressionTrail? {
    expr := optCast[ast.ChainExpression](defaultI)
    expr.Root = rootI.(*ast.RawGoCode)
    expr.CheckRoot = checkRootI != nil
    expr.Chain = sliceOf[ast.ChainExpressionItem](chainI)
    expr.DerefCount = derefsI.(int)
    expr.Position = pos(c)
    return &expr, nil
}
chainExpressionTrail <-  GoExpression endI:POS {
    return nil, &fileerr.Error{
        Message: "malformed chain expression",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            End:        *endI.(*ast.Position),
            Annotation: "unable to parse this line or the lines below",
        }),
        Suggestions: []fileerr.Suggestion{
            {
                Suggestion: "did you mean to put a default? default values start with the `~` operator",
                Example: "`woof?.bark[12?] ~ someDefault`",
            },
            {
                Suggestion: "remember that chain expressions cannot be embedded in Go expressions;\n" +
                    "you can either write a chain expression or a Go expression",
            },
        },
    }
}

chainExpressionDerefs <- '*'* {
    return len(c.text), nil
}

chainExpressionRoot <- (goIdentifier / '(' chainExpressionRootParenContent+ ')') {
    return &ast.RawGoCode{
        Code:     string(c.text),
        Position: pos(c),
    }, nil
}

chainExpressionRootParenContent <- '(' chainExpressionRootParenContent ')' /
                                   '[' chainExpressionRootParenContent ']' /
                                   '{' chainExpressionRootParenContent '}' /
                                   [^({[\]})]+

chainExpressionDefault <- posI:POS '~' WS* exprI:GoExpression {
    return ast.ChainExpression{
        DefaultOperator: posI.(*ast.Position),
        Default:         exprI.(*ast.GoCode),
    }, nil
}

//
// Chain Expression Item
//

ChainExpressionItem <- IndexExpression / DotIdentExpression / ParenExpression / TypeAssertionExpression

IndexExpression <- indexStart exprI:GoExpression checkIndexI:'?'? rBracketI:indexExpressionEnd checkValueI:'?'? {
    return &ast.IndexExpression{
        LBracket:   pos(c),
        Index:      exprI.(*ast.GoCode),
        RBracket:   rBracketI.(*ast.Position),
        CheckIndex: checkIndexI != nil,
        CheckValue: checkValueI != nil,
    }, nil
}
indexExpressionEnd <- indexEnd / POS {
    return unclosedIndex(c, "index")
}

DotIdentExpression <- '.' WS* identI:Ident checkI:'?'? {
    return &ast.DotIdentExpression{
        Ident:    identI.(*ast.Ident),
        Check:    checkI != nil,
        Position: pos(c),
    }, nil
}

ParenExpression <- listStart argsI:parenExpressionArgs? rParen:parenExpressionEnd checkI:'?'? {
    return &ast.ParenExpression{
        LParen: pos(c),
        Args:   optCast[[]*ast.GoCode](argsI),
        RParen: rParen.(*ast.Position),
        Check:  checkI != nil,
    }, nil
}
parenExpressionEnd <- listEnd / POS {
    return unclosedList(c, "parentheses")
}
parenExpressionArgs <- firstI:GoExpression restI:(_* ',' WS* GoExpression)* {
    return collectList[*ast.GoCode](firstI, restI, -1), nil
}

TypeAssertionExpression <- '.' lParenI:L_PAREN _* ptrsI:'*'* _* packageI:Namespace? typeI:Ident _* rParenI:R_PAREN checkI:'?'? {
    return &ast.TypeAssertionExpression{
        LParen:       lParenI.(*ast.Position),
        PointerCount: len(slice(ptrsI)),
        Package:      optCast[*ast.Ident](packageI),
        Type:         typeI.(*ast.Ident),
        RParen:       rParenI.(*ast.Position),
        Check:        checkI != nil,
        Position:     pos(c),
    }, nil
}
