// ============================================================================
// Package Directive
// ======================================================================================

PackageDoc <- commentsI:(EMPTY_LINE+ / CorgiComment)* {
    commentIs := slice(commentsI)
    comments := make([]file.CorgiComment, 0, len(commentIs))
    for _, cI := range commentIs {
        if c, ok := cI.(file.CorgiComment); ok {
            comments = append(comments, c)
        }
    }
    comments = comments[:len(comments):len(comments)]
    return comments, nil
}

Package <- PackageDirective / MissingPackageDirective

PackageDirective <- "package" _+ nameI:packageName {
    return file.PackageDirective{
        Name:     nameI.(file.Ident),
        Position: pos(c),
    }, nil
}

packageName <- identI:Ident EOL {
    return identI, nil
} / EOL {
    return file.Ident{}, &fileerr.Error{
        Message: "missing package name",
        ErrorAnnotation: anno(c, annotation{
            Start:       pos(c),
            StartOffset: 1,
            Annotation:  "expected a package name",
        }),
        Example: "`package woof`",
    }
} / startI:POS identI:UNEXPECTED EOL {
    return invalidIdent(c, "package", startI.(file.Position), identI.(string))
}

MissingPackageDirective <- POS {
    return file.PackageDirective{}, &fileerr.Error{
        Message: "missing package directive",
        ErrorAnnotation: anno(c, annotation{
            Start:       pos(c),
            ToEOL:       true,
            Annotation:  "expected `package` directive as first non-comment, found this instead",
        }),
        Example: "`package woof`",
    }
}

// ============================================================================
// Import
// ======================================================================================

Import <- SingleImport / GroupImport / BadImport

SingleImport <- "import" _+ specI:ImportSpec EOC {
    return file.Import{
        Imports:  []file.ImportScopeItem{specI.(file.ImportSpec)},
        Position: pos(c),
    }, nil
}

GroupImport <- "import" _* startI:listStart itmsI:importScopeItem* rParenI:groupImportEnd {
    return file.Import{
        LParen:   ptr(startI.(file.Position)),
        Imports:  sliceOf[file.ImportScopeItem](itmsI),
        RParen:   ptr(rParenI.(file.Position)),
        Position: pos(c),
    }, nil
}

groupImportEnd <- WS* rParenI:R_PAREN {
    return rParenI, nil
} / POS {
    return nil, &fileerr.Error{
        Message: "missing `)`",
        ErrorAnnotation: anno(c, annotation{
            Start:       pos(c),
            Annotation:  "expected `)` to close the import group",
        }),
    }
}

BadImport <- "import" _* startI:POS badI:UNEXPECTED endI:EOC {
    return file.Import{
        Imports: []file.ImportScopeItem{
            file.BadImportSpec{
                Line:     badI.(string),
                Position: startI.(file.Position),
            },
        },
        Position: pos(c),
    }, &fileerr.Error{
        Message: "invalid import",
        ErrorAnnotation: anno(c, annotation{
            Start:       startI.(file.Position),
            End:         endI.(file.Position),
            Annotation:  "expected an import path, optionally preceded by an import alias\n" +
                "or a group of imports",
        }),
        Example: "`import \"fmt\"`",
    }
}

importScopeItem <- WS* itmI:(CorgiComment / ImportSpec / BadImportSpec) {
    return itmI, nil
}

ImportSpec <- aliasI:importAlias? pathI:StaticString EOC {
    return file.ImportSpec{
        Alias:    optCastPtr[file.Ident](aliasI),
        Path:     pathI.(file.StaticString),
        Position: pos(c),
    }, nil
}

importAlias <- '.' _* {
    return file.Ident{Ident: ".", Position: pos(c)}, nil
} / identI:Ident _* {
    return identI, nil
} / (!(_* [`"]) .)+ {
    return invalidIdent(c, "import alias", pos(c), string(c.text))
}

BadImportSpec <- lineI:UNEXPECTED EOC {
    line := lineI.(string)
    return file.BadImportSpec{
        Line:     line,
        Position: pos(c),
    }, &fileerr.Error{
        Message: "invalid import spec",
        ErrorAnnotation: anno(c, annotation{
            Start:       pos(c),
            Len:         len(line),
            Annotation:  "expected an import path, optionally preceded by an import alias",
        }),
    }
}

// ============================================================================
// State
// ======================================================================================

State <- SingleState / GroupState / BadState

SingleState <- "state" _+ varI:StateVar EOC {
    return file.State{
        Vars:     []file.StateScopeItem{varI.(file.StateVar)},
        Position: pos(c),
    }, nil
}

GroupState <- "state" _* startI:listStart itmsI:stateScopeItem* rParenI:groupStateEnd {
    return file.State{
        LParen:   ptr(startI.(file.Position)),
        Vars:     sliceOf[file.StateScopeItem](itmsI),
        RParen:   ptr(rParenI.(file.Position)),
        Position: pos(c),
    }, nil
}

groupStateEnd <- WS* rParenI:R_PAREN {
    return rParenI, nil
} / POS {
    return nil, &fileerr.Error{
        Message: "missing `)`",
        ErrorAnnotation: anno(c, annotation{
            Start:       pos(c),
            Annotation:  "expected `)` to close the state group",
        }),
    }
}

BadState <- "state" _* startI:POS badI:UNEXPECTED endI:EOC {
    return file.State{
        Vars: []file.StateScopeItem{
            file.BadStateVar{
                Line:     badI.(string),
                Position: startI.(file.Position),
            },
        },
        Position: pos(c),
    }, &fileerr.Error{
        Message: "invalid state",
        ErrorAnnotation: anno(c, annotation{
            Start:      startI.(file.Position),
            End:        endI.(file.Position),
            Annotation: "expected a state variable declaration or a group of state variables",
        }),
        Example: "`state bark = \"woof\"`",
    }
}

stateScopeItem <- WS* itmI:(CorgiComment / StateVar / BadStateVar) {
    return itmI, nil
}

StateVar <- namesI:stateVarNames _* typI:stateVarType? _* assignI:POS valsI:stateVarValues {
    names := namesI.([]file.Ident)
    vals := valsI.([]file.GoCode)

    if len(names) != len(vals) && len(vals) > 0 {
        return file.StateVar{}, &fileerr.Error{
            Message: "state variable: unequal variable declarations and initializations",
            ErrorAnnotation: anno(c, annotation{
                Start:      pos(c),
                Annotation: fmt.Sprintf("have %d declarations and %d initializations", len(names), len(vals)),
            }),
            Example: "`state bark, howl = \"woof\", \"awoooo\"`",
            Suggestions: []fileerr.Suggestion{
                {Suggestion: "the number of variable names must always match the number of expressions"},
            },
        }
    }

    var assign *file.Position
    if len(vals) > 0 {
        assign = ptr(assignI.(file.Position))
    }

    return file.StateVar{
        Names:    names,
        Type:     optCastPtr[file.Type](typI),
        Assign:   assign,
        Values:   vals,
    }, nil
}

stateVarNames <- firstI:stateVarIdent restI:(_* ',' _* stateVarIdent)* {
    rest := getTuples[file.Ident](restI, -1)
    names := make([]file.Ident, 1, 1+len(rest))
    names[0] = firstI.(file.Ident)
    names = append(names, rest...)
    return names, nil
}

stateVarIdent <- Ident / [^\r\n\t ,=]+ {
    return invalidIdent(c, "state variable", pos(c), string(c.text))
}

stateVarType <- typI:Type _* {
    return typI, nil
} / (!(_* '=') [^\r\n])+ _* {
    return file.Type{
        Type:     string(c.text),
        Position: pos(c),
    }, &fileerr.Error{
        Message: "invalid type",
        ErrorAnnotation: anno(c, annotation{
            Start:       pos(c),
            Len:         len(c.text),
            Annotation:  "this is not a valid Go type",
        }),
    }
}

stateVarValues <- '=' WS* valsI:stateVarValueList EOC {
    return valsI, nil
} / '=' WS* valsI:stateVarValueList? startI:POS badI:UNEXPECTED endI:EOC {
    return optCast[[]file.GoCode](valsI),
        newUnexpectedTokensErr(c, startI.(file.Position), endI.(file.Position), "unexpected tokens")
} / '=' WS* startI:POS UNEXPECTED endI:EOC {
    return ([]file.GoCode)(nil), &fileerr.Error{
        Message: "invalid state variable values",
        ErrorAnnotation: anno(c, annotation{
            Start:       startI.(file.Position),
            End:         endI.(file.Position),
            Annotation:  "expected one or more Go expressions",
        }),
        Example: "`state bark = \"woof\"`",
    }
} / EOC {
    return ([]file.GoCode)(nil), nil
}

stateVarValueList <- firstI:GoExpression restI:(_* ',' _* GoExpression)* {
    rest := getTuples[file.GoCode](restI, -1)
    values := make([]file.GoCode, 1, 1+len(rest))
    values[0] = firstI.(file.GoCode)
    values = append(values, rest...)
    return values, nil
}

BadStateVar <- lineI:UNEXPECTED EOC {
    line := lineI.(string)
    return file.BadStateVar{
        Line:     line,
        Position: pos(c),
    }, &fileerr.Error{
        Message: "invalid state variable",
        ErrorAnnotation: anno(c, annotation{
            Start:       pos(c),
            Len:         len(line),
            Annotation:  "expected a state variable declaration",
        }),
    }
}
