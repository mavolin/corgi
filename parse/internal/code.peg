// ============================================================================
// Global Code
// ======================================================================================

GlobalCode <- !("import" / "comp" / "state") stmtI:GoStatement EOC {
    return file.Code{Statements: []file.GoCode{stmtI.(file.GoCode)}, Position: pos(c)}, nil
}

// ============================================================================
// Code
// ======================================================================================

Code <- implicitCode / explicitCode

explicitCode <- INDENTATION_REF "- " codeStatementsI:codeStatements {
    return file.Code{
        Statements: codeStatementsI.([]file.GoCode),
        Position:   pos(c),
    }, nil
}

codeStatements <- firstLineI:GoExpression restI:codeStatement* {
    rest := optCast[[]file.GoCode](restI)
    stmts := make([]file.GoCode, 1, 1+len(rest))
    stmts[0] = firstLineI.(file.GoCode)
    stmts = append(stmts, rest...)
    return stmts, nil
} / EOL {
    return ([]file.GoCode)(nil), &fileerr.Error{
        Message: "empty code block",
        ErrorAnnotation: anno(c, annotation{
            Start:      pos(c),
            Annotation: "expected code",
        }),
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "either write some code, or delete this line"},
        },
    }
}

codeStatement <- !(_* ';' EOL) EOC stmtI:GoExpression {
    return stmtI, nil
} / EOC EMPTY_LINE* INDENTATION2 stmtI:GoExpression {
    return stmtI, nil
}

implicitCode <- implicitAhead stmtI:GoStatement EOC {
    return file.Code{
        Statements: []file.GoCode{stmtI.(file.GoCode)},
        Position: pos(c),
    }, nil
}

implicitAhead <- &(declaration / assignment / increment / label / fallthroughKeyword)

declaration <- colonDecl / varDecl
colonDecl   <- goIdentifierList _* ":=" _* goRestOfCommand
varDecl     <- ("var" / "const") (_+ varDeclLine / '(' (WS* varDeclLine)* WS* ')')
varDeclLine <- goIdentifierList (_+ goType)? _* '=' _* goRestOfCommand

assignment <- goIdentifierList _* [-+*/%|&^]? '=' _* goRestOfCommand {
    return string(c.text), nil
}
increment <- goIdentifier _* ("++" / "--") {
    return string(c.text), nil
}

label <- goIdentifier _* ':' EOC
fallthroughKeyword <- "fallthrough" EOC

goRestOfCommand <- ('{' [^}]* '}' / '[' [^\]]* ']' / '(' [^)]* ')' / !EOC .)*

// ============================================================================
// Return
// ======================================================================================

Return <- "return" errI:returnErr {
    return file.Return{
        Err:      errI.(*file.GoCode),
        Position: pos(c),
    }, nil
}

returnErr <- EOC {
    return (*file.GoCode)(nil), nil
} / _* errI:GoExpression EOC {
    return ptr(errI.(file.GoCode)), nil
} / _* errI:GoExpression startI:POS UNEXPECTED endI:EOC {
    return ptr(errI.(file.GoCode)), newUnexpectedTokensErr(c, startI.(file.Position), endI.(file.Position), "unexpected tokens after return value")
} / _* startI:POS UNEXPECTED endI:EOC {
    return (*file.GoCode)(nil), newUnexpectedTokensErr(c, startI.(file.Position), endI.(file.Position), "expected nothing, or an error to be returned")
}

// ============================================================================
// Break/Continue
// ======================================================================================

Continue <- "continue" labelI:breakContinueLabel {
    return file.Continue{
        Label:    labelI.(*file.Ident),
        Position: pos(c),
    }, nil
}

Break <- "break" labelI:breakContinueLabel {
    return file.Break{
        Label:    labelI.(*file.Ident),
        Position: pos(c),
    }, nil
}

breakContinueLabel <- EOC {
    return (*file.Ident)(nil), nil
} /_+ identI:Ident EOC {
    return identI, nil
} / _+ identI:Ident startI:POS UNEXPECTED endI:EOC {
    return identI, newUnexpectedTokensErr(c, startI.(file.Position), endI.(file.Position), "unexpected tokens after break/continue label")
} / _* startI:POS UNEXPECTED endI:EOC {
    return (*file.Ident)(nil), newUnexpectedTokensErr(c, startI.(file.Position), endI.(file.Position), "expected nothing, or a label")
}
