// ============================================================================
// Go Expression
// ======================================================================================

// go expressions that are followed by a body should use ConditionalGoExpression
GoExpression <- codesI:(goParenExpr / String / expressionBlockFunction / rawGoExpression)+ {
    return combineGoCode(codesI), nil
}

nestedGoCode <- exprsI:(goParenExpr / String / statementBlockFunction / nestedRawGoCode)+ {
    return exprsI, nil
}

goParenExpr <- openI:goParenExprStart codeI:nestedGoCode? closeI:goParenExprEnd {
    return []any{openI, codeI, closeI}, nil
} / openI:goBraceExprStart codeI:nestedGoCode? closeI:goBraceExprEnd {
    return []any{openI, codeI, closeI}, nil
} / openI:goBracketExprStart codeI:nestedGoCode? closeI:goBracketExprEnd {
    return []any{openI, codeI, closeI}, nil
}

goParenExprStart <- _* &'(' pushStart '(' {
    return &ast.RawGoCode{Code: "(", Position: pos(c)}, nil
}
goBraceExprStart <- _* &'{' pushStart '{'  {
    return &ast.RawGoCode{Code: "{", Position: pos(c)}, nil
}
goBracketExprStart <- _* &'[' pushStart '[' {
    return &ast.RawGoCode{Code: "[", Position: pos(c)}, nil
}
goParenExprEnd <- ')' popStart {
    return &ast.RawGoCode{Code: ")", Position: pos(c)}, nil
} / POS {
    return unclosedParen(c, "(", ")")
}
goBraceExprEnd <- '}' popStart {
    return &ast.RawGoCode{Code: "}", Position: pos(c)}, nil
} / POS {
    return unclosedParen(c, "{", "}")
}
goBracketExprEnd <- ']' popStart {
    return &ast.RawGoCode{Code: "]", Position: pos(c)}, nil
} / POS {
    return unclosedParen(c, "[", "]")
}

// ============================================================================
// Conditional Go Expression
// ======================================================================================

// Doesn't consume '{' and '[' if they are the last block before an else if? or the EOC.
ConditionalGoExpression <- codesI:(conditionalGoParenExpr / String / expressionBlockFunction / rawGoExpression)+ {
    return combineGoCode(codesI), nil
}

conditionalGoParenExpr <- openI:goParenExprStart codeI:nestedGoCode? closeI:goParenExprEnd {
    return []any{openI, codeI, closeI}, nil
} / openI:goBraceExprStart codeI:nestedGoCode? closeI:goBraceExprEnd !(EOC / _* "else") {
    return []any{openI, codeI, closeI}, nil
} / openI:goBracketExprStart codeI:nestedGoCode? closeI:goBracketExprEnd !(EOC / _* "else") {
    return []any{openI, codeI, closeI}, nil
}

// ============================================================================
// Go Statement
// ======================================================================================

GoStatement <- codesI:(goParenExpr / String / statementBlockFunction / rawGoStatement)+ {
    return combineGoCode(codesI), nil
}

// ============================================================================
// Go Code
// ======================================================================================

rawGoExpression <- rawGoExpressionChar+ {
    return &ast.RawGoCode{Code: string(c.text), Position: pos(c)}, nil
}
rawGoStatement <- rawGoStatementChar+ {
    return &ast.RawGoCode{Code: string(c.text), Position: pos(c)}, nil
}

nestedRawGoCode <- nestedRawGoCodeChar+ {
    return &ast.RawGoCode{Code: string(c.text), Position: pos(c)}, nil
}

rawGoExpressionAllowedNewline <- [=&|^+/*%<>!-] WS*
rawGoStatementAllowedNewline  <- [=,&|^+/*%<>!-] WS*

rawGoExpressionChar <- !expressionBlockFunctionStarter (goRuneLit / rawGoExpressionAllowedNewline / !(_* [[{]) [^\r\n({[\]}),;:'"`])
rawGoStatementChar  <- !statementBlockFunctionStarter (goRuneLit / rawGoStatementAllowedNewline / !(_* [[{]) [^\r\n({[\]});'"`])

nestedRawGoCodeChar <- !statementBlockFunctionStarter (goRuneLit / WS+ / [^\r\n({[\]})'"`])

expressionBlockFunctionStarter <- (_+ / rawGoExpressionAllowedNewline) "block" _* '('
statementBlockFunctionStarter  <- (_+ / rawGoStatementAllowedNewline) "block" _* '('

// ============================================================================
// Block Function
// ======================================================================================

expressionBlockFunction <- prefixI:(_+ / rawGoExpressionAllowedNewline)? bfI:BlockFunction {
    if prefixI == nil {
        return bfI, nil
    }

    return []any{&ast.RawGoCode{Code: concat(prefixI), Position: pos(c)}, bfI}, nil
}

statementBlockFunction <- prefixI:(_+ / rawGoExpressionAllowedNewline)? bfI:BlockFunction {
    if prefixI == nil {
        return bfI, nil
    }

    return []any{&ast.RawGoCode{Code: concat(prefixI), Position: pos(c)}, bfI}, nil
}

BlockFunction <- "block" _* lParenI:listStart identI:Ident rParenI:blockFunctionEnd {
    return &ast.BlockFunction{
        LParen:   lParenI.(*ast.Position),
        Block:    identI.(*ast.Ident),
        RParen:   rParenI.(*ast.Position),
        Position: pos(c),
    }, nil
}

blockFunctionEnd <- listEnd / POS {
    return unclosedList(c, "`block` function arguments")
}

// ============================================================================
// String
// ======================================================================================

String <- InterpretedString / RawString

InterpretedString <- interpretedStringStart contentsI:InterpretedStringContent* endI:interpretedStringEnd {
    return &ast.String{
        Open:     pos(c),
        Quote:    '"',
        Contents: sliceOf[ast.StringContent](contentsI),
        Close:    endI.(*ast.Position),
    }, nil
}

interpretedStringStart <- pushStart startI:POS '"' { return startI.(*ast.Position), nil }
interpretedStringEnd <- '"' endI:POS popStart {
    return endI.(*ast.Position), nil
} / endI:POS {
    start := popStart(c)
    return endI.(*ast.Position), &fileerr.Error{
        Message: "unclosed string literal",
        ErrorAnnotation: anno.Anno(file(c), anno.Annotation{
            Highlight:  anno.HighlightToEOL(start).Delta(1, 0),
            Annotation: "expected a `\"` somewhere here",
        }),
        HintAnnotations: []fileerr.Annotation{
            anno.Position(file(c), start, "for the string literal started here"),
        },
    }
}

RawString <- rawStringStart contentsI:RawStringContent* endI:rawStringEnd {
    return &ast.String{
        Open:     pos(c),
        Quote:    '`',
        Contents: sliceOf[ast.StringContent](contentsI),
        Close:    endI.(*ast.Position),
    }, nil
}

rawStringStart <- pushStart startI:POS '`' { return startI.(*ast.Position), nil }
rawStringEnd <- posI:POS '`' popStart {
    return posI.(*ast.Position), nil
} / posI:POS {
    return posI.(*ast.Position), &fileerr.Error{
        Message:         "unclosed string literal",
        ErrorAnnotation: anno.Position(file(c), popStart(c), "expected a closing ``` for this ```"),
    }
}

InterpretedStringContent <- InterpretedStringText / StringInterpolation
RawStringContent         <- RawStringText / StringInterpolation

InterpretedStringText <- (nonInterpolationHash / !'#' (goInterpretedStringUnicodeValue / goByteValue / goRecoverInterpretedStringEscape))+ {
    return &ast.StringText{
        Text:     string(c.text),
        Position: pos(c),
    }, nil
}
RawStringText <- (nonInterpolationHash / !'#' ensureInline goRawStringUnicodeChar)+ {
    return &ast.StringText{
        Text:     string(c.text),
        Position: pos(c),
    }, nil
}

StringInterpolation <- interpolationStart interpI:stringInterpolation interpolationEnd {
    return interpI, nil
}
stringInterpolation <- EscapedHash / CharacterReference / ExpressionInterpolation / BadInterpolation
