// ============================================================================
// Package Directive
// ======================================================================================

PackageDoc <- commentsI:(EMPTY_LINE+ / DevComment)* {
    commentIs := slice(commentsI)
    comments := make([]*ast.DevComment, 0, len(commentIs))
    for _, cI := range commentIs {
        if c, ok := cI.(*ast.DevComment); ok {
            comments = append(comments, c)
        }
    }
    comments = comments[:len(comments):len(comments)]
    return comments, nil
}

Package <- PackageDirective / MissingPackageDirective

PackageDirective <- "package" _+ nameI:packageName {
    return &ast.PackageDirective{
        Name:     nameI.(*ast.Ident),
        Position: pos(c),
    }, nil
}

packageName <- identI:Ident EOL {
    return identI, nil
} / EOL {
    return (*ast.Ident)(nil), &fileerr.Error{
        Message: "missing package name",
        ErrorAnnotation: anno.Anno(file(c), anno.Annotation{
            Highlight:  anno.HighlightPosition(pos(c)).Delta(1, 1),
            Annotation: "expected a package name",
        }),
        Example: "`package woof`",
    }
} / startI:POS identI:UNEXPECTED EOL {
    return invalidIdent(c, "package", *startI.(*ast.Position), identI.(string))
}

MissingPackageDirective <- POS {
    return (*ast.PackageDirective)(nil), &fileerr.Error{
        Message: "missing package directive",
        ErrorAnnotation: anno.ToEOL(file(c), pos(c),
            "expected `package` directive as first non-comment, found this instead"),
        Example: "`package woof`",
    }
}

// ============================================================================
// Import
// ======================================================================================

Import <- SingleImport / GroupImport / BadImport

SingleImport <- "import" _+ specI:ImportSpec EOC {
    return ast.Import{
        Imports:  []ast.ImportNode{specI.(*ast.ImportSpec)},
        Position: pos(c),
    }, nil
}

GroupImport <- "import" _* lParenI:listStart nodesI:importNode* rParenI:groupImportEnd {
    return ast.Import{
        LParen:   lParenI.(*ast.Position),
        Imports:  sliceOf[ast.ImportNode](nodesI),
        RParen:   rParenI.(*ast.Position),
        Position: pos(c),
    }, nil
}

groupImportEnd <- WS* rParenI:R_PAREN {
    return rParenI, nil
} / POS {
    return nil, &fileerr.Error{
        Message: "missing `)`",
        ErrorAnnotation: annoPos(c, "expected `)` to close the import group"),
    }
}

BadImport <- "import" _* startI:POS badI:UNEXPECTED endI:EOC {
    return &ast.Import{
        Imports: []ast.ImportNode{
            &ast.BadImportSpec{
                Line:     badI.(string),
                Position: *startI.(*ast.Position),
            },
        },
        Position: pos(c),
    }, &fileerr.Error{
        Message: "invalid import",
        ErrorAnnotation: annoRange(c, startI, endI,
            "expected an import path, optionally preceded by an import alias\n" +
                "or a group of imports"),
        Example: "`import \"fmt\"`",
    }
}

importNode <- WS* nodeI:(DevComment / ImportSpec / BadImportSpec) {
    return nodeI, nil
}

ImportSpec <- aliasI:importAlias? pathI:StaticString EOC {
    return &ast.ImportSpec{
        Alias:    optCast[*ast.Ident](aliasI),
        Path:     pathI.(*ast.StaticString),
    }, nil
}

importAlias <- '.' _* {
    return ast.Ident{Ident: ".", Position: pos(c)}, nil
} / identI:Ident _* {
    return identI, nil
} / (!(_* [`"]) .)+ {
    return invalidIdent(c, "import alias", pos(c), string(c.text))
}

BadImportSpec <- lineI:UNEXPECTED EOC {
    line := lineI.(string)
    return &ast.BadImportSpec{
        Line:     line,
        Position: pos(c),
    }, &fileerr.Error{
        Message: "invalid import spec",
        ErrorAnnotation: anno.NChars(file(c), pos(c), len(line),
            "expected an import path, optionally preceded by an import alias"),
    }
}

// ============================================================================
// State
// ======================================================================================

State <- SingleState / GroupState / BadState

SingleState <- "state" _+ varI:StateVar EOC {
    return ast.State{
        Vars:     []ast.StateNode{varI.(*ast.StateVar)},
        Position: pos(c),
    }, nil
}

GroupState <- "state" _* lParenI:listStart nodesI:stateNode* rParenI:groupStateEnd {
    return ast.State{
        LParen:   lParenI.(*ast.Position),
        Vars:     sliceOf[ast.StateNode](nodesI),
        RParen:   rParenI.(*ast.Position),
        Position: pos(c),
    }, nil
}

groupStateEnd <- WS* rParenI:R_PAREN {
    return rParenI, nil
} / POS {
    return nil, &fileerr.Error{
        Message: "missing `)`",
        ErrorAnnotation: annoPos(c, "expected `)` to close the state group"),
    }
}

BadState <- "state" _* startI:POS badI:UNEXPECTED endI:EOC {
    return &ast.State{
        Vars: []ast.StateNode{
            &ast.BadStateVar{
                Line:     badI.(string),
                Position: *startI.(*ast.Position),
            },
        },
        Position: pos(c),
    }, &fileerr.Error{
        Message: "invalid state",
        ErrorAnnotation: annoRange(c, startI, endI,
            "expected a state variable declaration or a group of state variables"),
        Example: "`state bark = \"woof\"`",
    }
}

stateNode <- WS* nodeI:(DevComment / StateVar / BadStateVar) {
    return nodeI, nil
}

StateVar <- namesI:stateVarNames _* typI:stateVarType? _* assignI:POS valsI:stateVarValues {
    names := namesI.([]*ast.Ident)
    vals := valsI.([]*ast.GoCode)

    if len(names) != len(vals) && len(vals) > 0 {
        return (*ast.StateVar)(nil), &fileerr.Error{
            Message: "state variable: unequal number of declarations and initializations",
            ErrorAnnotation: annoPos(c,
                fmt.Sprintf("have %d declarations and %d initializations", len(names), len(vals))),
            Example: "`state bark, howl = \"woof\", \"awoooo\"`",
            Suggestions: []fileerr.Suggestion{
                {Suggestion: "the number of variable names must always match the number of expressions"},
            },
        }
    }

    var assign *ast.Position
    if len(vals) > 0 {
        assign = assignI.(*ast.Position)
    }

    return ast.StateVar{
        Names:    names,
        Type:     optCast[*ast.Type](typI),
        Assign:   assign,
        Values:   vals,
    }, nil
}

stateVarNames <- firstI:stateVarIdent restI:(_* ',' _* stateVarIdent)* {
    rest := getTuples[*ast.Ident](restI, -1)
    names := make([]*ast.Ident, 1, 1+len(rest))
    names[0] = firstI.(*ast.Ident)
    names = append(names, rest...)
    return names, nil
}

stateVarIdent <- Ident / [^\r\n\t ,=]+ {
    return invalidIdent(c, "state variable", pos(c), string(c.text))
}

stateVarType <- typI:Type _* {
    return typI, nil
} / textI:(!(_* '=') [^\r\n])+ _* {
    text := concat(textI)
    return ast.Type{
        Type:     string(c.text),
        Position: pos(c),
    }, &fileerr.Error{
        Message: "invalid type",
        ErrorAnnotation: anno.NChars(file(c), pos(c), len(text), "this is not a valid Go type"),
    }
}

stateVarValues <- '=' WS* valsI:stateVarValueList EOC {
    return valsI, nil
} / '=' WS* valsI:stateVarValueList? startI:POS badI:UNEXPECTED endI:EOC {
    return optCast[[]*ast.GoCode](valsI),
        newUnexpectedTokensErr(c, *startI.(*ast.Position), *endI.(*ast.Position), "unexpected tokens")
} / '=' WS* startI:POS UNEXPECTED endI:EOC {
    return ([]*ast.GoCode)(nil), &fileerr.Error{
        Message: "invalid state variable values",
        ErrorAnnotation: annoRange(c, startI, endI, "expected one or more Go expressions"),
        Example: "`state bark = \"woof\"`",
    }
} / EOC {
    return ([]*ast.GoCode)(nil), nil
}

stateVarValueList <- firstI:GoExpression restI:(_* ',' _* GoExpression)* {
    rest := getTuples[*ast.GoCode](restI, -1)
    values := make([]*ast.GoCode, 1, 1+len(rest))
    values[0] = firstI.(*ast.GoCode)
    values = append(values, rest...)
    return values, nil
}

BadStateVar <- lineI:UNEXPECTED EOC {
    line := lineI.(string)
    return &ast.BadStateVar{
        Line:     line,
        Position: pos(c),
    }, &fileerr.Error{
        Message: "invalid state variable",
        ErrorAnnotation: anno.NChars(file(c), pos(c), len(line), "expected a state variable declaration"),
    }
}
