Expression       <- ChainExpression / GoExpression
InlineExpression <- inlineStart exprI:Expression inlineEnd { return exprI, nil }

// ============================================================================
// Chain Expression
// ======================================================================================

ChainExpression <- derefsI:chainExpressionDerefs rootI:chainExpressionRoot checkRootI:'?'? chainI:ChainExpressionNode*
                   defaultI:chainExpressionDefault? endPosI:POS _* &{
    return checkRootI != nil || chainExprItmsCheck(sliceOf[ast.ChainExpressionNode](chainI)) || defaultI != nil, nil
} chainExpressionTrail? {
    expr := optCast[ast.ChainExpression](defaultI)
    expr.Root = rootI.(*ast.RawGoCode)
    expr.CheckRoot = checkRootI != nil
    expr.Chain = sliceOf[ast.ChainExpressionNode](chainI)
    expr.DerefCount = derefsI.(int)
    expr.Position = pos(c)
    return &expr, nil
}
chainExpressionTrail <-  exprI:GoExpression endI:POS {
    return nil, &fileerr.Error{
        Message:         "malformed chain expression",
        ErrorAnnotation: anno.Node(file(c), exprI.(ast.Node), "unable to parse this expression as of a chain expression"),
        Suggestions: []fileerr.Suggestion{
            {
                Suggestion: "did you mean to put a default? default values start with the `~` operator",
                Example: "`woof?.bark[12?] ~ someDefault`",
            },
            {
                Suggestion: "remember that chain expressions cannot be embedded in Go expressions;\n" +
                    "you can either write a chain expression or a Go expression",
            },
        },
    }
}

chainExpressionDerefs <- '*'* {
    return len(c.text), nil
}

chainExpressionRoot <- (goIdentifier / '(' chainExpressionRootParenContent+ ')') {
    return &ast.RawGoCode{
        Code:     string(c.text),
        Position: pos(c),
    }, nil
}

chainExpressionRootParenContent <- '(' chainExpressionRootParenContent ')' /
                                   '[' chainExpressionRootParenContent ']' /
                                   '{' chainExpressionRootParenContent '}' /
                                   [^({[\]})]+

chainExpressionDefault <- posI:POS '~' WS* exprI:GoExpression {
    return ast.ChainExpression{
        DefaultOperator: posI.(*ast.Position),
        Default:         exprI.(*ast.GoCode),
    }, nil
}

//
// Chain Expression Node
//

ChainExpressionNode <- IndexExpression / DotIdentExpression / ParenExpression / TypeAssertionExpression

IndexExpression <- indexStart exprI:GoExpression checkIndexI:'?'? rBracketI:indexExpressionEnd checkValueI:'?'? {
    return &ast.IndexExpression{
        LBracket:   pos(c),
        Index:      exprI.(*ast.GoCode),
        RBracket:   rBracketI.(*ast.Position),
        CheckIndex: checkIndexI != nil,
        CheckValue: checkValueI != nil,
    }, nil
}
indexExpressionEnd <- indexEnd / POS {
    return unclosedIndex(c, "index")
}

DotIdentExpression <- '.' WS* identI:Ident checkI:'?'? {
    return &ast.DotIdentExpression{
        Ident:    identI.(*ast.Ident),
        Check:    checkI != nil,
        Position: pos(c),
    }, nil
}

ParenExpression <- listStart argsI:parenExpressionArgs? rParen:parenExpressionEnd checkI:'?'? {
    return &ast.ParenExpression{
        LParen: pos(c),
        Args:   optCast[[]*ast.GoCode](argsI),
        RParen: rParen.(*ast.Position),
        Check:  checkI != nil,
    }, nil
}
parenExpressionEnd <- listEnd / POS {
    return unclosedList(c, "parentheses")
}
parenExpressionArgs <- firstI:GoExpression restI:(_* ',' WS* GoExpression)* {
    return collectList[*ast.GoCode](firstI, restI, -1), nil
}

TypeAssertionExpression <- '.' lParenI:L_PAREN _* ptrsI:'*'* _* packageI:Namespace? typeI:Ident checkTypeI:'?'? _* rParenI:R_PAREN checkValueI:'?'? {
    return &ast.TypeAssertionExpression{
        LParen:       lParenI.(*ast.Position),
        PointerCount: len(slice(ptrsI)),
        Package:      optCast[*ast.Ident](packageI),
        Type:         typeI.(*ast.Ident),
        CheckType:    checkTypeI != nil,
        RParen:       rParenI.(*ast.Position),
        CheckValue:   checkValueI != nil,
        Position:     pos(c),
    }, nil
}
