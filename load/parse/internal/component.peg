// ============================================================================
// Component
// ======================================================================================

Component <- "comp" _+ nameI:componentName _* typeParamsI:componentTypeParamList? _* paramsI:componentParamList bodyI:Body {
    comp := paramsI.(ast.Component)
    comp.Name = nameI.(*ast.Ident)

    typeParams := optCast[ast.Component](typeParamsI)
    comp.LBracket = typeParams.LBracket
    comp.TypeParams = typeParams.TypeParams
    comp.RBracket = typeParams.RBracket

    comp.Body = optCast[ast.Body](bodyI)
    comp.Position = pos(c)
    return &comp, nil
}

componentName <- identI:Ident {
    return identI, nil
} / startI:POS identI:(!(_* [(};]) [^\r\n(])+ &'(' {
    return invalidIdent(c, "component", *startI.(*ast.Position), concat(identI))
} / POS {
    return missingIdent(c, "component", "`comp foo()`", 1)
}

componentTypeParamList <- lBracketI:indexStart paramsI:typeParams? rBracketI:componentTypeParamListEnd {
    return ast.Component{
        LBracket:   lBracketI.(*ast.Position),
        TypeParams: optCast[[]*ast.TypeParam](paramsI),
        RBracket:   rBracketI.(*ast.Position),
    }, nil
}

componentTypeParamListEnd <- indexEnd / POS {
    return unclosedList(c, "component type parameters")
}

typeParams <- firstI:typeParam restI:(_* ',' WS* typeParam)* {
    return collectList[*ast.TypeParam](firstI, restI, -1), nil
}

typeParam <- namesI:typeParamNames posI:POS typeI:typeParamType {
    return &ast.TypeParam{
        Names: namesI.([]*ast.Ident),
        Type:  typeI.(*ast.Type),
    }, nil
}

typeParamNames <- firstI:typeParamName restI:(_* ',' WS* typeParamName)* {
    return collectList[*ast.Ident](firstI, restI, -1), nil
}

typeParamName <- Ident / [^\r\n :,)]+ &[:,)] {
    return invalidIdent(c, "type parameter", pos(c), string(c.text))
}

typeParamType <- _+ tI:Type {
    return tI, nil
} / POS {
    return (*ast.Type)(nil), &fileerr.Error{
        Message:         "type param: missing type",
        ErrorAnnotation: annoPos(c, "expected a space and a type"),
    }
}

componentParamList <- lParenI:listStart paramsI:componentParams? rParenI:componentParamListEnd {
    return ast.Component{
        LParen: lParenI.(*ast.Position),
        Params: optCast[[]*ast.ComponentParam](paramsI),
        RParen: rParenI.(*ast.Position),
    }, nil
} / POS {
    return ast.Component{}, &fileerr.Error{
        Message:         "component: missing parameters",
        ErrorAnnotation: annoPos(c, "expected a parameter list"),
        Example:         "`comp foo(bar string, baz: 123)`",
    }
}

componentParamListEnd <- listEnd / POS {
    return unclosedList(c, "component parameters")
}

componentParams <- firstI:componentParam restI:(_* ',' WS* componentParam)* {
    return collectList[*ast.ComponentParam](firstI, restI, -1), nil
}

componentParam <- nameI:componentParamName typeI:componentParamType? defaultI:componentParamDefault? {
    paramDefault := optCast[ast.ComponentParam](defaultI)

    p := &ast.ComponentParam{
        Name:     nameI.(*ast.Ident),
        Type:     optCast[*ast.Type](typeI),
        Colon:    paramDefault.Colon,
        Default:  paramDefault.Default,
        Position: pos(c),
    }
    if p.Type == nil && p.Default == nil {
        return p, &fileerr.Error{
            Message:         "component parameter: need either a type or a default",
            ErrorAnnotation: anno.Node(file(c), p.Name, "param needs either a type or a default"),
            Suggestions: []fileerr.Suggestion{
                {Suggestion: "give this parameter a type", Code: "`"+ p.Name.Ident + " string`"},
                {Suggestion: "give this parameter a default with an inferrable type", Code: "`"+ p.Name.Ident + ": \"woof\"`"},
            },
        }
    }

    return p, nil
}

componentParamName <- Ident / [^\r\n :,)]+ &[:,)] {
    return invalidIdent(c, "component parameter", pos(c), string(c.text))
}

componentParamType <- _+ tI:Type {
    return tI, nil
}

componentParamDefault <- _* colonI:POS ':' _* exprI:componentParamDefaultValue {
    return ast.ComponentParam{
        Colon:   colonI.(*ast.Position),
        Default: exprI.(*ast.GoCode),
    }, nil
}

componentParamDefaultValue <- exprI:GoExpression {
    return exprI.(*ast.GoCode), nil
} / POS {
    return (*ast.GoCode)(nil), &fileerr.Error{
        Message:         "component param: missing default",
        ErrorAnnotation: annoPos(c, "here"),
        HintAnnotations: []fileerr.Annotation{
            annoPos(c, "expected a default because of this `:`"),
        },
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "remove the `:`, if you didn't mean to define a default"},
        },
    }
}

// ============================================================================
// Component Call
// ======================================================================================

ComponentCall <- '+' headerI:ComponentCallHeader bodyI:ComponentCallBody {
    cc := headerI.(ast.ComponentCall)
    cc.Body = optCast[ast.Body](bodyI)
    cc.Position = pos(c)
    return &cc, nil
}

ComponentCallHeader <- namespaceI:Namespace? nameI:componentCallName typeArgsI:componentTypeArgList argsI:componentArgList {
    cc := argsI.(ast.ComponentCall)
    cc.Namespace = optCast[*ast.Ident](namespaceI)
    cc.Name = nameI.(*ast.Ident)

    typeArgs := optCast[ast.ComponentCall](typeArgsI)
    cc.LBracket = typeArgs.LBracket
    cc.TypeArgs = typeArgs.TypeArgs
    cc.RBracket = typeArgs.RBracket

    return cc, nil
}

componentCallName <- Ident / identI:(!(_* [(};]) [^\r\n(])+ &'(' {
    return invalidIdent(c, "component call", pos(c), concat(identI))
} / POS {
    return missingIdent(c, "component call", "`+foo()`", 1)
}

componentTypeArgList <- lBracketI:indexStart argsI:typeArgs? rBracketI:componentTypeArgListEnd {
    return ast.ComponentCall{
        LBracket: lBracketI.(*ast.Position),
        TypeArgs: optCast[[]*ast.Type](argsI),
        RBracket: rBracketI.(*ast.Position),
    }, nil
}

componentTypeArgListEnd <- indexEnd / POS {
    return unclosedList(c, "component type arguments")
}

typeArgs <- firstI:typeArg restI:(_* ',' WS* typeArg)* {
    return collectList[*ast.Type](firstI, restI, -1), nil
}

typeArg <- tI:Type {
    return tI, nil
} / POS {
    return &ast.Type{Position: pos(c)}, &fileerr.Error{
        Message:         "invalid or missing type argument",
        ErrorAnnotation: annoPos(c, "expected a type"),
    }
}

componentArgList <- lParenI:listStart argsI:componentArgs? rParenI:componentArgListEnd {
    return ast.ComponentCall{
        LParen: lParenI.(*ast.Position),
        Args:   optCast[[]*ast.ComponentArg](argsI),
        RParen: rParenI.(*ast.Position),
    }, nil
} / POS {
    return ast.ComponentCall{}, &fileerr.Error{
        Message:         "component call: missing arguments",
        ErrorAnnotation: annoPos(c, "expected an argument list"),
        Example:         "`+foo(bar: \"foo\", baz: 123)`",
    }
}

componentArgListEnd <- listEnd / POS {
    return unclosedList(c, "component arguments")
}

componentArgs <- firstI:componentArg restI:(_* ',' WS* componentArg)* {
    return collectList[*ast.ComponentArg](firstI, restI, -1), nil
}

componentArg <- nameI:componentArgName _* valI:componentArgValue {
    return &ast.ComponentArg{
        Name:  nameI.(*ast.Ident),
        Value: optCast[ast.Expression](valI),
    }, nil
}

componentArgName <- Ident / [^\r\n :,)]+ &[:,)] {
    return invalidIdent(c, "component argument", pos(c), string(c.text))
}

componentArgValue <- ':' WS* exprI:Expression {
    return exprI, nil
} / ':'? _* posI:POS {
    return nil, &fileerr.Error{
        Message: "missing component argument value",
        ErrorAnnotation: anno.Position(file(c), *posI.(*ast.Position), "expected a value"),
        Example: "`argName: 123`",
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "remember to always write the name of the argument before it's value"},
        },
    }
}

// ============================================================================
// Component Call Body
// ======================================================================================

ComponentCallBody <- _* bI:componentCallBody { return bI, nil }
componentCallBody <- UnderscoreBlockShorthand / Scope / EOC { return nil, nil } / uI:UNEXPECTED endI:EOC {
    return nil, &fileerr.Error{
        Message: "unexpected tokens",
        ErrorAnnotation: annoRange(c, pos(c), endI, "expected a body or the end of command"),
        Example: "`+foo()`\n`+foo() { ... }`\n`+foo() _[ ... ]`\n`+foo() _{ ... }`",
    }
}

// ============================================================================
// Component Underscore Block Shorthand
// ======================================================================================

UnderscoreBlockShorthand <- '_' bodyI:Body {
    return &ast.UnderscoreBlockShorthand{
        Body:     optCast[ast.Body](bodyI),
        Position: pos(c),
    }, nil
}

// ============================================================================
// Block
// ======================================================================================

Block <- "block" nameI:blockName bodyI:OptionalBody {
    return &ast.Block{
        Name:     nameI.(*ast.Ident),
        Body:     optCast[ast.Body](bodyI),
        Position: pos(c),
    }, nil
}

blockName <- identI:Ident{
    return identI, nil
} / startI:POS identI:(!(_* [[{};]) [^\r\n[{};])+ &[[{};] {
    return invalidIdent(c, "block", *startI.(*ast.Position), concat(identI))
} / POS {
    return missingIdent(c, "block", "`block bark [ woof ]`", 1)
}
