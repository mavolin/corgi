missingCondition <- _? posI:POS {
    return nil, &fileerr.Error{
        Message: "missing condition",
        ErrorAnnotation: annoPos(c, "expected a condition"),
    }
}

// ============================================================================
// If
// ======================================================================================

If <- "if" condI:ifHeader thenI:Body elseIfsI:ElseIf* elseI:Else? {
    return &ast.If{
        Header:    condI.(*ast.IfHeader),
        Then:      optCast[ast.Body](thenI),
        ElseIfs:   sliceOf[*ast.ElseIf](elseIfsI),
        Else:      optCast[*ast.Else](elseI),
        Position:  pos(c),
    }, nil
}

ElseIf <- WS* "else" _* "if" condI:ifHeader _* thenI:Body {
    return &ast.ElseIf{
        Header: condI.(*ast.IfHeader),
        Then:      optCast[ast.Body](thenI),
        Position:  pos(c),
    }, nil
}

Else <- WS* "else" _* thenI:Body {
    return &ast.Else{
        Then:     optCast[ast.Body](thenI),
        Position: pos(c),
    }, nil
}

ifHeader <- _+ condI:IfHeader {
    return condI, nil
} / missingCondition {
    return (*ast.IfHeader)(nil), nil
}

IfHeader <- stmtI:goIfHeaderStatement? condI:(ChainExpression / ConditionalGoExpression) {
    return &ast.IfHeader{
        Statement: optCast[*ast.GoCode](stmtI),
        Condition: optCast[ast.Expression](condI),
    }, nil
}
goIfHeaderStatement <- stmtI:GoStatement EOC WS* ![[{] {
    return stmtI, nil
}

// ============================================================================
// Switch
// ======================================================================================

Switch <- "switch" comparatorI:switchComparator lBraceI:scopeStart casesI:switchCases rBraceI:scopeEnd {
    s := &ast.Switch{
        Comparator: comparatorI.(*ast.GoCode),
        LBrace:     lBraceI.(*ast.Position),
        Cases:      casesI.([]*ast.Case),
        RBrace:     rBraceI.(*ast.Position),
        Position:   pos(c),
    }

    for _, c := range s.Cases {
        if c.Expression != nil {
            return s, nil
        }
    }

    return s, &fileerr.Error{
        Message: "switch: no cases",
        ErrorAnnotation: anno.Anno(file(c), anno.Annotation{
            Context:    anno.ContextDelta(0, 1),
            Highlight:  anno.HighlightNode(s),
            Annotation: "expected switch to have at least one non-default case",
        }),
    }
}

switchComparator <- _* &'{' {
    return (*ast.GoCode)(nil), nil
} / _+ compI:ConditionalGoExpression _* &'{' {
    return compI.(*ast.GoCode), nil
} / _+ compI:ConditionalGoExpression startI:POS [^\r\n{]+ endI:POS {
    return compI.(*ast.GoCode),
        newUnexpectedTokensErr(c, *startI.(*ast.Position), *endI.(*ast.Position), "switch comparator terminated early")
}

switchCases <- preFirstCase? casesI:switchCase* {
    cases := sliceOf[*ast.Case](casesI)

    var firstDefault *ast.Case
    for _, ca := range cases {
        if ca.Expression != nil {
            continue
        }
        if firstDefault == nil {
            firstDefault = ca
            continue
        }

        return cases, &fileerr.Error{
            Message: "multiple default cases in switch",
            ErrorAnnotation: anno.Node(file(c), ca, "second default case"),
            HintAnnotations: []fileerr.Annotation{
                anno.Node(file(c), firstDefault, "first default case"),
            },
        }
    }

    return cases, nil
}

preFirstCase <- (!("case" / "default") [^{}] / '{' preFirstCase '}'?)+ {
    return nil, &fileerr.Error{
        Message:         "switch: unexpected tokens",
        ErrorAnnotation: annoPos(c, "expected a `case` or `default`"),
    }
}

switchCase <- WS* caseI:(Case / Default) {
    return caseI, nil
}

Case <- "case" _+ condI:caseCondition _* colonI:switchColon thenI:switchThen? {
    return &ast.Case{
        Expression: optCast[ast.Expression](condI),
        Colon:      colonI.(*ast.Position),
        Then:       optCast[*ast.Scope](thenI),
        Position:   pos(c),
    }, nil
}

Default <- "default" _* colonI:switchColon thenI:switchThen? {
    return &ast.Case{
        Colon:    colonI.(*ast.Position),
        Then:     optCast[*ast.Scope](thenI),
        Position: pos(c),
    }, nil
}

switchColon <- ':' {
    return pos(c), nil
} / POS {
    return pos(c), &fileerr.Error{
        Message: "switch case: missing colon",
        ErrorAnnotation: annoPos(c, "expected a colon"),
    }
}

caseCondition <- _+ condI:Expression {
    return condI, nil
} / missingCondition {
    return nil, nil
}

switchThen <- nodesI:switchScopeNode+ {
    return &ast.Scope{Nodes: sliceOf[ast.ScopeNode](nodesI)}, nil
}

switchScopeNode <- !('}' / "case" _+ / "default" _* ':') nodeI:ScopeNode {
    return nodeI, nil
}

// ============================================================================
// For
// ======================================================================================

For <- "for" exprI:forHeader? _* bodyI:Body {
    return &ast.For{
        Header: optCast[ast.ForHeader](exprI),
        Body:       optCast[ast.Body](bodyI),
        Position:   pos(c),
    }, nil
}

ForHeader <- ForRangeHeader / ChainExpression / GoExpression

forHeader <- _+ condI:ForHeader {
    return condI, nil
}

// ============================================================================
// For Range Header
// ======================================================================================

ForRangeHeader <- varsI:forRangeHeaderVars? orderedPosI:POS orderedI:("ordered" _+)? rangePosI:POS "range" _+ exprI:Expression {
    e := optCast[ast.ForRangeHeader](varsI)
    if orderedI != nil {
        e.Ordered = orderedPosI.(*ast.Position)
    }
    e.Range = rangePosI.(*ast.Position)
    e.Expression = optCast[ast.Expression](exprI)
    e.Position = pos(c)
    return &e, nil
}

forRangeHeaderVars <- var1I:Ident _* var2I:(POS ',' _* Ident)? _* eqPosI:POS declaresI:':'? '=' _* {
    h := ast.ForRangeHeader{
        Var1:      var1I.(*ast.Ident),
        EqualSign: eqPosI.(*ast.Position),
        Declares:  declaresI != nil,
    }
    if var2I != nil {
        h.Comma = getTuple[*ast.Position](var2I, 0)
        h.Var2 = getTuple[*ast.Ident](var2I, -1)
    }

    return h, nil
}

