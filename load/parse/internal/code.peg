// ============================================================================
// Global Code
// ======================================================================================

GlobalCode <- !("import" / "comp" / "state") stmtI:GoStatement EOC {
    return &ast.Code{Statements: []*ast.GoCode{stmtI.(*ast.GoCode)}, Position: pos(c)}, nil
}

// ============================================================================
// Code
// ======================================================================================

Code <- implicitCode / explicitCode

explicitCode <- INDENTATION_REF "- " codeStatementsI:codeStatements {
    return &ast.Code{
        Statements: codeStatementsI.([]*ast.GoCode),
        Position:   pos(c),
    }, nil
}

codeStatements <- firstLineI:GoExpression restI:codeStatement* {
    restIs := slice(restI)
    stmts := make([]*ast.GoCode, 1+len(restIs))
    stmts[0] = firstLineI.(*ast.GoCode)
    for i, restI := range restIs {
        stmts[i+1] = restI.(*ast.GoCode)
    }
    return stmts, nil
} / EOL {
    return ([]*ast.GoCode)(nil), &fileerr.Error{
        Message:         "empty code block",
        ErrorAnnotation: annoPos(c, "expected code"),
        Suggestions: []fileerr.Suggestion{
            {Suggestion: "either write some code, or delete this line"},
        },
    }
}

codeStatement <- !(_* ';' EOL) EOC stmtI:GoExpression {
    return stmtI, nil
} / EOC EMPTY_LINE* INDENTATION2 stmtI:GoExpression {
    return stmtI, nil
}

implicitCode <- implicitAhead stmtI:GoStatement EOC {
    return &ast.Code{
        Statements: []*ast.GoCode{stmtI.(*ast.GoCode)},
        Position:   pos(c),
    }, nil
}

implicitAhead <- &(declaration / assignment / increment / label / fallthroughKeyword)

declaration <- colonDecl / varDecl
colonDecl   <- goIdentifierList _* ":=" _* goRestOfCommand
varDecl     <- ("var" / "const") (_+ varDeclLine / '(' (WS* varDeclLine)* WS* ')')
varDeclLine <- goIdentifierList (_+ goType)? _* '=' _* goRestOfCommand

assignment <- assignmentVarList _* [-+*/%|&^]? '=' _* goRestOfCommand
assignmentVarList <- assignmentVar _* (',' WS* assignmentVar)*
assignmentVar <- goIdentifier (_* ('.' _* goIdentifier / '[' _* [^\r\n\]]+ _* ']'))*

increment <- goIdentifier _* ("++" / "--")

label <- goIdentifier _* ':' EOC
fallthroughKeyword <- "fallthrough" EOC

goRestOfCommand <- ('{' [^}]* '}' / '[' [^\]]* ']' / '(' [^)]* ')' / !EOC .)*

// ============================================================================
// Return
// ======================================================================================

Return <- "return" errI:returnErr {
    return &ast.Return{
        Err:      errI.(*ast.GoCode),
        Position: pos(c),
    }, nil
}

returnErr <- EOC {
    return (*ast.GoCode)(nil), nil
} / _* errI:GoExpression EOC {
    return errI.(*ast.GoCode), nil
} / _* errI:GoExpression startI:POS UNEXPECTED endI:EOC {
    return errI.(*ast.GoCode), newUnexpectedTokensErr(c, *startI.(*ast.Position), *endI.(*ast.Position), "unexpected tokens after return value")
} / _* startI:POS UNEXPECTED endI:EOC {
    return (*ast.GoCode)(nil), newUnexpectedTokensErr(c, *startI.(*ast.Position), *endI.(*ast.Position), "expected nothing, or an error to be returned")
}

// ============================================================================
// Break/Continue
// ======================================================================================

Continue <- "continue" labelI:breakContinueLabel {
    return &ast.Continue{
        Label:    labelI.(*ast.Ident),
        Position: pos(c),
    }, nil
}

Break <- "break" labelI:breakContinueLabel {
    return &ast.Break{
        Label:    labelI.(*ast.Ident),
        Position: pos(c),
    }, nil
}

breakContinueLabel <- EOC {
    return (*ast.Ident)(nil), nil
} /_+ identI:Ident EOC {
    return identI, nil
} / _+ identI:Ident startI:POS UNEXPECTED endI:EOC {
    return identI, newUnexpectedTokensErr(c, *startI.(*ast.Position), *endI.(*ast.Position), "unexpected tokens after break/continue label")
} / _* startI:POS UNEXPECTED endI:EOC {
    return (*ast.Ident)(nil), newUnexpectedTokensErr(c, *startI.(*ast.Position), *endI.(*ast.Position), "expected nothing, or a label")
}
